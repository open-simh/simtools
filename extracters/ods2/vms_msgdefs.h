#ifndef __ACCDEF_LOADED
#define __ACCDEF_LOADED	1

/*** MODULE $accdef ***/
#define ACC$K_TERMLEN 84                /* TERMINATION MESSAGE LENGTH       */
#define ACC$C_TERMLEN 84                /* TERMINATION MESSAGE LENGTH       */
/* AND ACCOUNTING RECORD FOR NON BATCH JOBS                                 */
#define ACC$K_JOB_LEN 108               /* LENGTH OF BATCH JOB ACCOUNTING RECORD  */
#define ACC$C_JOB_LEN 108               /* LENGTH OF BATCH JOB ACCOUNTING RECORD  */
struct accdef {
    unsigned short int acc$w_msgtyp;    /* MESSAGE TYPE CODE                */
    unsigned short int acc$w_msgsiz;    /* LENGTH OF DATA MESSAGE (VALID ONLY IN ACCLOG)  */
    unsigned long int acc$l_finalsts;   /* FINAL EXIT STATUS                */
    unsigned long int acc$l_pid;        /* PROCESS ID                       */
    unsigned long int acc$l_jobid;      /* JOB IDENTIFICATION (VALID ONLY IN ACCLOG)  */
    unsigned int acc$q_termtime [2];    /* TERMINATION TIME (100NS UNITS)   */
    char acc$t_account [8];             /* ACCOUNT NAME STRING (BLANK FILLED)  */
    char acc$t_username [12];           /* USER NAME STRING (BLANK FILLED)  */
    unsigned long int acc$l_cputim;     /* CPUTIM IN 10MS UNITS             */
    unsigned long int acc$l_pageflts;   /* TOTAL PAGE FAULTS                */
    unsigned long int acc$l_pgflpeak;   /* PEAK PAGING FILE USAGE           */
    unsigned long int acc$l_wspeak;     /* PEAK WORKING SET SIZE            */
    unsigned long int acc$l_biocnt;     /* COUNT OF BUFFERED I/O OPERATIONS  */
    unsigned long int acc$l_diocnt;     /* COUNT OF DIRECT I/O OPERATIONS   */
    unsigned long int acc$l_volumes;    /* COUNT OF VOLUMES MOUNTED         */
    unsigned int acc$q_login [2];       /* LOGIN TIME (100NS UNITS)         */
    unsigned long int acc$l_owner;      /* PID OF SUBPROCESS OWNER          */
/* END OF TERMINATION MESSAGE                                               */
    char acc$t_job_name [8];            /* JOB NAME (BLANK FILLED)          */
    char acc$t_job_que [16];            /* QUEUE NAME (.ASCIC)              */
    } ;
#define ACC$K_PRT_LEN 88                /* LENGTH OF PRINT ACCOUNTING RECORD  */
#define ACC$C_PRT_LEN 88                /* LENGTH OF PRINT ACCOUNTING RECORD  */
/*                                                                          */
struct accdef1 {
    char accdef$$_fill_1 [48];
    unsigned long int acc$l_pagcnt;     /* SYMBIONT PAGE COUNT              */
    unsigned long int acc$l_qiocnt;     /* SYMBIONT QIO COUNT               */
    unsigned long int acc$l_getcnt;     /* SYMBIONT GET COUNT               */
    unsigned int acc$q_quetime [2];     /* TIME JOB WAS QUEUED              */
    char acc$t_prt_name [8];            /* NAME OF PRINT JOB                */
    char acc$t_prt_que [12];            /* NAME OF PRINT QUEUE              */
/* DEFINE USER ACCOUNTING MESSAGE DATA AREA                                 */
/*                                                                          */
    } ;
#define ACC$K_INS_LEN 176               /* LENGTH OF INSERT MESSAGE         */
#define ACC$C_INS_LEN 176               /* LENGTH OF INSERT MESSAGE         */
/*                                                                          */
#define ACC$K_PRCTRM 1                  /* JOB TERMINATION                  */
#define ACC$K_BATTRM 2                  /* BATCH JOB TERMINATION            */
#define ACC$K_INTTRM 3                  /* INTERACTIVE JOB TERMINATION      */
#define ACC$K_LOGTRM 4                  /* LOGIN FAILURE PROCESS TERMINATION  */
#define ACC$K_IMGTRM 5                  /* IMAGE TERMINATION                */
#define ACC$K_SUBTRM 6                  /* SUBPROCESS TERMINATION           */
#define ACC$K_DETTRM 7                  /* DETACHED PROCESS TERMINATION     */
#define ACC$K_NETTRM 8                  /* NETWORK PROCESS TERMINATION      */
/* MISC ACCOUNTING RECORDS                                                  */
#define ACC$K_PRTJOB 16                 /* PRINT JOB ACCOUNTING             */
#define ACC$K_INSMSG 17                 /* INSERTED MESSAGE                 */
/*                                                                          */
#define ACC$K_INSMESG 1                 /* INSERT MESSAGE INTO ACCOUNTING FILE  */
#define ACC$K_NEWFILE 2                 /* CREATE A NEW ACCOUNT FILE        */
#define ACC$K_ENABACC 3                 /* ENABLE ACCOUNTING                */
#define ACC$K_DISAACC 4                 /* DISABLE ACCOUNTING               */
#define ACC$K_ENABSEL 5                 /* ENABLE SELECTIVE ACCOUNTING      */
#define ACC$K_DISASEL 6                 /* DISABLE SELECTIVE ACCOUNTING     */
struct accdef2 {
    char accdef$$_fill_2 [44];
    char acc$t_user_data [132];         /* ALLOW UP TO 132 BYTES OF USER DATA  */
/* ASSIGN RECORD TYPE CODES FOR RECORDS IN THE ACCOUNT LOG FILE             */
/*                                                                          */
/* PROCESS ACCOUNTING RECORDS                                               */
/* DEFINE ACCOUNTING MANAGER MESSAGE CODES                                  */
/*                                                                          */
/*                                                                          */
    } ;

#endif					/* __ACCDEF_LOADED */
#ifndef __ACEDEF_LOADED
#define __ACEDEF_LOADED	1

/*** MODULE $acedef ***/
/*+                                                                         */
/*                                                                          */
/* Access Control list Entry structure definitions                          */
/*                                                                          */
/*-                                                                         */
#define ACE$C_KEYID 1                   /* Key identifier entry             */
#define ACE$C_RMSJNL_BI 2               /* RMS BI journal                   */
#define ACE$C_RMSJNL_AI 3               /* RMS AI journal                   */
#define ACE$C_RMSJNL_AT 4               /* RMS AT journal                   */
#define ACE$C_AUDIT 5                   /* Security audit journal entry     */
#define ACE$C_ALARM 6                   /* Security alarm entry             */
#define ACE$C_INFO 7                    /* General purpose information      */
#define ACE$C_RMSJNL_RU_DEFAULT 8       /* RU journal default volume        */
#define ACE$C_DIRDEF 9                  /* Directory default protection     */
#define ACE$C_RMSJNL_RU 10              /* RU journal (many per file)       */
#define ACE$C_SUBSYSTEM_IDS 11          /* Protected subsystem ids          */
#define ACE$C_RESERVED 255              /* Reserved ACE type                */
#define ACE$C_APPLICATION 7             /* Alternate application ACE code   */
#define ACE$C_CUST 1                    /* Customer defined                 */
#define ACE$C_CSS 2                     /* CSS defined                      */
#define ACE$C_VMS 3                     /* VMS defined                      */
#define ACE$M_SUCCESS 1
#define ACE$M_FAILURE 2
#define ACE$M_DEFAULT 256
#define ACE$M_PROTECTED 512
#define ACE$M_HIDDEN 1024
#define ACE$M_NOPROPAGATE 2048
#define ACE$M_READ 1
#define ACE$M_WRITE 2
#define ACE$M_EXECUTE 4
#define ACE$M_DELETE 8
#define ACE$M_CONTROL 16
#define ACE$K_LENGTH 8                  /* Length of the overhead area      */
#define ACE$C_LENGTH 8                  /* Length of the overhead area      */
#define ACE$C_RMS_ATTRIBUTES 0          /* variant of ACE for file attributes */
#define ACE$K_RMS_ATTRIBUTES 0          /* variant of ACE for file attributes */
#define ACE$K_RMSATR_MINOR_V50 2        /* minor ID for VMS 5.0             */
#define ACE$K_RMSATR_MINOR_VDW 2        /* minor ID for DECwindows V1.0     */
#define ACE$C_RMSATR_MINOR_ID 2         /* current minor ID (obsolete symbol) */
#define ACE$K_RMSATR_MINOR_ID 2
#define ACE$C_RMSATR_MAJOR_ID 1         /* current major ID                 */
#define ACE$K_RMSATR_MAJOR_ID 1
#define ACE$M_STATISTICS 1
#define ACE$M_XLATE_DEC 2
#define ACE$S_RMSATR 20                 /* size of RMS file attributes ACE (fixed fields) */
#define ACE$S_RMSATR_V50 20             /* size of RMS file attributes ACE (fixed fields) */
#define ACE$S_RMSATR_VDW 20             /* size of RMS file attributes ACE (fixed fields) */
/* Beyond the fixed fields, variable length information will by stored      */
#define ACE$_RMSATR_ORGANIZATION 1      /* organizational extension object ID  */
#define ACE$_RMSATR_SEMANTICS 2         /* file semantics object ID         */
#define ACE$K_RMSATR_ORG_MAX_LEN 64
#define ACE$K_RMSATR_SEM_MAX_LEN 64
#define ACE$S_RMSJNL_RU_DEFAULT 17      /* length of RMSJNL RU default ACE  */
#define ACE$M_JOURNAL_DISABLED 1
#define ACE$M_BACKUP_DONE 2
#define ACE$S_RMSJNL_RU 38              /* length of RMSJNL RU ACE          */
#define ACE$S_RMSJNL 50                 /* length of RMSJNL AI/BI/AT ACE    */
#pragma nostandard
struct acedef {
    unsigned char ace$b_size;           /* Size of the entry                */
    unsigned char ace$b_type;           /* Type of entry                    */
    variant_union  {
        unsigned short int ace$w_flags; /* Type dependent & independent flags  */
        variant_struct  {               /* Flags for INFO type ACE          */
            unsigned ace$v_info_type : 4; /* INFO ACE subtype               */
            unsigned ace$v_fill_0 : 4;
            } ace$r_flags_info;
        variant_struct  {               /* Flags for KEYID type             */
            unsigned ace$v_reserved : 4; /* Count of reserved longwords     */
            unsigned ace$v_fill_1 : 4;
            } ace$r_flags_keyid;
        variant_struct  {
            unsigned ace$v_success : 1; /* Audit or alarm upon success      */
            unsigned ace$v_failure : 1; /* Audit ot alarm upon failure      */
            unsigned ace$v_fill_2 : 6;
            } ace$r_flags_bits0;
        variant_struct  {               /* Type independent flags           */
            unsigned ace$v_fill_16 : 8;
            unsigned ace$v_default : 1; /* Directory default entry          */
            unsigned ace$v_protected : 1; /* Protected ACE                  */
            unsigned ace$v_hidden : 1;  /* Hidden ACE                       */
            unsigned ace$v_nopropagate : 1; /* No propagation between versions */
            unsigned ace$v_fill_3 : 4;
            } ace$r_flags_bits;
        } ace$r_flags_overlay;
    variant_union  {                    /* Start of ACE overlayed area      */
        variant_struct  {               /* KEY-ID and security audit types  */
            variant_union  {
                unsigned long int ace$l_access; /* Access rights bitmask    */
                variant_struct  {
                    unsigned ace$v_read : 1; /* Allowed to read             */
                    unsigned ace$v_write : 1; /* Allowed to write           */
                    unsigned ace$v_execute : 1; /* Allowed to execute       */
                    unsigned ace$v_delete : 1; /* Allowed to delete         */
                    unsigned ace$v_control : 1; /* All privileges of the owner  */
                    unsigned ace$v_fill_6 : 3;
                    } ace$r_fill_5;
                } ace$r_fill_4;
            variant_union  {
                unsigned long int ace$l_key; /* Start of the key fields     */
                char ace$t_auditname [16]; /* Start of the security journal name */
                } ace$r_key_overlay;
            } ace$r_key_aud_type;
        variant_struct  {
            variant_union  {
                unsigned long int ace$l_info_flags; /* INFO type application flags */
                variant_struct  {
                    unsigned short int ace$w_application_flags; /* VMS application flags word */
                    unsigned short int ace$w_application_facility; /* VMS application facility code */
                    } ace$r_fill_8;
                } ace$r_fill_7;
            variant_union  {
                char ace$t_info_start;  /* Start of the information         */
                variant_struct  {
                    unsigned short int ace$w_rmsatr_variant; /* Which variant of the RMS attributes ACE */
                    unsigned char ace$b_rmsatr_fixlen; /* length of fixed format fields */
/* (introduced at minor ID 3. Older                                         */
/*  ACE's are assumed to be all fixed form)                                 */
                    char ace$b_rmsatr_spare1; /* currectly unused           */
                    unsigned short int ace$w_rmsatr_minor_id; /* RMS file attributes ACE minor ID */
                    unsigned short int ace$w_rmsatr_major_id; /* RMS file attributes ACE major ID */
                    variant_union  {
                        unsigned long int ace$l_rms_attribute_flags; /* RMS file attributes flags definitions */
                        variant_struct  {
                            unsigned ace$v_statistics : 1; /* Statistics monitoring enabled on this file */
                            unsigned ace$v_xlate_dec : 1; /* File semantics are DEC-local */
                            unsigned ace$v_fill_11 : 6;
                            } ace$r_fill_10;
                        } ace$r_fill_9;
/* using a {field-type, length, value} scheme.  This allows extensibility   */
/* and compact representation.                                              */
/*                                                                          */
/* field types are:                                                         */
                    } ace$r_rmsatr_type;
                } ace$r_info_data;
            } ace$r_info_type;
        variant_struct  {               /* Used for all 5 RMSJNL_xxx ACEs   */
            char ace$t_volnam [12];     /* Volume name of journal file      */
            unsigned char ace$b_volnam_len; /* Length of volume name of journal file */
            unsigned char ace$b_rjrver; /* RMS journal file structure level */
            variant_union  {            /* File-id of journal file          */
                unsigned short int ace$w_fid [3]; /* file id                */
                variant_struct  {
                    unsigned short int ace$w_fid_num; /* file number        */
                    unsigned short int ace$w_fid_seq; /* sequence number    */
                    variant_union  {
                        unsigned short int ace$w_fid_rvn; /* relative volume number  */
                        variant_struct  {
                            unsigned char ace$b_fid_rvn; /* alternate format RVN  */
                            unsigned char ace$b_fid_nmx; /* alternate format file number extension  */
                            } ace$r_fid_rvn_fields;
                        } ace$r_fid_rvn_overlay;
                    } ace$r_fid_fields;
                } ace$r_fid_overlay;
            variant_union  {
                unsigned short int ace$w_rmsjnl_flags;
                variant_struct  {
                    unsigned ace$v_journal_disabled : 1; /* journaling disabled */
/* (AI, BI, AT only; set by BACKUP)                                         */
                    unsigned ace$v_backup_done : 1; /* BACKUP done on this file; */
/* RMS needs to write a backup marker                                       */
/* (AI, BI, AT only; set by BACKUP)                                         */
                    unsigned ace$v_fill_12 : 6;
                    } ace$r_rmsjnl_flags_bits;
                } ace$r_rmsjnl_flags_overlay;
            unsigned long int ace$l_jnlidx; /* journal stream index number  */
            unsigned int ace$q_cdate [2]; /* creation date/time of journal  */
            unsigned long int ace$l_backup_seqno; /* BACKUP sequence number (to */
/* find where to start in journal).                                         */
            unsigned int ace$q_modification_time [2]; /* timestamp of last backup or last */
/* journal entry recovered.                                                 */
            } ace$r_rmsjnl_type;
        variant_struct  {
            unsigned long int ace$l_spare1; /* For alignment                */
            unsigned long int ace$l_sys_prot; /* Default system protection  */
            unsigned long int ace$l_own_prot; /* Default owner protection   */
            unsigned long int ace$l_grp_prot; /* Default group protection   */
            unsigned long int ace$l_wor_prot; /* Default world protection   */
            } ace$r_dirdef_type;
        variant_struct  {               /* Protected subsystem ACE type     */
            unsigned long int ace$l_spare2; /* For alignment                */
            unsigned int ace$q_image_ids [2]; /* Start of the image ids (a  */
/* quadword for each identifier)                                            */
            } ace$r_image_id_type;
        } ace$r_ace_fields;
    } ;
#pragma standard

#endif					/* __ACEDEF_LOADED */
#ifndef __ACLDEF_LOADED
#define __ACLDEF_LOADED	1

/*** MODULE $acldef ***/
#define ACL$K_LENGTH 12                 /* Length of the overhead area      */
#define ACL$C_LENGTH 12                 /* Length of the overhead area      */
#define ACL$C_FILE 1                    /* Files                            */
#define ACL$C_DEVICE 2                  /* MBX, MT, TT, etc.                */
#define ACL$C_JOBCTL_QUEUE 3            /* Job controller queue             */
#define ACL$C_COMMON_EF_CLUSTER 4       /* Common event flag clusters       */
#define ACL$C_LOGICAL_NAME_TABLE 5      /* Logical name tables              */
#define ACL$C_PROCESS 6                 /* Process                          */
#define ACL$C_GROUP_GLOBAL_SECTION 7    /* Group global sections            */
#define ACL$C_SYSTEM_GLOBAL_SECTION 8   /* System global sections           */
#define ACL$C_RESERVED_OBJECT_1 9       /* Reserved object type             */
#define ACL$C_RESERVED_OBJECT_2 10      /* Reserved object type             */
#define ACL$C_RESERVED_OBJECT_3 11      /* Reserved object type             */
#define ACL$C_RESERVED_OBJECT_4 12      /* Reserved object type             */
/* Action codes                                                             */
#define ACL$C_ADDACLENT 1               /* Add an ACL entry                 */
#define ACL$C_DELACLENT 2               /* Delete an ACL entry              */
#define ACL$C_MODACLENT 3               /* Modify an ACL entry              */
#define ACL$C_FNDACLENT 4               /* Locate an ACL entry              */
#define ACL$C_FNDACETYP 5               /* Locate specific ACE type         */
#define ACL$C_DELETEACL 6               /* Delete entire ACL                */
#define ACL$C_READACL 7                 /* Read the ACL                     */
#define ACL$C_ACLLENGTH 8               /* Get the ACL's length             */
#define ACL$C_READACE 9                 /* Read a single ACE                */
#define ACL$C_RLOCK_ACL 10              /* Read lock on ACL                 */
#define ACL$C_WLOCK_ACL 11              /* Write lock on ACL                */
#define ACL$C_UNLOCK_ACL 12             /* Release exclusive lock           */
#define ACL$C_GRANT_ACE 13              /* ACE granting access              */
#define ACL$C_NEXT_ACE 14               /* Increment ACE number             */
#define ACL$C_RESERVED_ITEM_2 15        /* Reserved item code               */
#define ACL$C_RESERVED_ITEM_3 16        /* Reserved item code               */
#define ACL$S_ADDACLENT 255             /* Add an ACL entry                 */
#define ACL$S_DELACLENT 255             /* Delete an ACL entry              */
#define ACL$S_MODACLENT 255             /* Modify an ACL entry              */
#define ACL$S_FNDACLENT 255             /* Locate an ACL entry              */
#define ACL$S_FNDACETYP 255             /* Locate specific ACE type         */
#define ACL$S_DELETEACL 255             /* Delete entire ACL                */
#define ACL$S_READACL 512               /* Read the ACL                     */
#define ACL$S_ACLLENGTH 4               /* Get the ACL's length             */
#define ACL$S_READACE 255               /* Read a single ACE                */
#define ACL$S_RLOCK_ACL 4               /* Read lock on ACL                 */
#define ACL$S_WLOCK_ACL 4               /* Write lock on ACL                */
#define ACL$S_UNLOCK_ACL 4              /* Remove lock on ACL               */
#define ACL$S_GRANT_ACE 255             /* ACE granting access              */
#define ACL$S_NEXT_ACE 4                /* Increment ACE number             */
#define ACL$S_RESERVED_ITEM_2 255       /* Reserved item code               */
#define ACL$S_RESERVED_ITEM_3 255       /* Reserved item code               */
struct acldef {
    unsigned long int acl$l_flink;      /* Forward link to next list in the queue  */
    unsigned long int acl$l_blink;      /* Back link to previous list in queue  */
    unsigned short int acl$w_size;      /* Total size of the list           */
    unsigned char acl$b_type;           /* Structure type code              */
    char acldef$$_fill_1;               /* Spare unused byte                */
    unsigned long int acl$l_list;       /* Start of the Access Control Entries  */
/* Object types                                                             */
    } ;
 

#endif					/* __ACLDEF_LOADED */
#ifndef __ACRDEF_LOADED
#define __ACRDEF_LOADED	1

/*** MODULE $acrdef ***/
/*+                                                                         */
/* ACRDEF - ACCOUNTING RECORD DEFINITIONS                                   */
/*                                                                          */
/***********************************************************************    */
/* NOTE:  IF ANY FIELDS CHANGE, A NEW VERSION NUMBER MUST BE ADDED AND *    */
/*         "ACR$K_CURVER" EQUATED TO IT.                                      * */
/***********************************************************************    */
/*                                                                          */
/*-                                                                         */
/* RECORD/PACKET VERSIONS (ACR$V_VERSION)                                   */
#define ACR$K_VERSION2 0                /* VMS VERSION 2 ACCOUNTING FORMAT  */
#define ACR$K_VERSION3T 1               /* VMS VERSION 3 FIELD TEST         */
#define ACR$K_VERSION3 2                /* VMS VERSION 3 ACCOUNTING FORMAT  */
#define ACR$K_CURVER 2                  /* CURRENT FORMAT VERSION NUMBER    */
#define ACR$M_PACKET 1
#define ACR$M_TYPE 254
#define ACR$M_SUBTYPE 3840
#define ACR$M_VERSION 28672
#define ACR$M_CUSTOMER 32768
#define ACR$K_PRCDEL 1                  /* PROCESS DELETE                   */
#define ACR$K_PRCPUR 2                  /* PROCESS PURGE                    */
#define ACR$K_IMGDEL 3                  /* IMAGE DELETE                     */
#define ACR$K_IMGPUR 4                  /* IMAGE PURGE                      */
#define ACR$K_SYSINIT 5                 /* SYSTEM INITIALIZATION            */
#define ACR$K_SETTIME 6                 /* SET SYSTEM TIME                  */
#define ACR$K_LOGFAIL 7                 /* LOGIN VALIDATION FAILURE         */
#define ACR$K_PRINT 8                   /* PRINT JOB                        */
#define ACR$K_USER 9                    /* USER SUPPLIED DATA               */
#define ACR$K_ENABLE 10                 /* ACC. MANG. FUNCTION ENABLE       */
#define ACR$K_DISABLE 11                /* ACC. MANG. FUNCTION DISABLE      */
#define ACR$K_ALTACM 12                 /* DECLARE ALTERNATE ACC. MANG.     */
#define ACR$K_FILE_FL 13                /* ACCOUNTING FILE - FORWARD LINK   */
#define ACR$K_FILE_BL 14                /* ACCOUNTING FILE - BACKWARD LINK  */
/* RECORD SUBTYPE (ACR$V_SUBTYPE) CONSTANTS                                 */
#define ACR$K_INTERACTIVE 1             /* INTERACTIVE PROCESS              */
#define ACR$K_SUBPROCESS 2              /* SUBPROCESS                       */
#define ACR$K_DETACHED 3                /* DETACHED PROCESS                 */
#define ACR$K_BATCH 4                   /* BATCH PROCESS                    */
#define ACR$K_NETWORK 5                 /* NETWORK PROCESS                  */
/* PACKET TYPE (ACR$V_TYPE) CONSTANTS                                       */
#define ACR$K_ID 1                      /* IDENTIFICATION PACKET            */
#define ACR$K_RESOURCE 2                /* RESOURCE USAGE PACKET            */
#define ACR$K_IMAGENAME 3               /* IMAGENAME PACKET                 */
#define ACR$K_FILENAME 4                /* FILENAME PACKET                  */
#define ACR$K_USER_DATA 5               /* USER DATA PACKET                 */
#pragma nostandard
struct acrdef {
    variant_union  {
        unsigned short int acr$w_type;  /* RECORD/PACKET TYPE               */
        variant_struct  {
            unsigned acr$v_packet : 1;  /* RECORD(0)/PACKET(1)              */
            unsigned acr$v_type : 7;    /* RECORD/PACKET TYPE               */
            unsigned acr$v_subtype : 4; /* RECORD/PACKET SUBTYPE            */
            unsigned acr$v_version : 3; /* RECORD/PACKET VERSION NUMBER     */
            unsigned acr$v_customer : 1; /* DIGITAL(0)/CUSTOMER(1)          */
            } acr$r_type_bits;
/* RECORD TYPE (ACR$V_TYPE) CONSTANTS                                       */
        } acr$r_type_overlay;
    unsigned short int acr$w_length;    /* RECORD OR PACKET LENGTH          */
/*                                                                          */
/* RECORD HEADER                                                            */
/*                                                                          */
    } ;
#define ACR$K_HDRLEN 12                 /* RECORD HEADER LENGTH             */
#define ACR$C_HDRLEN 12                 /* RECORD HEADER LENGTH             */
/*                                                                          */
struct acrdef1 {
    char acrdef$$_fill_2 [4];
    unsigned int acr$q_systime [2];     /* EVENT SYSTEM TIME                */
/* IDENTIFICATION PACKET                                                    */
/*                                                                          */
    } ;
#define ACR$K_IDVAR 46                  /* BEGINNING OF VARIABLE STORAGE AREA  */
#define ACR$C_IDVAR 46                  /* BEGINNING OF VARIABLE STORAGE AREA  */
/*                                                                          */
struct acrdef2 {
    char acrdef$$_fill_3 [4];
    unsigned long int acr$l_pid;        /* PROCESS ID                       */
    unsigned long int acr$l_owner;      /* OWNER PROCES ID                  */
    variant_union  {
        unsigned long int acr$l_uic;    /* PROCESS UIC                      */
        variant_struct  {
            unsigned short int acr$w_mem; /* MEMBER UIC                     */
            unsigned short int acr$w_grp; /* GROUP UIC                      */
            } acr$r_uic_fields;
        } acr$r_uic_overlay;
    unsigned int acr$q_priv [2];        /* PROCESS PRIV                     */
    unsigned char acr$b_pri;            /* PROCESS PRIORITY                 */
    char acrdef$$_fill_1;               /* SPARE                            */
    unsigned short int acr$w_username;  /* USERNAME OFFSET                  */
    unsigned short int acr$w_account;   /* ACCOUNT NAME OFFSET              */
    unsigned short int acr$w_nodename;  /* NODE NAME OFFSET                 */
    unsigned short int acr$w_terminal;  /* TERMINAL NAME OFFSET             */
    unsigned short int acr$w_jobname;   /* JOB NAME OFFSET                  */
    unsigned long int acr$l_jobid;      /* JOB ID                           */
    unsigned short int acr$w_queue;     /* QUEUE NAME OFFSET                */
    unsigned short int acr$w_nodeaddr;  /* REMOTE NODE ADDRESS              */
    unsigned short int acr$w_remoteid;  /* REMOTE ID OFFSET                 */
/* RESOURCE PACKET                                                          */
/*                                                                          */
    } ;
struct acrdef3 {
    char acrdef$$_fill_4 [4];
    unsigned int acr$q_login [2];       /* PROCESS/IMAGE START TIME         */
    unsigned long int acr$l_status;     /* PROCESS/IMAGE FINAL STATUS       */
    unsigned long int acr$l_imgcnt;     /* IMAGE EXECUTION COUNT/SEQUENCE NUMBER  */
    unsigned long int acr$l_cputime;    /* PROCESS/IMAGE CPU TIME           */
    unsigned long int acr$l_faults;     /* PROCESS/IMAGE PAGE FAULT COUNT   */
    unsigned long int acr$l_faultio;    /* PROCESS/IMAGE PAGE FAULT I/O COUNT  */
    unsigned long int acr$l_wspeak;     /* PROCESS/IMAGE WORKING SET PEAK   */
    unsigned long int acr$l_pagefl;     /* PROCESS/IMAGE PEAK PAGE FILE USAGE  */
    unsigned long int acr$l_diocnt;     /* PROCESS/IMAGE DIRECT I/O COUNT   */
    unsigned long int acr$l_biocnt;     /* PROCESS/IMAGE BUFFERED I/O COUNT  */
    unsigned long int acr$l_volumes;    /* PROCESS/IMAGE VOLUME MOUNT COUNT  */
/*                                                                          */
/* IMAGENAME PACKET                                                         */
/*                                                                          */
    } ;
struct acrdef4 {
    char acrdef$$_fill_5 [4];
    char acr$t_imagename [256];         /* IMAGENAME                        */
/*                                                                          */
/* PRINT RESOURCE PACKET                                                    */
/*                                                                          */
    } ;
struct acrdef5 {
    char acrdef$$_fill_6 [4];
    unsigned long int acr$l_printsts;   /* JOB STATUS                       */
    unsigned int acr$q_quetime [2];     /* TIME JOB WAS QUEUED              */
    unsigned int acr$q_begtime [2];     /* TIME JOB WAS BEGUN               */
    unsigned long int acr$l_symcputim;  /* SYMBIONT CPU TIME                */
    unsigned long int acr$l_pagecnt;    /* TOTAL PAGES PRINTED              */
    unsigned long int acr$l_qiocnt;     /* TOTAL QIOS ISSUED                */
    unsigned long int acr$l_getcnt;     /* TOTAL GETS ISSUED                */
/*                                                                          */
/* FILENAME PACKET                                                          */
/*                                                                          */
    } ;
struct acrdef6 {
    char acrdef$$_fill_7 [4];
    char acr$t_filename [256];          /* FILENAME                         */
/*                                                                          */
/* USER DATA PACKET                                                         */
/*                                                                          */
    } ;
struct acrdef7 {
    char acrdef$$_fill_8 [4];
    char acr$t_user_data [256];         /* USER DATA                        */
    } ;
#pragma standard

#endif					/* __ACRDEF_LOADED */
#ifndef __ARGDEF_LOADED
#define __ARGDEF_LOADED	1

/*** MODULE $argdef ***/
/*                                                                          */
/*        ARG$ - The argument descriptors                                   */
/*                                                                          */
#define ARG$C_UNKNOWN 0                 /* Unspecified or unknown           */
#define ARG$C_VALUE 1                   /* Passed by value                  */
#define ARG$C_REF 2                     /* Passed by reference              */
#define ARG$C_DESC 3                    /* Passed by descriptor             */
#define ARG$K_SIZE 2
#define ARG$C_SIZE 2
#pragma nostandard
struct argdef {
    variant_union  {
        unsigned char arg$b_valctl;     /*Validation control byte           */
        variant_struct  {
            unsigned arg$v_passmech : 2; /*Passing mechanism                */
            unsigned arg$v_fill_18 : 6;
            } arg$r_valctl_bits;
/* Passing mechanisms                                                       */
        } arg$r_valctl_overlay;
    unsigned char arg$b_bytecnt;        /*Remaining byte count              */
    } ;
#pragma standard

#endif					/* __ARGDEF_LOADED */
#ifndef __ARMDEF_LOADED
#define __ARMDEF_LOADED	1

/*** MODULE $armdef ***/
/*+                                                                         */
/* Access Rights Mask longword definitions                                  */
/*-                                                                         */
#define ARM$M_READ 1
#define ARM$M_WRITE 2
#define ARM$M_EXECUTE 4
#define ARM$M_DELETE 8
#define ARM$M_CONTROL 16
struct armdef {
    unsigned arm$v_read : 1;            /* Read access                      */
    unsigned arm$v_write : 1;           /* Write access                     */
    unsigned arm$v_execute : 1;         /* Execute access                   */
    unsigned arm$v_delete : 1;          /* Delete access                    */
    unsigned arm$v_control : 1;         /* Control access (modify attributes) */
    unsigned arm$v_fill : 27;
    } ;
 

#endif					/* __ARMDEF_LOADED */
/*	ASSERT - V3.0	*/

# ifdef NDEBUG
# define assert(expr) 
# else
extern int _assert ();
# define assert(expr) 					\
	if	(expr) ;				\
	else { _assert ("expr", __FILE__, __LINE__); abort(); }
# endif
#ifndef __ATRDEF_LOADED
#define __ATRDEF_LOADED	1

/*** MODULE $atrdef ***/
/* ATTRIBUTE LIST DESCRIPTION. THE ATTRIBUTE CONTROL LIST IS USED TO READ AND */
/* WRITE FILE ATTRIBUTES. IT CONSISTS OF CONCATENATED ATTRIBUTE CONTROL BLOCKS */
/* TERMINATED BY A SINGLE ZERO LONGWORD.                                    */
/*                                                                          */
#define ATR$C_UCHAR 3                   /* 4 BYTE USER FILE CHARACTERISTICS  */
#define ATR$C_RECATTR 4                 /* 32 BYTES RECORD ATTRIBUTES       */
#define ATR$C_FILNAM 5                  /* 6 BYTE RAD-50 FILE NAME          */
#define ATR$C_FILTYP 6                  /* 2 BYTE RAD-50 FILE TYPE          */
#define ATR$C_FILVER 7                  /* 2 BYTE BINARY FILE VERSION       */
#define ATR$C_EXPDAT 8                  /* 7 BYTE ASCII EXPIRATION DATE     */
#define ATR$C_STATBLK 9                 /* 32 BYTE STATISTICS BLOCK         */
#define ATR$C_HEADER 10                 /* 512 BYTE FILE HEADER             */
#define ATR$C_BLOCKSIZE 11              /* MAGTAPE BLOCK SIZE               */
#define ATR$C_USERLABEL 12              /* USER FILE LABEL                  */
#define ATR$C_ASCDATES 13               /* REVISION COUNT THRU EXP DATE IN ASCII  */
#define ATR$C_ALCONTROL 14              /* COMPATIBILITY MODE ALLOCATION DATA  */
#define ATR$C_ENDLBLAST 15              /* END OF MAGTAPE LABEL PROCESSING AND SUPPLY AST CONTROL BLOCK  */
#define ATR$C_ASCNAME 16                /* FILE NAME, TYPE & VERSION IN ASCII  */
#define ATR$C_CREDATE 17                /* 64 BIT CREATION DATE             */
#define ATR$C_REVDATE 18                /* 64 BIT REVISION DATE             */
#define ATR$C_EXPDATE 19                /* 64 BIT EXPIRATION DATE           */
#define ATR$C_BAKDATE 20                /* 64 BIT BACKUP DATE               */
#define ATR$C_UIC 21                    /* 4 BYTE FILE OWNER UIC            */
#define ATR$C_FPRO 22                   /* 2 BYTE FILE PROTECTION           */
#define ATR$C_RPRO 23                   /* 2 BYTE RECORD PROTECTION         */
#define ATR$C_ACLEVEL 24                /* 1 BYTE FILE ACCESS LEVEL         */
#define ATR$C_SEMASK 25                 /* FILE SECURITY MASK AND LIMIT     */
#define ATR$C_UIC_RO 26                 /* READ ONLY UIC                    */
#define ATR$C_DIRSEQ 27                 /* DIRECTORY UPDATE SEQUENCE COUNT  */
#define ATR$C_BACKLINK 28               /* FILE BACK LINK POINTER           */
#define ATR$C_JOURNAL 29                /* JOURNAL CONTROL FLAGS            */
#define ATR$C_HDR1_ACC 30               /* ANSI TAPE HEADER 1 ACCESSIBILITY  */
/*  CHARACTER                                                               */
#define ATR$C_ADDACLENT 31              /* ADD AN ACCESS CONTROL ENTRY      */
#define ATR$C_DELACLENT 32              /* REMOVE AN ACCESS CONTROL ENTRY   */
#define ATR$C_MODACLENT 33              /* MODIFY AN ACL ENTRY              */
#define ATR$C_FNDACLENT 34              /* LOCATE AN ACL ENTRY              */
#define ATR$C_FNDACLTYP 35              /* FIND A SPECIFIC TYPE OF ACE      */
#define ATR$C_DELETEACL 36              /* DELETE THE ENTIRE ACL            */
#define ATR$C_READACL 37                /* READ THE ENTIRE ACL              */
#define ATR$C_ACLLENGTH 38              /* RETURN THE LENGTH OF THE ACL     */
#define ATR$C_READACE 39                /* READ A SINGLE ACE                */
#define ATR$C_RESERVED 40               /* MODIFY RESERVED AREA             */
#define ATR$C_HIGHWATER 41              /* HIGHWATER MARK (USER READ ONLY)     */
#define ATR$C_DUMMY_0 42                /* *** AVAILABLE CODE               */
#define ATR$C_PRIVS_USED 43             /* PRIVILEGES USED TO GAIN ACCESS   */
#define ATR$C_MATCHING_ACE 44           /* ACE USED TO GAIN ACCESS (IF ANY) */
#define ATR$C_ACCESS_MODE 45            /* ACCESS MODE FOR FOLLOWING ATTRIBUTE DESCRIPTORS */
#define ATR$C_FILE_SPEC 46              /* CONVERT FID TO FILE-SPEC         */
#define ATR$C_CLASS_MASK 47             /* Non-discretionary classification mask */
#define ATR$C_BUFFER_OFFSET 48          /* For magnetic tape only length of buffer offset of block in file */
#define ATR$C_RU_ACTIVE 49              /* Recoverable facility id number (if non-zero, means file has */
/* active recovery units managed by that facility)                          */
#define ATR$C_GRANT_ACE 50              /* ACE granting access              */
#define ATR$C_NEXT_ACE 51               /* Increment ACE number             */
/* All new attributes should be                                             */
/*  added here before MAX_PLUS1                                             */
#define ATR$C_MAX_PLUS1 52              /* Maximum code plus one            */
#define ATR$C_MAX_CODE 51
#define ATR$C_FNDACETYP 35
/* ATTRIBUTE MAXIMUM LENGTHS                                                */
#define ATR$S_UCHAR 4                   /* 4 BYTE USER FILE CHARACTERISTICS  */
#define ATR$S_RECATTR 32                /* 32 BYTES RECORD ATTRIBUTES       */
#define ATR$S_FILNAM 6                  /* 6 BYTE RAD-50 FILE NAME          */
#define ATR$S_FILTYP 2                  /* 2 BYTE RAD-50 FILE TYPE          */
#define ATR$S_FILVER 2                  /* 2 BYTE BINARY FILE VERSION       */
#define ATR$S_EXPDAT 7                  /* 7 BYTE ASCII EXPIRATION DATE     */
#define ATR$S_STATBLK 32                /* 32 BYTE STATISTICS BLOCK         */
#define ATR$S_HEADER 512                /* 512 BYTE FILE HEADER             */
#define ATR$S_BLOCKSIZE 2               /* MAGTAPE BLOCK SIZE               */
#define ATR$S_USERLABEL 80              /* USER FILE LABEL                  */
#define ATR$S_ASCDATES 35               /* REVISION COUNT THRU EXP DATE IN ASCII  */
#define ATR$S_ALCONTROL 14              /* COMPATIBILITY MODE ALLOCATION DATA  */
#define ATR$S_ENDLBLAST 4               /* END OF MAGTAPE LABEL PROCESSING AND SUPPLY AST CONTROL BLOCK  */
#define ATR$S_ASCNAME 86                /* FILE NAME, TYPE & VERSION IN ASCII  */
#define ATR$S_CREDATE 8                 /* 64 BIT CREATION DATE             */
#define ATR$S_REVDATE 8                 /* 64 BIT REVISION DATE             */
#define ATR$S_EXPDATE 8                 /* 64 BIT EXPIRATION DATE           */
#define ATR$S_BAKDATE 8                 /* 64 BIT BACKUP DATE               */
#define ATR$S_UIC 4                     /* 4 BYTE FILE OWNER UIC            */
#define ATR$S_FPRO 2                    /* 2 BYTE FILE PROTECTION           */
#define ATR$S_RPRO 2                    /* 2 BYTE RECORD PROTECTION         */
#define ATR$S_ACLEVEL 1                 /* 1 BYTE FILE ACCESS LEVEL         */
#define ATR$S_SEMASK 8                  /* FILE SECURITY MASK AND LIMIT     */
#define ATR$S_UIC_RO 4                  /* READ ONLY UIC                    */
#define ATR$S_DIRSEQ 2                  /* DIRECTORY UPDATE SEQUENCE COUNT  */
#define ATR$S_BACKLINK 6                /* FILE BACK LINK POINTER           */
#define ATR$S_JOURNAL 1                 /* JOURNAL CONTROL FLAGS            */
#define ATR$S_HDR1_ACC 1                /* ANSI TAPE HEADER 1 ACCESSIBILITY  */
/*  CHARACTER                                                               */
#define ATR$S_ADDACLENT 255             /* ADD AN ACCESS CONTROL ENTRY      */
#define ATR$S_DELACLENT 255             /* REMOVE AN ACCESS CONTROL ENTRY   */
#define ATR$S_MODACLENT 255             /* MODIFY AN ACL ENTRY              */
#define ATR$S_FNDACLENT 255             /* LOCATE AN ACL ENTRY              */
#define ATR$S_FNDACLTYP 255             /* FIND A SPECIFIC TYPE OF ACE      */
#define ATR$S_FNDACETYP 255             /* FIND A SPECIFIC TYPE OF ACE      */
#define ATR$S_DELETEACL 255             /* DELETE THE ENTIRE ACL            */
#define ATR$S_READACL 512               /* READ THE ENTIRE ACL              */
#define ATR$S_ACLLENGTH 4               /* RETURN THE LENGTH OF THE ACL     */
#define ATR$S_READACE 255               /* READ A SINGLE ACE                */
#define ATR$S_RESERVED 380              /* MODIFY RESERVED AREA             */
#define ATR$S_HIGHWATER 4               /* FILE HIGH WATER MARK (USER READ ONLY)     */
#define ATR$S_DUMMY_0 4                 /* *** AVAILABLE CODE               */
#define ATR$S_PRIVS_USED 4              /* PRIVS USED TO GAIN ACCESS        */
#define ATR$S_MATCHING_ACE 255          /* ACE USED TO GAIN ACCESS          */
#define ATR$S_ACCESS_MODE 1             /* ACCESS MODE FOR FOLLOWING ATTRIBUTE DESCRIPTORS */
#define ATR$S_FILE_SPEC 512             /* CONVERT FID TO FILE-SPEC         */
#define ATR$S_CLASS_MASK 20             /* Non-discretionary classification mask */
#define ATR$S_BUFFER_OFFSET 2           /* Buffer offset length field       */
#define ATR$S_RU_ACTIVE 1               /* Recoverable facility id if RUs active */
#define ATR$S_GRANT_ACE 255             /* ACE granting access              */
#define ATR$S_NEXT_ACE 4                /* Increment ACE number             */
struct atrdef {
    unsigned short int atr$w_size;      /* SIZE OF ATTRIBUTE IN BYTES       */
    unsigned short int atr$w_type;      /* ATTRIBUTE TYPE CODE              */
    unsigned long int atr$l_addr;       /* ADDRESS OF ATTRIBUTE TEXT        */
/* ATTRIBUTE CODES                                                          */
    } ;
 

#endif					/* __ATRDEF_LOADED */
#ifndef __BASDEF_LOADED
#define __BASDEF_LOADED	1

/*** MODULE $basdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:19.62 */
/*                                                                          */
/*EDIT: DJM1027                                                             */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/* FACILITY:	GENERAL UTILITY LIBRARY                                     */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS FILE, BASMSG.MSG, CONTAINS THE DEFINITIONS OF THE BASIC        */
/*	MESSAGES FOR VAX/VMS.  THIS FILE IS READ BY THE MESSAGE COMPILER    */
/*	TO BUILD AN OBJECT FILE CONTAINING THE BASIC MESSAGES.              */
/*                                                                          */
/* ENVIRONMENT:	USER MODE - AST REENTRANT                                   */
/*                                                                          */
/* AUTHOR: RTL DEVELOPMENT, CREATION DATE: 06-MAY-1983                      */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	NOTE:	ANY CHANGES TO THIS MODULE MUST ALSO BE REFLECTED IN        */
/*		BASERRMSG.REQ                                               */
/* 1-001	- ORIGINAL.  BLS 6-MAY-1983                                 */
/* 1-002 - CHANGE FACILITY TO BASIC INSTEAD OF BAS.  LEB 2-JUN-1983         */
/* 1-003 - NOPE, FACILITY SHOULD HAVE BEEN BAS ALL ALONG.  MDL 30-JUN-1983  */
/* 1-004 - CHANGE TEXT OF ERROR 178 AND NAME FROM ERRFILCOR TO EXRMSSHR.  MDL 29-AUG-1983 */
/* 1-005 - CHANGE SEVERITY OF PRIUSIFOR.  KC 11-JAN-1985.                   */
/* 1-006 - ADD ILLNETOPE AND ILLTFFOPE.  KC 11-JAN-1985.                    */
/* 1-007 - ADD FORLINPIC (FROM LINE !SL IN PICTURE !AC) AS A TRACEBACK ERROR FOR PICTURES. */
/*	  KC 15-JAN-1985.                                                   */
/* 1-008 - ADD ILLWAIVAL AND DEADLOCK.  KC 23-JUL-1985.                     */
/* 1-009 - ADD ORIERRWAS AND NOTBASIC.  KC 01-SEP-1985.                     */
/* 1-010 - ADD NEW UNUSED ERRORS SO THERE WILL ROOM TO ADD GRAPHICS ERRORS. */
/*	  KC 10-SEP-1985                                                    */
/* 1-011 - ADD ECHTYPNOT.  KC 18-NOV-1985.                                  */
/* 1-012 - ADD INVTRANUM, ILLPICOPE, ILLCLISTA, TRANOTDIF.  KC 26-NOV-1985. */
/* 1-013 - CHANGE GKSNOTINS TO A SEVERE MESSAGE (FROM FATAL).  KC 05-DEC-1985. */
/* 1-014 - ADD COLNOTCON.   KC 10-DEC-1985.                                 */
/* 1-015 - ADD MOST GRAPHICS MESSAGES.  KC 19-DEC-1985.                     */
/* 1-016 - NUMBER 271 IS NOT USED.   CHANGE WORDING OF 260.  KC 08-JAN-1986. */
/* 1-017 - CHANGE "VAX GKS/0b" TO "VAX GKS".  KC 09-JAN-1986.               */
/* 1-018 - CHANGE TYPO IN DEVNOTOPE.  KC 13-JAN-1986.                       */
/* 1-019 - CHANGE TEXT OF KEYBOARD WAIT EXHAUSTED TO "wait exhausted".      */
/*	  KC 17-FEB-1986.                                                   */
/* 1-020 - ADD REMSTRNOT, REMAP'ED STRING NOT STATIC.  KC 20-FEB-1986.      */
/* 1-021 - PAD ALL THE UNUSED MESSAGES WITH SPACES SO WE CAN PATCH          */
/*	  THEM EASILY FOR V4.5.   KC 28-FEB-1986.                           */
/* 1-022 - ADD NEW GRAPHICS ERROR MESSAGES FOR V4.5.   KC 16-APR-1986.      */
/* 1-023 - ADD ILLCNTCLA.   KC 15-MAY-1986.                                 */
/* 1-024 - ADD ARRTOOSMA, ARRAY TOO SMALL.  KC 20-MAY-1986.                 */
/* 1-025 - CHANGE TEXT OF FROLINOEG.  ADD ILLCOLMIX.  KC 16-JUN-1986.       */
/* 1-026 - ADD ILLDEVNAM.  KC 24-JUN-1986.                                  */
/* 1-027 - ADD MESSAGES FOR PROGRAMS W/O LINE NUMBERS.  DJM 14-AUG-1986.    */
/* 1-028 - CHANGE TEXT FOR PROLOSSOR, ADD LOCPOICAN.  DJM 17-SEP-1987.      */
/*--                                                                        */
#define BAS$_FACILITY 26
#define BAS$_VAXBAS 1736707
#define BAS$_BADDIRDEV 1736714
#define BAS$_ILLFILNAM 1736722
#define BAS$_ACCDEVUSE 1736730
#define BAS$_NO_ROOUSE 1736738
#define BAS$_CANFINFIL 1736746
#define BAS$_NOTVALDEV 1736754
#define BAS$_IO_CHAALR 1736762
#define BAS$_DEVNOTAVA 1736770
#define BAS$_IO_CHANOT 1736778
#define BAS$_PROVIO 1736786
#define BAS$_ENDFILDEV 1736794
#define BAS$_FATSYSIO_ 1736802
#define BAS$_USEDATERR 1736810
#define BAS$_DEVHUNWRI 1736818
#define BAS$_KEYWAIEXH 1736826
#define BAS$_NAMACCNOW 1736834
#define BAS$_TOOMANOPE 1736842
#define BAS$_ILLSYSUSA 1736850
#define BAS$_DISBLOINT 1736858
#define BAS$_PACIDSDON 1736866
#define BAS$_DISPACNOT 1736874
#define BAS$_DISPACLOC 1736882
#define BAS$_ILLCLUSIZ 1736890
#define BAS$_DISPACPRI 1736898
#define BAS$_DISPACNEE 1736906
#define BAS$_FATDISPAC 1736914
#define BAS$_IO_TO_DET 1736922
#define BAS$_PROC__TRA 1736930
#define BAS$_CORFILSTR 1736938
#define BAS$_DEVNOTFIL 1736946
#define BAS$_ILLBYTCOU 1736954
#define BAS$_NO_BUFSPA 1736962
#define BAS$_ODDADDTRA 1736970
#define BAS$_RESINSTRA 1736980
#define BAS$_MEMMANVIO 1736988
#define BAS$_SP_STAOVE 1736996
#define BAS$_DISERRDUR 1737004
#define BAS$_MEMPARFAI 1737012
#define BAS$_MAGSELERR 1737018
#define BAS$_MAGRECLEN 1737026
#define BAS$_NONRESRUN 1737034
#define BAS$_VIRBUFTOO 1737042
#define BAS$_VIRARRDIS 1737050
#define BAS$_MATARRTOO 1737058
#define BAS$_VIRARROPE 1737066
#define BAS$_ILLIO_CHA 1737074
#define BAS$_LINTOOLON 1737082
#define BAS$_FLOPOIERR 1737090
#define BAS$_ARGTOOLAR 1737098
#define BAS$_DATFORERR 1737104
#define BAS$_INTERR 1737114
#define BAS$_ILLNUM 1737122
#define BAS$_ILLARGLOG 1737130
#define BAS$_IMASQUROO 1737138
#define BAS$_SUBOUTRAN 1737146
#define BAS$_CANINVMAT 1737154
#define BAS$_OUTOF_DAT 1737162
#define BAS$_ON_STAOUT 1737170
#define BAS$_NOTENODAT 1737178
#define BAS$_INTOVEFOR 1737186
#define BAS$_DIVBY_ZER 1737194
#define BAS$_NO_RUNSYS 1737202
#define BAS$_FIEOVEBUF 1737210
#define BAS$_NOTRANACC 1737218
#define BAS$_ILLMAGUSA 1737226
#define BAS$_MISSPEFEA 1737234
#define BAS$_ILLSWIUSA 1737242
#define BAS$_UNUERR068 1737252
#define BAS$_UNUERR069 1737260
#define BAS$_UNUERR070 1737268
#define BAS$_STANOTFOU 1737276
#define BAS$_RETWITGOS 1737284
#define BAS$_FNEWITFUN 1737292
#define BAS$_UNDFUNCAL 1737300
#define BAS$_ILLSYM 1737308
#define BAS$_ILLVER 1737316
#define BAS$_ILLEXP 1737324
#define BAS$_ILLMODMIX 1737332
#define BAS$_ILLIF_STA 1737340
#define BAS$_ILLCONCLA 1737348
#define BAS$_ILLFUNNAM 1737356
#define BAS$_ILLDUMVAR 1737364
#define BAS$_ILLFN_RED 1737372
#define BAS$_ILLLINNUM 1737380
#define BAS$_MODERR 1737388
#define BAS$_CANCOMSTA 1737394
#define BAS$_EXPTOOCOM 1737404
#define BAS$_ARGDONMAT 1737412
#define BAS$_TOOMANARG 1737420
#define BAS$_INCFUNUSA 1737424
#define BAS$_ILLDEFNES 1737436
#define BAS$_FORWITNEX 1737444
#define BAS$_NEXWITFOR 1737452
#define BAS$_DEFWITFNE 1737460
#define BAS$_FNEWITDEF 1737468
#define BAS$_LITSTRNEE 1737476
#define BAS$_TOOFEWARG 1737484
#define BAS$_SYNERR 1737492
#define BAS$_STRIS_NEE 1737500
#define BAS$_NUMIS_NEE 1737508
#define BAS$_DATTYPERR 1737516
#define BAS$_ONEOR_TWO 1737524
#define BAS$_PROLOSSOR 1737532
#define BAS$_RESNO_ERR 1737540
#define BAS$_REDARR 1737546
#define BAS$_INCSUBUSE 1737552
#define BAS$_ON_STANEE 1737564
#define BAS$_ENDOF_STA 1737572
#define BAS$_WHA 1737579
#define BAS$_BADLINNUM 1737588
#define BAS$_NOTENOAVA 1737596
#define BAS$_EXEONLFIL 1737604
#define BAS$_PLEUSERUN 1737612
#define BAS$_CANCON 1737620
#define BAS$_FILEXIREN 1737628
#define BAS$_PRIUSIFOR 1737634
#define BAS$_MATARRWIT 1737644
#define BAS$_BADNUMPRI 1737652
#define BAS$_ILLIN_IMM 1737660
#define BAS$_PRIUSIBUF 1737668
#define BAS$_ILLSTA 1737676
#define BAS$_ILLFIEVAR 1737684
#define BAS$_STO 1737691
#define BAS$_MATDIMERR 1737700
#define BAS$_WROMATPAC 1737708
#define BAS$_MAXMEMEXC 1737716
#define BAS$_SCAFACINT 1737724
#define BAS$_TAPRECNOT 1737730
#define BAS$_TAPBOTDET 1737738
#define BAS$_KEYNOTCHA 1737746
#define BAS$_NO_CURREC 1737754
#define BAS$_RECHASBEE 1737762
#define BAS$_ILLUSADEV 1737770
#define BAS$_DUPKEYDET 1737778
#define BAS$_ILLUSA 1737786
#define BAS$_ILLILLACC 1737794
#define BAS$_ILLKEYATT 1737802
#define BAS$_FILIS_LOC 1737810
#define BAS$_INVFILOPT 1737818
#define BAS$_INDNOTINI 1737826
#define BAS$_ILLOPE 1737834
#define BAS$_ILLRECFIL 1737842
#define BAS$_BADRECIDE 1737850
#define BAS$_INVKEYREF 1737858
#define BAS$_KEYSIZTOO 1737866
#define BAS$_TAPNOTANS 1737874
#define BAS$_RECNUMEXC 1737882
#define BAS$_BADRECVAL 1737890
#define BAS$_NOTENDFIL 1737898
#define BAS$_NO_PRIKEY 1737906
#define BAS$_KEYFIEBEY 1737914
#define BAS$_ILLRECACC 1737922
#define BAS$_RECALREXI 1737930
#define BAS$_RECBUCLOC 1737938
#define BAS$_RECNOTFOU 1737946
#define BAS$_SIZRECINV 1737954
#define BAS$_RECFILTOO 1737962
#define BAS$_PRIKEYOUT 1737970
#define BAS$_KEYLARTHA 1737978
#define BAS$_FILATTNOT 1737986
#define BAS$_MOVOVEBUF 1737994
#define BAS$_CANOPEFIL 1738002
#define BAS$_NO_FILNAM 1738010
#define BAS$_TERFORFIL 1738018
#define BAS$_CANPOSEOF 1738026
#define BAS$_NEGFILSTR 1738034
#define BAS$_ILLRECFOR 1738042
#define BAS$_ILLALLCLA 1738050
#define BAS$_UNUERR169 1738060
#define BAS$_INDNOTFUL 1738066
#define BAS$_RRVNOTFUL 1738074
#define BAS$_RECLOCFAI 1738082
#define BAS$_INVRFAFIE 1738090
#define BAS$_FILEXPDAT 1738098
#define BAS$_NODNAMERR 1738106
#define BAS$_NEGZERTAB 1738112
#define BAS$_TOOMUCDAT 1738120
#define BAS$_EXRMSSHR 1738130
#define BAS$_UNEFILDAT 1738138
#define BAS$_NOSUPFOR 1738146
#define BAS$_DECERR 1738154
#define BAS$_NETOPEREJ 1738162
#define BAS$_REMOVEBUF 1738170
#define BAS$_UNAREMVAR 1738180
#define BAS$_RECOVEMAP 1738188
#define BAS$_IMPERRHAN 1738196
#define BAS$_ILLRECLOC 1738204
#define BAS$_REQRECSIZ 1738210
#define BAS$_TOOLITDAT 1738216
#define BAS$_ILLNETOPE 1738226
#define BAS$_ILLTFFOPE 1738234
#define BAS$_ILLWAIVAL 1738242
#define BAS$_DEADLOCK 1738250
#define BAS$_NOTBASIC 1738258
#define BAS$_DIMOUTRAN 1738266
#define BAS$_REMSTRNOT 1738276
#define BAS$_ARRTOOSMA 1738282
#define BAS$_UNUERR198 1738292
#define BAS$_UNUERR199 1738300
#define BAS$_UNUERR200 1738308
#define BAS$_UNUERR201 1738316
#define BAS$_UNUERR202 1738324
#define BAS$_UNUERR203 1738332
#define BAS$_UNUERR204 1738340
#define BAS$_UNUERR205 1738348
#define BAS$_UNUERR206 1738356
#define BAS$_UNUERR207 1738364
#define BAS$_UNUERR208 1738372
#define BAS$_UNUERR209 1738380
#define BAS$_UNUERR210 1738388
#define BAS$_UNUERR211 1738396
#define BAS$_UNUERR212 1738404
#define BAS$_UNUERR213 1738412
#define BAS$_UNUERR214 1738420
#define BAS$_UNUERR215 1738428
#define BAS$_UNUERR216 1738436
#define BAS$_UNUERR217 1738444
#define BAS$_UNUERR218 1738452
#define BAS$_UNUERR219 1738460
#define BAS$_UNUERR220 1738468
#define BAS$_UNUERR221 1738476
#define BAS$_UNUERR222 1738484
#define BAS$_UNUERR223 1738492
#define BAS$_UNUERR224 1738500
#define BAS$_UNUERR225 1738508
#define BAS$_GKSNOTINS 1738514
#define BAS$_STRTOOLON 1738522
#define BAS$_RECATTNOT 1738530
#define BAS$_DIFUSELON 1738540
#define BAS$_NO_FIEIMA 1738546
#define BAS$_ILLSTRIMA 1738554
#define BAS$_NULIMA 1738562
#define BAS$_ILLNUMIMA 1738570
#define BAS$_NUMIMASTR 1738578
#define BAS$_STRIMANUM 1738586
#define BAS$_TIMLIMEXC 1738594
#define BAS$_FIRARGSEQ 1738602
#define BAS$_ARRMUSSAM 1738610
#define BAS$_ARRMUSSQU 1738618
#define BAS$_CANCHAARR 1738626
#define BAS$_FLOOVE 1738634
#define BAS$_FLOUND 1738642
#define BAS$_CHATO_NON 1738650
#define BAS$_EXPERR 1738658
#define BAS$_ILLEXIDEF 1738668
#define BAS$_ERRTRANEE 1738676
#define BAS$_ILLRESSUB 1738684
#define BAS$_ILLRETSUB 1738690
#define BAS$_ARGOUTBOU 1738698
#define BAS$_NOTIMP 1738706
#define BAS$_RECSUBCAL 1738714
#define BAS$_FILACPFAI 1738722
#define BAS$_DIRERR 1738730
#define BAS$_UNUERR254 1738740
#define BAS$_UNUERR255 1738748
#define BAS$_ECHTYPNOT 1738754
#define BAS$_ILLTRANUM 1738762
#define BAS$_ILLPICOPE 1738770
#define BAS$_CLIPONOFF 1738778
#define BAS$_TRANOTDIF 1738786
#define BAS$_COLNOTCON 1738794
#define BAS$_ILLARESTY 1738802
#define BAS$_ILLTEXJUS 1738810
#define BAS$_ILLTEXPRE 1738818
#define BAS$_ILLTEXPAT 1738826
#define BAS$_ILLDEVID 1738834
#define BAS$_DEVTYPNOT 1738842
#define BAS$_DEVNOTOPE 1738850
#define BAS$_DEVOUTMET 1738858
#define BAS$_DEVINMET 1738866
#define BAS$_UNUERR271 1738876
#define BAS$_DEVOPEINC 1738882
#define BAS$_COONOTNDC 1738890
#define BAS$_ILLLINSTY 1738898
#define BAS$_ILLLINSIZ 1738906
#define BAS$_ILLPOISTY 1738914
#define BAS$_ILLTEXRAT 1738922
#define BAS$_ILLTEXHEI 1738930
#define BAS$_ILLSTYIND 1738938
#define BAS$_ILLCOLIND 1738946
#define BAS$_NUMCOOINS 1738954
#define BAS$_UNINUMNOT 1738962
#define BAS$_ILLECHARE 1738970
#define BAS$_ILLINIVAL 1738978
#define BAS$_ENTPOINOT 1738986
#define BAS$_UNKGKSERR 1738994
#define BAS$_INVCHASTR 1739002
#define BAS$_STRLENZER 1739010
#define BAS$_DATOVERF 1739018
#define BAS$_ILLCNTCLA 1739026
#define BAS$_ILLCOLMIX 1739034
#define BAS$_ILLDEVNAM 1739042
#define BAS$_USEABOINP 1739050
#define BAS$_UNUERR294 1739060
#define BAS$_UNUERR295 1739068
#define BAS$_UNUERR296 1739076
#define BAS$_UNUERR297 1739084
#define BAS$_UNUERR298 1739092
#define BAS$_UNUERR299 1739100
#define BAS$_UNUERR300 1739108
#define BAS$_FROPIC 1769299
#define BAS$_FROMOD 1769307
#define BAS$_FROSUB 1769315
#define BAS$_FROFUN 1769323
#define BAS$_FRODEFMOD 1769331
#define BAS$_FRODFSMOD 1769339
#define BAS$_FROGSBMOD 1769347
#define BAS$_FROOEGMOD 1769355
/*                                                                          */
#define BAS$_ORIERRWAS 1769363
#define BAS$_GKSACTIVATED 1769372
#define BAS$_FROLINPIC 1769379
#define BAS$_FORFILUSE 1769387
#define BAS$_USEPC_PSL 1769395
#define BAS$_FROIOL 1769403
#define BAS$_ON_CHAFIL 1769411
#define BAS$_FROLINMOD 1769419
#define BAS$_FROLINSUB 1769427
#define BAS$_FROLINFUN 1769435
#define BAS$_FROLINDEF 1769443
#define BAS$_FROLINDFS 1769451
#define BAS$_FROLINGSB 1769459
#define BAS$_FROLINOEG 1769467

#endif					/* __BASDEF_LOADED */
#ifndef __BRKDEF_LOADED
#define __BRKDEF_LOADED	1

/*** MODULE $brkdef ***/
/*+                                                                         */
/*                                                                          */
/* Breakthru system service input definitions.                              */
/*                                                                          */
/*-                                                                         */
#define BRK$C_DEVICE 1                  /* device name                      */
#define BRK$C_USERNAME 2                /* user name                        */
#define BRK$C_ALLUSERS 3                /* all users                        */
#define BRK$C_ALLTERMS 4                /* all logged in users              */
#define BRK$C_MAXSENDTYPE 4
/*                                                                          */
/* Requestor ID's, DEC use only (0-31)                                      */
/*                                                                          */
#define BRK$C_GENERAL 0                 /* GENERAL (OR UNSPECIFIED)         */
#define BRK$C_PHONE 1                   /* PHONE                            */
#define BRK$C_MAIL 2                    /* MAIL                             */
#define BRK$C_QUEUE 3                   /* QUEUE MANAGER                    */
#define BRK$C_SHUTDOWN 4                /* SYSTEM SHUTDOWN                  */
#define BRK$C_URGENT 5                  /* URGENT MESSAGE                   */
#define BRK$C_DCL 6                     /* DCL (control T)                  */
#define BRK$C_OPCOM 7                   /* OPERATOR MESSAGE                 */
/* Note that only first 16 are really stored by TTDRIVER now                */
#define BRK$C_USER1 32                  /* reserved to customer             */
#define BRK$C_USER2 33                  /* reserved to customer             */
#define BRK$C_USER3 34                  /* reserved to customer             */
#define BRK$C_USER4 35                  /* reserved to customer             */
#define BRK$C_USER5 36                  /* reserved to customer             */
#define BRK$C_USER6 37                  /* reserved to customer             */
#define BRK$C_USER7 38                  /* reserved to customer             */
#define BRK$C_USER8 39                  /* reserved to customer             */
#define BRK$C_USER9 40                  /* reserved to customer             */
#define BRK$C_USER10 41                 /* reserved to customer             */
#define BRK$C_USER11 42                 /* reserved to customer             */
#define BRK$C_USER12 43                 /* reserved to customer             */
#define BRK$C_USER13 44                 /* reserved to customer             */
#define BRK$C_USER14 45                 /* reserved to customer             */
#define BRK$C_USER15 46                 /* reserved to customer             */
#define BRK$C_USER16 47                 /* reserved to customer             */
#define BRK$M_SCREEN 256
#define BRK$M_BOTTOM 512
#define BRK$M_NOREFRESH 1024
#define BRK$M_CLUSTER 2048
struct flags_input {                    /* mimics $BRDCSTDEF                */
    unsigned brk$v_erase_lines : 8;     /* number of lines to erase         */
    unsigned brk$v_screen : 1;          /* Do screen formatted write        */
    unsigned brk$v_bottom : 1;          /* "screen" message at bottom       */
    unsigned brk$v_norefresh : 1;       /* Refresh an interrupted read      */
    unsigned brk$v_cluster : 1;         /* broadcast to cluster             */
    unsigned brk$v_fill_13 : 4;
    } ;
 

#endif					/* __BRKDEF_LOADED */
/********************************************************************************************************************************/
/* Created 25-MAY-1990 18:33:55 by VAX SDL V3.2-10     Source: 22-AUG-1989 11:35:21 DECW$LIBSRESD:[DDIFLIB.SRC]CDA$DEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE CDA$DEFINITIONS IDENT V1-006 ***/
/*++                                                                        */
/*                                                                          */
/*  COPYRIGHT (c) 1987, 1989 BY                                             */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                           */
/*  ALL RIGHTS RESERVED.                                                    */
/*                                                                          */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  */
/*  TRANSFERRED.                                                            */
/*                                                                          */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  */
/*  CORPORATION.                                                            */
/*                                                                          */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 */
/*                                                                          */
/* Function codes for CDA$CONVERT and domain$WRITE_format.                  */
#define CDA$_START 1                    /* Start conversion                 */
#define CDA$_CONTINUE 2                 /* Continue conversion              */
#define CDA$_STOP 3                     /* Stop conversion                  */
/* Item list structure definition.                                          */
struct item_list {
    unsigned short int cda$w_item_length; /* Item buffer length             */
    unsigned short int cda$w_item_code; /* Item code                        */
    char *cda$a_item_address;           /* Item buffer address              */
    } ;
/* Item codes for CDA$CONVERT, CDA$OPEN_CONVERTER, domain$READ_format, and  */
/* domain$WRITE_format.                                                     */
#define CDA$_PROCESSING_OPTION 1        /* Processing option                */
#define CDA$_INPUT_FORMAT 2             /* Input document format-name       */
#define CDA$_INPUT_FRONT_END_PROCEDURE 3 /* Input document front-end procedure */
#define CDA$_INPUT_FILE 4               /* Input file specification         */
#define CDA$_INPUT_DEFAULT 5            /* Input default file specification */
#define CDA$_INPUT_PROCEDURE 6          /* Input get data procedure         */
#define CDA$_INPUT_POSITION_PROCEDURE 7 /* Input get position procedure     */
#define CDA$_INPUT_PROCEDURE_PARM 8     /* Input procedure parameter        */
#define CDA$_INPUT_ROOT_AGGREGATE 9     /* Input root aggregate             */
#define CDA$_OUTPUT_FORMAT 10           /* Output document format-name      */
#define CDA$_OUTPUT_BACK_END_PROCEDURE 11 /* Output document back-end procedure */
#define CDA$_OUTPUT_FILE 12             /* Output file specification        */
#define CDA$_OUTPUT_DEFAULT 13          /* Output default file specification */
#define CDA$_OUTPUT_PROCEDURE 14        /* Output procedure                 */
#define CDA$_OUTPUT_PROCEDURE_PARM 15   /* Output procedure parameter       */
#define CDA$_OUTPUT_PROCEDURE_BUFFER 16 /* Output procedure initial buffer  */
#define CDA$_OUTPUT_ROOT_AGGREGATE 17   /* Output root aggregate            */
#define CDA$_OPTIONS_FILE 18            /* Options file specification       */
#define CDA$_INPUT_FRONT_END_DOMAIN 19  /* Input document front-end domain  */
#define CDA$_OUTPUT_BACK_END_DOMAIN 20  /* Output document back-end domain  */
#define CDA$_OPTIONS_LINE 21            /* Options line                     */
/* Character set identification codes (DEC STD 169).                        */
#define CDA$K_ISO_LATIN1 1              /* ISO Latin 1 (ISO 8859-1)         */
#define CDA$K_ISO_LATIN2 2              /* ISO Latin 2 (ISO 8859-2)         */
#define CDA$K_ISO_LATIN_ARABIC 3        /* ISO Latin-Arabic (ISO 8859-6)    */
#define CDA$K_ISO_LATIN_GREEK 4         /* ISO Latin-Greek (ISO 8859-7)     */
#define CDA$K_ISO_LATIN_HEBREW 6        /* ISO Latin-Hebrew (ISO 8859-8)    */
#define CDA$K_JIS_KATAKANA 32           /* JIS Roman, JIS Katakana (JIS X0201) */
#define CDA$K_DEC_TECH 33               /* DEC Special Graphics, DEC Technical */
#define CDA$K_DEC_MATH_ITALIC 34        /* DEC Mathematics Italic           */
#define CDA$K_DEC_MATH_SYMBOL 35        /* DEC Mathematics Symbol           */
#define CDA$K_DEC_MATH_EXTENSION 36     /* DEC Mathematics Extension        */
#define CDA$K_DEC_PUBLISHING 37         /* DEC Publishing                   */
#define CDA$K_DEC_KANJI 64              /* DEC Kanji (JIS X0208)            */
#define CDA$K_DEC_HANZI 65              /* DEC Hanzi (GB 2312)              */
/* Synonym definitions for compatibility                                    */
#define CDA$K_ISO_LATIN6 3              /* Obsolete synonym                 */
#define CDA$K_ISO_LATIN7 4              /* Obsolete synonym                 */
#define CDA$K_ISO_LATIN8 6              /* Obsolete synonym                 */
/* Values of the add-info parameter for CDA$LOCATE_ITEM and CDA$STORE_ITEM when */
/* the item data type is general floating point.                            */
#define CDA$K_F_FLOAT 0                 /* VAX F-floating                   */
#define CDA$K_D_FLOAT 1                 /* VAX D-floating                   */
#define CDA$K_G_FLOAT 2                 /* VAX G-floating                   */
#define CDA$K_H_FLOAT 3                 /* VAX H-floating                   */
#define CDA$K_IEEE_754_S_FLOAT 4        /* IEEE 754 single precision        */
#define CDA$K_IEEE_754_D_FLOAT 5        /* IEEE 754 double precision        */
#define CDA$K_NATIVE_S_FLOAT 6          /* Native single precision  VAX: F-float non-VAX: IEEE 754 single */
#define CDA$K_NATIVE_D_FLOAT 7          /* Native double precision  VAX: G-float non-VAX: IEEE 754 double */
/********************************************************************************************************************************/
/* Created 25-MAY-1990 18:35:33 by VAX SDL V3.2-10     Source: 25-MAY-1990 18:33:43 DECW$LIBSRESD:[DDIFLIB.OBJ]CDA$MSG.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $CDADEF ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on 25-MAY-1990 18:33:45.00 */
/*                                                                          */
/*++                                                                        */
/*                                                                          */
/*   COPYRIGHT (C) 1989 BY                                                  */
/*   DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                          */
/*   ALL RIGHTS RESERVED.                                                   */
/*                                                                          */
/*   THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED */
/*   ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE */
/*   INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER */
/*   COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY */
/*   OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY */
/*   TRANSFERRED.                                                           */
/*                                                                          */
/*   THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE */
/*   AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT */
/*   CORPORATION.                                                           */
/*                                                                          */
/*   DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS */
/*   SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                */
/*                                                                          */
/*   FACILITY:                                                              */
/*	COMPOUND DOCUMENT ACCESS TOOLKIT                                    */
/*                                                                          */
/*   ABSTRACT:                                                              */
/*	THIS FILE DEFINES CONDITION VALUES RETURNED BY CDA TOOLKIT          */
/*	PROCEDURES AND THE MESSAGE TEXT.                                    */
/*                                                                          */
/*   ENVIRONMENT:                                                           */
/*	TRANSPORTABLE.                                                      */
/*                                                                          */
/*   AUTHOR:                                                                */
/*	MARTIN L. JACK, JULY 1987                                           */
/*                                                                          */
/*   MODIFICATION HISTORY:                                                  */
/*                                                                          */
/*	V1-010	RTG0004		DICK GUMBEL		21-DEC-1989         */
/*		ADD INVINPDMN, INVOUTDMN, ICVNOTFND,                        */
/*		OCVNOTFND, AND DCVNOTFND                                    */
/*                                                                          */
/*	V1-009	MHB0000		MARK BRAMHALL		30-NOV-1988         */
/*		ADD CDA$_INHERIT.                                           */
/*                                                                          */
/*	V1-008	MLJ0008		MARTIN L. JACK		18-OCT-1988         */
/*		ADD MESSAGES FOR GENERAL-FLOATING-POINT DATA TYPE HANDLING. */
/*                                                                          */
/*	V1-007  LMS0004		LAUREN M. SACCO		03-OCT-1988         */
/*		ADD CDA$_VERSKEW.                                           */
/*                                                                          */
/*	V1-006	RTG0003		RICHARD T. GUMBEL	03-AUG-1988         */
/*		ADD INVOPTION.                                              */
/*                                                                          */
/*	V1-005	RTG0002		RICHARD T. GUMBEL	24-JUN-1988         */
/*		ADD UNSUPCNV.                                               */
/*                                                                          */
/*	V1-004	RTG0001		RICHARD T. GUMBEL	14-JUN-1988         */
/*		ADD INFINPLOG, INFOUTLOG, ERRINPLOG, ERROUTLOG.             */
/*                                                                          */
/*	V1-003	PMJ0001		PATRICIA M. JUSTUS	01-JUN-1988         */
/*		ADD INVDATLEN.                                              */
/*                                                                          */
/*	V1-002	MLJ0002		MARTIN L. JACK		06-APR-1988         */
/*		ADD INVSCOTRAN.                                             */
/*                                                                          */
/*	V1-001	MLJ0001		MARTIN L. JACK		09-DEC-1987         */
/*		INITIAL CREATION FROM DDIF$MSG.MSG.                         */
/*                                                                          */
/*--                                                                        */
/*+                                                                         */
/* IN ORDER TO DO AUTOMATED EXTRACTIONS FROM THIS MESSAGE FILE, AN IMPORTANT */
/* COMMENTING CONVENTION MUST BE FOLLOWED.  EACH MESSAGE DEFINITION MUST BE */
/* FOLLOWED BY A COMMENT BLOCK USING THE FOLLOWING FORMAT:                  */
/*                                                                          */
/*   XXXXXXXXX		<xxxxxxxxx>                                         */
/*   !<tab>[IDENT]XXXXXXXXX                                                 */
/*   !<tab>[MSG_TEXT]XXXXXXXXX                                              */
/*   !<tab>[MSG_EXP]XXXXXXXXX                                               */
/*   !<tab>[MORE]XXXXXXXXX                                                  */
/*   !<tab>[MSG_ACT]XXXXXXXXX                                               */
/*   !<tab>[MORE]XXXXXXXXX                                                  */
/*   !<tab>[END_MSG]                                                        */
/*                                                                          */
/* THE [IDENT] IS THE MESSAGE'S IDENTIFICATION FIELD.                       */
/*                                                                          */
/* THE [MSG_TEXT] IS THE TEXT OF THE MESSAGE WITH APPROPRIATE SUBSTITUTIONS */
/* FOR ANY FAO ARGUMENTS FILLED IN.                                         */
/*                                                                          */
/* THE [MSG_EXP] IS AN EXPLANATION OF THE MESSAGE.  YOU CAN CONTINUE TO     */
/* SUBSEQUENT LINES BY USING [MORE].                                        */
/*                                                                          */
/* THE [MSG_ACT] IS AN EXPLANATION OF THE ACTION NEEDED TO BE TAKEN BY THE  */
/* USER.  YOU CAN CONTINUE TO SUBSEQUENT LINES BY USING [MORE].             */
/*-                                                                         */
#define CDA$_FACILITY 436
/*	[START_MESSAGES]                                                    */
#define CDA$_NORMAL 28606465
/*	[IDENT]NORMAL                                                       */
/*	[MSG_TEXT]NORMAL SUCCESSFUL COMPLETION                              */
/*	[MSG_EXP]                                                           */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_DEFAULT 28606473
/*	[IDENT]DEFAULT                                                      */
/*	[MSG_TEXT]ITEM PRESENT BY DEFAULT                                   */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$LOCATE_ITEM, WHICH DETERMINED   */
/*	[MORE]THAT THE ITEM WAS PRESENT BY DEFAULT IN THE INPUT STREAM.     */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_SUSPEND 28606481
/*	[IDENT]SUSPEND                                                      */
/*	[MSG_TEXT]CONVERTER IS SUSPENDED                                    */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$CONVERT, WHICH DETERMINED THAT  */
/*	[MORE]THE BACK-END MODULE SUSPENDED CONVERSION.                     */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INHERIT 28606489
/*	[IDENT]INHERIT                                                      */
/*	[MSG_TEXT]ITEM PRESENT BY INHERITANCE                               */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$LOCATE_ITEM, WHICH DETERMINED   */
/*	[MORE]THAT THE ITEM WAS PRESENT BY INHERITANCE IN THE INPUT STREAM. */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INFINPLOG 28607267
/*	[IDENT]INFINPLOG                                                    */
/*	[MSG_TEXT]INFORMATIONAL MESSAGES PRODUCED DURING INPUT CONVERSION, SEE ERROR LOG */
/*	[MSG_EXP]THE INPUT CONVERSION COMPLETED BUT SOME INFORMATIONAL MESSAGES */
/*	[MORE]WERE PRODUCED.  REFER TO THE ERROR LOG FOR MORE DETAILS.      */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INFOUTLOG 28607275
/*	[IDENT]INFOUTLOG                                                    */
/*	[MSG_TEXT]INFORMATIONAL MESSAGES PRODUCED DURING OUTPUT CONVERSION, SEE ERROR LOG */
/*	[MSG_EXP]THE OUTPUT CONVERSION COMPLETED BUT SOME INFORMATIONAL MESSAGES */
/*	[MORE]WERE PRODUCED.  REFER TO THE ERROR LOG FOR MORE DETAILS.      */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_ENDOFDOC 28608866
/*	[IDENT]ENDOFDOC                                                     */
/*	[MSG_TEXT]END OF DOCUMENT                                           */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$GET_AGGREGATE, WHICH DETERMINED */
/*	[MORE]THAT NO MORE AGGREGATES EXIST IN THE DOCUMENT.                */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_ENDOFSEQ 28608874
/*	[IDENT]ENDOFSEQ                                                     */
/*	[MSG_TEXT]END OF SEQUENCE                                           */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$NEXT_AGGREGATE REFERENCING AN   */
/*	[MORE]AGGREGATE THAT WAS AT THE END OF A SEQUENCE.                  */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_EMPTY 28608882
/*	[IDENT]EMPTY                                                        */
/*	[MSG_TEXT]EMPTY ITEM                                                */
/*	[MSG_EXP]THE APPLICATION CALLED A CDA ACCESS PROCEDURE REFERENCING AN */
/*	[MORE]ITEM THAT IS EMPTY.                                           */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INDEX 28608890
/*	[IDENT]INDEX                                                        */
/*	[MSG_TEXT]INDEX OUT OF RANGE                                        */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$LOCATE_ITEM, CDA$STORE_ITEM, OR */
/*	[MORE]CDA$ERASE_ITEM REFERENCING AN ARRAY-VALUED ITEM, BUT THE INDEX */
/*	[MORE]IS OUT OF RANGE.                                              */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVINSERT 28608898
/*	[IDENT]INVINSERT                                                    */
/*	[MSG_TEXT]INVALID INSERT                                            */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$INSERT_AGGREGATE OR             */
/*	[MORE]CDA$STORE_ITEM REFERENCING AN AGGREGATE THAT WAS ALREADY PART */
/*	[MORE]OF A SEQUENCE, BUT WAS NOT THE FIRST AGGREGATE OF THE SEQUENCE. */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVAGGTYP 28608906
/*	[IDENT]INVAGGTYP                                                    */
/*	[MSG_TEXT]INVALID AGGREGATE TYPE                                    */
/*	[MSG_EXP]THE APPLICATION CALLED A CDA ACCESS PROCEDURE REFERENCING AN */
/*	[MORE]AGGREGATE TYPE CODE THAT IS UNDEFINED, OR AN AGGREGATE THAT HAS */
/*	[MORE]AN UNDEFINED TYPE CODE.                                       */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVITMCOD 28608914
/*	[IDENT]INVITMCOD                                                    */
/*	[MSG_TEXT]INVALID ITEM CODE                                         */
/*	[MSG_EXP]THE APPLICATION CALLED A CDA ACCESS PROCEDURE REFERENCING AN */
/*	[MORE]AGGREGATE ITEM CODE THAT IS NOT DEFINED.                      */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVDOC 28608922
/*	[IDENT]INVDOC                                                       */
/*	[MSG_TEXT]INVALID DOCUMENT SYNTAX                                   */
/*	[MSG_EXP]THE CDA ACCESS PROCEDURES DETERMINED THAT THE DOCUMENT     */
/*	[MORE]CONTAINS INVALID SYNTAX.                                      */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVITMLST 28608930
/*	[IDENT]INVITMLST                                                    */
/*	[MSG_TEXT]INVALID ITEM LIST                                         */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$OPEN_FILE OR                    */
/*	[MORE]CDA$CREATE_ROOT_AGGREGATE WITH A PROCESSING OPTIONS ITEM LIST */
/*	[MORE]THAT CONTAINED AN INVALID ITEM.                               */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_VAREMPTY 28608938
/*	[IDENT]VAREMPTY                                                     */
/*	[MSG_TEXT]EMPTY VARIANT ITEM                                        */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$LOCATE_ITEM, CDA$STORE_ITEM, OR */
/*	[MORE]CDA$ERASE_ITEM REFERENCING AN ITEM THAT HAS A VARIABLE DATA   */
/*	[MORE]TYPE.  THE ITEM THAT SPECIFIES THE DATA TYPE IS EMPTY.        */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_VARINDEX 28608946
/*	[IDENT]VARINDEX                                                     */
/*	[MSG_TEXT]VARIANT INDEX OUT OF RANGE                                */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$LOCATE_ITEM, CDA$STORE_ITEM, OR */
/*	[MORE]CDA$ERASE_ITEM REFERENCING AN ARRAY-VALUED ITEM THAT HAS A    */
/*	[MORE]VARIABLE DATA TYPE, BUT THE INDEX IS OUT OF RANGE FOR THE ITEM */
/*	[MORE]THAT SPECIFIES THE DATA TYPE.                                 */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_VARVALUE 28608954
/*	[IDENT]VARVALUE                                                     */
/*	[MSG_TEXT]VARIANT VALUE OUT OF RANGE                                */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$LOCATE_ITEM, CDA$STORE_ITEM, OR */
/*	[MORE]CDA$ERASE_ITEM REFERENCING AN ITEM THAT HAS A VARIABLE        */
/*	[MORE]DATA TYPE, BUT THE ITEM THAT SPECIFIES THE DATA TYPE HAS AN   */
/*	[MORE]INVALID VALUE.                                                */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVTAGCOD 28608962
/*	[IDENT]INVTAGCOD                                                    */
/*	[MSG_TEXT]INVALID TAG CODE                                          */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$_STORE_ITEM REFERENCING AN ITEM */
/*	[MORE]THAT HAS A SPECIAL TAG ENCODING, BUT THE VALUE OF THE ADD-INFO */
/*	[MORE]PARAMETER IS NOT DEFINED FOR THE ITEM.                        */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVBUFLEN 28608970
/*	[IDENT]INVBUFLEN                                                    */
/*	[MSG_TEXT]INVALID BUFFER LENGTH                                     */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$_STORE_ITEM REFERENCING AN ITEM */
/*	[MORE]THAT IS REQUIRED TO HAVE A SPECIFIED BUFFER LENGTH.  THE      */
/*	[MORE]VALUE OF THE BUFFER LENGTH PARAMETER IS NOT THE REQUIRED VALUE. */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_ALLOCFAIL 28608978
/*	[IDENT]ALLOCFAIL                                                    */
/*	[MSG_TEXT]MEMORY ALLOCATION FAILURE                                 */
/*	[MSG_EXP]THE STANDARD MEMORY ALLOCATION PROCEDURE                   */
/*	[MORE]FAILED TO ALLOCATE DYNAMIC MEMORY.                            */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVFUNCOD 28608986
/*	[IDENT]INVFUNCOD                                                    */
/*	[MSG_TEXT]INVALID FUNCTION CODE                                     */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$CONVERT WITH AN INVALID FUNCTION */
/*	[MORE]CODE.                                                         */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_UNSUPFMT 28608994
/*	[IDENT]UNSUPFMT                                                     */
/*	[MSG_TEXT]UNSUPPORTED DOCUMENT FORMAT                               */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$CONVERT WITH AN UNSUPPORTED     */
/*	[MORE]DOCUMENT FORMAT NAME.  THE DOCUMENT FORMAT NAME MAY BE MISSPELLED, */
/*	[MORE]OR THE REQUIRED CONVERSION MODULE MAY NOT BE INSTALLED.       */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_READONLY 28609002
/*	[IDENT]READONLY                                                     */
/*	[MSG_TEXT]AGGREGATE IS READ-ONLY                                    */
/*	[MSG_EXP]THE APPLICATION REQUESTED INPUT PROCESSING OPTIONS THAT    */
/*	[MORE]REQUIRE AN AGGREGATE TO BE READ-ONLY.  THE APPLICATION ATTEMPTED */
/*	[MORE]TO WRITE OR DELETE THE AGGREGATE.                             */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_DEFNOTFOU 28609010
/*	[IDENT]DEFNOTFOU                                                    */
/*	[MSG_TEXT]DEFINITION NOT FOUND                                      */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$FIND_DEFINITION REFERENCING AN  */
/*	[MORE]ENTITY THAT IS NOT DEFINED.                                   */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_READFAIL 28609018
/*	[IDENT]READFAIL                                                     */
/*	[MSG_TEXT]READ FAILURE                                              */
/*	[MSG_EXP]THE STANDARD READ FUNCTION HAS FAILED.                     */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_WRITFAIL 28609026
/*	[IDENT]WRITFAIL                                                     */
/*	[MSG_TEXT]WRITE FAILURE                                             */
/*	[MSG_EXP]THE STANDARD WRITE FUNCTION HAS FAILED.                    */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_OPENFAIL 28609034
/*	[IDENT]OPENFAIL                                                     */
/*	[MSG_TEXT]OPEN FAILURE                                              */
/*	[MSG_EXP]THE STANDARD OPEN FUNCTION HAS FAILED.                     */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_CLOSEFAIL 28609042
/*	[IDENT]CLOSEFAIL                                                    */
/*	[MSG_TEXT]CLOSE FAILURE                                             */
/*	[MSG_EXP]THE STANDARD CLOSE FUNCTION HAS FAILED.                    */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVSCOCOD 28609050
/*	[IDENT]INVSCOCOD                                                    */
/*	[MSG_TEXT]INVALID SCOPE CODE                                        */
/*	[MSG_EXP]THE APPLICATION CALLED CDA$ENTER_SCOPE OR CDA$LEAVE_SCOPE  */
/*	[MORE]REFERENCING A SCOPE CODE THAT IS NOT DEFINED OR INVALID       */
/*	[MORE]IN FOLLOWING CORRECT DOCUMENT SCOPING RULES.                  */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVSCOTRAN 28609058
/*	[IDENT]INVSCOTRAN                                                   */
/*	[MSG_TEXT]INVALID SCOPE TRANSITION                                  */
/*	[MSG_EXP]THE APPLICATION MADE AN CALL TO CDA$ENTER_SCOPE OR         */
/*	[MORE]CDA$LEAVE_SCOPE THAT DID NOT FOLLOW CORRECT SCOPING RULES.    */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_ERRINPLOG 28609066
/*	[IDENT]ERRINPLOG                                                    */
/*	[MSG_TEXT]ERROR MESSAGES PRODUCED DURING INPUT CONVERSION, SEE ERROR LOG */
/*	[MSG_EXP]THE INPUT CONVERSION DID NOT COMPLETE AND SOME ERROR MESSAGES */
/*	[MORE]WERE PRODUCED.  REFER TO THE ERROR LOG FOR MORE DETAILS.      */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_ERROUTLOG 28609074
/*	[IDENT]ERROUTLOG                                                    */
/*	[MSG_TEXT]ERROR MESSAGES PRODUCED DURING OUTPUT CONVERSION, SEE ERROR LOG */
/*	[MSG_EXP]THE OUTPUT CONVERSION DID NOT COMPLETE AND SOME ERROR MESSAGES */
/*	[MORE]WERE PRODUCED.  REFER TO THE ERROR LOG FOR MORE DETAILS.      */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVDATLEN 28609082
/*	[IDENT]INVDATLEN                                                    */
/*	[MSG_TEXT]INVALID DATA LENGTH                                       */
/*	[MSG_EXP]THE LENGTH OF THE VALUE DATA EXCEEDED THE SPECIFIED        */
/*	[MORE]LENGTH FOR THE DATA TYPE.                                     */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_UNSUPCNV 28609090
/*	[IDENT]UNSUPCNV                                                     */
/*	[MSG_TEXT]UNSUPPORTED DOCUMENT CONVERSION                           */
/*	[MSG_EXP]THE INPUT AND OUTPUT DOCUMENT FORMATS ARE INCOMPATIBLE FOR CONVERSION */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVOPTION 28609098
/*	[IDENT]INVOPTION                                                    */
/*	[MSG_TEXT]INVALID CONVERTER OPTION                                  */
/*	[MSG_EXP]AN INVALID OPTION WAS SPECIFIED FOR THE CONVERTER.  REFER TO THE */
/*	[MORE]DOCUMENTATION FOR THIS CONVERTER TO SEE THE VALID OPTIONS.    */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_VERSKEW 28609106
/*	[IDENT]VERSKEW                                                      */
/*	[MSG_TEXT]MAJOR VERSION SKEW BETWEEN INPUT FILE AND CDA TOOLKT.     */
/*	[MSG_EXP]THE FILE'S MAJOR VERSION IS DIFFERENT FROM THE TOOLKIT'S.  */
/*	[MORE]THUS, THE TOOLKIT CANNOT PROPERLY PROCESS THE FILE.           */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVADDINF 28609114
/*	[IDENT]INVADDINF                                                    */
/*	[MSG_TEXT]INVALID ADDITIONAL INFORMATION                            */
/*	[MSG_EXP]THE ADD-INFO PARAMETER IN A CALL TO CDA$LOCATE_ITEM OR     */
/*	[MORE]CDA$STORE_ITEM IS INVALID.                                    */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVFLTVAL 28609122
/*	[IDENT]INVFLTVAL                                                    */
/*	[MSG_TEXT]INVALID FLOATING POINT VALUE                              */
/*	[MSG_EXP]A FLOATING POINT DATUM HAS A RESERVED VALUE.               */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_FLTTRN 28609130
/*	[IDENT]FLTTRN                                                       */
/*	[MSG_TEXT]FLOATING-POINT TRUNCATION                                 */
/*	[MSG_EXP]DURING CDA$LOCATE_ITEM FOR A GENERAL FLOATING-POINT VALUE, */
/*	[MORE]FLOATING TRUNCATION OCCURRED.                                 */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVINPDMN 28609138
/*	[IDENT]INVINPDMN                                                    */
/*	[MSG_TEXT]INVALID INPUT DOMAIN                                      */
/*	[MSG_EXP]AN INVALID INPUT DOMAIN WAS SPECIFIED FOR THE FRONT        */
/*	[MORE]END.  ONLY DDIF AND DTIF ARE SUPPORTED AS DOMAINS.            */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INVOUTDMN 28609146
/*	[IDENT]INVOUTDMN                                                    */
/*	[MSG_TEXT]INVALID OUTPUT DOMAIN                                     */
/*	[MSG_EXP]AN INVALID OUTPUT DOMAIN WAS SPECIFIED FOR THE BACK        */
/*	[MORE]END.  ONLY DDIF AND DTIF ARE SUPPORTED AS DOMAINS.            */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_DCVNOTFND 28609154
/*	[IDENT]DCVNOTFND                                                    */
/*	[MSG_TEXT]DOMAIN CONVERTER NOT FOUND                                */
/*	[MSG_EXP]THE REQUIRED DOMAIN CONVERTER COULD NOT BE FOUND.          */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_ICVNOTFND 28609162
/*	[IDENT]ICVNOTFND                                                    */
/*	[MSG_TEXT]INPUT CONVERTER NOT FOUND                                 */
/*	[MSG_EXP]THE SPECIFIED INPUT CONVERTER COULD NOT BE FOUND.          */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_OCVNOTFND 28609170
/*	[IDENT]OCVNOTFND                                                    */
/*	[MSG_TEXT]OUTPUT CONVERTER NOT FOUND                                */
/*	[MSG_EXP]THE SPECIFIED OUTPUT CONVERTER COULD NOT BE FOUND.         */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
#define CDA$_INTERR 28609668
/*	[IDENT]INTERR                                                       */
/*	[MSG_TEXT]INTERNAL ERROR                                            */
/*	[MSG_EXP]THE CDA TOOLKIT DETECTED AN INTERNAL ERROR.                */
/*	[MSG_ACT]                                                           */
/*	[END_MSG]                                                           */
/*	[END_MESSAGES]                                                      */
/********************************************************************************************************************************/
/* Created  5-DEC-1994 15:48:00 by VAX SDL V3.2-10     Source: 28-MAR-1994 17:04:44 DECW$LIBSRESD:[CDALIB.SRC]CDADEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE CDA_DEFINITIONS IDENT V1-006 ***/
#ifndef _cdadef_
#define _cdadef_
/*++                                                                        */
/*                                                                          */
/*  COPYRIGHT (c) 1987, 1992 BY                                             */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                           */
/*  ALL RIGHTS RESERVED.                                                    */
/*                                                                          */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  */
/*  TRANSFERRED.                                                            */
/*                                                                          */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  */
/*  CORPORATION.                                                            */
/*                                                                          */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 */
/*                                                                          */
/* General Toolkit processing option item codes for cda_create_root_aggregate */
/* and cda_open_file.                                                       */
#define CDA_LOG_INFORMATION_MESSAGES 2561 /* Automatically log information messages */
#define CDA_INPUT_FILE_SYSTEM 2562      /* value is ptr to char string input file system name. */
#define CDA_OUTPUT_FILE_SYSTEM 2563     /* value is ptr to char string output file system name. */
/*			Valid strings are same as those for the DDIF$_ERF_LABEL_TYPE. */
#define CDA_SKIP_MISSING_REFERENCES 2564 /* ignore missing ext refs and keep procesing. */
#define CDA_INPUT_FILE_SYSTEM_HANDLE 2565 /* value is handle representing file system context */
#define CDA_OUTPUT_FILE_SYSTEM_HANDLE 2566 /* value is handle representing file system context */
/* Function codes for cda_convert and domain_write_format.                  */
#define CDA_START 1                     /* Start conversion                 */
#define CDA_CONTINUE 2                  /* Continue conversion              */
#define CDA_STOP 3                      /* Stop conversion                  */
struct item_list {
    unsigned short int cda_w_item_length; /* Item buffer length             */
    unsigned short int cda_w_item_code; /* Item code                        */
    char *cda_a_item_address;           /* Item buffer address              */
    } ;
/* Item codes for cda_convert, cda_open_converter, cda_create_message_log,  */
/* domain_read_format, and domain_write_format.                             */
#define CDA_PROCESSING_OPTION 1         /* Processing option                */
#define CDA_INPUT_FORMAT 2              /* Input document format-name       */
#define CDA_INPUT_FRONT_END_PROCEDURE 3 /* Input document front-end procedure */
#define CDA_INPUT_FILE 4                /* Input file specification         */
#define CDA_INPUT_DEFAULT 5             /* Input default file specification */
#define CDA_INPUT_PROCEDURE 6           /* Input get data procedure         */
#define CDA_INPUT_POSITION_PROCEDURE 7  /* Input get position procedure     */
#define CDA_INPUT_PROCEDURE_PARM 8      /* Input procedure parameter        */
#define CDA_INPUT_ROOT_AGGREGATE 9      /* Input root aggregate             */
#define CDA_OUTPUT_FORMAT 10            /* Output document format-name      */
#define CDA_OUTPUT_BACK_END_PROCEDURE 11 /* Output document back-end procedure */
#define CDA_OUTPUT_FILE 12              /* Output file specification        */
#define CDA_OUTPUT_DEFAULT 13           /* Output default file specification */
#define CDA_OUTPUT_PROCEDURE 14         /* Output procedure                 */
#define CDA_OUTPUT_PROCEDURE_PARM 15    /* Output procedure parameter       */
#define CDA_OUTPUT_PROCEDURE_BUFFER 16  /* Output procedure initial buffer  */
#define CDA_OUTPUT_ROOT_AGGREGATE 17    /* Output root aggregate            */
#define CDA_OPTIONS_FILE 18             /* Options file specification       */
#define CDA_INPUT_FRONT_END_DOMAIN 19   /* Input document front-end domain  */
#define CDA_OUTPUT_BACK_END_DOMAIN 20   /* Output document back-end domain  */
#define CDA_OPTIONS_LINE 21             /* Options line                     */
#define CDA_INPUT_PRIVATE_ITEM 22       /* Front End private item           */
#define CDA_MESSAGE_LOG_FILE 23         /* Message log file spec            */
#define CDA_DEFAULT_MESSAGE_LOG_FILE 24 /* Default message log file spec    */
#define CDA_RESULT_MESSAGE_LOG_FILE 25  /* Result message spec              */
#define CDA_RESULT_MSG_FILE_RET_LEN 26  /* Result message spec length       */
#define CDA_MESSAGE_OUTPUT_PROCEDURE 27 /* Message-put rtn                  */
#define CDA_MESSAGE_OUTPUT_PROC_PARM 28 /* Message-put parameter            */
#define CDA_MESSAGE_OUTPUT_PROC_BUFFER 29 /* Message-put buffer             */
#define CDA_MESSAGE_FLUSH_PROCEDURE 30  /* Message-flush rtn                */
#define CDA_MESSAGE_HANDLE 31           /* Message-flush rtn                */
#define CDA_SEARCH_DOMAIN 32            /* Domain for GetFormatList         */
#define CDA_SEARCH_FEBE 33              /* FeBe parameter for GetFormatList */
#define CDA_YIELD_ROUTINE 34            /* cda_convert user callback routine */
#define CDA_YIELD_PARM 35               /* cda_convert user callback routine prm */
/* Item codes for dots_pack and dots_unpack.                                */
#define DOTS_INPUT_DEFAULT 1            /* Input default file name          */
#define DOTS_INPUT_FILE 2               /* Input file name                  */
#define DOTS_OUTPUT_DEFAULT 3           /* Output default file name         */
#define DOTS_OUTPUT_FILE 4              /* Output file name                 */
#define DOTS_OUTPUT_RESULT 5            /* Output resultant file name       */
#define DOTS_MISSING_REFERENCE 6        /* Name of missing reference        */
#define DOTS_CONTROLLED_COPY 7          /* Obey ERF_CONTROL item when packing */
#define DOTS_INPUT_PROCEDURE 8          /* user-supplied get-rtn            */
#define DOTS_INPUT_PROCEDURE_PARM 9     /* parameter for get-rtn            */
#define DOTS_OUTPUT_PROCEDURE 10        /* user-supplied put-rtn            */
#define DOTS_OUTPUT_PROCEDURE_PARM 11   /* parameter for put-rtn            */
#define DOTS_OUTPUT_PROCEDURE_BUFFER 12 /* addr & length of initial buffer  */
#define DOTS_INPUT_DEFAULT_TYPE 13      /* name of file system to which INPUT_DEFAULT applies */
#define DOTS_INPUT_FILE_TYPE 14         /* name of file system to which INPUT_FILE applies */
#define DOTS_OUTPUT_DEFAULT_TYPE 15     /* name of file system to which OUTPUT_DEFAULT applies */
#define DOTS_OUTPUT_FILE_TYPE 16        /* name of file system to which OUTPUT_FILE applies */
#define DOTS_SIMPLE_ENCODE 17           /* wrap simple DDIF or DTIF (no refs) into DOTS */
#define DOTS_ALWAYS_ENCODE 18           /* always create DOTS encoding even when doc has no refs */
/* Synonym definitions for ease-of-use                                      */
/* These are duplicates of the CDA_ definitions and MUST be equivalent.     */
#define DOTS_INPUT_FILE_SYSTEM 2562
#define DOTS_OUTPUT_FILE_SYSTEM 2563
#define DOTS_SKIP_MISSING_REFERENCES 2564
#define DOTS_INPUT_FILE_SYSTEM_HANDLE 2565
#define DOTS_OUTPUT_FILE_SYSTEM_HANDLE 2566
/* general UNKNOWN choice enumeration for backward compatibility use when skipping unknown choices */
#define CDA_K_UNKNOWN 32767             /* Unknown choice                   */
/* Domain constants for GetFormatList.                                      */
#define CDA_ALL_DOMAINS 1               /* All domains.                     */
#define CDA_DDIF_DOMAIN 2               /* Only DDIF domain.                */
#define CDA_DTIF_DOMAIN 3               /* Only DTIF domain.                */
/* FeBe constants for GetFormatList.                                        */
#define CDA_BOTH_FEBE 1                 /* Both front and back end converters. */
#define CDA_FRONT_END 2                 /* Front end converters only.       */
#define CDA_BACK_END 3                  /* Back end converters only.        */
/* CdaGetDataType Item Codes.                                               */
#define CDA_FILE_NAME 1                 /* File name string                 */
#define CDA_FILE_BUFFER 2               /* File content                     */
#define CDA_FILE_TYPE_STRING 3          /* String type return pointer       */
#define CDA_FILE_TYPE_LENGTH 4          /* Return string length             */
#define CDA_FILE_TYPE_VALUE 5           /* Core type return value           */
#define CDA_MAGIC_FILE_NAME 6           /* Alternate magic file name        */
/* CdaGetDataType Core File Type Return Values.                             */
#define CDA_K_FILE_CONTENT_DDIF 1       /* File contains DDIF               */
#define CDA_K_FILE_CONTENT_DOTS 2       /*  ""     ""    DOTS               */
#define CDA_K_FILE_CONTENT_DTIF 3       /*  ""     ""    DTIF               */
#define CDA_K_FILE_CONTENT_PS 4         /*  ""     ""    PostScript         */
#define CDA_K_FILE_CONTENT_TEXT 5       /*  ""     ""    Text               */
/* Character set identification codes (DEC STD 169).                        */
#define CDA_K_ISO_LATIN1 1              /* ISO Latin 1 (ISO 8859-1)         */
#define CDA_K_ISO_LATIN2 2              /* ISO Latin 2 (ISO 8859-2)         */
#define CDA_K_ISO_LATIN_ARABIC 3        /* ISO Latin-Arabic (ISO 8859-6)    */
#define CDA_K_ISO_LATIN_GREEK 4         /* ISO Latin-Greek (ISO 8859-7)     */
#define CDA_K_ISO_LATIN_HEBREW 6        /* ISO Latin-Hebrew (ISO 8859-8)    */
#define CDA_K_JIS_KATAKANA 32           /* JIS Roman, JIS Katakana (JIS X0201) */
#define CDA_K_DEC_TECH 33               /* DEC Special Graphics, DEC Technical */
#define CDA_K_DEC_MATH_ITALIC 34        /* DEC Mathematics Italic           */
#define CDA_K_DEC_MATH_SYMBOL 35        /* DEC Mathematics Symbol           */
#define CDA_K_DEC_MATH_EXTENSION 36     /* DEC Mathematics Extension        */
#define CDA_K_DEC_PUBLISHING 37         /* DEC Publishing                   */
#define CDA_K_DEC_KANJI 64              /* DEC Kanji (JIS X0208)            */
#define CDA_K_DEC_HANZI 65              /* DEC Hanzi (GB 2312)              */
#define CDA_K_DEC_HANGUL 66             /* DEC Hangul                       */
#define CDA_K_DEC_CNS11643 67           /* DEC Hanyu (CNS11643)             */
#define CDA_K_DEC_DTSCS 68              /* DEC Hanyu (DTSCS)                */
/* Synonym definitions for compatibility                                    */
#define CDA_K_ISO_LATIN6 3              /* Obsolete synonym                 */
#define CDA_K_ISO_LATIN7 4              /* Obsolete synonym                 */
#define CDA_K_ISO_LATIN8 6              /* Obsolete synonym                 */
/* Values of the add-info parameter for cda_locate_item and cda_store_item when */
/* the item data type is general floating point.                            */
#define CDA_K_F_FLOAT 0                 /* VAX F-floating                   */
#define CDA_K_D_FLOAT 1                 /* VAX D-floating                   */
#define CDA_K_G_FLOAT 2                 /* VAX G-floating                   */
#define CDA_K_H_FLOAT 3                 /* VAX H-floating                   */
#define CDA_K_IEEE_754_S_FLOAT 4        /* IEEE 754 single precision        */
#define CDA_K_IEEE_754_D_FLOAT 5        /* IEEE 754 double precision        */
#define CDA_K_NATIVE_S_FLOAT 6          /* Native single precision  VAX: F-float non-VAX: IEEE 754 single */
#define CDA_K_NATIVE_D_FLOAT 7          /* Native double precision  VAX: G-float non-VAX: IEEE 754 double */
/* Item codes for cda_status_to_message, cda_write_message.                 */
#define CDA_MESSAGE_SEVERITY 1          /* Message severity                 */
#define CDA_MESSAGE_PREFIX 2            /* Message prefix                   */
#define CDA_MESSAGE_PARAMETER 3         /* Messge parameter                 */
/* Values of the SEVERITY item code for cda_status_to_message and           */
/* cda_write_message routines.                                              */
#define CDA_K_WARNING 0                 /* Warning = 000                    */
#define CDA_K_NORMAL 1                  /* Normal = 001                     */
#define CDA_K_ERROR 2                   /* Error = 010                      */
#define CDA_K_INFORMATIONAL 3           /* Informational = 011              */
#define CDA_K_FATAL 4                   /* Fatal = 100                      */
#endif
/**/
/******************************************************************************/
/**                                                                          **/
/**  Copyright (c) 1994                                                      **/
/**  by DIGITAL Equipment Corporation, Maynard, Mass.                        **/
/**                                                                          **/
/**  This software is furnished under a license and may be used and  copied  **/
/**  only  in  accordance  with  the  terms  of  such  license and with the  **/
/**  inclusion of the above copyright notice.  This software or  any  other  **/
/**  copies  thereof may not be provided or otherwise made available to any  **/
/**  other person.  No title to and ownership of  the  software  is  hereby  **/
/**  transferred.                                                            **/
/**                                                                          **/
/**  The information in this software is subject to change  without  notice  **/
/**  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  **/
/**  Corporation.                                                            **/
/**                                                                          **/
/**  DIGITAL assumes no responsibility for the use or  reliability  of  its  **/
/**  software on equipment which is not supplied by DIGITAL.                 **/
/**                                                                          **/
/******************************************************************************/
/********************************************************************************************************************************/
/* Created  5-DEC-1994 15:49:12 by VAX SDL V3.2-10     Source:  5-DEC-1994 15:47:47 DECW$LIBSRESD:[CDALIB.OBJ]CDAMSG.SDL;2 */
/********************************************************************************************************************************/
 
/*** MODULE $CDADEF ***/
#define CDA_FACILITY 436
#define CDA_NORMAL 28606465
#define CDA_DEFAULT 28606473
#define CDA_SUSPEND 28606481
#define CDA_INHERIT 28606489
#define CDA_UNRECENC 28606497
#define CDA_INFINPLOG 28607267
#define CDA_INFOUTLOG 28607275
#define CDA_FILESPEC 28607283
#define CDA_ITMAGGCNT 28607291
#define CDA_AGGCNT 28607299
#define CDA_RETROOT 28607307
#define CDA_RETDESCR 28607315
#define CDA_RETHDR 28607323
#define CDA_RETSEG 28607331
#define CDA_RETEOS 28607339
#define CDA_RETCONT 28607347
#define CDA_RETSCOPE 28607355
#define CDA_RETEOD 28607363
#define CDA_TYPEREF 28607371
#define CDA_RETDTSRTE 28607379
#define CDA_RETDTSEXT 28607387
#define CDA_RETDTFTBL 28607395
#define CDA_RETDTFROW 28607403
#define CDA_RETDTFCELL 28607411
#define CDA_STYGDEFBK 28607419
#define CDA_OUTFILE 28607427
#define CDA_UNRECOPT 28607435
#define CDA_INVOPTVAL 28607443
#define CDA_MISEXTREF 28608064
#define CDA_MISSTYGDE 28608072
#define CDA_NUMADDINFO 28608080
#define CDA_PARENMISS 28608088
#define CDA_NOOUTFIL 28608096
#define CDA_ENDOFDOC 28608866
#define CDA_ENDOFSEQ 28608874
#define CDA_EMPTY 28608882
#define CDA_INDEX 28608890
#define CDA_INVINSERT 28608898
#define CDA_INVAGGTYP 28608906
#define CDA_INVITMCOD 28608914
#define CDA_INVDOC 28608922
#define CDA_INVITMLST 28608930
#define CDA_VAREMPTY 28608938
#define CDA_VARINDEX 28608946
#define CDA_VARVALUE 28608954
#define CDA_INVTAGCOD 28608962
#define CDA_INVBUFLEN 28608970
#define CDA_ALLOCFAIL 28608978
#define CDA_INVFUNCOD 28608986
#define CDA_UNSUPFMT 28608994
#define CDA_READONLY 28609002
#define CDA_DEFNOTFOU 28609010
#define CDA_READFAIL 28609018
#define CDA_WRITFAIL 28609026
#define CDA_OPENFAIL 28609034
#define CDA_CLOSEFAIL 28609042
#define CDA_INVSCOCOD 28609050
#define CDA_INVSCOTRAN 28609058
#define CDA_ERRINPLOG 28609066
#define CDA_ERROUTLOG 28609074
#define CDA_INVDATLEN 28609082
#define CDA_UNSUPCNV 28609090
#define CDA_INVOPTION 28609098
#define CDA_VERSKEW 28609106
#define CDA_INVADDINF 28609114
#define CDA_INVFLTVAL 28609122
#define CDA_FLTTRN 28609130
#define CDA_INVINPDMN 28609138
#define CDA_INVOUTDMN 28609146
#define CDA_DCVNOTFND 28609154
#define CDA_ICVNOTFND 28609162
#define CDA_OCVNOTFND 28609170
#define CDA_INVSTSCOD 28609178
#define CDA_INVAGGCTX 28609186
#define CDA_REQITMMIS 28609194
#define CDA_INVTOKEN 28609202
#define CDA_KEYWDNF 28609210
#define CDA_LOGENDDOC 28609218
#define CDA_ENDOFFILE 28609226
#define CDA_INVAGGRITEM 28609234
#define CDA_INTNOTALLOW 28609242
#define CDA_STRNOTALLOW 28609250
#define CDA_ENUMNOTALLOW 28609258
#define CDA_BOOLREQ 28609266
#define CDA_INVENUM 28609274
#define CDA_INVADDINFO 28609282
#define CDA_INVFLAGS 28609290
#define CDA_INVHEX 28609298
#define CDA_INVFLOAT 28609306
#define CDA_INVBINARY 28609314
#define CDA_VARINTTRN 28609322
#define CDA_AGGNOTALLOW 28609330
#define CDA_WRTONLY 28609338
#define CDA_DCVBADEXIT 28609346
#define CDA_ICVBADEXIT 28609354
#define CDA_OCVBADEXIT 28609362
#define CDA_CVTSIGSIG 28609370
#define CDA_CVTSTOPSIG 28609378
#define CDA_INTERR 28609668
#ifndef _cda_ptp_
#define _cda_ptp_
/*
**++
**
**  COPYRIGHT (c) 1989, 1992 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**	This file contains function prototype definitions for the CDA
**      toolkit routines.
**
**--
**/

/*
 * Include CDA defined types.
 */
#ifndef _cdatyp_
#include <cdatyp.h>
#endif

/*
 * Start of the function prototypes for CDA toolkit routines.
 */
PROTO(CDAstatus CDA_CALLBACK cda_malloc,
	(CDAsize CDA_FAR *,
	 CDAaddress CDA_FAR *,
	 CDAuserparam));

PROTO(CDAaddress CDA_APIENTRY CdaMalloc,
	 (CDAsize));

PROTO(CDAstatus CDA_CALLBACK cda_free,
	(CDAsize CDA_FAR *,
	 CDAaddress CDA_FAR *,
	 CDAuserparam));

PROTO(CDAstatus CDA_APIENTRY CdaFree,
	 (CDAaddress));

PROTO(CDAstatus CDA_APIENTRY cda_calloc,
	(CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAaddress CDA_FAR *,
	 CDAuserparam));

PROTO(CDAaddress CDA_APIENTRY CdaCalloc,
	(CDAsize,
	 CDAsize));

PROTO(CDAstatus CDA_APIENTRY cda_realloc,
	(CDAaddress CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAaddress CDA_APIENTRY CdaRealloc,
	(CDAaddress,
	 CDAsize));

PROTO(CDAstatus CDA_APIENTRY cda_aggregate_type_to_object_id,
	(CDAaggtype CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAbufaddr,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_close_file,
	(DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_close_message_log,
	(CDAmessagehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_close_stream,
	(DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_close_text_file,
	(CDAtextfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_convert,
	(CDAconstant CDA_FAR *,
	 CDAitemlist CDA_FAR *,
         CDAaddress,
	 CDAconverterhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_convert_aggregate,
	(CDArootagghandle CDA_FAR *,
         CDAfrontendhandle CDA_FAR *,
	 CDAagghandle CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_convert_document,
	(CDArootagghandle CDA_FAR *,
         CDAfrontendhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_convert_position,
	(CDAfrontendhandle CDA_FAR *,
         CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_copy_aggregate,
	(CDArootagghandle CDA_FAR *,
         CDAagghandle CDA_FAR *,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_aggregate,
	(CDArootagghandle CDA_FAR *,
         CDAaggtype CDA_FAR *,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_file,
	(CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDArootagghandle CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_file_cda,
	 (CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDArootagghandle CDA_FAR *,
	 CDAitemlist CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_message_log,
	(CDAitemlist CDA_FAR *,
	 CDAmessagehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_root_aggregate,
	(CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAitemlist CDA_FAR *,
	 CDAaggtype CDA_FAR *,
	 CDArootagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_stream,
	(CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam,
	 				     CDAsize CDA_FAR *,
	 				     CDAbufaddr,
			  		     CDAsize CDA_FAR *,
	 				     CDAbufaddr CDA_FAR *),
	 CDAuserparam,
	 CDAsize CDA_FAR *,
	 CDAbufaddr,
	 DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_create_text_file,
	(CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAtextfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_delete_aggregate,
	(CDArootagghandle CDA_FAR *,
         CDAagghandle CDA_FAR *));

PROTO(void CDA_APIENTRY cda_delete_format_list,
	(CDAformatlist *));

PROTO(CDAstatus CDA_APIENTRY cda_delete_root_aggregate,
	 (CDArootagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_enter_scope,
	(CDArootagghandle CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAconstant CDA_FAR *,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_erase_item,
	(CDArootagghandle CDA_FAR *,
	 CDAagghandle CDA_FAR *,
	 CDAconstant CDA_FAR *,
	 CDAindex CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_find_definition,
	(CDArootagghandle CDA_FAR *,
         CDAaggtype CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAbufaddr,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_find_transformation,
	(CDArootagghandle CDA_FAR *,
         float CDA_FAR *(CDA_FAR *)));

PROTO(CDAstatus CDA_APIENTRY cda_flush_message_log,
	 (CDAmessagehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_flush_stream,
	(DDISstreamhandle CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam),
	 CDAuserparam));

PROTO(CDAstatus CDA_APIENTRY cda_get_aggregate,
	(CDArootagghandle CDA_FAR *,
         DDISstreamhandle CDA_FAR *,
	 CDAagghandle CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_get_array_size,
	(CDAagghandle CDA_FAR *,
         CDAconstant CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_get_data_type,
	(CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_get_document,
	(CDArootagghandle CDA_FAR *,
         DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_get_external_encoding,
	(CDArootagghandle CDA_FAR *,
         DDISstreamhandle CDA_FAR *,
	 CDAagghandle CDA_FAR *));

PROTO (CDAstatus CDA_APIENTRY cda_get_format_list,
	(CDAitemlist *, CDAformatlist **));

PROTO(CDAstatus CDA_APIENTRY cda_get_stream_position,
	(DDISstreamhandle CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam,
	 				     CDAsize CDA_FAR *),
	 CDAuserparam,
	 CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_get_text_position,
	(CDAtextfilehandle CDA_FAR *,
         CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_insert_aggregate,
	(CDAagghandle CDA_FAR *,
         CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_leave_scope,
	(CDArootagghandle CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAconstant CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_locate_item,
	(CDArootagghandle CDA_FAR *,
	 CDAagghandle CDA_FAR *,
	 CDAconstant CDA_FAR *,
	 CDAaddress CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAindex CDA_FAR *,
	 CDAconstant CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_next_aggregate,
	(CDAagghandle CDA_FAR *,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_object_id_to_aggregate_type,
	(CDAsize CDA_FAR *,
	 CDAbufaddr,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_open_converter,
	(CDAitemlist CDA_FAR *,
	 CDAconverterhandle CDA_FAR *,
	 CDAfrontendhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_open_erf_file,
	(CDArootagghandle *, CDAagghandle *, DDISstreamhandle *,
	 CDAfilehandle *, CDArootagghandle *, CDAsize *, CDAenvirontext *,
         CDAsize *, CDAenvirontext *, CDAsize *, CDAitemlist *));

PROTO(CDAstatus CDA_APIENTRY cda_open_file,
	(CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAaggtype CDA_FAR *,
	 CDAitemlist CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *,
	 CDArootagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_open_stream,
	(
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam,
	 				     CDAsize CDA_FAR *,
	 				     CDAbufaddr CDA_FAR *),
	 CDAuserparam,
	 DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_open_text_file,
	(CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAtextfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_prune_aggregate,
	(CDArootagghandle CDA_FAR *,
         CDAagghandle CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_prune_position,
	(CDArootagghandle CDA_FAR *,
         CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_put_aggregate,
	(CDArootagghandle CDA_FAR *,
         DDISstreamhandle CDA_FAR *,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_put_document,
	(CDArootagghandle CDA_FAR *,
         DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_read_text_file,
	(CDAtextfilehandle CDA_FAR *,
         CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *(CDA_FAR *)));

PROTO(CDAstatus CDA_APIENTRY cda_remove_aggregate,
	 (CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_status_to_message,
	(CDAstatus CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_store_item,
	(CDArootagghandle CDA_FAR *,
	 CDAagghandle CDA_FAR *,
	 CDAconstant CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAaddress,
	 CDAindex CDA_FAR *,
	 CDAconstant CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_write_full_message,
	(CDAmessagehandle CDA_FAR *,
	 CDArootagghandle CDA_FAR *,
	 CDAstatus CDA_FAR *,
	 CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_write_message,
	(CDAmessagehandle CDA_FAR *,
	 CDAstatus CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_write_status_message,
	(CDAmessagehandle CDA_FAR *,
	 CDAstatus CDA_FAR *,
	 CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY cda_write_text_file,
	(CDAtextfilehandle CDA_FAR *,
         CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY dots_pack,
	(CDAitemlist CDA_FAR *,
	 CDAitemlist CDA_FAR *(CDA_FAR *)));

PROTO(CDAstatus CDA_APIENTRY dots_unpack,
	(CDAitemlist CDA_FAR *,
	 CDAitemlist CDA_FAR *(CDA_FAR *)));

PROTO(CDAstatus CDA_APIENTRY dots_free_output_list,
	(CDAitemlist CDA_FAR *));


/*** Prototypes for "C" bindings ***/

PROTO(CDAstatus CDA_APIENTRY CdaAggregateTypeToObjectId,
	(CDAaggtype,
         CDAsize,
	 CDAbufaddr,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCloseFile,
	(DDISstreamhandle,
	 CDAfilehandle));

PROTO(CDAstatus CDA_APIENTRY CdaCloseMessageLog,
	(CDAmessagehandle));

PROTO(CDAstatus CDA_APIENTRY CdaCloseStream,
	(DDISstreamhandle));

PROTO(CDAstatus CDA_APIENTRY CdaCloseTextFile,
	(CDAtextfilehandle));

PROTO(CDAstatus CDA_APIENTRY CdaConvert,
	(CDAconstant ,
	 CDAitemlist CDA_FAR *,
         CDAaddress,
	 CDAconverterhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaConvertAggregate,
	(CDArootagghandle,
         CDAfrontendhandle,
	 CDAagghandle CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaConvertDocument,
	(CDArootagghandle,
         CDAfrontendhandle));

PROTO(CDAstatus CDA_APIENTRY CdaConvertPosition,
	(CDAfrontendhandle,
         CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCopyAggregate,
	(CDArootagghandle,
	 CDAagghandle,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateAggregate,
	(CDArootagghandle,
         CDAaggtype,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateFile,
	(CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDArootagghandle,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateFileCda,
	(CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDArootagghandle,
	 CDAitemlist CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateMessageLog,
	(CDAitemlist CDA_FAR *,
	 CDAmessagehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateRootAggregate,
	(CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAitemlist CDA_FAR *,
	 CDAaggtype,
	 CDArootagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateStream,
	(CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam,
	 				     CDAsize CDA_FAR *,
	 				     CDAbufaddr,
					     CDAsize CDA_FAR *,
	 				     CDAbufaddr CDA_FAR *),
	 CDAuserparam,
	 CDAsize,
	 CDAbufaddr,
	 DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaCreateTextFile,
	(CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAtextfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaDeleteAggregate,
	(CDArootagghandle,
	 CDAagghandle));

PROTO(void CDA_APIENTRY CdaDeleteFormatList,
	(CDAformatlist *));

PROTO(CDAstatus CDA_APIENTRY CdaDeleteRootAggregate,
	(CDArootagghandle));

PROTO(CDAstatus CDA_APIENTRY CdaEnterScope,
	(CDArootagghandle,
	 DDISstreamhandle,
	 CDAconstant,
	 CDAagghandle));

PROTO(CDAstatus CDA_APIENTRY CdaEraseItem,
	(CDArootagghandle,
	 CDAagghandle,
	 CDAconstant,
	 CDAindex));

PROTO(CDAstatus CDA_APIENTRY CdaFindDefinition,
	(CDArootagghandle,
         CDAaggtype,
	 CDAsize,
	 CDAbufaddr,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaFindTransformation,
	(CDArootagghandle,
         float CDA_FAR *(CDA_FAR *)));

PROTO(CDAstatus CDA_APIENTRY CdaFlushMessageLog,
	(CDAmessagehandle));

PROTO(CDAstatus CDA_APIENTRY CdaFlushStream,
	(DDISstreamhandle,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam),
	 				     CDAuserparam));

PROTO(CDAstatus CDA_APIENTRY CdaGetAggregate,
	(CDArootagghandle,
	 DDISstreamhandle,
	 CDAagghandle CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaGetArraySize,
	(CDAagghandle,
	 CDAconstant,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaGetDataType,
	(CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaGetDocument,
	(CDArootagghandle,
	 DDISstreamhandle));

PROTO(CDAstatus CDA_APIENTRY CdaGetExternalEncoding,
	(CDArootagghandle,
	 DDISstreamhandle,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaGetFormatList,
	(CDAitemlist *, CDAformatlist **));

PROTO(CDAstatus CDA_APIENTRY CdaGetStreamPosition,
	(DDISstreamhandle,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam,
	 				     CDAsize CDA_FAR *),
	 CDAuserparam,
	 CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaGetTextPosition,
	(CDAtextfilehandle,
         CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaInsertAggregate,
	(CDAagghandle,
	 CDAagghandle));

PROTO(CDAstatus CDA_APIENTRY CdaLeaveScope,
	(CDArootagghandle,
	 DDISstreamhandle,
	 CDAconstant));

PROTO(CDAstatus CDA_APIENTRY CdaLocateItem,
	(CDArootagghandle,
	 CDAagghandle,
	 CDAconstant,
	 CDAaddress CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAindex,
	 CDAconstant CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaNextAggregate,
	(CDAagghandle,
	 CDAagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaObjectIdToAggregateType,
	(CDAsize,
         CDAbufaddr,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaOpenConverter,
	(CDAitemlist CDA_FAR *,
	 CDAconverterhandle,
	 CDAfrontendhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaOpenErfFile,
	(CDArootagghandle, CDAagghandle, DDISstreamhandle *,
	 CDAfilehandle *, CDArootagghandle *, CDAsize, CDAenvirontext *,
         CDAsize, CDAenvirontext *, CDAsize *, CDAitemlist *));

PROTO(CDAstatus CDA_APIENTRY CdaOpenFile,
	(CDAsize,
	 CDAenvirontext CDA_FAR *,
         CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAaggtype,
	 CDAitemlist CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 DDISstreamhandle CDA_FAR *,
	 CDAfilehandle CDA_FAR *,
	 CDArootagghandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaOpenStream,
	(CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAstatus (CDA_CALLBACK *) (CDAsize CDA_FAR *,
	 				     CDAaddress CDA_FAR *,
	 				     CDAuserparam),
	 CDAuserparam,
	 CDAstatus (CDA_CALLBACK *) (CDAuserparam,
	 				     CDAsize CDA_FAR *,
	 				     CDAbufaddr CDA_FAR *),
	 CDAuserparam,
	 DDISstreamhandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaOpenTextFile,
	(CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAtextfilehandle CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaPruneAggregate,
	(CDArootagghandle,
	 CDAagghandle CDA_FAR *,
	 CDAaggtype CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaPrunePosition,
	(CDArootagghandle,
	 CDAsize CDA_FAR *,
	 CDAsize CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaPutAggregate,
	(CDArootagghandle,
	 DDISstreamhandle,
	 CDAagghandle));

PROTO(CDAstatus CDA_APIENTRY CdaPutDocument,
	(CDArootagghandle,
	 DDISstreamhandle));

PROTO(CDAstatus CDA_APIENTRY CdaReadTextFile,
	(CDAtextfilehandle,
         CDAsize CDA_FAR *,
	 CDAenvirontext CDA_FAR *(CDA_FAR *)));

PROTO(CDAstatus CDA_APIENTRY CdaRemoveAggregate,
	(CDAagghandle));

PROTO(CDAstatus CDA_APIENTRY CdaStatusToMessage,
	(CDAstatus,
	 CDAsize,
	 CDAenvirontext CDA_FAR *,
	 CDAsize CDA_FAR *,
	 CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaStoreItem,
	(CDArootagghandle,
	 CDAagghandle,
	 CDAconstant,
	 CDAsize,
	 CDAaddress,
	 CDAindex,
	 CDAconstant));

PROTO(CDAstatus CDA_APIENTRY CdaWriteFullMessage,
	(CDAmessagehandle,
	 CDArootagghandle,
	 CDAstatus,
	 CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaWriteMessage,
	(CDAmessagehandle,
	 CDAstatus,
	 CDAsize,
	 CDAenvirontext CDA_FAR *));


PROTO(CDAstatus CDA_APIENTRY CdaWriteStatusMessage,
	(CDAmessagehandle,
	 CDAstatus,
	 CDAitemlist CDA_FAR *));

PROTO(CDAstatus CDA_APIENTRY CdaWriteTextFile,
	(CDAtextfilehandle,
         CDAsize,
	 CDAenvirontext CDA_FAR *));

/*
 * The following prototypes indicate the format and argument types for
 * user supplied routines as well as converter entry points.
 *
 * prototype of user defined "stream get" routine.
 *      CDAstatus (CDA_CALLBACK *get_rtn)(CDAuserparam,
 *	 				          CDAsize CDA_FAR *,
 *	 				          CDAbufaddr CDA_FAR *);
 *
 * prototype of user defined "stream put" routine.
 *      CDAstatus (CDA_CALLBACK *put_rtn)(CDAuserparam,
 *	 					  CDAsize CDA_FAR *,
 *	 					  CDAbufaddr,
 *			    			  CDAsize CDA_FAR *,
 *						  CDAbufaddr CDA_FAR *);
 *
 * prototype of user defined "stream flush" routine.
 *	CDAstatus (CDA_CALLBACK *flush_rtn)(CDAuserparam);
 *
 * prototype of user defined  "put-message" routine.
 *      CDAstatus (CDA_CALLBACK *put_message_rtn)(CDAuserparam,
 *			    				  CDAstatus CDA_FAR *,
 *	 						  CDAsize CDA_FAR *,
 *							  CDAenvirontext CDA_FAR *,
 *                          				  CDAsize CDA_FAR *,
 *	 						  CDAenvirontext CDA_FAR *(CDA_FAR *)));
 *
 * prototype of user defined "flush-message" routine.
 *      CDAstatus (CDA_CALLBACK *flush_message_rtn) (CDAuserparam));
 *
 * prototype of user defined "memory allocation" routine.
 *      CDAstatus (CDA_CALLBACK *alloc_rtn)(CDAsize CDA_FAR *,
 *	 					    CDAaddress CDA_FAR *,
 *			    			    CDAuserparam);
 *
 * prototype of user defined "memory deallocation" routine.
 *      CDAstatus (CDA_CALLBACK *dealloc_rtn)(CDAsize CDA_FAR *,
 *	 					      CDAaddress CDA_FAR *,
 *			    			      CDAuserparam);
 *
 * prototype of front_end "get aggregate" routine.
 *      CDAstatus (CDA_CALLBACK *get_agg_rtn)(CDAuserparam CDA_FAR *,
 *			    			      CDAagghandle CDA_FAR *,
 *	 					      CDAaggtype CDA_FAR *);
 *
 * prototype of front_end "get position" routine.
 *      CDAstatus (CDA_CALLBACK *get_pos_rtn)(CDAuserparam CDA_FAR *,
 *			    			      CDAsize CDA_FAR *,
 *						      CDAsize CDA_FAR *);
 *
 * prototype of front-end "close" routine.
 *      CDAstatus (CDA_CALLBACK *cfe_a_close_rtn)(CDAuserparam CDA_FAR *);
 *
 * prototype of front-end "open" routine.
 *      CDAstatus (CDA_APIENTRY *open_rtn)(CDAitemlist CDA_FAR *,
 *	     		CDAconverterhandle CDA_FAR *,
 *	     		CDAuserparam CDA_FAR *,
 *	     		CDAstatus (CDA_CALLBACK **)(CDAuserparam CDA_FAR *,
 *	 					    CDAagghandle CDA_FAR *,
 *			    		 	    CDAaggtype CDA_FAR *),
 *			CDAstatus (CDA_CALLBACK **)(CDAuserparam CDA_FAR *,
 *	 					    CDAsize CDA_FAR *,
 *			    			    CDAsize CDA_FAR *),
 *	     		CDAstatus (CDA_CALLBACK **)(CDAuserparam CDA_FAR *)
 *	);
 *
 * prototype of "back_end" routine.
 *      CDAstatus (CDA_APIENTRY *cnv_a_back_end_rtn)
 *						(CDAconstant CDA_FAR *,
 *			    			 CDAitemlist CDA_FAR *,
 *						 CDAuserparam,
 *	 					 CDAfrontendhandle CDA_FAR *,
 *			    			 CDAuserparam CDA_FAR *);
 *
 */
#endif
#ifndef _cdatrans_
#define _cdatrans_
/*
**++
**
**  COPYRIGHT (c) 1991 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**	This file contains the translation table to define ANSI C style
**	predefined symbols back to their pre ANSI C counterparts if we are
**	not compiling with a conformant compiler.
**
**--
**/

/*
 * Define __ predefined symbols in sources back to pre ansi style
 * if we are compiling with non ANSI C conformant compiler.
 */
#ifndef __STDC__
#ifdef unix
#ifndef __unix__
#define __unix__ unix
#endif
#endif
#ifdef vms
#ifndef __vms__
#define __vms__ vms
#endif
#endif
#ifdef vax
#ifndef __vax__
#define __vax__ vax
#endif
#endif
#ifdef vaxc
#ifndef __vaxc__
#define __vaxc__ vaxc
#endif
#endif
#endif

/* Handle case of __unix defined but not __unix__ (c89) */
#ifdef __unix
#ifndef __unix__
#define __unix__ __unix
#endif
#endif

#endif  /* ifndef _cdatrans_ */
#ifndef _cdatyp_
#define _cdatyp_
/*
**++
**
**  COPYRIGHT (c) 1991, 1992 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**	This file contains the type definitions for the CDA & DDIS routines.
**
**--
**/

/*
 * Translate __ predefined symbols to pre ANSI C style when not
 * compiling with an ANSI C conformant compiler.
 */
#include <cdatrans.h>


/*
 * The symbol CDAbig_endian is defined here for big endian platforms.
 * When compiling applications on big endian platforms not listed below,
 * the symbol CDAbig_endian must be defined on the compile command line.
 */
#if defined(sun) || defined(hpux)
#define CDAbig_endian
#endif

/*
 * The symbol CDAlocal_DAS is defined here for platforms on which we
 * use our "portable subset" of the DECimage Application Services (DAS)
 * code.  Defining CDAlocal_DAS causes the correct version of image
 * headers files to be used in those modules that have DAS dependencies. 
 */
#if defined(sun) || defined(hpux)
#define CDAlocal_DAS
#endif

/*
 * The symbol CDA64bit is defined here for platforms with 64-bit addresses.
 * When compiling applications on 64-bit platforms not listed below,
 * the symbol CDA64bit must be defined on the compile command line.
 */
#if defined(__unix__) && (defined(__alpha__) || defined(__alpha))
#define CDA64bit
#endif


/*
 * The CDA_EXPAND_PROTO flag along with the PROTO macro allow for tailoring
 * routine declarations to expand to function prototypes or not depending
 * on the particular platform (compiler) capabilities.
 * If CDA_EXPAND_PROTO is defined, the PROTO macro will expand to function
 * prototypes.  If OS2 or msdos turn on flag as prototypes must be used
 * on these platforms.  For other platforms it is left to the application
 * to #define CDA_EXPAND_PROTO before #include of this file if function
 * prototyping is desired.
 */
#if defined(OS2) || defined(msdos) || defined(__vaxc__) || defined(__STDC__)
#ifndef CDA_EXPAND_PROTO
#define CDA_EXPAND_PROTO 1
#endif
#endif

/*
 * CDA keyword macros.
 */
#ifndef CDA_MACROS_DEFINED
#define CDA_MACROS_DEFINED
#if defined (OS2) || defined (RATIONAL) || defined (MSWINDOWS)
#define CDA_HUGE huge
#define CDA_FAR  far
#define CDA_APIENTRY far pascal
#define CDA_CALLBACK far pascal _loadds _export
#else
#if defined(msdos)
#define CDA_HUGE huge
#define CDA_FAR  far
#define CDA_APIENTRY far cdecl
#define CDA_CALLBACK far cdecl
#else
#define CDA_FAR
#define CDA_HUGE
#define CDA_APIENTRY
#define CDA_CALLBACK
#endif
#endif
#endif

/*
 * CDA defined types.
 */
#ifndef CDA_TYPES
#define CDA_TYPES

#if defined(CDA64bit)
typedef unsigned int	CDAstatus;	/* Return status code		 */
typedef long		CDAsize;	/* Size or position arg		 */
typedef int		CDAcount;	/* Count or length arg		 */
typedef unsigned short	CDAitemcode;	/* Itemlist item code		 */
typedef unsigned short	CDAitemlength;	/* Itemlist item length		 */
typedef unsigned char * CDAbufaddr;	/* Addr. array of unsigned bytes */
typedef void *		CDAaddress;	/* Generic address argument	 */
typedef int		CDAcardinal;	/* Integer arguments		 */
typedef unsigned int	CDAidnum;	/* Numeric identifier (row number, window id, etc.) */
typedef int		CDAboolean;	/* Boolean value		 */
typedef char 		CDAenvirontext;	/* Environment specific text	 */
					/* character			 */
typedef unsigned char	CDAoctet;	/* Unsigned 8-bit entity	 */
typedef int		CDAaggtype;	/* CDA aggregate type code	 */
typedef int		CDAconstant;	/* CDA enumerated constant	 */
typedef	int		CDAindex;	/* Array index			 */
typedef void *		CDAuserparam;	/* User supplied parameter       */
typedef unsigned int	CDAflags;	/* Flags/mask longword		 */
typedef unsigned int 	CDAlargebitfield; /* Bitfield type for fields > 8   */
typedef unsigned int 	CDAsmallbitfield; /* Bitfield type for fields <= 8
                                             when needed to avoid padding   */
typedef unsigned int	CDAuint32;	/* 32-bit unsigned */
typedef int		CDAmeasurement;
#endif

#if defined (__vms__) || ( defined(__unix__) && ! defined(CDA64bit) )
typedef unsigned long	CDAstatus;	/* Return status code		    */
typedef long		CDAsize;	/* Size, length, or position arg    */
typedef int		CDAcount;	/* Count or length arg		 */
typedef unsigned short	CDAitemcode;	/* Itemlist item code		    */
typedef unsigned short	CDAitemlength;	/* Itemlist item length		    */
typedef unsigned char CDA_HUGE * CDAbufaddr; /* Addr. array of unsigned bytes */
typedef void CDA_FAR *	CDAaddress;	/* Generic address argument	    */
typedef int		CDAcardinal;	/* Integer arguments		    */
typedef unsigned long	CDAidnum;	/* Numeric identifier (row number, window id, etc.) */
typedef int		CDAboolean;	/* Boolean value		    */
typedef char 		CDAenvirontext;	/* Environment specific text	    */
					/* character			    */
typedef unsigned char	CDAoctet;	/* Unsigned 8-bit entity	    */
typedef int		CDAaggtype;	/* CDA aggregate type code	    */
typedef long 		CDAconstant;	/* CDA enumerated constant	    */
typedef	int		CDAindex;	/* Array index			    */
typedef void CDA_FAR *	CDAuserparam;   /* User supplied parameter	    */
typedef unsigned long	CDAflags;	/* Flags/mask longword		    */
typedef unsigned int 	CDAlargebitfield; /* Bitfield type		    */
typedef unsigned int 	CDAsmallbitfield; /* Bitfield type for fields <= 8
					     when needed to avoid padding   */
typedef unsigned long	CDAuint32;	/* 32-bit unsigned */
typedef long		CDAmeasurement;
#endif

#if defined(OS2) || defined(msdos)
typedef unsigned long	CDAstatus;	/* Return status code		    */
typedef long		CDAsize;	/* Size, length, or position arg    */
typedef int		CDAcount;	/* Count or length arg		 */
typedef unsigned short	CDAitemcode;	/* Itemlist item code		    */
typedef unsigned short	CDAitemlength;	/* Itemlist item length		    */
typedef unsigned char CDA_HUGE * CDAbufaddr; /* Addr. array of unsigned bytes */
typedef void CDA_FAR *	CDAaddress;	/* Generic address argument	    */
typedef int		CDAcardinal;	/* Integer arguments		    */
typedef unsigned long	CDAidnum;	/* Numeric identifier (row number, window id, etc.) */
typedef char		CDAboolean;	/* Boolean value		    */
typedef char 		CDAenvirontext;	/* Environment specific text	    */
					/* character			    */
typedef unsigned char	CDAoctet;	/* Unsigned 8-bit entity	    */
typedef int		CDAaggtype;	/* CDA aggregate type code	    */
typedef long		CDAconstant;	/* CDA enumerated constant	    */
typedef int		CDAindex;	/* Array index			    */
typedef void CDA_FAR *	CDAuserparam;   /* User supplied parameter	    */
typedef unsigned long	CDAflags;	/* Flags/mask longword		    */
typedef unsigned int 	CDAlargebitfield; /* Bitfield type for fields > 8   */
typedef unsigned char 	CDAsmallbitfield; /* Bitfield type for fields <= 8
					     when needed to avoid padding   */
typedef unsigned long	CDAuint32;	/* 32-bit unsigned */
typedef long		CDAmeasurement;
#endif

typedef struct cda_itemlist {		/* Itemlist structure		 */
    CDAitemlength item_length;
    CDAitemcode   item_code;		/* Parameter can be value or adrr*/
    union {				/* It is recommended that this   */
	CDAsize	    item_value;		/* itemlist struct be used over  */
	CDAaddress  item_address;	/* the struct cda_itemlist def'd */
	} CDAitemparam;			/* in cda_def.h (cda_def.h).	 */
    } CDAitemlist;

typedef struct cda_format_list_entry
{
    CDAconstant		domain;		/* The domain for this format.      */
    CDAconstant		febe;		/* Front end or a back end format.  */
    CDAsize		length;		/* The length of the format name.   */
    CDAenvirontext	*format;	/* A pointer to the memory location
					   at which the format name is stored
					   as an ASCII character string.    */
} CDAformatlist;


typedef struct cda_aggregate CDA_FAR *CDAagghandle; /* Aggregate handle	     */

typedef struct cda_document CDA_FAR *CDArootagghandle;/* Root aggregate handle */

typedef struct cda_converter CDA_FAR *CDAconverterhandle;   /* Converter handle	     */

typedef struct cda_frontend CDA_FAR *CDAfrontendhandle;	    /* Cvtr front end handle */

typedef struct cda_filehandle CDA_FAR *CDAfilehandle;	    /* CDA file handle	     */

typedef struct cda_text_filehandle CDA_FAR *CDAtextfilehandle; /* Text file handle   */

typedef struct cda_message CDA_FAR *CDAmessagehandle;	    /* CDA message handle    */

/*
 * DDIS defined types.
 */
typedef	struct ddis_context CDA_FAR *DDISstreamhandle;	    /* DDIS stream handle    */

typedef CDAuint32	DDIStype;	/* DDIS tag (type) argument	 */
typedef CDAuint32	DDISlength;	/* DDIS length argument ?? type ??*/
typedef CDAuint32	DDISentry;	/* DDIS parse table entry	 */

#endif				/* for the CDA_TYPES definition */

/*
 * usage: PROTO (return_type function, (arg1, arg2, arg3))
 */
#ifndef PROTO
#if CDA_EXPAND_PROTO == 1
#define PROTO(name, arg_list) name arg_list
#else
#define PROTO(name, arg_list) name ()
#endif
#endif

#endif
#ifndef __CHFDEF_LOADED
#define __CHFDEF_LOADED	1

/*	CHFDEF - V3.0 - Structure Definitions for Condition Handlers	*/

#pragma nostandard
# include sfdef
#pragma standard

struct	chf$arglist 
	{
	struct	chf$signal_array  *chf$l_sigarglst;	/* pointer to signal array */
	struct	chf$mech_array	  *chf$l_mcharglst;	/* pointer to mechanism array */
	};


struct	chf$signal_array 
	{
	long	chf$l_sig_args;				/* number of signal array arguments (variable) */
	long	chf$l_sig_name;				/* name of condition */
	long	chf$l_sig_arg1;				/* first signal specific argument */

							/* NOTE:  Following chf$l_sig_arg1 are two longwords 
							   containing the values (at the time of the exception) 
							   of the program counter and processor status longword, 
							   respectively */
	};


struct	chf$mech_array 
	{
	long	chf$l_mch_args;				/* number of mechanism array arguments (always 4) */
	struct	sf$frame  *chf$l_mch_frame;		/* establisher frame address */
							/* Note:  see SFDEF.H for the definition of struct sf$frame */
	long	chf$l_mch_depth;			/* frame depth of establisher */
	long	chf$l_mch_savr0;			/* saved register 0 (at time of condition) */
	long	chf$l_mch_savr1;			/* saved register 1 (at time of condition) */
	};

#endif					/* __CHFDEF_LOADED */
#ifndef __CHKPNTDEF_LOADED
#define __CHKPNTDEF_LOADED	1

/*** MODULE $chkpntdef ***/
/*-                                                                         */
/*                                                                          */
/* Define flags for calls to create checkpointable processes                */
/*+                                                                         */
#define CHKPNT$M_AUTO_RESTART 1
#define CHKPNT$M_DEBUG 2
#define CHKPNT$M_ASYNC 4
struct chkpntdef {
    unsigned chkpnt$v_auto_restart : 1; /* auto-restart detached process    */
    unsigned chkpnt$v_debug : 1;        /* merge in DEBUG                   */
    unsigned chkpnt$v_async : 1;        /* asynchronous checkpoint process  */
    unsigned chkpnt$v_fill_14 : 5;
    } ;
 

#endif					/* __CHKPNTDEF_LOADED */
#ifndef __CHPDEF_LOADED
#define __CHPDEF_LOADED	1

/*** MODULE $chpdef ***/
/*+                                                                         */
/*                                                                          */
/* Item definitions for the $CHKPRO (check protection) service.             */
/*                                                                          */
/*-                                                                         */
#define CHP$_END 0                      /* list end                         */
#define CHP$_ACCESS 1                   /* intended access                  */
#define CHP$_FLAGS 2                    /* read / write flags               */
#define CHP$_PRIV 3                     /* privilege mask                   */
#define CHP$_ACMODE 4                   /* accessor access mode             */
#define CHP$_ACCLASS 5                  /* accessor security classification */
#define CHP$_RIGHTS 6                   /* rights list                      */
#define CHP$_ADDRIGHTS 7                /* additional rights list segments  */
#define CHP$_MODE 8                     /* simple access mode               */
#define CHP$_MODES 9                    /* per action access mode           */
#define CHP$_MINCLASS 10                /* minimum security classification  */
#define CHP$_MAXCLASS 11                /* maximum security classification  */
#define CHP$_OWNER 12                   /* object owner UIC                 */
#define CHP$_PROT 13                    /* protection mask                  */
#define CHP$_ACL 14                     /* access control list segment      */
#define CHP$_AUDITNAME 15               /* security audit name              */
#define CHP$_ALARMNAME 16               /* security alarm name              */
#define CHP$_MATCHEDACE 17              /* address of matching ACE          */
#define CHP$_PRIVUSED 18                /* mask of privileges used          */
#define CHP$_MAX_CODE 19                /* highest CHP$ item code           */
#define CHP$M_SYSPRV 1
#define CHP$M_BYPASS 2
#define CHP$M_UPGRADE 4
#define CHP$M_DOWNGRADE 8
#define CHP$M_GRPPRV 16
#define CHP$M_READALL 32
struct privs_used_bits {
    unsigned chp$v_sysprv : 1;          /* access via SYSPRV privilege      */
    unsigned chp$v_bypass : 1;          /* access via BYPASS privilege      */
    unsigned chp$v_upgrade : 1;         /* access via UPGRADE privilege     */
    unsigned chp$v_downgrade : 1;       /* access via DOWNGRADE privilege   */
    unsigned chp$v_grpprv : 1;          /* access via GRPPRV privilege      */
    unsigned chp$v_readall : 1;         /* access via READALL privilege     */
    unsigned chp$v_fill_15 : 2;
    } ;
#define CHP$M_READ 1
#define CHP$M_WRITE 2
#define CHP$M_USEREADALL 4
struct flag_bits {
    unsigned chp$v_read : 1;            /* non-discretionary read access    */
    unsigned chp$v_write : 1;           /* non-discretionary write access   */
    unsigned chp$v_usereadall : 1;      /* READALL privilege applies        */
    unsigned chp$v_fill_16 : 5;
    } ;
#define CHP$M_NOACCESS 1
#define CHP$M_REMDUPID 2
struct profile_flags {
    unsigned chp$v_noaccess : 1;        /* do not access UAF to build profile */
    unsigned chp$v_remdupid : 1;        /* remove duplicate system rights IDs */
    unsigned chp$v_fill_17 : 6;
    } ;
 

#endif					/* __CHPDEF_LOADED */
#ifndef __CLIDEF_LOADED
#define __CLIDEF_LOADED	1

/*** MODULE $clidef ***/
/*++                                                                        */
/*                                                                          */
/* $CLIDEF --- COMMAND LAGUAGE INTERFACE DEFINITIONS                        */
/*                                                                          */
/* THIS MODULE DEFINES THE OFFSET VALUES FOR THE DATA STRUCTURES            */
/* USED TO COMMUNICATED COMMAND INFORMATION BETWEEN THE CLI AND             */
/* THE UTILITY THAT WAS REQUESTED TO PERFORM THE OPERATION.                 */
/*                                                                          */
/*--                                                                        */
#define CLI$M_DEBUG 1
#define CLI$M_DBGTRU 2
#define CLI$M_VERIFY 4
#define CLI$M_BATCH 8
#define CLI$M_INDIRECT 16
#define CLI$M_VFYINP 32
#define CLI$M_TRMVRBLV 768
#define CLI$M_DBGEXCP 65536
#pragma nostandard
struct clidef {
    unsigned long int cli$l_iniargcnt;  /* INITIAL ARG COUNT                */
    int *cli$a_progxfer;                /* PROGRAM TRANSFER VECTOR ADDRESS  */
    int *cli$a_utilserv;                /* ADDRESS OF CLI UTILITY SERVICE   */
    int *cli$a_imghdadr;                /* ADDRESS OF IMAGE HEADER          */
    int *cli$a_imgfiled;                /* ADDRESS OF IMAGE FILE DATA       */
    unsigned long int cli$l_linkflag;   /* LINK FLAG LONGWORD               */
    variant_union  {
        unsigned long int cli$l_cliflag; /* CLI FLAG LONGWORD               */
        variant_struct  {
            unsigned cli$v_debug : 1;   /* DEBUG QUALIFIER SEEN             */
            unsigned cli$v_dbgtru : 1;  /* DEBUG WAS TRUE                   */
            unsigned cli$v_verify : 1;  /* VERIFY IS ON                     */
            unsigned cli$v_batch : 1;   /* THIS PROCESS IS A BATCH JOB      */
            unsigned cli$v_indirect : 1; /* INDIRECT LEVEL NOT EQUAL TO ZERO  */
            unsigned cli$v_vfyinp : 1;  /* UTILITY SHOULD VERFIY INPUT      */
            unsigned clidef$$_fill_1 : 2; /* ROUND UP TO NEXT BYTE          */
            unsigned cli$v_trmvrblv : 2; /* TERMINAL VERBOSITY LEVEL        */
            unsigned clidef$$_fill_2 : 6; /* ROUND UP TO NEXT BYTE          */
            unsigned cli$v_dbgexcp : 1; /* DEBUGGER CALLED VIA "DEBUG" EXCEPTION  */
            unsigned cli$v_fill_18 : 7;
            } cli$r_cliflag_bits;
/*        THE FOLLOWING ARGUMENTS ARE OPTIONAL DEPENDING ON INIARGCNT       */
        } cli$r_cliflag_overlay;
    unsigned long int cli$l_arglist;    /* ADDRESS OF APPLICATION ARGUMENT LIST  */
/* (USED FOR MERGED IMAGE ARG. PASSING)                                     */
/*                                                                          */
/*        DEFINE CLI COMMAND INTERFACE REQUEST BLOCK                        */
/*                                                                          */
    } ;
#define CLI$M_PARMREQ 1
#define CLI$M_ABSADR 2
#define CLI$M_EXPNAM 4
#define CLI$M_LASTVAL 1
#define CLI$M_DUMMY 2
#define CLI$M_PARMPRS 1
#define CLI$M_CONCATINP 2
#define CLI$M_MOREINP 4
#define CLI$M_PARMDEF 8
#define CLI$M_MOREVALS 1
#define CLI$M_KEYVALU 2
#define CLI$K_REQDESC 28                /* SIZE OF THE STRUCTURE            */
#define CLI$C_REQDESC 28                /* SIZE OF THE STRUCTURE            */
/*                                                                          */
struct clidef1 {
    variant_union  {
        long int clidef$$_fill_3;       /* DUMMY ARG                        */
        variant_struct  {
            variant_union  {
                unsigned char cli$b_rqtype; /* TYPE OF REQUEST BEING MADE   */
                variant_struct  {
                    unsigned cli$v_subtyp : 4; /* SUB TYPE VIELD            */
                    unsigned cli$v_prityp : 4; /* PRIMARY TYPYE             */
                    } cli$r_rqtype_bits;
                } cli$r_rqtype_overlay;
            variant_union  {
                unsigned short int cli$w_servcod; /* CLI SERVICE CODE       */
                variant_struct  {
                    variant_union  {
                        unsigned char cli$b_rqindx; /* OFFSET FOR VALUE KEYWORD INDEX  */
                        unsigned char cli$b_bitnum; /* BIT TO SET IF REQUEST IS SUCESSFUL  */
                        } cli$r_rqindx_overlay;
                    variant_union  {
                        unsigned char cli$b_rqflgs; /* INPUT FLAGS CONCERNING REQUEST  */
                        variant_struct  {
                            unsigned cli$v_parmreq : 1; /* PARAMATER IS REQUIRED  */
                            unsigned cli$v_absadr : 1; /* ALL ADDRESS ARE ABSOLUTE  */
                            unsigned cli$v_expnam : 1; /* RETURN EXPLICIT NAMES ONLY  */
                            unsigned cli$v_fill_19 : 5;
                            } cli$r_rqflgs_bits0;
                        variant_struct  {
                            unsigned cli$v_lastval : 1; /* LAST VALUE ALLOWED  */
                            unsigned cli$v_dummy : 1; /* *** SAVE PLACE FOR ABS ADR ***  */
                            unsigned cli$v_fill_20 : 6;
                            } cli$r_rqflgs_bits1;
                        } cli$r_rqflgs_overlay;
                    } cli$r_servcod_fields;
                } cli$r_servcod_overlay;
            variant_union  {
                unsigned char cli$b_rqstat; /* OUTPUT STATUS FLAGS          */
                variant_struct  {
                    unsigned cli$v_parmprs : 1; /* PARAMETER IS PRESENT     */
                    unsigned cli$v_concatinp : 1; /* INPUT CONCATONATION EXISTS  */
                    unsigned cli$v_moreinp : 1; /* ANOTHER SET OF INPUT PARAMETERS  */
                    unsigned cli$v_parmdef : 1; /* PARAMETER WAS DEFAULTED PRESENT  */
                    unsigned cli$v_fill_21 : 4;
                    } cli$r_rqstat_bits0;
                variant_struct  {
                    unsigned cli$v_morevals : 1; /* UNPROCESSED VALUES REMAIN  */
                    unsigned cli$v_keyvalu : 1; /* SUBSEQUENT TOKEN IS VALUE FOR KEY  */
                    unsigned cli$v_fill_22 : 6;
                    } cli$r_rqstat_bits1;
                } cli$r_rqstat_overlay;
            } cli$r_fill_3_fields;
        } cli$r_fill_3_overlay;
    int *cli$a_erract;                  /* ADDRESS OF ERROR ACTION ROUTINE  */
    variant_union  {
        unsigned int cli$q_rqdesc [2];  /* QUADWORD REQUEST DESCRIPTOR      */
        variant_struct  {
            unsigned short int cli$w_rqsize; /* RESULTANT SIZE OF PARAMETER  */
            short int clidef$$_fill_4;  /* SPARE WORD IN DESCRIPTOR         */
            variant_union  {
                unsigned long int cli$l_rqvalu; /* ACTUAL VALUE IN VALUE CONVERSTION  */
                int *cli$a_rqaddr;      /* ADDRESS OF RESULTANT PARAMETER   */
                } cli$r_rqvalu_overlay;
            } cli$r_rqdesc_fields;
        } cli$r_rqdesc_overlay;
    int *cli$a_prsact;                  /* PARAMETER PRESENT ACTION ROUTINE  */
    int *cli$a_absact;                  /* PARAMETER ABSENT ACTION ROUTINE  */
    int *cli$a_qualst;                  /* ADDRESS OF QUALIFIERS            */
/* Define the Descriptor Used by Symbol and Logical-name Callbacks          */
/*                                                                          */
    } ;
struct clidef2 {
    char clidef$$_fill_8 [4];
    unsigned int cli$q_namdesc [2];     /* Logical name or symbol name      */
    unsigned int cli$q_valdesc [2];     /* Equivalence name or symbol value  */
    unsigned int cli$q_tabdesc [2];     /* Name of logical name table       */
    unsigned long int cli$l_itmlst;     /* Address of item list             */
    unsigned long int cli$l_attr;       /* Address of attribute longword    */
/*                                                                          */
/* Define the Descriptor Locations Used for the Old/New                     */
/* Out-of-Band Character(s) Masks                                           */
/*                                                                          */
    } ;
struct clidef3 {
    char clidef$$_fill_9 [4];
    unsigned long int cli$l_new_mask;   /* Enable/disable mask              */
    unsigned long int cli$l_old_mask;   /* Previous enabled values mask     */
/*                                                                          */
/* Define the descriptor used for ATTACH callback                           */
/*                                                                          */
    } ;
struct clidef4 {
    char clidef$$_fill_10 [4];
    unsigned long int cli$l_pid;        /* PID of "destination" process     */
/*                                                                          */
/* Define the descriptor used for SPAWN callback                            */
/*                                                                          */
    } ;
#define CLI$M_NOWAIT 1
#define CLI$M_NOCLISYM 2
#define CLI$M_NOLOGNAM 4
#define CLI$M_NOKEYPAD 8
#define CLI$M_NOTIFY 16
#define CLI$M_NOCONTROL 32
#define CLI$K_SPAWN_VERSION 1           /* Latest version                   */
#define CLI$C_SPAWN_VERSION 1           /* Latest version                   */
#define CLI$K_SRVDESC 84                /* Length of longest "service" callback  */
#define CLI$C_SRVDESC 84                /* Length of longest "service" callback  */
/*                                                                          */
struct clidef5 {
    char clidef$$_fill_11 [4];
    variant_union  {
        unsigned char cli$b_flags;      /* Flags byte                       */
        variant_struct  {
            unsigned cli$v_nowait : 1;  /* Do not wait for subprocess completion  */
            unsigned cli$v_noclisym : 1; /* Do not copy CLI symbols to subprocess  */
            unsigned cli$v_nolognam : 1; /* Do not copy logical names to subprocess  */
            unsigned cli$v_nokeypad : 1; /* Do not copy keypad state to subprocess */
            unsigned cli$v_notify : 1;  /* Output notification message      */
            unsigned cli$v_nocontrol : 1; /* Do not put CR/LF in front of prompt string */
            unsigned cli$v_fill_23 : 2;
            } cli$r_flags_bits;
        } cli$r_flags_overlay;
    char clidef$$_fill_5 [3];           /* Unused                           */
    unsigned long int cli$l_outpid;     /* PID of subprocess on return      */
    unsigned long int cli$l_lststatus;  /* Address to store final subprocess status  */
    unsigned int cli$q_cmdstr [2];      /* Descriptor of command string     */
    unsigned int cli$q_input [2];       /* Descriptor of input filespec     */
    unsigned int cli$q_output [2];      /* Descriptor of output filespec    */
    unsigned int cli$q_prcnam [2];      /* Descriptor of name for subprocess  */
    unsigned long int cli$l_astadr;     /* Address of termination AST routine  */
    unsigned long int cli$l_astprm;     /* Address of AST routine parameter  */
    unsigned char cli$b_efn;            /* Event flag to set on termination  */
    unsigned char cli$b_version;        /* Data structure version           */
    char clidef$$_fill_6 [2];           /* Unused                           */
    unsigned int cli$q_prompt [2];      /* Descriptor of prompt string      */
    unsigned int cli$q_cli [2];         /* Descriptor of cli name           */
    unsigned int cli$q_table [2];       /* Descriptor of cli table name     */
/*                                                                          */
/* Define the length of the longest "supervisor-mode service" request block, */
/* so that programs can allocate a fixed amount of space for the block.     */
/*                                                                          */
/* DEFINE THE PARAMETER QUALIFIER DESCRIPTOR                                */
/*                                                                          */
    } ;
#define CLI$M_ALLOCCUR 1
#define CLI$M_QDUSRV 2
#define CLI$M_QDEXPA 4
#define CLI$M_QUALTRU 1
#define CLI$M_QUALEXP 2
#define CLI$K_QUALDEF 20                /* SIZE OF FIXED PART OF STRUCTURE  */
#define CLI$C_QUALDEF 20                /* SIZE OF FIXED PART OF STRUCTURE  */
#define CLI$K_QDBITS 20                 /* START OF BIT LISTS(VARIALBLE LENGTH)  */
#define CLI$C_QDBITS 20                 /* START OF BIT LISTS(VARIALBLE LENGTH)  */
struct clidef6 {
    unsigned char cli$b_qdblksiz;       /* SIZE OF THE FINAL BLOCK          */
    unsigned char cli$b_qdcode;         /* ID CODE FOR THE QUALIFIER        */
    variant_union  {
        unsigned char cli$b_qdflgs;     /* FLAGS BYTE                       */
        variant_struct  {
            unsigned cli$v_alloccur : 1; /* TAKE ACTION ON ALL OCCURANCES   */
            unsigned cli$v_qdusrv : 1;  /* USER CONTEX VALUE IS PRESENT     */
            unsigned cli$v_qdexpa : 1;  /* TAKE ACTION ON EXPLICIT OCCURANCES  */
            unsigned cli$v_fill_24 : 5;
            } cli$r_qdflgs_bits;
        } cli$r_qdflgs_overlay;
    variant_union  {
        unsigned char cli$b_qdstat;     /* QUALIFIER STATUS                 */
        variant_struct  {
            unsigned cli$v_qualtru : 1; /* QUALIFIER IS TRUE                */
            unsigned cli$v_qualexp : 1; /* QUALIFIER EXPLICITLY STATED      */
            unsigned cli$v_fill_25 : 6;
            } cli$r_qdstat_bits;
        } cli$r_qdstat_overlay;
    variant_union  {
        unsigned int cli$q_qdvaldesc [2]; /* QUALIFIER VALUE DESCRIPTOR     */
        variant_struct  {
            unsigned short int cli$w_qdvalsiz; /* SIZE OF VALUE             */
            short int clidef$$_fill_7;  /* SPARE WORD                       */
            int *cli$a_qdvaladr;        /* ADDRESS OF VALUE STRING          */
            } cli$r_qdvaldesc_fields;
        } cli$r_qdvaldesc_overlay;
    int *cli$a_truact;                  /* QUALIFIER TRUE ACTION ROUTINE    */
    int *cli$a_flsact;                  /* QUALIFIER FALSE ACTION ROUTINE   */
    unsigned long int cli$l_usrval;     /* OPTION USER VALUE IF PRESENT     */
/*                                                                          */
/* DEFINE SPACE FOR THE RESULT PARSE WORK AREA                              */
/*                                                                          */
    } ;
#define CLI$K_WORKAREA 128              /* SIZE OF HEADER                   */
#define CLI$C_WORKAREA 128              /* SIZE OF HEADER                   */
/*                                                                          */
#define CLI$K_UTILOPR 0                 /* UTILITY OPERATIONS               */
#define CLI$K_INPSPEC 1                 /* REQUEST FOR AN INPUT SPECIFICATION  */
#define CLI$K_OUTSPEC 2                 /* AN OUTPUT FILE SPECIFICATION     */
#define CLI$K_PARDONE 3                 /* PARAMETER DONE REQUEST           */
#define CLI$K_VALCONV 4                 /* REQUEST A VALUE CONVERSION       */
#define CLI$K_CLINT 5                   /* CLINT OPERATIONS                 */
/*                                                                          */
#define CLI$K_INITPRS 0                 /* REQUEST INITIALIZATION OF PARSE  */
#define CLI$K_GETCMD 1                  /* GET COMMAND BUFFER LIMITS        */
#define CLI$K_GETQUAL 2                 /* OPTAIN STATE OF QUALIFIERS       */
#define CLI$K_GETOPT 3                  /* DECODE COMMAND OPTION            */
#define CLI$K_GETLINE 4                 /* GET COMMAND LINE                 */
/*                                                                          */
/* THE CLISERV REQUEST TYPE APPEARS HERE, INSTEAD OF WITH THE OTHER REQUEST */
/* TYPES, BECAUSE IT HAS NO SUBFUNCTIONS ASSOCIATED WITH IT, AND BECAUSE A  */
/* DAY 1 CODING ERROR CAUSES DCL TO EXPECT THAT THIS REQUEST NUMBER WILL    */
/* APPEAR IN THE SUBFUNCTION BITS.  THIS MEANS THAT NO UTILITY OPERATION    */
/* CAN BE DEFINED WITH THE SUBFUNCTION NUMBER 5.                            */
/*                                                                          */
#define CLI$K_CLISERV 5                 /* REQUEST A SERVICE FROM THE CLI   */
/*                                                                          */
#define CLI$K_INPUT1 16                 /* PRIMARY INPUT                    */
#define CLI$K_INPUT2 17                 /* SECONDARY INPUT                  */
#define CLI$K_INPUT3 18                 /* THIRD,                           */
#define CLI$K_INPUT4 19                 /* ETC,ETC,ETC                      */
/*                                                                          */
#define CLI$K_OUTPUT1 32                /* FIRST OUTPUT                     */
#define CLI$K_OUTPUT2 33                /* SECOND OUTPUT                    */
#define CLI$K_OUTPUT3 34                /* THIRD,-                          */
#define CLI$K_OUTPUT4 35                /* ETC,ETC,ETC                      */
/*                                                                          */
#define CLI$K_ENDPRM1 48                /* COMPLETED PARAMETER SET 1        */
#define CLI$K_ENDPRM2 49                /* COMPLETED PARAMETER SET 2        */
#define CLI$K_ENDPRM3 50                /* COMPLETED PARAMETER SET 3        */
#define CLI$K_ENDPRM4 51                /* COMPLETED PARAMETER SET 4        */
/*                                                                          */
#define CLI$K_NUMERVAL 64               /* NUMBERIC VALUE                   */
#define CLI$K_ASCIIVAL 65               /* ASCII VALUE                      */
#define CLI$K_KEYWORD 66                /* KEYWORD VALUE                    */
#define CLI$K_KEYVAL 67                 /* KEYWORD WITH VALUE               */
#define CLI$K_FILSPEC 68                /* VALUE IS A FILESPEC              */
/*                                                                          */
#define CLI$K_PRESENT 80                /* DETERMINE IF ENTITY IS PRESENT   */
#define CLI$K_GETVALUE 81               /* GET VALUE OF ENTITY              */
#define CLI$K_ENDPARSE 82               /* CLEAN UP AFTER PARSING COMMAND   */
#define CLI$K_DCLPARSE 83               /* PARSE USER COMMAND LINE          */
#define CLI$K_DISPATCH 84               /* DISPATCH TO ACTION ROUTINE       */
#define CLI$K_NEXTQUAL 85               /* PROCESS NEXT QUALIFIER           */
union clidef7 {
    unsigned long int cli$l_workarea [32]; /* ALLOCATE 32 LONG WORDS        */
/* DEFINE CLI UTILITY REQUEST CODES                                         */
/*                                                                          */
/*        CODES ARE 8 BITS, CONSISTING OF 2 4 BIT FIELDS                    */
/*        THE LEAST 4 BITS ARE SUBFUCTION DEFINITONS                        */
/*        AND THE MOST SIGNIFICANT 4 BITS ARE REQUEST TYPE                  */
/*                                                                          */
/* DEFINE REQUEST TYPE CODES                                                */
/* DEFINE COMPLETE CODES FOR UTILITY OPERATIONS                             */
/*                                                                          */
/* DEFINE COMPLETE CODES FOR INPUT SPECIFICATIONS                           */
/*                                                                          */
/* DEFINE COMPLETE CODES FOR OUTPUT SPECIFICATIONS                          */
/*                                                                          */
/* DEFINE CODES FOR RESULT PARSE PARAMETER COMPLETION                       */
/*                                                                          */
/* DEFINE CODES FOR VALUE CONVERSION REQUESTS                               */
/*                                                                          */
/* DEFINE COMPLETE CODES FOR UTILITY OPERATIONS                             */
/*                                                                          */
    } ;
#pragma standard

#endif					/* __CLIDEF_LOADED */
#ifndef __CLIMSGDEF_LOADED
#define __CLIMSGDEF_LOADED	1

/*	CLIMSGDEF - V3.0	*/

/*
 *	CLI Error Message Code Definitions.
 */

# define	CLI$_ABVERB	0X00038008
# define	CLI$_ABKEYW	0X00038010
# define	CLI$_BUFOVF	0X00038018
# define	CLI$_COMPLX	0X00038020
# define	CLI$_DEFOVF	0X00038028
# define	CLI$_DIRECT	0X00038030
# define	CLI$_EXPSYN	0X00038038
# define	CLI$_IMCHNG	0X00038040
# define	CLI$_INSFPRM	0X00038048
# define	CLI$_IVCHAR	0X00038050
# define	CLI$_SPARE	0X00038058
# define	CLI$_IVKEYW	0X00038060
# define	CLI$_IVOPER	0X00038068
# define	CLI$_IVPROT	0X00038070
# define	CLI$_IVQLOC	0X00038078
# define	CLI$_IVSYMB	0X00038080
# define	CLI$_IVVALU	0X00038088
# define	CLI$_IVVERB	0X00038090
# define	CLI$_MAXPARM	0X00038098
# define	CLI$_NOATFIL	0X000380A0
# define	CLI$_NOCCAT	0X000380A8
# define	CLI$_NOCOMD	0X000380B0
# define	CLI$_NOKEYW	0X000380B8
# define	CLI$_NOLIST	0X000380C0
# define	CLI$_NOQUAL	0X000380C8
# define	CLI$_NOVALU	0X000380D0
# define	CLI$_NOTNEG	0X000380D8
# define	CLI$_NULFIL	0X000380E0
# define	CLI$_NUMBER	0X000380E8
# define	CLI$_ONCOMD	0X000380F0
# define	CLI$_ONERR	0X000380F8
# define	CLI$_ONLEVL	0X00038100
# define	CLI$_ONOVF	0X00038108
# define	CLI$_PARMDEL	0X00038110
# define	CLI$_RSLOVF	0X00038118
# define	CLI$_SKPDAT	0X00038120
# define	CLI$_STKOVF	0X00038128
# define	CLI$_SYMDEL	0X00038130
# define	CLI$_SYMOVF	0X00038138
# define	CLI$_UNDSYM	0X00038140
# define	CLI$_USGOTO	0X00038148
# define	CLI$_VALREQ	0X00038150
# define	CLI$_ONEVAL	0X00038158
# define	CLI$_OVRFLW	0X00038160
# define	CLI$_UNPROQUAL	0X00038168
# define	CLI$_UNPROPARM	0X00038170
# define	CLI$_INVKEY	0X00038178
# define	CLI$_INVRSP	0X00038180
# define	CLI$_UNDFIL	0X00038188
# define	CLI$_FILOPN	0X00038190
# define	CLI$_BADRET	0X00038198
# define	CLI$_ABSYMD	0X000381A0
# define	CLI$_INVUIC	0X000381A8
# define	CLI$_BADTEXT	0X000381B0
# define	CLI$_ABFNAM	0X000381B8
# define	CLI$_IVFNAM	0X000381C0
# define	CLI$_BLKOVRFLOW	0X000381C8
# define	CLI$_BLKUNDFLOW	0X000381D0
# define	CLI$_BADBLK	0X000381D8
# define	CLI$_NOLBLS	0X000381E0
# define	CLI$_NOCHANGE	0X000381E8
# define	CLI$_ABSENT	0X000381F0
# define	CLI$_NEGATED	0X000381F8
# define	CLI$_INVFILSPE	0X00038200
# define	CLI$_INVLOGFIL	0X00038208
# define	CLI$_NOTHEN	0X00038210
# define	CLI$_SYMTOOLNG	0X00038218
# define	CLI$_ASTDCL	0X00038220
# define	CLI$_INVRANGE	0X00038228
# define	CLI$_LOCNEG	0X00038230
# define	CLI$_CMDNOTFND	0X00038238
# define	CLI$_IVQUAL	0X00038240
# define	CLI$_CMDSEG	0X00038248
# define	CLI$_NOTIFY	0X00038250
# define	CLI$_CONFLICT	0X00038258
# define	CLI$_UNDKEY	0X00038260
# define	CLI$_ARGREQ	0X00038268
# define	CLI$_SYMLNG	0X00038270
# define	CLI$_SYMABR	0X00038278
# define	CLI$_IVKEYNAM	0X00038280
# define	CLI$_NOPAREN	0X00038288
# define	CLI$_IVATIME	0X00038290
# define	CLI$_IVDTIME	0X00038298
# define	CLI$_TKNOVF	0X000382A0
# define	CLI$_CMDFILERR	0X000382A8
# define	CLI$_CONFQUAL	0X00038802
# define	CLI$_INVQUAL	0X0003880A
# define	CLI$_REQPRMABS	0X00038812
# define	CLI$_INVQUALNUM	0X0003881A
# define	CLI$_INVREQTYP	0X00038822
# define	CLI$_NOVALUE	0X0003882A
# define	CLI$_VALCNVERR	0X00038832
# define	CLI$_ILLVAL	0X0003883A
# define	CLI$_NOOPTPRS	0X00038842
# define	CLI$_CREQUEJOB	0X0003884A
# define	CLI$_SUBMITERR	0X00038852
# define	CLI$_DEVALSPL	0X0003885A
# define	CLI$_DEVNOTSPL	0X00038862
# define	CLI$_IVDEVTYPE	0X0003886A
# define	CLI$_IMGFNF	0X00038872
# define	CLI$_DEVNOTFOR	0X0003887A
# define	CLI$_PWDNOTVAL	0X00038882
# define	CLI$_PWDNOTVER	0X0003888A
# define	CLI$_PWDLOCKED	0X00038892
# define	CLI$_NOTFR	0X0003889A
# define	CLI$_PWDSYNTAX	0X000388A2
# define	CLI$_IMGNAME	0X000388AA
# define	CLI$_IMAGEFNF	0X000388B2
# define	CLI$_BADSTRLVL	0X000388BA
# define	CLI$_REFUSED	0X000388C2
# define	CLI$_BADCTLMSK	0X000388CA
# define	CLI$_INVRFM	0X000388D2
# define	CLI$_NOCLINT	0X000388DA
# define	CLI$_NOSPAWN	0X000388E2
# define	CLI$_SPWNIO	0X000388EA
# define	CLI$_TRMMBX	0X000388F2
# define	CLI$_STRTOOLNG	0X000388FA
# define	CLI$_CMDGONE	0X00038902
# define	CLI$_NOCMDPROC	0X0003890A
# define	CLI$_INVROUT	0X00038912
# define	CLI$_OLDTAB	0X0003891A
# define	CLI$_INVTAB	0X00038922
# define	CLI$_NOTDISCON	0X0003892A
# define	CLI$_ENTNF	0X00038932
# define	CLI$_DEFKEY	0X0003DDC3
# define	CLI$_DELKEY	0X0003DDCB
# define	CLI$_SETKEY	0X0003DDD3
# define	CLI$_SPARE1	0X0003DDDB
# define	CLI$_ALLOC	0X0003DDE3
# define	CLI$_SUPERSEDE	0X0003DDEB
# define	CLI$_INSPRIV	0X0003DDF3
# define	CLI$_NODIRCHG	0X0003DDFB
# define	CLI$_IGNQUAL	0X0003DE03
# define	CLI$_TABEXIST	0X0003DE0B
# define	CLI$_TABSUPER	0X0003DE13
# define	CLI$_TABNOTFND	0X0003DE1B
# define	CLI$_DELSYM	0X0003DE23
# define	CLI$_SYMTRUNC	0X0003DE2B
# define	CLI$_KEYCNV	0X0003DE33
# define	CLI$_SPAWNED	0X0003FD01
# define	CLI$_ATTACHED	0X0003FD09
# define	CLI$_RETURNED	0X0003FD11
# define	CLI$_PRESENT	0X0003FD19
# define	CLI$_DEFAULTED	0X0003FD21
# define	CLI$_CONCAT	0X0003FD29
# define	CLI$_LOCPRES	0X0003FD31
# define	CLI$_COMMA	0X0003FD39
# define	CLI$_OKTAB	0X0003FD41
# define	CLI$_UPGTAB	0X0003FD49
# define	CLI$_PROC_ID	0X0003FFF1
# define	CLI$_QUEJOBCRE	0X0003FFF9
# define	CLI$_NORMAL	0X00030001

#endif					/* __CLIMSGDEF_LOADED */
#ifndef __CLISERVDEF_LOADED
#define __CLISERVDEF_LOADED	1

/*** MODULE $cliservdef ***/
/*                                                                          */
/* DEFINE CLI SERVICE REQUEST CODES                                         */
/*                                                                          */
/* DEFINE CLI SERVICE CODES                                                 */
#define CLI$K_PAUSE 1                   /* PAUSE THE IMAGE                  */
#define CLI$K_DEFLOCAL 2                /* DEFINE A SYMBOL IN THE LOCAL TABLE  */
#define CLI$K_DEFGLOBAL 3               /* DEFINE A SYMBOL IN THE GLOBAL TABLE  */
#define CLI$K_CHAIN 4                   /* PASS AN IMAGE TO RUN AFTER THIS ONE  */
#define CLI$K_COMMAND 5                 /* PASS A COMMAND LINE TO LATER EXECUTE  */
#define CLI$K_CREALOG 6                 /* DEFINE A PROCESS LOGICAL NAME    */
#define CLI$K_DELELOG 7                 /* DELETE A PROCESS LOGICAL NAME    */
#define CLI$K_DISACTRLY 8               /* DISABLE DCL CONTROL Y PROCESSING  */
#define CLI$K_ENABCTRLY 9               /* ENABLE DCL CONTROL Y PROCESSING  */
#define CLI$K_GETSYM 10                 /* RETURN VALUE OF A SYMBOL         */
#define CLI$K_DELELCL 11                /* DELETE A LOCAL SYMBOL            */
#define CLI$K_DELEGBL 12                /* DELETE A GLOBAL SYMBOL           */
#define CLI$K_DISAOOB 13                /* DISABLE OUT-OF-BAND CHARACTER(S)  */
#define CLI$K_ENABOOB 14                /* RE-ENABLE OUT-OF-BAND CHARACTER(S)  */
#define CLI$K_SPAWN 15                  /* SPAWN A SUBPROCESS               */
#define CLI$K_ATTACH 16                 /* ATTACH TO A PROCESS              */
/*                                                                          */
/* Define local/global symbol flag returned by GETSYM                       */
/*                                                                          */
#define CLI$K_LOCAL_SYM 1               /* Local symbol                     */
#define CLI$K_GLOBAL_SYM 2              /* Global symbol                    */
 

#endif					/* __CLISERVDEF_LOADED */
#ifndef __CLIVERBDEF_LOADED
#define __CLIVERBDEF_LOADED	1

/*** MODULE $cliverbdef ***/
/*                                                                          */
/* DEFINE GENERIC CODES FOR VERBS                                           */
/*                                                                          */
/* DEFINE VERB QENERIC CODES                                                */
#define CLI$K_VERB_ALLO 1               /* ALLOCATE                         */
#define CLI$K_VERB_ANAL 2               /* ANALIZE                          */
#define CLI$K_VERB_ASSI 3               /* ASSIGN                           */
#define CLI$K_VERB_BASI 4               /* BASIC                            */
#define CLI$K_VERB_BLIS 5               /* BLISS                            */
#define CLI$K_VERB_COBO 6               /* COBOL                            */
#define CLI$K_VERB_CONT 7               /* CONTINUE                         */
#define CLI$K_VERB_COPY 8               /* COPY                             */
#define CLI$K_VERB_CREA 9               /* CREATE                           */
#define CLI$K_VERB_DATA 10              /* DATA                             */
#define CLI$K_VERB_DEAL 11              /* DEALLOCATE                       */
#define CLI$K_VERB_DEAS 12              /* DEASSIGN                         */
#define CLI$K_VERB_DEBU 13              /* DEBUG                            */
#define CLI$K_VERB_DEFI 14              /* DEFINE                           */
#define CLI$K_VERB_DELE 15              /* DELETE                           */
#define CLI$K_VERB_DEPO 16              /* DEPOSIT                          */
#define CLI$K_VERB_DIFF 17              /* DIFFERENCE COMMAND               */
#define CLI$K_VERB_DIRE 18              /* DIRECTORY                        */
#define CLI$K_VERB_DISM 19              /* DISMOUNT                         */
#define CLI$K_VERB_EDIT 20              /* EDIT                             */
#define CLI$K_VERB_EOD 21               /* EOD                              */
#define CLI$K_VERB_EXAM 22              /* EXAMINE                          */
#define CLI$K_VERB_EXIT 23              /* EXIT                             */
#define CLI$K_VERB_FORT 24              /* FORTRAN                          */
#define CLI$K_VERB_GOTO 25              /* GOTO                             */
#define CLI$K_VERB_HELP 26              /* HELP                             */
#define CLI$K_VERB_IF 27                /* IF                               */
#define CLI$K_VERB_INIT 28              /* INITIALIZE                       */
#define CLI$K_VERB_INQU 29              /* INQUIRE                          */
#define CLI$K_VERB_LINK 30              /* LINK                             */
#define CLI$K_VERB_LOGO 31              /* LOGOUT                           */
#define CLI$K_VERB_MACR 32              /* MACRO                            */
#define CLI$K_VERB_MCR 33               /* MCR                              */
#define CLI$K_VERB_ON 34                /* ON                               */
#define CLI$K_VERB_PRIN 35              /* PRINT                            */
#define CLI$K_VERB_RUN 36               /* RUN                              */
#define CLI$K_VERB_SET 37               /* SET                              */
#define CLI$K_VERB_SHOW 38              /* SHOW                             */
#define CLI$K_VERB_STAR 39              /* START                            */
#define CLI$K_VERB_STOP 40              /* STOP                             */
#define CLI$K_VERB_SUBM 41              /* SUBMIT                           */
#define CLI$K_VERB_TYPE 42              /* TYPE                             */
#define CLI$K_VERB_MOUN 43              /* MOUNT                            */
#define CLI$K_VERB_PATC 44              /* PATCH                            */
#define CLI$K_VERB_REPL 45              /* REPLAY                           */
#define CLI$K_VERB_UNLO 46              /* UNLOCK                           */
#define CLI$K_VERB_APPE 47              /* APPEND COMMAND                   */
#define CLI$K_VERB_DUMP 48              /* DUMP                             */
#define CLI$K_VERB_PURG 49              /* PURGE                            */
#define CLI$K_VERB_RENA 50              /* RENAME                           */
#define CLI$K_VERB_CANC 51              /* CANCEL                           */
#define CLI$K_VERB_LIBR 52              /* LIBRARY                          */
#define CLI$K_VERB_SORT 53              /* SORT                             */
#define CLI$K_VERB_REQU 54              /* REQUEST                          */
#define CLI$K_VERB_SYNC 55              /* SYNCRONIZE                       */
#define CLI$K_VERB_CORA 56              /* CORAL                            */
#define CLI$K_VERB_PASC 57              /* PASCAL                           */
#define CLI$K_VERB_PLI 58               /* PL/1                             */
#define CLI$K_VERB_MESS 59              /* MESSAGE                          */
/* DEFINE VERB QENERIC CODES                                                */
#define CLI$K_VERB_FORE 255             /* FOREIGN COMMAND                  */
 

#endif					/* __CLIVERBDEF_LOADED */
#ifndef __CLSDEF_LOADED
#define __CLSDEF_LOADED	1

/*** MODULE $clsdef ***/
/*+                                                                         */
/*                                                                          */
/* Security classification mask block. Contains security and integrity      */
/* level and categories for non-discretionary access controls.              */
/*                                                                          */
/*-                                                                         */
struct clsdef {
    unsigned char cls$b_secur_lev;      /* Security level                   */
    unsigned char cls$b_integ_lev;      /* Integrity level                  */
    short int cls$w_fill_1;             /* Reserved                         */
    int cls$q_secur_cat [2];            /* Security category mask           */
    int cls$q_integ_cat [2];            /* Integrity category mask          */
    } ;
#define CLS$_SECSTR 1                   /* Textual secrecy/security string  */
#define CLS$_INTSTR 2                   /* Textual integrity string         */
#define CLS$_CLSBLK 3                   /* Simple classification block      */
#define CLS$_MINCLSBLK 4                /* Minimum classification block     */
#define CLS$_MAXCLSBLK 5                /* Maximum classification block     */
#define CLS$_WIDTH 6                    /* Width of display for $FORMAT_CLASS */
#define CLS$_TRMDSC 7                   /* Line terminator for $FORMAT_CLASS */
#define CLS$_INDENT 8                   /* Line indenting for $FORMAT_CLASS */
#define CLS$_OLDCLSBLK 9                /* Previous classification block    */
#define CLS$_OLDMINCLS 10               /* Previous minimum class block     */
#define CLS$_OLDMAXCLS 11               /* Previous maximum class block     */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
 

#endif					/* __CLSDEF_LOADED */
/*
 *	%W%	(DEC OSF/1)	%G%
 */
/*
 *  Copyright (c) 1989, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	Digital's Proprietary Interface to DECthreads (CMA)
 *
 *  ABSTRACT:
 *
 *	External definitions for CMA services
 *
 *  AUTHORS:
 *
 *	Dave Butenhof
 *
 *  CREATION DATE:
 * 
 *	2 November 1988
 *
 *  MODIFICATION HISTORY:
 * 
 *	001	Robert A. Conti	3 November 1988
 *		Merge comments from Ada version
 *	002	Dave Butenhof	7 November 1988
 *		Clean up code and typedefs
 *	003	Dave Butenhof	9 February 1989
 *		Bring up to latest arch. spec
 *	004	Dave Butenhof	2 March 1989
 *		IN Handles by value, fix routine types
 *	005	Dave Butenhof	20 July 1989
 *		Update to latest APA conventions, CMA style
 *	006	Dave Butenhof	2 August 1989
 *		Add MBZ field to once block for revision control.
 *	007	Dave Butenhof	16 August 1989
 *		More APA changes (argument passing)
 *	008	Dave Butenhof	16 August 1989
 *		Add some constants for boolean and address types
 *	009	Dave Butenhof	25 August 1989
 *		Fix handle (embed array in a structure to make argument
 *		passing more consistent).
 *	010	Dave Butenhof	25 August 1989
 *		Define stack operations (these are all suffixed with _np,
 *		since they're not architecturally defined).
 *	011	Dave Butenhof	30 August 1989
 *		Change cma_c_true to "!cma_c_false" (conform to C convention
 *		more explicitly).
 *	012	Dave Butenhof	31 August 1989
 *		Change back to match architecture: take input handles by
 *		value, not by reference.
 *	013	Dave Butenhof	12 September 1989
 *		Change cma_c_null (for VMS) to be globaldef.
 *	014	Dave Butenhof	14 September 1989
 *		Change "state" field of cma_t_alert_state to be boolean.
 *	015	Dave Butenhof	27 September 1989
 *		Make cma_t_boolean an unsigned int (not a char) to improve
 *		data structure alignment.
 *	016	Hans Oser	03 October 1989
 *		cma_c_null_thread added in cma_t_exit_status for null thread
 *	017	Bob Conti 	05 October 1989
 *	        Add type cma_t_status and provide octal status values
 *              for architecture-defined errors. Add exception for thread exit.
 *	018	Dave Butenhof	12 October 1989
 *		Modify cma_t_once structure to follow internal definition.
 *	020	Dave Butenhof	16 October 1989
 *		cma_dcl_once incorrectly declares a "cma_once_block" instead
 *		of a "cma_t_once_block".
 *	021     Webb Scales     17 October 1989
 *		MIPS/Ultrix integration:  removed argument prototypes from
 *		routine-typedef declarations, and redefined cma_t_address for
 *		MIPS platforms
 *	022	Dave Butenhof	20 October 1989
 *		Change conditional on cma_c_null definition: "globalref" on
 *		vms (not on vaxc) and "extern" otherwise (even on VAX/ULTRIX
 *		vcc).
 *	023	Dave Butenhof	24 October 1989
 *		Make cma_t_date_time fields unsigned to correspond to internal
 *		tick time.
 *	024	Webb Scales	26 October 1989
 *		Add include of types.h for timeb.h
 *	025	Dave Butenhof	27 November 1989
 *		Add cma_allocate_stack_np routine.
 *	026	Dave Butenhof	30 November 1989
 *		Name and argument order changes to track changes made to CMA
 *		interface by POSIX 1003.4 threads working group.
 *	027	Dave Butenhof	5 December 1989
 *		Make some consistency changes to function names.
 *	028	Bob Conti	8 December 1989
 *		Add status codes corresponding to new conditions for
 *		raising CMA exceptions.
 *	029	Dave Butenhof	8 December 1989
 *		Add cma_s_unimp status code.
 *	030	Webb Scales	8 December 1989
 *		MIPS/Ultrix integration:  made "EXCEPTION.match_value" into a
 *		union of "match.addr" and "match.value".
 *	031	Bob Conti	9 December 1989
 *		Added INCLUDE for CMA_EXCEPTIONS and moved the 
 *		typedefs for exceptions into that package. 
 *		Removed definitions for statuses that are never exceptions and
 *		exception cma_e_uninitexc.
 *	032	Bob Conti	10 December 1989
 *		Restored cma_e_uninitexc to this interface.  
 *		(It can't hurt to be here *and* in CMA_EXCEPTION.h)
 *	033	Bob Conti	11 December 1989
 *		Added cma_s_errimprep status code.
 *	034	Bob Conti	11 December 1989
 *		Remove cma_s_errimprep status code.
 *		Add status code cma_s_inialrpro, for attempting to call 
 *		cma_init while an initialization is in progress.
 *	035	Dave Butenhof	23 January 1990
 *		Add support for conditional use of function prototypes.
 *	036	Dave Butenhof	26 January 1990
 *		Use new cma_config.h to define configuration symbols.
 *	037	Dave Butenhof	8 February 1990
 *		Recognize that (for now) cma_debug is a legitimate part of
 *		the CMA reference implementation, and define it in the
 *		interface.
 *	038	Dave Butenhof	15 February 1990
 *		Correct oversight; add priority argument to
 *		cma_thread_set_sched to conform to POSIX pthreads.
 *	039	Dave Butenhof	27 February 1990
 *		Add priority argument to cma_attr_set_sched, since setting
 *		policy and priority separately on an attributes object really
 *		makes no more sense than setting them separately on a running
 *		thread.  Also, "implement" the new symbols for scheduling
 *		policies and priorities.
 *	040	Dave Butenhof	28 February 1990
 *		Ooops--we've got two "cma_c_sched_default" symbols.  Change
 *		the inherit-sched one to "cma_c_sched_use_default".
 *	041	Webb Scales	20 March 1990
 *		Added exceptions to support U*ix signal-to-exception mapping.
 *	042	Webb Scales	16 April 1990
 *		Added notcmastack exception
 *	043	Dave Butenhof	18 April 1990
 *		Remove conditionals around cma_c_null (now extern even on
 *		VAX/VMS).
 *	044	Webb Scales	2 May 1990
 *		Changed the value of cma_c_true to a constant instead of an
 *		expression, to accomodate the old (V1.3) MIPS/Ultrix compiler.
 *	045	Webb Scales	4 June 1990
 *		Added more exceptions.
 *	046	Dave Butenhof	13 June 1990
 *		During initial MIPS ULTRIX migration, prototypes for the
 *		"callback" routines (main thread, destructor, init) were
 *		removed because they wouldn't compile.  They should have been
 *		restored when conditional prototypes were implemented; do so
 *		now.
 *	047	Webb Scales	15 June 1990
 *		Added scheduling policies for "Ada low" and "idle".
 *	048	Dave Butenhof	26 June 1990
 *		Add constants and functions for controlling whether mutex
 *		locks can nest within a thread ("friendly mutexes").
 *	049	Dave Butenhof and Webb Scales	03 August 1990
 *		Add prototype for cma_cond_signal_interrupt.
 *	050	Webb Scales	15 August 1990
 *		Made status code definitions platform-generic.
 *	051	Dave Butenhof	27 August 1990
 *		Change name of Webb's "interrupt level signal" to
 *		cma_cond_signal_int rather than more awkward
 *		cma_cond_signal_interrupt (since he put the shorter form into
 *		the transfer vector, and has used it in cmalib).
 *	052	Dave Butenhof	27 August 1990
 *		Change interfaces to pass handles & structures by reference.
 *	053	Webb Scales	31 August 1990
 *		Added severity argument to CMA_STATUS macro
 *	054	Paul Curtin	17 September 1990
 *		Added errno function
 *	055	Webb Scales	17 September 1990
 *		Added errno macro that sets up wrapper function.
 *	056	Bob Conti	1 October 1990
 *		Delete cma_c_null_thread from exit_status
 *	057	Dave Butenhof	9 October 1990
 *		Add argument to cma_t_init_routine and cma_once prototypes,
 *		to accomodate enhancement to one-time initialization.
 *	058	Dave Butenhof	9 October 1990
 *		Use new _CMA_IMPORT_ config symbol for the exception and
 *		cma_c_null definitions.
 *	059	Dave Butenhof	11 October 1990
 *		Move errno stuff to it's own file, cma_errno.h.
 *	060	Webb Scales	15 October 1990
 *		Removed "idle" scheduling policy.
 *	061	Dave Butenhof	27 December 1990
 *		Rearrange and rename some exceptions.
 *	062	Dave Butenhof & Webb Scales	21 January 1991
 *		Figure out new exception prefixes (change low-level
 *		exceptions to "exc" prefix).
 *	063	Paul Curtin	31 January 1991
 *		Added user header files; conditionally removed
 *		on defining _CMA_NOWRAPPERS_  (for CMA build, ...)
 *	064	Dave Butenhof	7 February 1991
 *		New alert control scoping primitives.
 *	065	Dave Butenhof	12 February 1991
 *		Change "friendly" mutex to "recursive"
 *	066	Dave Butenhof	14 February 1991
 *		Integrate Aron Insinga's changes to improve compatibility
 *		with non-default C/C++ compilers.
 *	067	Webb Scales	19 February 1991
 *		Added symbol which users can test to see if the threading
 *		package is us (especially important for the pthreads interface)
 *	068	Dave Butenhof	18 March 1991
 *		Add an external variable cma_g_debug which points to the
 *		debugger code, so that users can always call through it (this
 *		is mostly necessary under the VAX/VMS Debugger, which refuses
 *		to look at function names from a shareable image).
 *	069	Dave Butenhof	25 March 1991
 *		Include exc_handling.h rather than cma_exception.h, and move
 *		all the exception definitions into exc_handling.h.
 *	070	Dave Butenhof	05 April 1991
 *		CFRONT fix from Aron Insinga.
 *	071	Dave Butenhof	12 April 1991
 *		Don't include the DECthreads "hack" support for
 *		thread-synchronous I/O and per-thread errno if this is an
 *		OSF/1 based system, since the standard system versions
 *		provide the necessary support.
 *	072	Dave Butenhof	23 May 1991
 *		Include cma_ux.h and cma_px.h headers on MP system, so we get
 *		a few of the wrappers.
 *	073	Dave Butenhof	05 June 1991
 *		On non-VMS DCE platforms, public header files (except
 *		pthread.h and pthread_exc.h) are in /usr/include/dce.
 *	074	Dave Butenhof	10 June 1991
 *		Create cma_thread_get_unique
 *	075	Dave Butenhof	18 September 1991
 *		Integrate HP CMA5 reverse drop.
 *	076	Dave Butenhof	04 October 1991
 *		Move a few files into "dce/" for non-VMS. Also fix
 *		uniprocessor conditionals.
 *	077	Dave Butenhof	29 October 1991
 *		Make the cxxl_unused_handle variable static (this is a hack
 *		for the "cfront" C++ preprocessor, to ensure that handle
 *		typedefs are written to the C intermediate file).
 *	078	Dave Butenhof	19 November 1991
 *		Remove use of _POSIX_REENTRANT_FUNCTIONS, since it breaks the
 *		capability to build without libc_r.a on OSF/1 for code that
 *		also includes unistd.h.
 *	079	Dave Butenhof	03 December 1991
 *		Fix test for cma_config.h to check for __vms as well as vms
 *		(to work with DEC C /standard=ansi).
 */

#ifndef CMA_INCLUDE
#define CMA_INCLUDE

/*
 * Define a symbol which client code can test to determine whether the 
 * underlying threads package is DECthreads or not.  This is especially
 * important to clients of the Pthreads interface who may want to use
 * certain DECthreads extensions, such as the global lock and non-real-time
 * scheduling policies, on the DECthreads platform while maintaining 
 * portability to a "vanilla" pthreads implementation.
 */
#define _DECTHREADS_	1

/*
 * The implementation makes these basic decisions
 */

#if defined(vms) || defined(__vms)
# include <cma_config.h>		/* configuration symbols */
#else
# include <dce/cma_config.h>		/* configuration symbols */
#endif

#if _CMA_OS_ != _CMA__VMS
# include <sys/types.h>
# include <sys/timeb.h>
#endif

#if _CMA_OS_ == _CMA__VMS
# include <exc_handling.h>		/* Bring in exception services */
#else
# include <dce/exc_handling.h>		/* Bring in exception services */
#endif

#if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
# define _REENTRANT	1		/* Enable reentrant errno.h */
#endif

#ifdef _CMA_PROTO_
# define _CMA_PROTOTYPE_(arg)	arg
#else
# define _CMA_PROTOTYPE_(arg)	()
#endif

/*
 * Sample decisions for the environment types
 */


typedef int			cma_t_integer;

typedef unsigned int		cma_t_boolean;

typedef unsigned int		cma_t_natural;

typedef float			cma_t_interval;

typedef	int			cma_t_key;

typedef int			cma_t_status;

typedef	int			cma_t_priority;

#if _CMA_VOID_
typedef void			*cma_t_address;
#else
typedef char			*cma_t_address;
#endif

#define cma_c_false	(cma_t_boolean)0
#define cma_c_true	(cma_t_boolean)1
#define cma_c_null_ptr	(cma_t_address)0

#define cma_c_prio_fifo_min	16
#define cma_c_prio_fifo_mid	24
#define cma_c_prio_fifo_max	31
#define cma_c_prio_rr_min	16
#define cma_c_prio_rr_mid	24
#define cma_c_prio_rr_max	31
#define cma_c_prio_through_min	8
#define cma_c_prio_through_mid	12
#define cma_c_prio_through_max	15
#define cma_c_prio_back_min	1
#define cma_c_prio_back_mid	4
#define cma_c_prio_back_max	7
#define cma_c_prio_ada_low_min	0
#define cma_c_prio_ada_low_mid	4
#define cma_c_prio_ada_low_max	7

/*
 * The implementation of the cma_t_date_time type should match the "native
 * time" of the platform: that allows clients to use the full set of platform
 * time operations, rather than just "cma_get_expiration", to compute and
 * test timed waits.
 *
 * This section assumes the platform is either "VMS" or "UNIX-ish".  Others
 * will require changes.
 */
#if _CMA_OS_ == _CMA__VMS
typedef struct CMA_T_DATE_TIME {
    unsigned long int	low;
    unsigned long int	high;
    }				cma_t_date_time;
#else
typedef struct timeb		cma_t_date_time;
#endif

/* 
 * Sample decisions for what handles shall be 
 */

typedef struct CMA_T_HANDLE {
    cma_t_address	field1;
    cma_t_address	field2;
    } cma_t_handle;

#define cma_thread_get_unique(handle) \
    (((unsigned int)((cma_t_thread *)handle)->field2) & 0xffff)

#if (_CMA_COMPILER_ == _CMA__CFRONT) && (_CMA_OS_ == _CMA__VMS)
/*
 * The following declaration is a hack to support CFRONT (C++ preprocessor);
 * without an actual instance, the struct definition isn't written out.
 * Creates problems for VAX C when it compiles CFRONT output.
 */
static struct CMA_T_HANDLE	cxxl_unused_handle;
#endif

#define cma_c_handle_size sizeof(cma_t_handle)

typedef	cma_t_handle	cma_t_mutex;	/* Needed for CMA_ONCE_BLOCK */

/*
 * Predefined null handle
 */

_CMA_IMPORT_ cma_t_handle	cma_c_null;

/*
 * Sample decision for a one-time initialization control block and its
 * initialization macro.
 *
 * Declare a one time initialization control block as:
 *
 *	static cma_t_once	block = cma_once_init;
 */
typedef struct CMA_T_ONCE {
    cma_t_integer	field1;
    cma_t_integer	field2;
    cma_t_integer	field3;
    }				cma_t_once;

#define cma_once_init	{0, 0, 0}

/* 
 * Sample decision for a variable to save the current alert state.
 */
typedef struct CMA_T_ALERT_STATE {
    cma_t_integer	state1;
    cma_t_integer	state2;
    }				cma_t_alert_state;

/*
 * The following are the portable CMA definitions
 */

/*
 * Operations on Handles
 */

/*
 * The value of a handle can be assigned the value of another handle.	
 */

extern void
cma_handle_assign _CMA_PROTOTYPE_ ((
	cma_t_handle	*handle1,	/* Input handle */
	cma_t_handle	*handle2));	/* Output handle */

/*
 * The value of a handle can be compared to the value of another handle.
 */

extern cma_t_boolean
cma_handle_equal _CMA_PROTOTYPE_ ((
	cma_t_handle	*handle1,
	cma_t_handle	*handle2));

/*
 * Operations on attributes objects
 */

typedef cma_t_handle	cma_t_attr;

/*
 * An attributes object is created to specify the attributes of other CMA
 * objects that will be created.
 */

extern void
cma_attr_create _CMA_PROTOTYPE_ ((
	cma_t_attr	*new_attr,
	cma_t_attr	*attr));

/*
 * An attributes object can be deleted when it is no longer needed.
 */

extern void
cma_attr_delete _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr));

/*
 * Operations on threads
 */

typedef cma_t_handle	cma_t_thread;
typedef cma_t_address	(*cma_t_start_routine) _CMA_PROTOTYPE_ ((
	cma_t_address	arg));

typedef enum CMA_T_EXIT_STATUS {
    cma_c_term_error		= 0,
    cma_c_term_normal		= 1,
    cma_c_term_alert		= 2
    }				cma_t_exit_status;

typedef enum CMA_T_SCHED_INHERIT {
    cma_c_sched_inherit = 0,
    cma_c_sched_use_default = 1
    }				cma_t_sched_inherit;

typedef enum CMA_T_SCHED_POLICY {
    cma_c_sched_fifo = 0,
    cma_c_sched_rr = 1,
    cma_c_sched_throughput = 2,
    cma_c_sched_background = 3,
    cma_c_sched_ada_low = 4
    }				cma_t_sched_policy;

#define cma_c_sched_default	cma_c_sched_throughput
#define cma_c_sched_other	cma_c_sched_default

/*
 * The following procedures can be used to control thread creation,
 * termination and deletion.
 */

/*
 * To create a thread object and runnable thread, a routine must be specified
 * as the new thread's start routine.  An argument may be passed to this
 * routine, as an untyped address; an untyped address may also be returned as
 * the routine's value.  An attributes object may be used to specify details
 * about the kind of thread being created.
 */
extern void
cma_thread_create _CMA_PROTOTYPE_ ((
	cma_t_thread		*new_thread,
	cma_t_attr		*attr,
	cma_t_start_routine	start_routine,
	cma_t_address		arg));

/*
 * A thread object may be "detached" to specify that the return value and
 * completion status will not be requested.
 */
extern void
cma_thread_detach _CMA_PROTOTYPE_ ((
	cma_t_thread	*thread));

/* 
 * A thread may terminate it's own execution.
 */
extern void
cma_thread_exit_error _CMA_PROTOTYPE_ ((void));

extern void
cma_thread_exit_normal _CMA_PROTOTYPE_ ((
	cma_t_address	result));

/* 
 * A thread can await termination of another thread and retrieve the return
 * value and completion status of the thread.
 */
extern void
cma_thread_join _CMA_PROTOTYPE_ ((
	cma_t_thread		*thread,
	cma_t_exit_status	*exit_status,
	cma_t_address		*result));

/*
 * Operations to define thread creation attributes
 */

/*
 * Set or obtain the default thread priority.
 */
extern void
cma_attr_set_priority _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr,
	cma_t_priority	pri));

extern void
cma_attr_get_priority _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr,
	cma_t_priority	*pri));

/*
 * Set or obtain the default scheduling algorithm
 */
extern void
cma_attr_set_sched _CMA_PROTOTYPE_ ((
	cma_t_attr		*attr,
	cma_t_sched_policy	policy,
	cma_t_priority		priority));

extern void
cma_attr_get_sched _CMA_PROTOTYPE_ ((
	cma_t_attr		*attr,
	cma_t_sched_policy	*policy));

/*
 * Set or obtain whether a thread will use the default scheduling attributes,
 * or inherit them from the creating thread.
 */
extern void
cma_attr_set_inherit_sched _CMA_PROTOTYPE_ ((
	cma_t_attr		*attr,
	cma_t_sched_inherit	setting));

extern void
cma_attr_get_inherit_sched _CMA_PROTOTYPE_ ((
	cma_t_attr		*attr,
	cma_t_sched_inherit	*setting));

/*
 * Set or obtain the default stack size
 */
extern void
cma_attr_set_stacksize _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr,
	cma_t_natural	stacksize));

extern void
cma_attr_get_stacksize _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr,
	cma_t_natural	*stacksize));

/*
 * Set or obtain the default guard size
 */
extern void
cma_attr_set_guardsize _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr,
	cma_t_natural	guardsize));

extern void
cma_attr_get_guardsize _CMA_PROTOTYPE_ ((
	cma_t_attr	*attr,
	cma_t_natural	*guardsize));

/*
 * Thread Scheduling Operations
 */

/*
 * The current user_assigned priority of a thread can be changed.
 */
extern void
cma_thread_set_priority _CMA_PROTOTYPE_ ((
	cma_t_thread	*thread,
	cma_t_priority	priority));

/*
 * The current user_assigned scheduler algorithm of a thread can be changed.
 */
extern void
cma_thread_set_sched _CMA_PROTOTYPE_ ((
	cma_t_thread		*thread,
	cma_t_sched_policy	policy,
	cma_t_priority		priority));

/*
 * A thread may tell the scheduler that its processor can be made available.
 */
extern void
cma_yield _CMA_PROTOTYPE_ ((void));

/*
 * A thread may enter a wait state for a speciifed period of time.
 */
extern void
cma_delay _CMA_PROTOTYPE_ ((
	cma_t_interval	interval));

/*
 * Thread Information Operations
 */

/*
 * A thread may obtain a copy of its own thread handle.
 */
extern void
cma_thread_get_self _CMA_PROTOTYPE_ ((
	cma_t_thread	*thread));

/*
 * The current user_assigned priority of a thread can be read.
 */
extern void
cma_thread_get_priority _CMA_PROTOTYPE_ ((
	cma_t_thread	*thread,
	cma_t_priority	*priority));

/*
 * The current user_assigned scheduler algorithm of a thread can be read.
 */
extern void
cma_thread_get_sched _CMA_PROTOTYPE_ ((
	cma_t_thread		*thread,
	cma_t_sched_policy	*policy));

/*
 * Operations on Mutexes
 */

typedef enum CMA_T_MUTEX_KIND {
    cma_c_mutex_fast = 0,
    cma_c_mutex_recursive = 1,
    cma_c_mutex_nonrecursive = 2
    }				cma_t_mutex_kind;

/*
 * Operations to define mutex creation attributes
 */

/*
 * Set or obtain whether mutex locks can nest.
 */
extern void
cma_attr_set_mutex_kind _CMA_PROTOTYPE_ ((
	cma_t_attr		*attr,
	cma_t_mutex_kind	nest));

extern void
cma_attr_get_mutex_kind _CMA_PROTOTYPE_ ((
	cma_t_attr		*attr,
	cma_t_mutex_kind	*nest));

/* 
 * The following routines create, delete, lock and unlock mutexes.
 */
extern void
cma_mutex_create _CMA_PROTOTYPE_ ((
	cma_t_mutex	*new_mutex,
	cma_t_attr	*attr));

extern void
cma_mutex_delete _CMA_PROTOTYPE_ ((
	cma_t_mutex	*mutex));

extern void
cma_mutex_lock _CMA_PROTOTYPE_ ((
	cma_t_mutex	*mutex));

extern cma_t_boolean
cma_mutex_try_lock _CMA_PROTOTYPE_ ((
	cma_t_mutex	*mutex));

extern void
cma_mutex_unlock _CMA_PROTOTYPE_ ((
	cma_t_mutex	*mutex));

extern void
cma_lock_global _CMA_PROTOTYPE_ ((void));

extern void
cma_unlock_global _CMA_PROTOTYPE_ ((void));

/*
 * Operations on condition variables
 */

typedef cma_t_handle	cma_t_cond;

/*
 * A thread can create and delete condition variables.
 */
extern void
cma_cond_create _CMA_PROTOTYPE_ ((
	cma_t_cond	*new_condition,
	cma_t_attr	*attr));

extern void
cma_cond_delete _CMA_PROTOTYPE_ ((
	cma_t_cond	*condition));

/*
 * A thread can signal to and broadcast on a condition variable.
 */
extern void
cma_cond_broadcast _CMA_PROTOTYPE_ ((
	cma_t_cond	*condition));

extern void
cma_cond_signal _CMA_PROTOTYPE_ ((
	cma_t_cond	*condition));

extern void
cma_cond_signal_int _CMA_PROTOTYPE_ ((
	cma_t_cond	*condition));

/*
 * A thread can wait for a condition variable to be signalled or broadcast.
 */
extern void
cma_cond_wait _CMA_PROTOTYPE_ ((
	cma_t_cond	*condition,
	cma_t_mutex	*mutex));

/*
 * Operations for timed waiting
 */

/*
 * A thread can perform a timed wait on a condition variable.
 */
extern cma_t_status
cma_cond_timed_wait _CMA_PROTOTYPE_ ((
	cma_t_cond	*condition,
	cma_t_mutex	*mutex,
	cma_t_date_time	*expiration));

/*
 * A thread may perform some operations on absolute date-time and intervals.
 */

extern void
cma_time_get_expiration _CMA_PROTOTYPE_ ((
	cma_t_date_time	*expiration,
	cma_t_interval	interval));

/*
 * Operations for CMA and client initialization.
 */

/*
 * Initialize the CMA facility.
 */
extern void
cma_init _CMA_PROTOTYPE_ ((void));

/*
 * A thread can declare a one-time initialization routine.  The address of
 * the init block and routine are passed as parameters.
 */

typedef void		(*cma_t_init_routine) _CMA_PROTOTYPE_ ((
	cma_t_address	arg));

extern void
cma_once _CMA_PROTOTYPE_ ((
	cma_t_once		*init_block,
	cma_t_init_routine	init_routine,
	cma_t_address		arg));

/*
 * Operations for per-thread context
 */

typedef void		(*cma_t_destructor) _CMA_PROTOTYPE_ ((
	cma_t_address	ctx_value));

/*
 * A unique per-thread context key can be obtained for the process
 */
extern void
cma_key_create _CMA_PROTOTYPE_ ((
	cma_t_key		*key,
	cma_t_attr		*attr,
	cma_t_destructor	destructor));

/*
 * A thread can set a per-thread context value identified by a key.
 */
extern void
cma_key_set_context _CMA_PROTOTYPE_ ((
	cma_t_key	key,
	cma_t_address	context_value));

/*
 * A thread can retrieve a per-thread context value identified by a key.
 */
extern void
cma_key_get_context _CMA_PROTOTYPE_ ((
	cma_t_key	key,
	cma_t_address	*context_value));

/*
 * Operations for alerts.
 */

/*
 * The current thread can request that a thread terminate it's execution.
 */

extern void
cma_thread_alert _CMA_PROTOTYPE_ ((
	cma_t_thread	*thread));

/*
 * The current thread can poll for alert delivery.
 */
extern void
cma_alert_test _CMA_PROTOTYPE_ ((void));

/*
 * The current thread can disable asynchronous alert delivery, restore the
 * previous state of asynchronous alert delivery, or enable asynchronous
 * alert delivery.
 */
extern void
cma_alert_disable_asynch _CMA_PROTOTYPE_ ((
	cma_t_alert_state	*prior));

extern void
cma_alert_disable_general _CMA_PROTOTYPE_ ((
	cma_t_alert_state	*prior));

extern void
cma_alert_enable_asynch _CMA_PROTOTYPE_ ((void));

extern void
cma_alert_enable_general _CMA_PROTOTYPE_ ((
	cma_t_alert_state	*prior));

extern void
cma_alert_restore _CMA_PROTOTYPE_ ((
	cma_t_alert_state	*prior));

/*
 * Operations on stacks
 */

typedef	cma_t_handle	cma_t_stack_np;
typedef void		(*cma_t_call_routine) ();

/*
 * Allocate stack space
 */
extern void
cma_stack_allocate_np _CMA_PROTOTYPE_ ((
	cma_t_integer	size,
	cma_t_address	*new_size));

/*
 * Assign a stack to a thread
 */
extern void
cma_stack_assign_np _CMA_PROTOTYPE_ ((
	cma_t_stack_np	*stack,
	cma_t_thread	*thread));

/*
 * Call a routine on a new stack
 */
extern void
cma_stack_call_routine_np _CMA_PROTOTYPE_ ((
	cma_t_stack_np		*stack,
	cma_t_call_routine	routine,
	cma_t_address		arg,
	cma_t_address		*result));

/*
 * Check stack limit
 */
extern cma_t_boolean
cma_stack_check_limit_np _CMA_PROTOTYPE_ ((
	cma_t_integer	size));

/*
 * Create a new stack
 */
extern void
cma_stack_create_np _CMA_PROTOTYPE_ ((
	cma_t_stack_np	*stack,
	cma_t_attr	*attr));

/*
 * Delete a stack
 */
extern void
cma_stack_delete_np _CMA_PROTOTYPE_ ((
	cma_t_stack_np	*stack));

/*
 * Debug threads
 */
extern void
cma_debug _CMA_PROTOTYPE_ ((void));

extern void
cma_debug_cmd _CMA_PROTOTYPE_ ((char *cmd, ...));

_CMA_IMPORT_ void (*cma_g_debug) _CMA_PROTOTYPE_ ((void));

# if _CMA_OS_ == _CMA__VMS
#  include <cma_px.h>
# else
#  include <dce/cma_px.h>
# endif

# ifndef _CMA_NOWRAPPERS_
#  if !_CMA_REENTRANT_CLIB_
#   if _CMA_OS_ == _CMA__VMS
#    include <cma_errno.h>
#    include <cmalib_crtlx.h>
#   else
#    include <dce/cma_errno.h>
#    include <dce/cmalib_crtlx.h>
#    include <dce/cma_stdio.h>
#   endif
#  endif
#  if _CMA_OS_ == _CMA__UNIX
#   include <dce/cma_ux.h>
#  endif
#  if _CMA_OS_ == _CMA__VMS
#   include <cma_sigwait.h>
#  else
#   include <dce/cma_sigwait.h>
#  endif
# endif

# ifdef _HP_LIBC_R
#  include <cma_libc_calls.h>
# endif

#endif
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA.H */
/*  *24    3-DEC-1991 11:58:45 BUTENHOF "Fix test for cma_config.h include" */
/*  *23   19-NOV-1991 12:17:35 BUTENHOF "Remove tests for _POSIX_REENTRANT_FUNCTIONS" */
/*  *22   31-OCT-1991 12:38:56 BUTENHOF "cfront fix: make cxxl_unused_handle static" */
/*  *21   16-OCT-1991 10:11:19 BUTENHOF "Remove cma_stdio.h on VMS" */
/*  *20   14-OCT-1991 13:37:10 BUTENHOF "Refine/fix use of config symbols" */
/*  *19   24-SEP-1991 16:25:56 BUTENHOF "Merge CMA5 reverse IBM/HP/Apollo drops" */
/*  *18   10-JUN-1991 19:49:57 SCALES "Convert to stream format for ULTRIX build" */
/*  *17   10-JUN-1991 19:19:45 BUTENHOF "Fix the sccs headers" */
/*  *16   10-JUN-1991 18:16:04 SCALES "Add sccs headers for Ultrix" */
/*  *15   10-JUN-1991 14:12:55 BUTENHOF "Add macro to extract thread sequence #" */
/*  *14    5-JUN-1991 17:30:55 BUTENHOF "On UNIX platforms, most headers are in dce/" */
/*  *13   29-MAY-1991 16:58:42 BUTENHOF "Change cma_debug() prototype" */
/*  *12   12-APR-1991 23:34:36 BUTENHOF "CFRONT fix" */
/*  *11    1-APR-1991 18:08:05 BUTENHOF "QAR 93, exception text" */
/*  *10   21-MAR-1991 09:25:48 BUTENHOF "Make sure that cma_debug is in link" */
/*  *9    19-FEB-1991 22:21:10 SCALES "::" */
/*  *8    14-FEB-1991 23:50:54 BUTENHOF "Improve multiple c-compiler support" */
/*  *7    13-FEB-1991 17:54:13 BUTENHOF "Change mutex attribute name symbols" */
/*  *6    12-FEB-1991 23:09:22 BUTENHOF "Recursive/nonrecursive mutexes" */
/*  *5    12-FEB-1991 01:28:12 BUTENHOF "New alert control primitives" */
/*  *4    31-JAN-1991 16:32:34 CURTIN "added user header files" */
/*  *3    24-JAN-1991 00:34:20 BUTENHOF "Modify exception names again" */
/*  *2    28-DEC-1990 00:04:18 BUTENHOF "Change exception names" */
/*  *1    12-DEC-1990 21:39:46 BUTENHOF "CMA header" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA.H */
/*
 *  Copyright (c) 1990, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMALIB services
 *
 *  ABSTRACT:
 *
 *	Header file for C run-time library wrapper routines
 *
 *  AUTHORS:
 *
 *	Webb Scales
 *
 *  CREATION DATE:
 *
 *	29 March 1990
 *
 *  MODIFICATION HISTORY:
 *
 *	001	Dave Butenhof	30 March 1990
 *		Use "int" instead of "sigset_t" type.
 *	002	Webb Scales	12 April 1990
 *		Return to sigset_t, and supply a typedef for it on VMS.
 *	003	Webb Scales	27 April 1990
 *		And correct the routine prototype for sigwait to use sigset_t.
 *	004	Dave Butenhof	18 May 1990
 *		move sigwait to new cma_px.h (POSIX emulation).
 *	005	Dave Butenhof	29 June 1990
 *		Add typecasts to the VM macros to correct for not having
 *		mutable types ("void *").
 *	006	Paul Curtin	17 September 1990
 *		Added module to CMALIB, from CMA.
 *	007	Webb Scales	17 September 1990
 *		Corrected macro values, moved errno macro to CMA.H
 *	008	Dave Butenhof	11 October 1990
 *		Remove redundant cma_errno prototype.
 *	009	Paul Curtin	24 January 1991
 *		Removed arguments from wrapper macros, changed the
 *		return values on protos, and removed arguments from protos.
 *		Return values now match `man' pages.
 *	010	Paul Curtin	28 January 1991
 *		Conditionalized wrapper macros on _CMA_NOWRAPPERS_
 *	011	Paul Curtin	06 February 1991
 *		More reworking of return types.
 *	012	Dave Butenhof	19 February 1991
 *		Fix prototypes to work with C++ (hopefully without breaking
 *		anyone else).
 */


#ifndef CMA_CRTLX
#define CMA_CRTLX

/*
 *  INCLUDE FILES
 */
#include <stddef.h>

/*
 * CONSTANTS AND MACROS
 */

/*
 * Memory Allocation Routine Wrappers
 */

#ifndef _CMA_NOWRAPPERS_
# define calloc		cma_lib_calloc
# define cfree		cma_lib_cfree
# define free		cma_lib_free
# define malloc		cma_lib_malloc
# define realloc	cma_lib_realloc
#endif

/*
 * TYPEDEFS
 */

/*
 *  GLOBAL DATA
 */

/*
 * INTERFACES
 */

extern cma_t_address
cma_lib_calloc _CMA_PROTOTYPE_ ((size_t nmemb, size_t size));

extern void
cma_lib_cfree _CMA_PROTOTYPE_ ((void *ptr));

extern void
cma_lib_free _CMA_PROTOTYPE_ ((void *ptr));

extern cma_t_address
cma_lib_malloc _CMA_PROTOTYPE_ ((size_t size));

extern cma_t_address
cma_lib_realloc _CMA_PROTOTYPE_ ((void *ptr, size_t size));

#endif  /* CMA_CRTLX */
/*
 *	%W%	(DEC OSF/1)	%G%
 */
/*
 *  Copyright (c) 1990, 1992 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMA services
 *
 *  ABSTRACT:
 *
 *	Configuration header file to set up control symbols.
 *
 *  AUTHORS:
 *
 *	Dave Butenhof
 *
 *  CREATION DATE:
 *
 *	26 January 1990
 *
 *  MODIFIED BY:
 *
 *	Dave Butenhof
 *	Bob Conti
 *	Paul Curtin
 *	Webb Scales
 */

#ifndef CMA_CONFIG
#define CMA_CONFIG

/*
 *  INCLUDE FILES
 */

/*
 * CONSTANTS AND MACROS
 */

/*
 * Quick reference guide to DECthreads configuration symbols:
 *
 *	_USER_THREADS_
 *			If this has been defined, then cma_config.h will
 *			override the default calculation of the
 *			_CMA_UNIPROCESSOR_ config. symbol, forcing use of
 *			user threads even if the system supports kernel
 *			threads.
 *	_CMA_COMPILER_		(CC, VAXC, DECC, CFRONT, GCC,
 *				DECCPLUS, GCPLUS)
 *			Each compiler has its own quirks, and DECthreads
 *			tries to do as much with each as possible. For
 *			example, it instantiates function prototypes where
 *			possible, even if the compiler is not fully ANSI C
 *			compliant.
 *	_CMA_HARDWARE_		(MIPS, VAX, M68K, HPPA, IBMR2, ALPHA)
 *			The computer on which DECthreads will run.
 *	_CMA_OS_		(UNIX, VMS)
 *			The operating system on which DECthreads will run;
 *			generally, all UNIX-descended systems have certain
 *			similarities which need to be considered as a group.
 *	_CMA_VENDOR_		(APOLLO, DIGITAL, HP, IBM, OSF, SUN)
 *			The company supplying the O/S, since each have
 *			slightly different behavior and requirements.
 *	_CMA_PLATFORM_		(MIPS/UNIX, VAX/VMS, VAX/UNIX, M68K/UNIX,
 *				HPPA/UNIX, RS6000/UNIX, ALPHA/UNIX ALPHA/VMS)
 *			This is a convenience to test both hardware and O/S
 *			variants together.
 *	_CMA_PROTECT_MEMORY_	(0, 1)
 *			This is TRUE (1) if the environment supports
 *			protecting memory pages (DECthreads will set stack
 *			guard pages to no access to trap stack overflows).
 *	_CMA_PROTO_	(1 or undefined)
 *			This is set if the compiler supports function
 *			prototypes (if __STDC__ is true, or if any of a
 *			number of specific compilers is being used). Note:
 *			this must be tested by an #ifdef.
 *	_CMA_OSIMPL_		(AIX, OSF, BSD, SYSV)
 *			The closest ancestor of the operating system, since
 *			each family inherits common characteristics
 *			(particularly in signal behaviors).
 *	_CMA_STACK_TRACE_	(0, 1)
 *			This can be set to cause DECthreads to generate trace
 *			messages when stack management operations are called.
 *			It triggers conditional compilation in cma_stack.c.
 *	_CMA_VOID_		(0, 1)
 *			This is TRUE (1) if the compiler supports the use of
 *			"void *" types. Most __STDC__ compilers do (except
 *			that a version of MIPS C had a bug that prevented its
 *			use). If _CMA_VOID_ is FALSE (0), DECthreads will use
 *			"char *" instead.
 *	_CMA_VOLATILE_		("volatile" or null)
 *			DECthreads requires "volatile" storage class in
 *			several places, including exception handling. Since
 *			some compilers do not support "volatile", DECthreads
 *			uses this symbol in place of the "volatile" keyword.
 *			Note that DECthreads runtimes built with compilers
 *			that do not support volatile may show incorrect
 *			behavior under certain circumstances (particularly
 *			during delivery of exceptions). Because these
 *			situations tend to occur only when errors have
 *			already occurred, it is hoped that the absence of
 *			volatile will not prevent normal DECthreads
 *			operation.
 *	_CMA_UPSTACK_		(0, 1)
 *			This specifies the direction of stack growth on the
 *			target platform. If TRUE (1), then a stack "push"
 *			(e.g., for a function call) causes the stack pointer
 *			value to INCREASE. If FALSE (0), a stack "push"
 *			causes the stack pointer value to DECREASE.
 *	_CMA_KTHREADS_		(NONE, MACH)
 *			This specifies the type of kernel threads (if any)
 *			supported by the target. In general, DECthreads will
 *			map user threads onto kernel threads if they are
 *			available.
 *	_CMA_UNIPROCESSOR_	(0, 1)
 *			A value of TRUE (1) means that kernel threads are not
 *			supported and threads are a purely user-mode
 *			abstraction. This allows certain optimizations (for
 *			example, "current thread" can be implemented as a
 *			fetch from a global variable rather than a search for
 *			the stack pointer).
 *	_CMA_MULTIPLEX_		(0, 1)
 *			If TRUE (1) then kernel threads are supported, and
 *			DECthreads additionally will multiplex multiple user
 *			threads on each kernel thread. This balances some of
 *			the advantages and disadvantages of each (user mode
 *			context switching is faster, but use of kernel
 *			threads is more robust since kernel functions
 *			generally block only the calling kernel thread).
 *	_CMA_THREAD_IS_VP_	(0, 1)
 *			A convenience, meaning that kernel threads are being
 *			used, and no multiplexing is being done. It is
 *			computed from _CMA_MULTIPLEX_ and _CMA_KTHREADS_.
 *	_CMA_THREAD_SYNC_IO_	(0, 1)
 *			If TRUE (1) then the system supports "thread
 *			synchronous I/O", and DECthreads does not have to
 *			emulate it. This is automatically set when DECthreads
 *			is not configured for a uniprocessor OR for
 *			multiplexing on kernel threads, but can be overridden
 *			if the O/S supports thread sync. I/O on user-mode
 *			threads.
 *	_CMA_PER_THD_SYNC_SIGS_	(0, 1)
 *			If TRUE (1) then the system supports per-thread
 *			synchronous signals.  Currently, this is set only for
 *			one-to-one thread mapping on OSF/1 based systems.
 *	_CMA_REENTRANT_CLIB_	(0, 1)
 *			If TRUE (1) then the C library functions are thread
 *			reentrant. Currently, this is assumed only if
 *			_CMA_THREAD_IS_VP_ or the O/S is descended from OSF/1
 *			(which provides a libc_r library that allows
 *			DECthreads to make the C functions reentrant even
 *			when it is context switching in user mode).
 *	_CMA_MP_HARDWARE_	(0, 1)
 *			Generally, this is the same as "_CMA_KTHREADS_ !=
 *			_CMA__NONE" (kernel threads are assumed to run on
 *			multiprocessor hardware), but should be overridden if
 *			kernel threads are being used and it isn't desirable
 *			to assume MP hardware (setting this for non-MP
 *			hardware may degrade performance).
 *	_CMA_SPINLOOP_		(0, n)
 *			For MP hardware, DECthreads can be configured to
 *			"spin" on a mutex lock for some time before giving up
 *			and blocking the thread. If set to 0, DECthreads will
 *			not spin. Otherwise, _CMA_SPINLOOP_ determines the
 *			number of times DECthreads will try to acquire the
 *			lock before blocking.
 *	_CMA_NO_POSIX_SIGNAL_	(1 or undefined)
 *			If defined, the target platform doesn't support a
 *			POSIX-compatible sigaction() function; DECthreads
 *			will use sigvec() instead. NOTE: must be tested with
 *			#ifdef.
 *	_CMA_VARARGS_		(1 or undefined)
 *			(Not currently used; probably obsolete)
 *	_CMA_IMPORT_, _CMA_EXPORT_, _CMA_EXPORT_FLAG_
 *			Specifies the keywords used for EXPORTing variables
 *			from DECthreads, or IMPORTing those variables to
 *			client code. For normal UNIX systems, IMPORT is
 *			usually "extern" and EXPORT is usually null. Because
 *			of oddities in the VAX C implementation of extern,
 *			DECthreads uses "globaldef" for EXPORT and
 *			"globalref" for IMPORT. _CMA_EXPORT_FLAG_ is 1 (TRUE)
 *			if _CMA_EXPORT_ has a non-null value, and 0 (FALSE)
 *			otherwise.
 *	_CMA_TRACE_KERNEL_	(n or undefined)
 *			If defined, DECthreads will allocate an array of "n"
 *			elements and trace information relating to the use of
 *			the "kernel critical" lock (the user mode scheduling
 *			lock). This can be examined from the debugger, or
 *			printed by cma__format_karray(). It shows the module,
 *			line number, and thread ID of the last n kernel
 *			lock/unlock operations.
 *	_CMA_TRACE_SEM_		(n or undefined)
 *			If defined, DECthreads will allocate an array of "n"
 *			elements and trace information relating to the use of
 *			internal semaphores (the basic blocking mechanism
 *			used for mutexes and condition variables). This can
 *			be examined from the debugger, or printed by
 *			cma__sem_format_array(). It shows the module, line
 *			number, thread ID, and semaphore opcode of the
 *			last n semaphore operations.
 *	_CMA_NOWRAPPERS_	(1 or undefined)
 *			If defined, DECthreads will not use its I/O and C
 *			library wrapper functions. Generally, this is set to
 *		    	1 for building DECthreads, and undefined for building
 *			client code.
 *	_CMA_VSSCANF_		(0, 1)
 *			If set to 1, the DECthreads stdio wrappers will
 *			include the scanf family. The wrappers cannot be
 *			built without the real "v*scanf" function, which don't
 *			exist on most platforms; but we're prepared if we
 *			ever find a platform that does support them. Note that
 *			we assume that using one symbol implicitly assumes
 *			that if one of the v*scanf family is present, they
 *			all will be.
 */

/*
 * NOTE: all configuration symbols are set up such that they can be
 * overridden by a -D switch on the command line if desired.
 */

/*
 * Name of the platform C compiler
 */
#define _CMA__CC	1
#define _CMA__VAXC	2
#define _CMA__DECC	3
#define _CMA__CFRONT	4
#define _CMA__GCC	5
#define _CMA__DECCPLUS	6
#define _CMA__GCPLUS	7

/*
 * Test for C++ compilers before C compilers because Glockenspiel C++ also
 * defines symbols for the VAX C compiler and this could be the case for
 * other C++/C compiler combinations
 */
#ifndef _CMA_COMPILER_
# if defined(__cplusplus)		/* test for other C++ compilers first */
#  if defined(__DECCXX)
#   define _CMA_COMPILER_	_CMA__DECCPLUS
#  else
#   define _CMA_COMPILER_	_CMA__CFRONT
#  endif
# elif defined(__decc) || defined(__DECC)
#  define _CMA_COMPILER_	_CMA__DECC
# elif defined(vaxc) || defined(VAXC) || defined(__vaxc) || defined(__VAXC)
#  define _CMA_COMPILER_	_CMA__VAXC
# elif defined(__GNUC__) || defined(__GNUC) || defined(__gnuc)
#  define _CMA_COMPILER_	_CMA__GCC
# else
#  define _CMA_COMPILER_	_CMA__CC
# endif
#endif

/*
 * Name of the hardware platform
 */
#define	_CMA__MIPS	1
#define	_CMA__VAX	2
#define _CMA__M68K	3
#define _CMA__HPPA	4
#define _CMA__IBMR2     5
#define _CMA__ALPHA	6

#ifndef	_CMA_HARDWARE_
# if defined(vax) || defined (VAX) || defined(__vax) || defined(__VAX)
#  define	_CMA_HARDWARE_	_CMA__VAX
# endif
# if defined(mips) || defined(MIPS) || defined(__mips) || defined(__MIPS)
#  define	_CMA_HARDWARE_	_CMA__MIPS
# endif
# if defined(m68k) || defined(m68000) || defined(_ISP__M68K) || defined(M68000) || defined(mc68000) 
#  define	_CMA_HARDWARE_	_CMA__M68K
# endif
# if defined(hp9000s300) || defined(__hp9000s300)
#  define	_CMA_HARDWARE_	_CMA__M68K
# endif
# if defined(__hppa)
#  define	_CMA_HARDWARE_	_CMA__HPPA
# endif
# if defined(_IBMR2)
#  define _CMA_HARDWARE_	_CMA__IBMR2
# endif
# if defined(__ALPHA)
#  define _CMA_HARDWARE_	_CMA__ALPHA
# endif
# ifndef _CMA_HARDWARE_
   !!!Error: _CMA_HARDWARE_ not set
# endif
#endif

/*
 * Name of the software platform
 */
#define	_CMA__UNIX	1
#define	_CMA__VMS	2

#ifndef	_CMA_OS_
# if defined(unix) || defined(__unix) || defined(_AIX) || defined(__OSF__) || defined(__osf__)
#  define	_CMA_OS_	_CMA__UNIX
# endif
# if defined(vms) || defined(__vms) || defined(VMS) || defined(__VMS) || defined(__vms__)
#  define	_CMA_OS_	_CMA__VMS
# endif
# ifndef _CMA_OS_
   !!!Error: _CMA_OS_ not set
# endif
#endif

/*
 * Name of the software vendor
 */
#define _CMA__APOLLO	1
#define _CMA__DIGITAL	2
#define _CMA__HP        3
#define _CMA__IBM       4
#define _CMA__OSF	5
#define _CMA__SUN       6

#ifndef _CMA_VENDOR_
# ifdef apollo
#  define	_CMA_VENDOR_	_CMA__APOLLO
# endif
# if _CMA_OS_ == _CMA__VMS
#  define	_CMA_VENDOR_	_CMA__DIGITAL
# endif
# if defined(ultrix) || defined(__ULTRIX) || defined (__ultrix)
#  define	_CMA_VENDOR_	_CMA__DIGITAL
# endif
# if defined(__osf__) && !defined(__OSF__) && (_CMA_HARDWARE_ == _CMA__MIPS)
#  define	_CMA_VENDOR_	_CMA__DIGITAL
# endif
# if defined(__osf__) && !defined(__OSF__) && (_CMA_HARDWARE_ == _CMA__ALPHA)
#  define	_CMA_VENDOR_	_CMA__DIGITAL
# endif
# if defined(hpux) || defined(__hpux)
#  define	_CMA_VENDOR_	_CMA__HP
# endif
# ifdef _IBMR2
#  define 	_CMA_VENDOR_	_CMA__IBM
# endif
# ifdef sun
#  define	_CMA_VENDOR_	_CMA__SUN
# endif
# if defined (__OSF__) && !defined (_CMA_VENDOR_)
#  define	_CMA_VENDOR_	_CMA__OSF
# endif
# ifndef _CMA_VENDOR_
   !!!Error: _CMA_VENDOR_ not set
# endif
#endif

/*
 * Combined platform (OS + hardware)
 */
#define	_CMA__MIPS_UNIX		1
#define	_CMA__VAX_VMS		2
#define _CMA__VAX_UNIX		3
#define _CMA__M68K_UNIX		4
#define _CMA__HPPA_UNIX		5
#define _CMA__IBMR2_UNIX	6
#define _CMA__ALPHA_UNIX	7
#define _CMA__ALPHA_VMS		8

#ifndef	_CMA_PLATFORM_
# if _CMA_OS_ == _CMA__UNIX
#  if _CMA_HARDWARE_ == _CMA__MIPS
#   define _CMA_PLATFORM_	_CMA__MIPS_UNIX
#  endif
#  if _CMA_HARDWARE_ == _CMA__VAX
#   define _CMA_PLATFORM_	_CMA__VAX_UNIX
#  endif
#  if _CMA_HARDWARE_ == _CMA__M68K
#   define _CMA_PLATFORM_	_CMA__M68K_UNIX
#  endif
#  if _CMA_HARDWARE_ == _CMA__HPPA
#   define _CMA_PLATFORM_	_CMA__HPPA_UNIX
#  endif
#  if _CMA_HARDWARE_ == _CMA__IBMR2
#   define _CMA_PLATFORM_	_CMA__IBMR2_UNIX
#  endif
#  if _CMA_HARDWARE_ == _CMA__ALPHA
#   define _CMA_PLATFORM_	_CMA__ALPHA_UNIX
#  endif
# endif
# if _CMA_OS_ == _CMA__VMS
#  if _CMA_HARDWARE_ == _CMA__VAX
#   define _CMA_PLATFORM_	_CMA__VAX_VMS
#  endif
#  if _CMA_HARDWARE_ == _CMA__ALPHA
#   define _CMA_PLATFORM_	_CMA__ALPHA_VMS
#  endif
# endif
# ifndef _CMA_PLATFORM_
   !!!Error: _CMA_PLATFORM_ not set
# endif
#endif

/*
 * Set to 1 if system supports setting memory page protection (see
 * cma_stack.c for use of page protection routines; "cma_vmprot.h" defines
 * interface to generic jacket routines "cma__set_noaccess" and
 * "cma__set_access").
 */
#ifndef _CMA_PROTECT_MEMORY_
# if _CMA_PLATFORM_ == _CMA__VAX_VMS
#  define _CMA_PROTECT_MEMORY_	1
# endif
# if _CMA_PLATFORM_ == _CMA__MIPS_UNIX
#  define _CMA_PROTECT_MEMORY_  1
# endif
# if _CMA_PLATFORM_ == _CMA__VAX_UNIX
#  define _CMA_PROTECT_MEMORY_  1
# endif
#endif

/*
 * This controls whether ANSI C function prototypes are used for CMA
 * interfaces.
 */
#ifndef	_CMA_PROTO_
# ifdef __STDC__
#  define _CMA_PROTO_		1
# endif
# if _CMA_COMPILER_ == _CMA__DECC
#  define _CMA_PROTO_		1
# endif
# if _CMA_COMPILER_ == _CMA__GCC
#  define _CMA_PROTO_		1
# endif
# if _CMA_COMPILER_ == _CMA__DECCPLUS
#  define _CMA_PROTO_		1
# endif
# if _CMA_COMPILER_ == _CMA__GCPLUS
#  define _CMA_PROTO_		1
# endif
# if _CMA_COMPILER_ == _CMA__CFRONT
#  define _CMA_PROTO_		1
# endif
# if _CMA_COMPILER_ == _CMA__VAXC
#  define _CMA_PROTO_		1
# endif
# if _CMA_PLATFORM_ == _CMA__MIPS_UNIX
#  define _CMA_PROTO_		1
# endif
# if _CMA_VENDOR_ == _CMA__APOLLO
#  define _CMA_PROTO_		1
# endif
# if _CMA_PLATFORM_ == _CMA__IBMR2_UNIX
#  define _CMA_PROTO_		1
# endif
/* Otherwise, _CMA_PROTO_ is undefined, which means do not use prototypes. */
#endif

#define _CMA__OS_AIX	1
#define _CMA__OS_OSF	2
#define _CMA__OS_BSD	3
#define _CMA__OS_SYSV	4
#define _CMA__OS_VMS	5

/*
 * MIPS C on DEC OSF/1 sets __osf__ but not __OSF__; but gcc on "raw" OSF/1
 * sets __OSF__ but not __osf__. This little ditty provides a bridge.
 */
#if defined (__OSF__) && !defined (__osf__)
# define __osf__
#endif

#ifndef _CMA_OSIMPL_
# if _CMA_OS_ == _CMA__VMS
#  define _CMA_OSIMPL_		_CMA__OS_VMS
# else
#  if defined (__osf__)
#   define _CMA_OSIMPL_		_CMA__OS_OSF
#  else
#   if _CMA_VENDOR_ == _CMA__IBM
#    define _CMA_OSIMPL_	_CMA__OS_AIX
#   else
#    if _CMA_VENDOR_ == _CMA__SUN
#     define _CMA_OSIMPL_	_CMA__OS_SYSV
#    else
#     define _CMA_OSIMPL_	_CMA__OS_BSD
#    endif
#   endif
#  endif
# endif
#endif

/*
 * The stack manager module (cma_stack.c) can printf messages which can be
 * useful for debugging (if changes are made to stack management for a
 * platform).
 */
#ifndef _CMA_STACK_TRACE_
# define _CMA_STACK_TRACE_	0	/* DEBUG (report stack management) */
#endif

/*
 * Define whether to use "void *" or "char *" pointers, based on whether the
 * compiler can support them.
 */
#ifndef	_CMA_VOID_
# ifdef __STDC__
#  define _CMA_VOID_		1
# endif
# if _CMA_COMPILER_ == _CMA__VAXC 
#  define _CMA_VOID_	        1
# endif
# if _CMA_COMPILER_ == _CMA__DECCPLUS
#  define _CMA_VOID_		1
# endif
# if _CMA_COMPILER_ == _CMA__GCPLUS
#  define _CMA_VOID_		1
# endif
# if _CMA_COMPILER_ == _CMA__CFRONT
#  define _CMA_VOID_		1
# endif
# if _CMA_COMPILER_ == _CMA__DECC
#  define _CMA_VOID_		1
# endif
# if _CMA_VENDOR_ == _CMA__SUN
#  define _CMA_VOID_            1
# endif
# if _CMA_VENDOR_ == _CMA__HP
#  define _CMA_VOID_            1
# endif
# ifndef _CMA_VOID_
#  define _CMA_VOID_		0
# endif
#endif

/*
 * Certain structures within CMA (especially in exception handling) should be
 * marked "volatile", however some C compilers do not support "volatile" on
 * structures.  Set this to "volatile" unless using such a deficient
 * compiler, in which case it should be "".
 */
#ifndef	_CMA_VOLATILE_
# if _CMA_PLATFORM_ == _CMA__VAX_UNIX
#  if _CMA_COMPILER_ == _CMA__CC
#   define _CMA_VOLATILE_
#   define _CMA_VOLATILE_FLAG_		0
#  endif
# endif
# if _CMA_VENDOR_ == _CMA__SUN
#  define _CMA_VOLATILE_
#  define _CMA_VOLATILE_FLAG_		0
# endif
# if _CMA_COMPILER_ == _CMA__CFRONT
#  define _CMA_VOLATILE_
#  define _CMA_VOLATILE_FLAG_		0
# endif
#ifndef	_CMA_VOLATILE_
#  define _CMA_VOLATILE_  		volatile
#  define _CMA_VOLATILE_FLAG_		1
# endif
#endif

/*
 * This symbol defines whether stacks grow towards lower addresses or higher
 * addresses (_CMA_UPSTACK_ is defined if the stack grows up).
 */
#ifndef _CMA_UPSTACK_
# if _CMA_HARDWARE_ == _CMA__HPPA
#  define _CMA_UPSTACK_ 1
# endif
#endif

/*
 * If the platform supports kernel threads, then the DECthreads VP layer can
 * provide parallel computation. This symbol defines the variety of kernel
 * threads supported by the platform.
 */
#define _CMA__NONE	0
#define _CMA__MACH	1

#ifndef _CMA_KTHREADS_
# if _CMA_OSIMPL_ == _CMA__OS_OSF
#  define _CMA_KTHREADS_	_CMA__MACH
# else
#  define _CMA_KTHREADS_	_CMA__NONE
# endif
#endif

/*
 * This symbol, if defined, provides for some shortcuts that can be made when
 * only uniprocessor hardware is supported (for example, using a fixed entry
 * for "current thread" instead of search stack clusters).
 *
 * If the builder has specifically defined _CMA_UNIPROCESSOR_ to 1, then
 * build a non-kernel-thread version even if the system supports kernel
 * threads, by setting _CMA_KTHREADS_ to _CMA__NONE.
 *
 * Note that if _USER_THREADS_ is set, then _CMA_UNIPROCESSOR_ is explicitly
 * defined to "TRUE" regardless of the platform. That overrides the default
 * user/kernel threads decision, forcing use of user threads. If kernel
 * threads have been determined to be present, they are turned off.
 */
#ifdef _USER_THREADS_
# define _CMA_UNIPROCESSOR_	1
#endif

#ifndef _CMA_UNIPROCESSOR_
# if _CMA_KTHREADS_ == _CMA__NONE
#  define _CMA_UNIPROCESSOR_	1
# else
#  define _CMA_UNIPROCESSOR_	0
# endif
#elif _CMA_UNIPROCESSOR_
# undef _CMA_KTHREADS_
# define _CMA_KTHREADS_		_CMA__NONE
#endif

/*
 * Specify whether this implementation will multiplex on top of VPs
 */
#ifndef _CMA_MULTIPLEX_
# if !_CMA_UNIPROCESSOR_
#  define _CMA_MULTIPLEX_	0	/* No support yet! */
# endif
# ifndef _CMA_MULTIPLEX_
#  define _CMA_MULTIPLEX_	0
# endif
#endif

/*
 * _CMA_THREAD_IS_VP_ is true IFF the platform supports kernel threads and
 * each DECthreads thread is permanently bound to a specific kernel thread
 * throughout its life: in other words, it is a kernel thread platform and
 * threads are not multiplexed in user mode.
 */
#ifndef _CMA_THREAD_IS_VP_
# if _CMA_MULTIPLEX_ || (_CMA_KTHREADS_ == _CMA__NONE)
#  define _CMA_THREAD_IS_VP_	0
# else
#  define _CMA_THREAD_IS_VP_	1
# endif
#endif

/*
 * _CMA_THREAD_SYNC_IO_ is true IFF a blocking I/O function (e.g., read())
 * will block only the DECthreads thread that issued the call. It should
 * generally be false if _CMA_MULTIPLEX_ || _CMA_UNIPROCESSOR_, but can be
 * controlled separately. If _CMA_THREAD_SYNC_IO_ is true, the DECthreads I/O
 * wrapper functions will not be compiled.
 */
#ifndef _CMA_THREAD_SYNC_IO_
# if _CMA_MULTIPLEX_ || _CMA_UNIPROCESSOR_
#  define _CMA_THREAD_SYNC_IO_	0
# else
#  define _CMA_THREAD_SYNC_IO_	1
# endif
#endif

/*
 * _CMA_PER_THD_SYNC_SIGS_ is true IFF the system supports per-thread
 * synchronous signal actions for DECthreads threads. Generally, that means
 * that kernel threads support per-thread sync. signals, and DECthreads is
 * mapped one-to-one on kernel threads (_CMA_THREAD_IS_VP_).
 */
#ifndef _CMA_PER_THD_SYNC_SIGS_
# if _CMA_THREAD_IS_VP_ && (_CMA_OSIMPL_ == _CMA__OS_OSF)
#  define _CMA_PER_THD_SYNC_SIGS_	1
# else
#  define _CMA_PER_THD_SYNC_SIGS_	0
# endif
#endif

/*
 * _CMA_REENTRANT_CLIB_ is true IFF the platform's C library is reentrant.
 * This is generally true on a platform where _CMA_THREAD_IS_VP_ is true, but
 * may also be true for multiplexed threads if the C library is designed
 * properly (for example, the OSF/1 libc_r library allows thread packages to
 * pass it a vector of interlock management functions, rather than assuming
 * that some Mach thread synchronization mechanism is sufficient).
 */
#ifndef _CMA_REENTRANT_CLIB_
# if _CMA_THREAD_IS_VP_ || (defined(_POSIX_REENTRANT_FUNCTIONS) && (_CMA_HARDWARE_ == _CMA__HPPA))
#  define _CMA_REENTRANT_CLIB_	1
# else
#  define _CMA_REENTRANT_CLIB_	0
# endif
#endif

/*
 * _CMA_MP_HARDWARE_ defines whether DECthreads is being built to support
 * actual multiprocessor hardware, not merely kernel threads. In most cases,
 * the important distinction is kernel threads vs. user multiplexing.
 * However, there are some decisions that ought to be based on whether the
 * kernel threads may actually run on different CPUs concurrently; so we
 * might as well have this convenient symbol.
 */
#ifndef _CMA_MP_HARDWARE_
# if _CMA_KTHREADS_ != _CMA__NONE
#  define _CMA_MP_HARDWARE_	1	/* Assume YES for kernel threads */
# else
#  define _CMA_MP_HARDWARE_	0	/* Assume NO if no kernel threads */
# endif
#endif

/*
 * _CMA_SPINLOOP_ controls the number of times a thread will spin (in a tight
 * loop) attempting to lock a mutex before it gives up and blocks itself.
 *
 * On a uniprocessor configuration, this symbol should be defined to zero;
 * spinning won't accomplish anything but to waste the rest of the thread's
 * timeslice. Even when kernel threads are supported on uniprocessor
 * hardware, this symbol likely has little value, since the thread may still
 * spin (wasting CPU) until the kernel performs a thread context switch.
 */
#ifndef _CMA_SPINLOOP_
# if _CMA_MP_HARDWARE_
#  define	_CMA_SPINLOOP_		100
# else
#  define	_CMA_SPINLOOP_		0
# endif
#endif

/*
 * Some UNIX vendors don't yet provide POSIX compatible sigaction().
 * In this case, use sigvec() instead.
 */
#ifndef _CMA_NO_POSIX_SIGNAL_
# if _CMA_VENDOR_ == _CMA__SUN
#  define _CMA_NO_POSIX_SIGNAL_         1
# endif
#endif

/*
 * Use ANSI varargs method for functions with variable number of
 * arguments.  Not same as _CMA_PROTO_ or __STDC__, because some
 * compilers support varargs without prototypes or full __STDC__
 * compatibility.
 */
#ifndef _CMA_VARARGS_
# ifdef __STDC__
#  define _CMA_VARARGS_		1
# endif
# if _CMA_COMPILER_ == _CMA__VAXC
#  define _CMA_VARARGS_		1
# endif
# if _CMA_PLATFORM_ == _CMA__MIPS_UNIX
#  define _CMA_VARARGS_		1
# endif
# if _CMA_VENDOR_ == _CMA__APOLLO
#  define _CMA_VARARGS_		1
# endif
# if _CMA_VENDOR_ == _CMA__SUN
#  define _CMA_VARARGS_		1
# endif
# if _CMA_VENDOR_ == _CMA__HP
#  define _CMA_VARARGS_		1
# endif
# if _CMA_PLATFORM_ == _CMA__IBMR2_UNIX
#  define _CMA_VARARGS_		1
# endif
#endif

/*
 * Define the symbols used to "import" and "export" symbols for the client
 * interface.  Note that these shouldn't be used for symbols shared only
 * between CMA modules; it's for those symbols which are "imported" in the
 * cma.h (or pthread.h) header files, such as cma_c_null,
 * pthread_attr_default, and the exception names.
 *
 * On most platforms (with well-integrated C compilers), "import" should be
 * "extern", and "export" should be "".
 *
 * FIX-ME: what about GCC, DECc, etc. on VAX VMS? Do they do "extern"
 * properly?
 */
#if _CMA_PLATFORM_ == _CMA__VAX_VMS
# define _CMA_IMPORT_ globalref
# define _CMA_EXPORT_ globaldef
# define _CMA_EXPORT_FLAG_	1
#else
# define _CMA_IMPORT_ extern
# define _CMA_EXPORT_
# define _CMA_EXPORT_FLAG_	0
#endif

/*
 * The DECthreads stdio formatting wrappers (printf & scanf family) depend on
 * the existence of the stdarg variety of those functions (vsprintf &
 * vsscanf), since DECthreads must pass on the client's variable argument
 * list. Most systems have vsprintf, however we haven't seen one with
 * vsscanf, although it seems a logical extension. The scanf family wrappers
 * are coded, but can't be built without vsscanf: for a system which does
 * supply this elusive function, turn on the _CMA_VSSCANF_ config symbol and
 * rebuild DECthreads.
 */
#ifndef _CMA_VSSCANF_
# define _CMA_VSSCANF_	0
#endif

/*
 * TYPEDEFS
 */

/*
 *  GLOBAL DATA
 */

/*
 * INTERNAL INTERFACES
 */

#endif
/*
 *	%W%	(ULTRIX/OSF)	%G%
 */
/*
 *  Copyright (c) 1990, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMA services
 *
 *  ABSTRACT:
 *
 *	Header file for CMA's per-thread errno.
 *
 *  AUTHORS:
 *
 *	Dave Butenhof
 *
 *  CREATION DATE:
 *
 *	11 October 1990
 *
 *  MODIFICATION HISTORY:
 *  
 *	001	Paul Curtin	31 January 1991
 *		added _CMA_NOWRAPPERS_ conditional statement
 *	002	Dave Butenhof	21 March 1991
 *		Define EDEADLK if not defined by system's errno.h, since we
 *		need it for several P1003.4a operations. Some BSD-derived
 *		systems already define EDEADLK as a synonym for EWOULDBLOCK,
 *		so that seems like a reasonable value to use.
 *	003	Dave Butenhof	19 September 1991
 *		Integrate HPUX CMA5 reverse drop: omit DECthreads errno
 *		definitions if system supports _POSIX_REENTRANT_FUNCTIONS
 *		(which necessarily includes per-thread errno).
 *	004	Dave Butenhof	29 October 1991
 *		This file isn't included by cma.h on systems that support
 *		reentrant C library functions (presumably including a
 *		per-thread errno); however, since cma_errno.h nevertheless is
 *		present on DCE systems, and many programs may include it
 *		directly, it also needs to protect itself by checking for
 *		_CMA_REENTRANT_CLIB_ directly.
 *	005	Dave Butenhof	19 November 1991
 *		Remove direct check for _POSIX_REENTRANT_FUNCTIONS; rely on
 *		_CMA_REENTRANT_CLIB_, since we control that. OSF/1 defines
 *		_POSIX_REENTRANT_FUNCTIONS, but OSF DCE reference port isn't
 *		using libc_r.a.
 */

#ifndef CMA_ERRNO
# define CMA_ERRNO

/*
 *  INCLUDE FILES
 */

# include <errno.h>

# ifndef EDEADLK
#  define EDEADLK	EWOULDBLOCK
# endif

/*
 * CONSTANTS AND MACROS
 */

/*
 * Errno function
 */
# if !defined(_CMA_REENTRANT_CLIB_)
#  ifndef _CMA_NOWRAPPERS_
#   define errno	(*(cma_errno ()))
#  endif

/*
 * TYPEDEFS
 */

/*
 *  GLOBAL DATA
 */

/*
 * INTERNAL INTERFACES
 */

extern int *
cma_errno _CMA_PROTOTYPE_ ((void));

# endif /* !defined(_CMA_REENTRANT_CLIB_) */

#endif
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_ERRNO.H */
/*  *10   19-NOV-1991 12:18:01 BUTENHOF "Remove tests for _POSIX_REENTRANT_FUNCTIONS" */
/*  *9    31-OCT-1991 12:39:23 BUTENHOF "Conditionalize on !_CMA_REENTRANT_CLIB_" */
/*  *8    24-SEP-1991 16:27:11 BUTENHOF "Merge CMA5 reverse IBM/HP/Apollo drops" */
/*  *7    11-JUN-1991 10:36:52 BUTENHOF "Convert to stream format for ULTRIX build" */
/*  *6    10-JUN-1991 19:20:43 BUTENHOF "Fix the sccs headers" */
/*  *5    10-JUN-1991 18:21:41 SCALES "Add sccs headers for Ultrix" */
/*  *4    12-APR-1991 23:35:46 BUTENHOF "Support per-thread errno for kernel threads" */
/*  *3    21-MAR-1991 09:26:12 BUTENHOF "Define EDEADLK if not defined by system" */
/*  *2    31-JAN-1991 16:36:07 CURTIN "added _CMA_NOWRAPPERS_ conditional statement" */
/*  *1    12-DEC-1990 21:45:13 BUTENHOF "Per-thread errno" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_ERRNO.H */
/*
 *  Copyright (c) 1989, 1992 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMA services
 *
 *  ABSTRACT:
 *
 *	Header file for VAX/VMS host-specific functions
 *
 *  AUTHORS:
 *
 *	Dave Butenhof and Webb Scales
 *
 *  CREATION DATE:
 *
 *	19 October 1989
 *
 *  MODIFICATION HISTORY:
 *
 *	001	Dave Butenhof	20 October 1989
 *		Change "cma__fetch_SP" to all lower case to match APA naming
 *		conventions.
 *	002	Webb Scales	18 November 1989
 *		Add host dependent thread context structures.
 *	003	Dave Butenhof and Webb Scales	9 January 1990
 *		Delete cma__add_atomic, since it's not used anywhere.
 *	004	Dave Butenhof	13 April 1990
 *		Add cma__fetch_fp for exception package.
 *	005	Webb Scales	16 April 1990
 *		Add default stack limits
 *	006	Dave Butenhof	19 April 1990
 *		Remove cma__fetch_fp (it's not in host-specific exception
 *		header, which is client-visible).
 *	007	Webb Scales	3 May 1990
 *		Replace cma__lock_any and cma__unlock_any by 
 *		cma__interrupt_disable and cma__interrupt_enable.
 *	008	Dave Butenhof	14 June 1990
 *		Implement cma__kernel_set and cma__kernel_unset to allow
 *		optimizing mutexes (for processors without interlocked
 *		instructions, the old cma__test_and_set and cma__unset will
 *		lock the kernel before attempting "atomic" operations on
 *		arbitrary data).
 *	009	Paul Curtin	18 July 1990
 *		Added an include for ssdef.h
 *	010	Webb Scales	16 August 1990
 *		Rearranged things, moving a lot into the host-generic file.
 *	011	Dave Butenhof	6 December 1990
 *		Move "generic host-specific" stuff back here, to fit in new
 *		build system (there is no generic cma_host.h).
 *	012	Dave Butenhof	09 April 1991
 *		Improve portability by adding a type for internal locks,
 *		rather than assuming it can be just an int.
 *	013	Dave Butenhof	14 May 1991
 *		Fix MP cma__t_atomic_bit macros.
 *	014	Webb Scales	28 January 1992
 *		Rework async context switch.
 *	015	Webb Scales	11 February 1992
 *		Add clear-interrupt macro.
 */


#ifndef CMA_HOST_DEFS
# define CMA_HOST_DEFS

/*
 *  INCLUDE FILES
 */

# ifndef SS$_NORMAL
#  include <ssdef.h>
# endif

/*
 * CONSTANTS AND MACROS
 */

/*
 * Initialization for "atomic bit" objects
 */
# define cma__c_tac_static_clear	0
# define cma__tac_clear(addr)	(*(addr) = (cma__t_atomic_bit)0)
# define cma__tac_set(addr)	(*(addr) = (cma__t_atomic_bit)1)
# define cma__tac_isset(addr)	(*(addr) != (cma__t_atomic_bit)0)

# pragma builtins

/*
 * Return the present value of the stack pointer for the current thread
 *
 * _READ_GPR reads the value of a general processor register 
 *  (register 14 is SP)
 */
# define cma__fetch_sp() ((unsigned int)_READ_GPR (14))

/*
 * Disable interrupts (ASTs)
 */
# if 0 /* This macro is not currently needed, use the dummy */
#  define cma__interrupt_disable(state)	(state = sys$setast (1))
# else
#  define cma__interrupt_disable(dummy)
# endif

/*
 * Re-enable interrupts (ASTs)
 */
# if 0 /* This macro is not currently needed, use the dummy */
#  define cma__interrupt_enable(state) \
    (cma__assert_warn ( \
	    state == ss$_wasclr || state == ss$_wasset, \
	    "cma__interrupt_enable:  bad state specified"), \
    (state == ss$_wasset ? sys$setast (1) : 0))
# else
#  define cma__interrupt_enable(dummy)
# endif

/*
 * Clear interrupt (AST).  Allow other interrupts to interrupt, even though
 * the current interrupt is still active.
 */
# define cma__clear_interrupt(dummy)	cma__clrast()

/*
 * Atomically test (and return) low bit of longword at the specified address,
 * and set the bit.
 */
# define cma__test_and_set(address) ((int)_BBSSI (0, (address)))

/*
 * Atomically clear the low bit of longword at the specified address.
 */
# define cma__unset(address) (_BBCCI (0, (address)))

# define cma__kernel_set(address) ((int)_BBSSI (0, (address)))

# define cma__kernel_unset(address) (_BBCCI (0, (address)))

/*
 * Maximum and minimum addresses in default thread stack
 */
# define cma__c_def_stack_min	0x40000000
# define cma__c_def_stack_max	0x7fffffff

/*
 * TYPEDEFS
 */

typedef int	cma__t_atomic_bit;

typedef struct CMA__T_STATIC_CTX {
    long int	fp;
    long int	sp;
    } cma__t_static_ctx;

typedef cma_t_boolean cma__t_async_ctx;

/*
 *  GLOBAL DATA
 */

/*
 * INTERNAL INTERFACES
 */

#endif					/* CMA_HOST_DEFS */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_HOST.H */
/*  *7    11-FEB-1992 16:29:51 SCALES """Add clear-interrupt macros""" */
/*  *6    29-JAN-1992 23:50:21 SCALES "Rework async context switch for VMS" */
/*  *5    22-NOV-1991 11:54:26 BUTENHOF "" */
/*  *4    14-MAY-1991 16:19:32 BUTENHOF "Remove static TAC inits" */
/*  *3    12-APR-1991 23:33:18 BUTENHOF "Add cma__t_int_lock type" */
/*  *2    11-DEC-1990 20:29:26 BUTENHOF "Add additonal host-specific defs" */
/*  *1     5-DEC-1990 19:26:37 BUTENHOF "VAX/VMS host definitions" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_HOST.H */
/*
 *  Copyright (c) 1990 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	Common Multithread Architecture (CMA) High-Level Library services
 *
 *  ABSTRACT:
 *
 *	External definitions for CMA High-Level Library services
 *
 *  AUTHORS:
 *
 *	Webb Scales
 *
 *  CREATION DATE:
 * 
 *	7 August 1990
 *
 *  MODIFICATION HISTORY:
 * 
 *	001	Webb Scales	28 August 1990
 *		Removed exception declaration.
 *	002	Webb Scales	28 August 1990
 *		Fix parameter passing to pass structures by reference.
 */


#ifndef CMA_LIB_INCLUDE
#define CMA_LIB_INCLUDE

#include <cma.h>


/*
 * The following are the portable CMA High-Level Library definitions
 */


/*
 * Operations on attributes objects
 */

typedef cma_t_handle	cma_lib_t_attr;

/*
 * An attributes object is created to specify the attributes of other CMA
 * objects that will be created.
 */
extern void
cma_lib_attr_create _CMA_PROTOTYPE_ ((
	cma_lib_t_attr	*new_attr,
	cma_lib_t_attr	*attr));

/*
 * An attributes object can be deleted when it is no longer needed.
 */
extern void
cma_lib_attr_delete _CMA_PROTOTYPE_ ((
	cma_lib_t_attr	*attr));


/*
 * Operations on queues
 */

typedef cma_t_handle	cma_lib_t_queue;

extern void
cma_lib_queue_create _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*new_queue,
	cma_lib_t_attr  *att));

extern void
cma_lib_queue_delete _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue));

extern void
cma_lib_queue_dequeue _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   *element));

extern void
cma_lib_queue_enqueue _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   element));

extern cma_t_boolean
cma_lib_queue_try_enqueue_int _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   element));

extern void
cma_lib_queue_requeue _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   element));

extern cma_t_boolean
cma_lib_queue_try_dequeue _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   *element));

extern cma_t_boolean
cma_lib_queue_try_enqueue _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   element));

extern cma_t_boolean
cma_lib_queue_try_requeue _CMA_PROTOTYPE_ ((
	cma_lib_t_queue	*queue,
	cma_t_address   element));

/*
 * Set or obtain the default queue size
 */
extern void
cma_lib_attr_get_queuesize _CMA_PROTOTYPE_ ((
	cma_lib_t_attr	*attr,
	cma_t_natural	*queuesize));

extern void
cma_lib_attr_set_queuesize _CMA_PROTOTYPE_ ((
	cma_lib_t_attr	*attr,
	cma_t_natural	queuesize));

#endif
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_LIBRARY.H */
/*  *4    29-AUG-1990 17:04:05 SCALES "Convert to stream format" */
/*  *3    28-AUG-1990 18:34:54 SCALES "Fix parameter passing" */
/*  *2    28-AUG-1990 16:34:29 SCALES "Remove exception declarations" */
/*  *1    27-AUG-1990 02:20:06 SCALES "" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_LIBRARY.H */
/*
 *	%W%	(ULTRIX/OSF)	%G%
 */
/*
 *  Copyright (c) 1990. 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMA services
 *
 *  ABSTRACT:
 *
 *	Header file for POSIX wrapper routines
 *
 *  AUTHORS:
 *
 *	Dave Butenhof
 *
 *  CREATION DATE:
 *
 *	18 May 1990
 *
 *  MODIFICATION HISTORY:
 *
 *	001	Webb Scales	25 Septemeber 1990
 *		Put in ifndef/define around POSIX type definitions to prevent
 *		collisions with other pre-POSIX facilities.
 *	002	Paul Curtin	 11 December 1990
 *		Added sigaction work, and split some of cma_px.h off
 *		into cma_sigwait.h
 *	003	Paul Curtin	31 January 1991
 *		Added _CMA_NOWRAPPERS_ conditional statements
 *	004	Dave Butenhof	5 February 1991
 *		To avoid breaking client code (now that this is pulled in
 *		transparently by cma.h, pthread.h, pthread_exc.h), drop all
 *		the header file includes; which means also dropping the
 *		prototypes (oh well).
 *	005	Dave Butenhof	10 May 1991
 *		Remove cma_signal() declaration... the macro is sufficient,
 *		since it will "reroute" the declaration in
 *		/usr/include/signal.h when the client code includes it.
 *	006	Dave Butenhof	23 May 1991
 *		Add conditionals for _CMA_UNIPROCESSOR_ so kernel-thread
 *		versions of DECthreads can still use some wrappers (e.g.,
 *		cma_sigaction()).
 *	007	Webb Scales	10 June 1991
 *		Conditionalize out sigaction macro for kernel threads.
 *	008	Webb Scales	 8 July 1991
 *		Fix typo in os-impl symbol name.
 *	009	Dave Butenhof	19 September 1991
 *		Integrate HPUX CMA5 reverse drop: add check for
 *		_POSIX_REENTRANT_FUNCTIONS to disable wrappers.
 *	010	Dave Butenhof	04 October 1991
 *		Clean up use of _CMA_UNIPROCESSOR_
 *	011	Dave Butenhof	19 November 1991
 *		Remove direct check for _POSIX_REENTRANT_FUNCTIONS; rely on
 *		_CMA_REENTRANT_CLIB_, since we control that. OSF/1 defines
 *		_POSIX_REENTRANT_FUNCTIONS, but OSF DCE reference port isn't
 *		using libc_r.a.
 */


#ifndef CMA_PX
#define CMA_PX

/*
 *  INCLUDE FILES
 */

/*
 * CONSTANTS AND MACROS
 */

#if !_CMA_REENTRANT_CLIB_
# ifndef _CMA_NOWRAPPERS_
#  if !_CMA_THREAD_IS_VP_
#   define sigaction cma_sigaction   
#  endif
# endif
#endif

/*
 * TYPEDEFS
 */

#if _CMA_OSIMPL_ == _CMA__OS_OSF
# include <sys/timers.h>
#else
# ifndef _TIMESPEC_T_
# define _TIMESPEC_T_
typedef struct timespec {
    unsigned long	tv_sec;		/* seconds */
    long		tv_nsec;	/* and nanoseconds */
    } timespec_t;
# endif
#endif

/*
 * INTERFACES
 */

#endif  /* CMA_PX */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_PX.H */
/*  *15   19-NOV-1991 12:18:07 BUTENHOF "Remove tests for _POSIX_REENTRANT_FUNCTIONS" */
/*  *14   14-OCT-1991 13:39:45 BUTENHOF "Refine/fix use of config symbols" */
/*  *13   24-SEP-1991 16:27:42 BUTENHOF "Merge CMA5 reverse IBM/HP/Apollo drops" */
/*  *12    8-JUL-1991 15:46:25 SCALES "Fix typo in os-impl symbol" */
/*  *11   10-JUN-1991 19:54:59 SCALES "Convert to stream format for ULTRIX build" */
/*  *10   10-JUN-1991 19:21:16 BUTENHOF "Fix the sccs headers" */
/*  *9    10-JUN-1991 18:22:56 SCALES "Add sccs headers for Ultrix" */
/*  *8    10-JUN-1991 17:54:54 SCALES "Conditionalize sigaction macro for kernel threads" */
/*  *7     5-JUN-1991 18:38:04 BUTENHOF "Include sys/timers.h for timespec" */
/*  *6    29-MAY-1991 17:02:17 BUTENHOF "Change wrapper macros for MP" */
/*  *5    10-MAY-1991 17:52:06 BUTENHOF "Remove prototype" */
/*  *4     6-FEB-1991 01:33:10 BUTENHOF "Drop prototypes to avoid pulling in signal.h, socket.h, etc." */
/*  *3    31-JAN-1991 16:37:42 CURTIN "added _CMA_NOWRAPPERS_ conditional statments" */
/*  *2    17-DEC-1990 14:34:36 CURTIN "split with cma_sigwait.h" */
/*  *1    12-DEC-1990 21:48:42 BUTENHOF "P1003.4a support" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_PX.H */
/*
 *	%W%	(ULTRIX/OSF)	%G%
 */
/*
 *  Copyright (c) 1990, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMA services
 *
 *  ABSTRACT:
 *
 *	Header file for the CMA implementation of POSIX sigwait routine
 *
 *  AUTHORS:
 *
 *	Paul Curtin
 *
 *  CREATION DATE:
 *
 *	10 December 1990
 *
 *  MODIFICATION HISTORY:
 *
 *	001	Dave Butenhof	5 February 1991
 *		To avoid breaking client code (now that this is pulled in
 *		transparently by cma.h, pthread.h, pthread_exc.h), drop all
 *		the header file includes; which means also dropping the
 *		prototypes (oh well).
 *	002	Paul Curtin	9 May 1991
 *		Removed empty proto for cma_sigwait, should acquire from
 *		system header (ie, we redefine system sigwait to cma_sigwait)
 *	003	Paul Curtin	14 May 1991 
 *		Added full proto for cma_sigwait, not part of some systems...
 *	004	Dave Butenhof	19 September 1991
 *		Integrate HPUX CMA5 reverse drop; don't define cma_sigwait()
 *		wrapper if system supports _POSIX_REENTRANT_FUNCTIONS.
 *	005	Dave Butenhof	19 November 1991
 *		Remove direct check for _POSIX_REENTRANT_FUNCTIONS; rely on
 *		_CMA_REENTRANT_CLIB_, since we control that. OSF/1 defines
 *		_POSIX_REENTRANT_FUNCTIONS, but OSF DCE reference port isn't
 *		using libc_r.a. Preserve the intent (I hope) of HP's changes
 *		via checks for HPPA hardware.
 *	006	Dave Butenhof	21 November 1991
 *		Fix error in 005 that's caught by strict ANSI checking (c89)
 */


#ifndef CMA_SIGWAIT
#define CMA_SIGWAIT

/*
 *  INCLUDE FILES
 */
#include <signal.h>

/*
 * CONSTANTS AND MACROS
 */

/*
 * Note:  sigwait is currently only defined in the POSIX spec and nowhere 
 *	else (ie, it is not in Section 2 of the Unix Manual, it is not part of
 *	the C RTL, and it is not part of the CMA specification) so it is an 
 *	orphan.  It is documented here until it is given its rightful place.
 */
# if !defined(_CMA_NOWRAPPERS_) && (_CMA_HARDWARE_ != _CMA__HPPA)
#  define sigwait cma_sigwait
# endif

/*
 * TYPEDEFS
 */

# if _CMA_OS_ == _CMA__VMS
#  ifndef _SIGSET_T_
#  define _SIGSET_T_
typedef	int	sigset_t;		/* For sigwait */
#  endif
# endif

/*
 *  GLOBAL DATA
 */

/*
 *  PROTOTYPES
 */
# if _CMA_OS_ != _CMA__VMS
#  if _CMA_HARDWARE_ != _CMA__HPPA
extern cma_t_integer
cma_sigwait _CMA_PROTOTYPE_ ((
        sigset_t    *set));
#  else
extern cma_t_integer
sigwait _CMA_PROTOTYPE_ ((
        sigset_t    *set));
#  endif
# endif

#endif
#ifndef __COBDEF_LOADED
#define __COBDEF_LOADED	1

/*** MODULE $cobdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:25.01 */
/*                                                                          */
/* FILE: COBMSG.MSG  EDIT: DJM2014                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* EDIT HISTORY:                                                            */
/*                                                                          */
/* 2-001 - CONVERT TO MESSAGE UTILITY SOURCE FORMAT.  ADAPTED FROM COBMSG.MDL */
/*	  VERSION 1-019.  SBL 22-APR-1981                                   */
/* 2-002 - USE COB$ FACILITY FOR COB$_NORMAL.  SBL 27-APR-1981              */
/* 2-003 - COPIED CHANGES MADE TO COBMSG.MDL TO THIS MSG FILE.  THE MESSAGES */
/*	  ADDED INCLUDE COB$_LSTHNDUSE, COB$_LSTHNDLDB, AND COB$_EXPDBOVER. */
/*	  LB 7-MAY-81.                                                      */
/* 2-004	- ADDED COB$_KEYNOTMAT.  PDG 24-JUL-81.                     */
/* 2-005	- ADDED .TITLE PDG 26-JUL-81.                               */
/* 2-006	- ADDED COB$_UNLUNOFIL AND COB$_RECNOTLOC.  PDG 7-AUG-81.   */
/* 2-007 - UPDATED COPYRIGHT DATE AND FIXED SPELLING ERROR.  LB 9-AUG-81.   */
/* 2-008 - ADDED COB$_UNLNO_CUR.  LB 29-OCT-81.                             */
/* 2-009 - CHANGED COB$_GOTNO_ALT TO BE COB$_GOTO_ALT.  THIS HAD BEEN IN    */
/*	  ERROR IN THIS FILE AS WELL AS IN COBERROR.  LB  1-APR-82.         */
/* 2-010 - CHANGE TITLE TO COB$MSGDEF.  SBL 28-AUG-1982                     */
/* 2-011 - ADDED COB$_ERRDURPOS FOR COB$POS_ERASE AND COB$_REAMP_D_R        */
/*	  FOR COB$IOEXCEPTION.				LGB 6-SEP-83        */
/*	  ADDED COB$_INVDEFVAL FOR COB$ACCEPT		LGB 3-OCT-83        */
/* 2-012 - ADDED NUMEROUS CODES FOR COBOL V4.0 SUPPORT FOR COB$IOEXCEPTION. */
/*	  DJM 17-NOV-86                                                     */
/* 2-013 - CHANGED MESSAGE AND SEVERITY FOR COB$_INTDIVZER AND COB$_UNDEF_EXP */
/*	  AS THE PROGRAM IS ALLOWED TO CONTINUE WITH THE NEW STANDARD.      */
/*	  ALSO - ADD MESSAGE COB$_DIVBYZER.  DJM 27-APR-1987                */
/* 2-014 - REMOVE REFERENCE TO ISAM.  DJM 30-DEC-1987                       */
/*                                                                          */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	COB$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACRO CALL:                                                          */
/*                                                                          */
/*	$COBDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS AS EXTERNAL;                 */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*-                                                                         */
/*                                                                          */
/*                                                                          */
/*			; NOTE: ERROR CODES MUST NOT OVERLAP SUCCESS CODES!!! */
#define COB$_FACILITY 25
#define COB$_NORMAL 1671169
/* COBOL V4 SUPPORT, NEXT 2 MESSAGES                                        */
#define COB$_READUPKEY 1671177
#define COB$_RECNOTSIZ 1671185
#define COB$_GOTO_ALT 1671236
#define COB$_RECACTPER 1671244
#define COB$_NESERRPER 1671252
#define COB$_TIMOVELON 1671260
#define COB$_OCCDEPOVE 1671268
#define COB$_SUBOVELON 1671276
#define COB$_ERRDURSOR 1671284
#define COB$_UNEINSCON 1671292
#define COB$_CALFAI 1671300
#define COB$_INVLINVAL 1671308
/*				***** NO_USEPRO MUST BE THE FIRST ERROR     */
/*				***** MESSAGE ASSOCIATED WITH               */
/*				***** COB$IOEXCEPTION.  IT IS USED AS       */
/*				***** THE BASE OF AN ENCODING ALGORITHM.    */
/*                                                                          */
#define COB$_NO_USEPRO 1671316
#define COB$_ERRON_FIL 1671324
#define COB$_OPTMISOPE 1671332
#define COB$_FILALRLOC 1671340
#define COB$_FILALROPE 1671348
#define COB$_FILCLOLOC 1671356
#define COB$_NO_SPACE 1671364
#define COB$_FILNOTFOU 1671372
#define COB$_OPTMISCLO 1671380
#define COB$_FILALRCLO 1671388
#define COB$_NO_NEXLOG 1671396
#define COB$_OPTMISREA 1671404
#define COB$_NO_NEXVAL 1671412
#define COB$_RECLOCREA 1671420
#define COB$_RECLOC_OK 1671428
#define COB$_REAUNOFIL 1671436
#define COB$_REAINCOPE 1671444
#define COB$_WRIBEYBOU 1671452
#define COB$_WRIUNOFIL 1671460
#define COB$_WRIINCOPE 1671468
#define COB$_REWNO_R_S 1671476
#define COB$_REWUNOFIL 1671484
#define COB$_REWINCOPE 1671492
#define COB$_RECNOTEXI 1671500
#define COB$_OPTMISSTA 1671508
#define COB$_RECLOCSTA 1671516
#define COB$_STAUNOFIL 1671524
#define COB$_STAINCOPE 1671532
#define COB$_RECLOCWRI 1671540
#define COB$_RECLOCDEL 1671548
#define COB$_DELNO_R_S 1671556
#define COB$_DELUNOFIL 1671564
#define COB$_DELINCOPE 1671572
#define COB$_RECLOCREW 1671580
#define COB$_WRIDUPKEY 1671588
#define COB$_WRICREDUP 1671596
#define COB$_WRINOTASC 1671604
#define COB$_WRIDUPALT 1671612
#define COB$_REWCREDUP 1671620
#define COB$_PRIKEYCHA 1671628
#define COB$_REWDISDUP 1671636
#define COB$_WRIDISDUP 1671644
#define COB$_REASMAMIN 1671652
#define COB$_EOFON_ACC 1671660
#define COB$_ERRDURACC 1671668
#define COB$_DISMORMAX 1671676
#define COB$_INTEXPOVE 1671684
#define COB$_INTEXPUND 1671692
#define COB$_INTRESOPE 1671700
#define COB$_NO_MES_00 1671708          /* PLACE HOLDER. WAS INTDIVZER      */
#define COB$_INVDECDIG 1671716
#define COB$_NO_MES_01 1671724          /* PLACE HOLDER. WAS UNDEF_EXP      */
#define COB$_WRISMAMIN 1671732
#define COB$_REWSMAMIN 1671740
#define COB$_NAMNOTLIN 1671748
#define COB$_INVCHANAM 1671756
#define COB$_ORGNOTMAT 1671764
#define COB$_CANFAIL 1671772
#define COB$_INVARG 1671780
#define COB$_FAIGET_VM 1671788
#define COB$_FAIFREEVM 1671796
#define COB$_ERRDURDIS 1671804
#define COB$_USE_EXIT 1671812
#define COB$_RECACTUSE 1671820
#define COB$_FATINTERR 1671828
#define COB$_FAIGET_EF 1671836
#define COB$_SETEXTFAI 1671844
#define COB$_INVDECDAT 1671852
#define COB$_LSTHNDUSE 1671860
#define COB$_LSTHNDLDB 1671868
#define COB$_EXPDBOVER 1671876
#define COB$_KEYNOTMAT 1671884
#define COB$_UNLUNOFIL 1671892
#define COB$_RECNOTLOC 1671900
#define COB$_UNLNO_CUR 1671908
#define COB$_REAMP_D_R 1671916
#define COB$_ERRDURPOS 1671924
#define COB$_INVDEFVAL 1671932
/* COBOL V4 SUPPORT, NEXT 10 MESSAGES                                       */
#define COB$_REARECTOB 1671940
#define COB$_WRIRECTOB 1671948
#define COB$_DEVNOTAPL 1671956
#define COB$_INVRECSIZ 1671964
#define COB$_RECSIZEXC 1671972
#define COB$_INVRECTYP 1671980
#define COB$_INVBLKFAC 1671988
#define COB$_CONCODSET 1671996
#define COB$_COLSEQKEY 1672004
#define COB$_CONPADCHR 1672012
#define COB$_INTDIVZER 1679170
#define COB$_DIVBY_ZER 1679178
#define COB$_UNDEF_EXP 1679186

#endif					/* __COBDEF_LOADED */
#ifndef __CQUALDEF_LOADED
#define __CQUALDEF_LOADED	1

/*** MODULE $cqualdef ***/
#define LIB$M_CQF_CONFIRM 1
#define LIB$M_CQF_EXCLUDE 2
#define LIB$M_CQF_BEFORE 4
#define LIB$M_CQF_SINCE 8
#define LIB$M_CQF_CREATED 16
#define LIB$M_CQF_MODIFIED 32
#define LIB$M_CQF_EXPIRED 64
#define LIB$M_CQF_BACKUP 128
#define LIB$M_CQF_BYOWNER 256
#pragma nostandard
struct cquals {
    variant_union  {
        variant_struct  {
            unsigned lib$v_cqf_confirm : 1; /*                              */
            unsigned lib$v_cqf_exclude : 1; /*                              */
            unsigned lib$v_cqf_before : 1; /*                               */
            unsigned lib$v_cqf_since : 1; /*                                */
            unsigned lib$v_cqf_created : 1; /*                              */
            unsigned lib$v_cqf_modified : 1; /*                             */
            unsigned lib$v_cqf_expired : 1; /*                              */
            unsigned lib$v_cqf_backup : 1; /*                               */
            unsigned lib$v_cqf_byowner : 1; /*                              */
            unsigned lib$v_qf_fill : 23;
            } lib$l_qualifier_flags;
        variant_struct  {
            unsigned lib$v_cqf_assigned : 9;
            unsigned lib$v_cqf_unassigned : 23;
            } lib$r_qf_overlay2;
        } lib$r_flags_overlay;
    } ;
#pragma standard

#endif					/* __CQUALDEF_LOADED */
#ifndef __CRDEF_LOADED
#define __CRDEF_LOADED	1

/*** MODULE $crdef ***/
/*+                                                                         */
/* CARD READER STATUS BITS                                                  */
/*-                                                                         */
#define CR$M_TMODE 15
#define CR$K_T026 0                     /*026 PUNCH CODE TRANSLATION        */
#define CR$K_T029 1                     /*029 PUNCH CODE TRANSLATION        */
#pragma nostandard
union crdef {
    variant_struct  {
        unsigned cr$v_tmode : 4;        /* TRANSLATION MODE                 */
        unsigned cr$v_fill_26 : 4;
        } cr$r_crdef_bits;
/*                                                                          */
/* TRANSLATION MODE DEFINITIONS                                             */
/*                                                                          */
/*                                                                          */
    } ;
#pragma standard

#endif					/* __CRDEF_LOADED */
#ifndef __CREDEF_LOADED
#define __CREDEF_LOADED	1

/*** MODULE $credef ***/
/*                                                                          */
/* Create options table                                                     */
/*                                                                          */
#define CRE$C_VMSV2 2                   /* VMS version V04-000 format       */
#define CRE$C_VMSV3 3                   /* VMS version 3 format             */
#define CRE$M_NOCASECMP 1
#define CRE$M_NOCASENTR 2
#define CRE$M_UPCASNTRY 4
#define CRE$C_HLPCASING 6               /* Treat upper casing as it is for HELP libs  */
#define CRE$C_OBJCASING 3               /* Treat upper casing as it is for OBJECT libs  */
#define CRE$C_MACTXTCAS 0               /* Treat upper casing as it is for MACRO and TEXT libs  */
#define CRE$K_LENGTH 80                 /*                                  */
#define CRE$C_LENGTH 80                 /*                                  */
#pragma nostandard
struct credef {
    unsigned long int cre$l_type;       /* Type of library                  */
/*  (library types defined in $LBRDEF)                                      */
    unsigned long int cre$l_keylen;     /* Length of keys in library        */
    unsigned long int cre$l_alloc;      /* Initial file allocation          */
    unsigned long int cre$l_idxmax;     /* Maximum number of indices        */
    unsigned long int cre$l_uhdmax;     /* Size of additional module header data  */
    unsigned long int cre$l_entall;     /* Number of index entries to pre-allocate  */
    unsigned long int cre$l_luhmax;     /* Number of library update history records to store  */
    unsigned long int cre$l_vertyp;     /* Version type of library to create  */
    variant_union  {
        unsigned long int cre$l_idxopt; /* Index options                    */
        variant_struct  {
            unsigned cre$v_nocasecmp : 1; /* Do not upper case the match key  */
            unsigned cre$v_nocasentr : 1; /* Do not upper case the index key when comparing with a match key  */
            unsigned cre$v_upcasntry : 1; /* Upper case the index key when entering it into the library  */
            unsigned cre$v_fill_4 : 5;
            } cre$r_idxopt_bits;
        } cre$r_idxopt_overlay;
    long int credef$$_fill_1 [11];      /* Reserved 11 longwords            */
    } ;
#pragma standard

#endif					/* __CREDEF_LOADED */
#ifndef __CRFDEF_LOADED
#define __CRFDEF_LOADED	1

/*** MODULE $crfdef ***/
/*                                                                          */
/* CRF$INSRTREF ARGUMENT LIST                                               */
/*                                                                          */
#pragma nostandard
struct crfdef {
    long int crfdef$$_fill_1;           /* ARGUMENT COUNT                   */
    unsigned long int crf$l_ir_ctltbl;  /* CRF CONTROL TABLE ADR            */
    unsigned long int crf$l_ir_keyadr;  /* KEY ADDRESS                      */
    unsigned long int crf$l_ir_refadr;  /* REFERENCE INDICATOR ADR          */
    unsigned short int crf$w_ir_reflag; /* REFERENCE INDICATOR FLAGS        */
    char crfdef$$_fill_2 [2];           /* UNUSED                           */
    unsigned char crf$b_ir_defind;      /* DEFINITION INDICATOR             */
    char crfdef$$_fill_3 [3];           /* UNUSED                           */
/*                                                                          */
/* CRF$INSRTKEY ARGUMENT LIST                                               */
/*                                                                          */
    } ;
struct crfdef1 {
    long int crfdef$$_fill_4;           /* ARGUMENT COUNT                   */
    unsigned long int crf$l_ik_ctltbl;  /* CRF CONTROL TABLE ADR            */
    unsigned long int crf$l_ik_keyadr;  /* ADDRESS OF KEY                   */
    unsigned long int crf$l_ik_valadr;  /* ADDRESS OF VALUE                 */
    unsigned short int crf$w_ik_valflg; /* VALUE FLAGS                      */
    char crfdef$$_fill_5 [2];           /* UNUSED                           */
/*                                                                          */
/* CRF$OUT ARGUMENT LIST                                                    */
/*                                                                          */
    } ;
struct crfdef2 {
    long int crfdef$$_fill_6;           /* ARGUMENT COUNT                   */
    unsigned long int crf$l_ou_ctltbl;  /* CRF CONTROL TABLE ADR            */
    unsigned long int crf$l_ou_linwid;  /* OUTPUT LINE WIDTH                */
    unsigned char crf$b_ou_pag1;        /* ! LINES/PAGE 1                   */
    char crfdef$$_fill_7 [3];           /* UNUSED                           */
    unsigned char crf$b_ou_sucpag;      /* ! LINES/SUCCESSIVE PAGES         */
    char crfdef$$_fill_8 [3];           /* UNUSED                           */
    unsigned char crf$b_ou_prtind;      /* REF PRINT INDICATOR              */
    char crfdef$$_fill_9 [3];           /* UNUSED                           */
    unsigned char crf$b_ou_savind;      /* SAVE INDICATOR                   */
/*                                                                          */
/* CRF CONTROL TABLE OFFSETS                                                */
/*                                                                          */
    } ;
struct crfdef3 {
    unsigned long int crf$l_hasht;      /* HASH TABLE ADDRESS               */
    unsigned long int crf$l_lastkey;    /* LAST KEY LOOKED AT ADDRESS       */
    variant_union  {
        unsigned char crf$b_keytype;    /* TYPE OF KEY IN TABLE             */
        variant_struct  {
            unsigned crf$v_binary : 1;  /* 1 = KEY IS BINARY 0 = ASCII      */
            unsigned crf$v_fill_0 : 7;
            } crf$r_keytype_bits;
        } crf$r_keytype_overlay;
    unsigned char crf$b_flags;          /* MISC. FLAGS FOR FUTURE EXPANSION  */
    unsigned short int crf$w_errsts;    /* SECONDARY ERROR STATUS CODE      */
    unsigned long int crf$l_entries;    /* NUMBER OF ENTRIES IN CROSS REFERENCE  */
    unsigned long int crf$l_dynmem [2]; /* LISTHEAD OF DYNAMIC MEMORY       */
    unsigned long int crf$l_maxblk;     /* SIZE (IN BYTES) OF BLOCK TO ALLOCATE  */
    unsigned long int crf$l_memexp;     /* SIZE (IN PAGES) OF BLOCK TO ALLOCATE  */
    long int crfdef$$_fill_10 [8];      /* SPARES                           */
    unsigned long int crf$l_error;      /* ERROR ROUTINE ADDRESS            */
    unsigned long int crf$l_output;     /* OUTPUT ROUTINE ADDRESS           */
    unsigned long int crf$l_k1fmtbl;    /* KEY1 FIELD FORMAT TBL ADR        */
    unsigned long int crf$l_k2fmtbl;    /* KEY2 FIELD FORMAT TBL ADR        */
    unsigned long int crf$l_v1fmtbl;    /* VAL1 FIELD FORMAT TBL ADR        */
    unsigned long int crf$l_v2fmtbl;    /* VAL2 FIELD FORMAT TBL ADR        */
    unsigned long int crf$l_r1fmtbl;    /* REF1 FIELD FORMAT TBL ADR        */
    unsigned long int crf$l_r2fmtbl;    /* REF2 FIELD FORMAT TBL ADR        */
    } ;
#pragma standard

#endif					/* __CRFDEF_LOADED */
#ifndef __CRFMSG_LOADED
#define __CRFMSG_LOADED	1

/*** MODULE $crfmsg ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:20:05.59 */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* VERSION:	'V04-000'                                                   */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/* RETURN STATUS CODES FOR CROSS REFERENCE PROGRAM                          */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	V02-002	BLS0156		BENN SCHREIBER	 1-MAR-1982                 */
/*		REMOVE UNUSED MESSAGES                                      */
/*                                                                          */
/*	V02-001	BLS0123		BENN SCHREIBER	19-DEC-1981                 */
/*		CHANGE TEXT OF FAOFAIL                                      */
/*                                                                          */
/*                                                                          */
/* SUCCESS CODES		(SEVERITY LEVEL 1)                          */
/*                                                                          */
#define CREF$_FACILITY 101
#define CRF$_SUCCESS 6651905
#define CRF$_KEYPRVENTR 6651913
#define CRF$_KEY1STENTR 6651921
#define CRF$_REFPRVENTR 6651929
#define CRF$_UNUSERR 6651937
/*                                                                          */
/* SEVERE ERROR CODES		(SEVERITY LEVEL 2)                          */
/*                                                                          */
#define CRF$_UNUERR1 6651986
#define CRF$_UNUERR2 6651994
#define CRF$_UNUERR3 6652002
#define CRF$_UNUERR4 6652010
#define CRF$_UNUERR5 6652018
#define CRF$_UNUERR6 6652026
#define CRF$_UNUERR7 6652034
#define CRF$_NO_OUTRTN 6652042
#define CRF$_LINELNG 6652050
#define CRF$_FAOFAIL 6652058
#define CRF$_UNUERR8 6652066

#endif					/* __CRFMSG_LOADED */
#ifndef __CTYPE_LOADED
#define __CTYPE_LOADED	1

/*	CTYPE - V3.0 - Character Type Classification Macros	*/

#define _U	0x1
#define _L	0x2
#define _D	0x4
#define _S	0x8
#define _P	0x10
#define _C	0x20
#define _X	0x40
#define _B	0x80

#pragma nostandard
#ifdef CC$VAXCSHR
#define	_ctype_	(*vaxc$ga__ctype_)
globalref char _ctype_[];
#else
globalvalue c$v_ctypedefs;

extern char readonly _ctype_[];
#endif

#undef isupper
#undef islower
#undef isalpha
#undef isdigit
#undef isalnum
#undef isxdigit
#undef isspace
#undef ispunct
#undef isgraph
#undef isprint
#undef iscntrl
#undef isascii

#pragma standard

#define isupper(c)	(_ctype_[(c) & 0x7F] & _U)
#define islower(c)	(_ctype_[(c) & 0x7F] & _L)
#define isalpha(c)	(_ctype_[(c) & 0x7F] & (_U | _L))
#define isdigit(c)	(_ctype_[(c) & 0x7F] & _D)
#define isalnum(c)	(_ctype_[(c) & 0x7F] & (_U | _L | _D))
#define isxdigit(c)	(_ctype_[(c) & 0x7F] & _X)
#define isspace(c)	(_ctype_[(c) & 0x7F] & _S)
#define ispunct(c)	(_ctype_[(c) & 0x7F] & _P)
#define isgraph(c)	(_ctype_[(c) & 0x7F] & (_P | _U | _L | _D))
#define isprint(c)	(_ctype_[(c) & 0x7F] & (_P | _U | _L | _D | _B))
#define iscntrl(c)	(_ctype_[(c) & 0x7F] & _C)
#define isascii(c)	((unsigned)(c) <= 0x7F)

#define _toupper(c)	((c) >= 'a' && (c) <= 'z' ? (c) & 0x5F:(c))
#define _tolower(c)	((c) >= 'A' && (c) <= 'Z' ? (c) | 0x20:(c))

#define toascii(c)	((c) & 0x7F)

int toupper(char c);

int tolower(char c);

#endif					/* __CTYPE_LOADED */
#ifndef __CURSES_LOADED
#define __CURSES_LOADED	1

/*	CURSES - V3.0	*/

#pragma nostandard
# include ssdef
# include stdio
# include smgdef

# define	bool	char
# define	reg	register

# ifndef	TRUE
# define	TRUE	(1)
# define	FALSE	(0)
# endif
# define	ERR	(0)
# define	OK	(1)

# define	_SUBWIN		0001
# define	_ENDLINE	0002
# define	_FULLWIN	0004
# define	_SCROLLWIN	0010
# define	_FLUSH		0020
# define	_STANDOUT	0200

# define	_NOECHO		001
# define	_NONL		002
# define	_NOCRMODE	004
# define	_NORAW		010

# define	_BLINK		SMG$M_BLINK
# define	_BOLD		SMG$M_BOLD
# define	_REVERSE	SMG$M_REVERSE
# define	_UNDERLINE	SMG$M_UNDERLINE

struct	_win_st
{
	int	_cur_y, _cur_x;
	int	_max_y, _max_x;
	int	_beg_y, _beg_x;
	short	_flags;
	char	_clear, _leave, _scroll, _wrap;
	char	**_y;
	short	*_firstch, *_lastch;
	struct _win_st	*_next, *_parent, *_child;
	int	_id;
};


struct	_kb_st
{
	int	_id;
	unsigned char	_flags;
	struct
	{
		unsigned short	length;
		unsigned char	type;
		unsigned char	class;
		char		*address;
	}	_buffer_desc;
	int	_count;
	char	*_ptr;
};

struct	_pb_st
{
	int	_id;
	int	_rows, _cols;
	union	SMGDEF	*_attr;
	int	_attr_size;
};

# define	_KEYBOARD	struct _kb_st
# define	WINDOW		struct _win_st
# define	_PASTEBOARD	struct _pb_st


#ifdef CC$VAXCSHR

#define	LINES (*vaxc$ga_LINES)
#define	COLS (*vaxc$ga_COLS)
#define	stdscr (*vaxc$ga_stdscr)
#define	curscr (*vaxc$ga_curscr)
#define	stdkb (*vaxc$ga_stdkb)
#define	stdpb (*vaxc$ga_stdpb)

globalref int	LINES;
globalref int	COLS;
globalref WINDOW	*stdscr;
globalref WINDOW	*curscr;
globalref _KEYBOARD	*stdkb;
globalref _PASTEBOARD	*stdpb;

#else

extern	noshare int		LINES, COLS;
extern	noshare WINDOW		*stdscr, *curscr;
extern	noshare _KEYBOARD	*stdkb;
extern	noshare _PASTEBOARD	*stdpb;

#endif

# define	getch()		wgetch	(stdscr)
# define	addch(ch)	waddch	(stdscr, ch)
# define	addstr(string)	waddstr	(stdscr, string)
# define	move(y, x)	wmove	(stdscr, y, x)
# define	refresh()	wrefresh (stdscr)
# define	clear()		wclear	(stdscr)
# define	clrtobot()	wclrtobot (stdscr)
# define	clrtoeol()	wclrtoeol (stdscr)
# define	delch()		wdelch 	(stdscr)
# define	erase()		werase (stdscr)
# define	insch(ch)	winsch	(stdscr, ch)
# define	insertln()	winsertln (stdscr)
# define	standout()	wstandout (stdscr)
# define	standend()	wstandend (stdscr)
# define	getstr(string)	wgetstr	(stdscr, string)
# define	inch()		winch	(stdscr)
# define	setattr(attr)	wsetattr (stdscr, attr)
# define	clrattr(attr)	wclrattr (stdscr, attr)
# define	deleteln()	wdeleteln (stdscr)
# define	insstr(string)	winsstr (stdscr, string)

# define mvwaddch(win,y,x,ch)	(wmove(win,y,x)==ERR)?ERR:waddch(win,ch)
# define mvwgetch(win,y,x)	(wmove(win,y,x)==ERR)?ERR:wgetch(win)
# define mvwaddstr(win,y,x,str)	(wmove(win,y,x)==ERR)?ERR:waddstr(win,str)
# define mvwinsstr(win,y,x,str)	(wmove(win,y,x)==ERR)?ERR:winsstr(win,str)
# define mvwgetstr(win,y,x,str)	(wmove(win,y,x)==ERR)?ERR:wgetstr(win,str)
# define mvwinch(win,y,x)	(wmove(win,y,x)==ERR)?ERR:winch(win)
# define mvwdelch(win,y,x)	(wmove(win,y,x)==ERR)?ERR:wdelch(win)
# define mvwinsch(win,y,x,ch)	(wmove(win,y,x)==ERR)?ERR:winsch(win,ch)
# define mvwdeleteln(win,y,x)	(wmove(win,y,x)==ERR)?ERR:wdeleteln(win)
# define mvaddch(y,x,ch)	mvwaddch (stdscr, y, x, ch)
# define mvgetch(y,x)		mvwgetch (stdscr, y, x)
# define mvaddstr(y,x,str)	mvwaddstr (stdscr, y, x, str)
# define mvinsstr(y,x,str)	mvwinsstr (stdscr, y, x, str)
# define mvgetstr(y,x,str)	mvwgetstr (stdscr, y, x, str)
# define mvinch(y,x)		mvwinch (stdscr, y, x)
# define mvdelch(y,x)		mvwdelch (stdscr, y, x)
# define mvinsch(y,x,ch)	mvwinsch (stdscr, y, x, ch)
# define mvdeleteln(y,x)	mvwdeleteln (stdscr, y, x)
# define mvcur(ly,lx,ny,nx)	wmove (stdscr, ny, nx)
#pragma standard

# define clearok(win, bf)	(win->_clear = bf)
# define leaveok(win, bf)	(win->_leave = bf)
# define scrollok(win, bf)	(win->_scroll = bf)
# define wrapok(win, bf)	(win->_wrap = bf)
# define flushok(win,bf) (bf ? win->_flags |= _FLUSH : (win->_flags &= ~_FLUSH))
# define getyx(win,y,x)		y = win->_cur_y, x = win->_cur_x

# define echo()			(stdkb->_flags &= ~_NOECHO)
# define noecho()		(stdkb->_flags |= _NOECHO)
# define nl()			(stdkb->_flags &= ~_NONL)
# define nonl()			(stdkb->_flags |= _NONL)
# define crmode()		((stdkb->_flags &= ~_NOCRMODE), nonl ())
# define nocrmode()		(stdkb->_flags |= _NOCRMODE)
# define raw()			(stdkb->_flags &= ~_NORAW)
# define noraw()		(stdkb->_flags |= _NORAW)

# define check(status)	if (!(status & SS$_NORMAL))	\
			{	c$$translate (status); 	\
				return ERR;		\
			}

# define bool int

int waddch (WINDOW *win, char ch);

int waddstr (WINDOW *win, char *str);

int box (WINDOW *win, char vert, char hor);

int wclear (WINDOW *win);

int wclrattr (WINDOW *win, int attr);

int wclrtobot (WINDOW *win);

int wclrtoeol (WINDOW *win);

int wdelch (WINDOW *win);

int wdeleteln (WINDOW *win);

int delwin (WINDOW *win);

int endwin (void);

int werase (WINDOW *win);

int wgetch (WINDOW *win);

int wgetstr (WINDOW *win, char *str);

char winch (WINDOW *win);

WINDOW *initscr (void);

int winsch (WINDOW *win, char ch);

int winsertln (WINDOW *win);

int winsstr (WINDOW *win, char *str);

int longname (char *termbuf, char *name);

int mvwin (WINDOW *win, int st_row, int st_col);

int wmove (WINDOW *win, int y, int x);

WINDOW *newwin (int numlines, int numcols, int begin_y, int begin_x);

int overlay (WINDOW *win1, WINDOW *win2);

int overwrite (WINDOW *win1, WINDOW *win2);

#pragma NOSTANDARD
#undef printw
#undef wprintw
#undef wscanw
#undef scanw
#pragma STANDARD

int printw (char *format_spec, ...);

int wprintw (WINDOW *win, char *format_spec, ...);

int wrefresh (WINDOW *win);

int wscanw (WINDOW *win, char *format_spec, ...);

int	scanw (char *fmt, int arg1);

int scroll (WINDOW *win);

int wsetattr (WINDOW *win, int attr);

WINDOW *subwin (WINDOW *win, int numlines, int numcols,
			int begin_y, int begin_x);

int wstandend (WINDOW *win);

int wstandout (WINDOW *win);

int touchwin (WINDOW *win);

#if defined(CC$mixed_float) || defined(CC$VAXCSHR)

#ifndef CC$gfloat
#define CC$gfloat 0
#endif

#if CC$gfloat

#define printw  vaxc$gprintw
#define scanw   vaxc$gscanw
#define wprintw vaxc$gwprintw
#define wscanw  vaxc$gwscanw

#else

#define printw  vaxc$dprintw
#define scanw   vaxc$dscanw
#define wprintw vaxc$dwprintw
#define wscanw  vaxc$dwscanw

#endif
#endif

#endif					/* __CURSES_LOADED */
#ifndef __DCDEF_LOADED
#define __DCDEF_LOADED	1

/*** MODULE $dcdef ***/
/*                                                                          */
/* DEVICE ADAPTER, CLASS, AND TYPE DEFINITIONS                              */
/*                                                                          */
/*                                                                          */
/* DEFINE ADAPTER TYPES                                                     */
/*                                                                          */
/*DEFINE ADAPTER TYPES                                                      */
#define AT$_MBA 0                       /* MASSBUS ADAPTER                  */
#define AT$_UBA 1                       /* UNIBUS ADAPTER                   */
#define AT$_DR 2                        /* DR32 ADAPTER                     */
#define AT$_MPM 3                       /* MULTI-PORT MEMORY                */
#define AT$_CI 4                        /* CI BUS                           */
#define AT$_NULL 5                      /* NULL (SOFTWARE) ADAPTER          */
#define AT$_BDA 6                       /* BI DISK ADAPTER(KDB50)           */
#define AT$_DMB32 7                     /* DMB32 ADAPTER                    */
#define AT$_DRB32 8                     /* DRB32 ADAPTER                    */
#define AT$_BVP 9                       /* BVP GENERIC ADAPTER              */
#define AT$_BVP_SSP 10                  /* BVP STORAGE SYSTEMS PORT         */
#define AT$_BVP_NIP 11                  /* BVP NI PORT                      */
#define AT$_KA410 12                    /* VAXstar system                   */
#define AT$_GENBI 13                    /* Generic BI device                */
#define AT$_NBI 14                      /* NBIB on BI.                      */
#define AT$_DISK9 15
#define AT$_XBI 16
#define AT$_TERM9 17
#define AT$_TAPE9 18
#define AT$_PRTR9 19
#define AT$_SFUN9 20
#define AT$_USER9 21
#define AT$_MBUSIO 22
#define AT$_MBUSGFX 23
#define AT$_KA640 24
/*                                                                          */
/* DEFINE DEVICE CLASSES                                                    */
/*                                                                          */
/*DEFINE DEVICE CLASSES                                                     */
#define DC$_DISK 1                      /* DISK                             */
#define DC$_TAPE 2                      /* TAPES                            */
#define DC$_SCOM 32                     /* SYNCHRONOUS COMMUNICATIONS DEVICES  */
#define DC$_CARD 65                     /* CARD READER                      */
#define DC$_TERM 66                     /* TERMINAL                         */
#define DC$_LP 67                       /* LINE PRINTER                     */
#define DC$_WORKSTATION 70              /* WORKSTATIONS                     */
#define DC$_REALTIME 96                 /* REAL-TIME                        */
#define DC$_BUS 128                     /* BUSES, E.G, CI                   */
#define DC$_MAILBOX 160                 /* MAILBOX                          */
#define DC$_MISC 200                    /* MISCELLANEOUS DEVICES            */
/*                                                                          */
/* DEFINE DEVICE TYPES                                                      */
/*                                                                          */
/*                                                                          */
/* DISK DEVICES                                                             */
/*                                                                          */
#define DT$_RK06 1                      /*RK06 DISK                         */
#define DT$_RK07 2                      /*RK07 DISK                         */
#define DT$_RP04 3                      /*RP04 DISK                         */
#define DT$_RP05 4                      /*RP05 DISK                         */
#define DT$_RP06 5                      /*RP06 DISK                         */
#define DT$_RM03 6                      /*RM03 DISK                         */
#define DT$_RP07 7                      /*RP07 DISK                         */
#define DT$_RP07HT 8                    /*RP07 DISK WITH HEAD/TRACK         */
#define DT$_RL01 9                      /*RL01 DISK                         */
#define DT$_RL02 10                     /*RL02 DISK                         */
#define DT$_RX02 11                     /*RX02 DISK                         */
#define DT$_RX04 12                     /*RX04 DISK                         */
#define DT$_RM80 13                     /*RM80 DISK                         */
#define DT$_TU58 14                     /*TU58                              */
#define DT$_RM05 15                     /*RM05 DISK                         */
#define DT$_RX01 16                     /*RX01 DISK                         */
#define DT$_ML11 17                     /*ML11 disk                         */
#define DT$_RB02 18                     /*R02 ON RB730                      */
#define DT$_RB80 19                     /*R80 ON RB730                      */
#define DT$_RA80 20                     /*R80 ON INTELLIGENT CONTROLLER     */
#define DT$_RA81 21                     /*R81 ON INTELLIGENT CONTROLLER     */
#define DT$_RA60 22                     /*PINON ON INTELLIGENT CONTROLLER   */
#define DT$_RZ01 23                     /*AZTEC REMOVABLE (Old name)        */
#define DT$_RC25 23                     /*AZTEC REMOVABLE (New name)        */
#define DT$_RZF01 24                    /*AZTEC FIXED (Old name)            */
#define DT$_RCF25 24                    /*AZTEC FIXED (New name)            */
#define DT$_RD51 25                     /*RD51 FIXED DISK DRIVE             */
#define DT$_RX50 26                     /*RX50 FLOPPY DISK DRIVE            */
#define DT$_RD52 27                     /*RD52 FIXED DISK DRIVE             */
#define DT$_RD53 28                     /*RD53 FIXED DISK DRIVE             */
#define DT$_RD26 29                     /*RD26 FIXED DISK DRIVE             */
#define DT$_RA82 30                     /*RA82 FIXED DISK DRIVE             */
#define DT$_RD31 31                     /*RD31 FIXED DISK DRIVE             */
#define DT$_RD54 32                     /*RD54 FIXED DISK DRIVE             */
#define DT$_CRX50 33                    /*Console RX50                      */
#define DT$_RRD50 34                    /*RRD50                             */
#define DT$_GENERIC_DU 35               /*Brand X Disk                      */
#define DT$_RX33 36                     /*RX33 DISKETTE DRIVE               */
#define DT$_RX18 37                     /*RX18                              */
#define DT$_RA70 38
#define DT$_RA90 39
#define DT$_RD32 40
#define DT$_DISK9 41
#define DT$_RX35 42
#define DT$_RF30 43
#define DT$_RF70 44
#define DT$_RF71 44
#define DT$_RD33 45
#define DT$_ESE20 46
#define DT$_TU56 47
#define DT$_FD1 129                     /*FOREIGN DISK TYPE 1               */
#define DT$_FD2 130                     /*FOREIGN DISK TYPE 2               */
#define DT$_FD3 131                     /*FOREIGN DISK TYPE 3               */
#define DT$_FD4 132                     /*FOREIGN DISK TYPE 4               */
#define DT$_FD5 133                     /*FOREIGN DISK TYPE 5               */
#define DT$_FD6 134                     /*FOREIGN DISK TYPE 6               */
#define DT$_FD7 135                     /*FOREIGN DISK TYPE 7               */
#define DT$_FD8 136                     /*FOREIGN DISK TYPE 8               */
/*                                                                          */
/* TAPE DEVICES                                                             */
/*                                                                          */
#define DT$_TE16 1                      /*TE16 MAGTAPE                      */
#define DT$_TU45 2                      /*TU45 MAGTAPE                      */
#define DT$_TU77 3                      /*TU77 MAGTAPE                      */
#define DT$_TS11 4                      /*TS11 MAGTAPE                      */
#define DT$_TU78 5                      /*TU78 MAGTAPE                      */
#define DT$_TA78 6                      /*TA78 MAGTAPE                      */
#define DT$_TU80 7                      /*TU80 MAGTAPE                      */
#define DT$_TU81 8                      /*TU81 MAGTAPE                      */
#define DT$_TA81 9
#define DT$_TK50 10                     /*TK50 CARTRIDGE TAPE               */
#define DT$_MR_TU70 11                  /*TU70 STC TAPE (DX20)              */
#define DT$_MR_TU72 12                  /*TU72 STC TAPE                     */
#define DT$_MW_TSU05 13                 /*TSU05 TAPE (CSS)                  */
#define DT$_MW_TSV05 14                 /*TSV05 TAPE (CSS)                  */
#define DT$_TK70 15                     /*TK70 CARTRIDGE TAPE               */
#define DT$_RV20 16
#define DT$_RV80 16
#define DT$_TK60 17                     /*TK60 CARTRIDGE TAPE               */
#define DT$_GENERIC_TU 18               /*Brand X Tape                      */
#define DT$_TA79 19                     /*TA79                              */
#define DT$_TAPE9 20
#define DT$_TA90 21
#define DT$_TF30 22
#define DT$_TF70 23
#define DT$_RV60 24
/*                                                                          */
/* TERMINAL DEVICE TYPES                                                    */
/*                                                                          */
/* new definitions for terminal types should be placed in $ttdef only       */
/* this table remains around for compatibility only                         */
/*                                                                          */
/* **** MATCHES $TTDEF *****                                                */
#define DT$_TTYUNKN 0                   /* UNKNOWN TERMINAL                 */
#define DT$_VT05 1                      /* VT05                             */
#define DT$_FT1 16                      /* FOREIGN TERMINAL TYPES           */
#define DT$_FT2 17
#define DT$_FT3 18
#define DT$_FT4 19
#define DT$_FT5 20
#define DT$_FT6 21
#define DT$_FT7 22
#define DT$_FT8 23                      /* END OF FOREIGN TYPES             */
/* RESERVE REST UP TO 32 FOR EXTENSIONS                                     */
#define DT$_LAX 32                      /* LA TYPE TERMINAL                 */
#define DT$_LA36 32                     /* LA36                             */
#define DT$_LA120 33
#define DT$_VT5X 64                     /* VT5X TYPE                        */
#define DT$_VT52 64                     /* VT52                             */
#define DT$_VT55 65                     /* VT55                             */
#define DT$_TQ_BTS 4                    /* TQ_BTS                           */
#define DT$_TEK401X 10                  /* TEK401X series                   */
#define DT$_VT100 96                    /* VT100                            */
#define DT$_VK100 2
#define DT$_VT173 3
#define DT$_LA34 34
#define DT$_LA38 35
#define DT$_LA12 36
#define DT$_LA24 37
#define DT$_LA100 37
#define DT$_LQP02 38
#define DT$_VT101 97
#define DT$_VT102 98
#define DT$_VT105 99
#define DT$_VT125 100
#define DT$_VT131 101
#define DT$_VT132 102
#define DT$_DZ11 66                     /* DZ11 CONTROLLER                  */
#define DT$_DZ32 67                     /* DZ32 CONTROLLER                  */
#define DT$_DZ730 68                    /* DZ730 (COMBO) CONTROLLER         */
#define DT$_DMZ32 69                    /* DMZ32 CONTROLLER                 */
#define DT$_DHV 70                      /* DHV CONTROLLER                   */
#define DT$_DHU 71                      /* DHU CONTROLLER                   */
#define DT$_SLU 72                      /* Onboard Serial Line Unit         */
#define DT$_TERM9 73                    /*Terminal on 009                   */
#define DT$_LAT 74                      /* LAT terminals                    */
/*                                                                          */
/* Terminal WORKSTATIONS                                                    */
/*                                                                          */
#define DT$_VS100 1                     /* VAXstation 100                   */
#define DT$_VS125 2                     /* VAXstation 125                   */
#define DT$_VL_VS8200 3                 /* VAXstation 8200 (Lynx)           */
#define DT$_VD 4                        /* VAXstation Vir. Device           */
#define DT$_DECW_OUTPUT 5
#define DT$_DECW_INPUT 6
/*                                                                          */
/* SYNCHRONOUS COMMUNICATIONS DEVICE TYPES                                  */
/*                                                                          */
#define DT$_DMC11 1                     /* DMC11                            */
#define DT$_DMR11 2                     /* DMR11                            */
#define DT$_XK_3271 3                   /* DUP-11 FOR 3271 PROTOCOL EMULATOR  */
#define DT$_XJ_2780 4                   /* DUP-11 FOR 2780 " "              */
#define DT$_NW_X25 5                    /* X25 PROTOCOL EMULATOR            */
#define DT$_NV_X29 6                    /* X29 " "                          */
#define DT$_SB_ISB11 7                  /* ISB-11 DEC dataway               */
#define DT$_MX_MUX200 8                 /* MUX-200 PROTOCOL EMULATOR        */
#define DT$_DMP11 9                     /* DMP11                            */
#define DT$_DMF32 10                    /* DMF32                            */
#define DT$_XV_3271 11                  /* DV-11 3271 PROTOCOL EMULATOR     */
#define DT$_CI 12                       /* CI - Computer Interconnect       */
#define DT$_NI 13                       /* NI - Network Interconnect        */
#define DT$_UNA11 14                    /* UNIBUS to NI adapter             */
#define DT$_DEUNA 14                    /* UNIBUS to NI adapter             */
#define DT$_YN_X25 15                   /* KMS11 X.25 P. E.                 */
#define DT$_YO_X25 16                   /* " " "                            */
#define DT$_YP_ADCCP 17                 /* " ADCCP P.E.                     */
#define DT$_YQ_3271 18                  /* " " "                            */
#define DT$_YR_DDCMP 19                 /* " DDCMP                          */
#define DT$_YS_SDLC 20                  /* " SDLC                           */
#define DT$_UK_KTC32 21                 /* " KTC32                          */
#define DT$_DEQNA 22                    /* Q-BUS to NI adapter              */
#define DT$_DMV11 23                    /* DMV11                            */
#define DT$_ES_LANCE 24                 /* SCORPIO to NI adapter            */
#define DT$_DELUA 25                    /* LSI version of DEUNA             */
#define DT$_NQ_3271 26                  /* DHCF                             */
#define DT$_DMB32 27                    /* DMB32 (BICombo)                  */
#define DT$_YI_KMS11K 28                /* not a product, used by field service */
#define DT$_ET_DEBNT 29                 /* DEBNT (DEBNA grandpa)            */
#define DT$_ET_DEBNA 29                 /* DEBNA (BI-NI adapter)            */
#define DT$_SJ_DSV11 30                 /* DSV11 Q-BUS sync adapter         */
#define DT$_SL_DSB32 31                 /* DSB32 BI sync adaptor            */
#define DT$_ZS_DST32 32                 /* DST32, X25                       */
#define DT$_XQ_DELQA 33                 /* DELQA - Q-BUS to NI adaptor      */
/*                                                                          */
/* LINE PRINTER AND CARD READER DEVICE TYPES                                */
/*                                                                          */
#define DT$_LP11 1                      /* LP11                             */
#define DT$_LA11 2                      /* LA11                             */
#define DT$_LA180 3                     /* LA180                            */
#define DT$_LC_DMF32 4                  /* DMF32                            */
#define DT$_LI_DMB32 5                  /* DMB32                            */
#define DT$_PRTR9 6                     /*Printer on 009                    */
#define DT$_CR11 1                      /* CR11 CARD READER                 */
/*                                                                          */
/* MAILBOX DEVICE TYPES                                                     */
/*                                                                          */
#define DT$_MBX 1                       /* LOCAL MEMORY MAILBOX             */
#define DT$_SHRMBX 2                    /* SHARED MEMORY MAILBOX            */
#define DT$_NULL 3                      /* The NULL DEVICE                  */
/*                                                                          */
/* REALTIME DEVICE TYPES                                                    */
/*                                                                          */
#define DT$_LPA11 1                     /* LPA-11                           */
#define DT$_DR780 2                     /* DR780                            */
#define DT$_DR750 3                     /* DR750                            */
#define DT$_DR11W 4                     /* DR11W                            */
#define DT$_PCL11R 5                    /* PCL11 RECEIVER (CSS)             */
#define DT$_PCL11T 6                    /* PCL11 TRANSMTTER (CSS)           */
#define DT$_DR11C 7                     /* DR11C PARALLEL INTERFACE         */
#define DT$_BS_DT07 8                   /* UNIBUS SWITCH                    */
#define DT$_XP_PCL11B 9                 /* PCL-11B (DECNET and NONDECNET mode CSS) */
#define DT$_IX_IEX11 10                 /* IEEE-488 to UNIBUS INTERFACE     */
#define DT$_FP_FEPCM 11                 /* FEPCM CSS frontend processor     */
#define DT$_TK_FCM 12                   /* FEPCM CSS frontend processor     */
#define DT$_XI_DR11C 13                 /* PARALLEL INTERFACE ON DMF-32     */
#define DT$_XA_DRV11WA 14               /* DMA Parallel Interface           */
#define DT$_DRB32 15                    /* DRB32 (or MFA)                   */
#define DT$_HX_DRQ3B 16                 /* DRQ3B PARALLEL INTERFACE         */
/*                                                                          */
/* BUS CLASS DEVICES                                                        */
/*                                                                          */
#define DT$_CI780 1                     /* CI780                            */
#define DT$_CI750 2                     /* CI750                            */
#define DT$_UQPORT 3                    /* UQPORT is generic UDA            */
#define DT$_UDA50 3                     /* UDA50                            */
#define DT$_UDA50A 4                    /* UDA50A                           */
#define DT$_LESI 5                      /* Low end storage                  */
#define DT$_TU81P 6                     /* TU81 port                        */
#define DT$_RDRX 7                      /* RDRX port                        */
#define DT$_TK50P 8                     /* TK50 port                        */
#define DT$_RUX50P 9                    /* RUX50 port                       */
#define DT$_RC26P 10                    /* RC26P port                       */
#define DT$_QDA50 11                    /* KDA50 port (old name)            */
#define DT$_KDA50 11                    /* KDA50 port                       */
#define DT$_BDA50 12                    /* KDB50 port (old name)            */
#define DT$_KDB50 12                    /* KDB50 port (alias BDA50)         */
#define DT$_RRD50P 13                   /* RRD50 port                       */
#define DT$_QDA25 14                    /* KDA25 port (old name)            */
#define DT$_KDA25 14                    /* KDA25 port                       */
#define DT$_BCI750 15                   /* BI-CI750 port                    */
#define DT$_BCA 16                      /* BI-CI port                       */
#define DT$_RQDX3 17                    /* RQDX3 port                       */
#define DT$_NISCA 18                    /* NI-SCA port                      */
#define DT$_AIO 19                      /* BVP SSP port                     */
#define DT$_KFBTA 19                    /* BVP SSP port                     */
#define DT$_AIE 20                      /* BVP multi-port                   */
#define DT$_DEBNT 20                    /* BVP multi-port                   */
#define DT$_BSA 21
#define DT$_KSB50 21
#define DT$_TK70P 22                    /* TK70 port                        */
#define DT$_RV20P 23
#define DT$_RV80P 23
#define DT$_TK60P 24                    /* TK60 port                        */
#define DT$_SII 25
#define DT$_KFSQSA 26
#define DT$_SHAC 27
#define DT$_CIXCA 28
#define DT$_CIXCB 29
/*                                                                          */
/* MISCELLANEOUS DEVICES                                                    */
/*                                                                          */
#define DT$_DN11 1                      /* AUTODIALER                       */
#define DT$_PV 2                        /* Pseudo keyboard                  */
#define DT$_SFUN9 3
#define DT$_USER9 4
 

#endif					/* __DCDEF_LOADED */
/********************************************************************************************************************************/
/* Created 25-MAY-1990 18:34:19 by VAX SDL V3.2-10     Source: 28-NOV-1989 15:23:24 DECW$LIBSRESD:[DDIFLIB.SRC]DDIF$DEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE DDIF$DEFINITIONS IDENT V1-010 ***/
/*++                                                                        */
/*                                                                          */
/*  COPYRIGHT (c) 1987 BY                                                   */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                           */
/*  ALL RIGHTS RESERVED.                                                    */
/*                                                                          */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  */
/*  TRANSFERRED.                                                            */
/*                                                                          */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  */
/*  CORPORATION.                                                            */
/*                                                                          */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 */
/*                                                                          */
/* Item codes for CDA$CREATE_ROOT_AGGREGATE processing-options parameter.   */
#define DDIF$_INHERIT_ATTRIBUTES 1      /* Inherit segment attributes       */
#define DDIF$_RETAIN_DEFINITIONS 2      /* Enable DDIF$FIND_DEFINITION      */
#define DDIF$_EVALUATE_CONTENT 3        /* Evaluate generic content references */
#define DDIF$_DISCARD_I_SEGMENTS 4      /* Discard image data segments      */
#define DDIF$_DISCARD_2D_SEGMENTS 5     /* Discard graphics data segments   */
#define DDIF$_DISCARD_T_SEGMENTS 6      /* Discard text data segments       */
#define DDIF$_DISCARD_TBL_SEGMENTS 7    /* Discard table data segments      */
#define DDIF$_DISCARD_PDL_SEGMENTS 8    /* Discard page description language segments */
#define DDIF$_ENABLE_INHERIT_STATUS 9   /* Enable CDA$_INHERIT status       */
/* Scope codes for CDA$ENTER_SCOPE and CDA$LEAVE_SCOPE.                     */
/* If an aggregate type is listed, it must be presented with CDA$ENTER_SCOPE. */
#define DDIF$K_DOCUMENT_SCOPE 0         /* Document scope                   */
#define DDIF$K_CONTENT_SCOPE 1          /* Content scope                    */
#define DDIF$K_SEGMENT_SCOPE 2          /* Segment scope		DDIF$_SEG */
#define DDIF$K_EXTERNAL_SCOPE 3         /* External scope		DDIF$_EXT */
/* Aggregate type codes.                                                    */
#define DDIF$_DDF 1                     /* DDIF document root               */
#define DDIF$_DSC 2                     /* Document descriptor              */
#define DDIF$_DHD 3                     /* Document header                  */
#define DDIF$_SEG 4                     /* Document segment                 */
#define DDIF$_TXT 5                     /* Latin-1 text content             */
#define DDIF$_GTX 6                     /* General text content             */
#define DDIF$_HRD 7                     /* Hard directive                   */
#define DDIF$_SFT 8                     /* Soft directive                   */
#define DDIF$_HRV 9                     /* Hard value directive             */
#define DDIF$_SFV 10                    /* Soft value directive             */
#define DDIF$_BEZ 11                    /* Bezier curve content             */
#define DDIF$_LIN 12                    /* Polyline content                 */
#define DDIF$_ARC 13                    /* Arc content                      */
#define DDIF$_FAS 14                    /* Fill area set content            */
#define DDIF$_IMG 15                    /* Image content                    */
#define DDIF$_CRF 16                    /* Content reference                */
#define DDIF$_EXT 17                    /* External content                 */
#define DDIF$_PVT 18                    /* Private content                  */
#define DDIF$_GLY 19                    /* Layout galley                    */
#define DDIF$_EOS 20                    /* End of segment                   */
#define DDIF$_ERF 21                    /* External reference               */
#define DDIF$_IDU 22                    /* Image data unit                  */
#define DDIF$_PTH 23                    /* Composite path                   */
#define DDIF$_SGA 24                    /* Segment attributes               */
#define DDIF$_CTD 25                    /* Content definition               */
#define DDIF$_FTD 26                    /* Font definition                  */
#define DDIF$_LSD 27                    /* Line style definition            */
#define DDIF$_PHD 28                    /* Path definition                  */
#define DDIF$_PTD 29                    /* Pattern definition               */
#define DDIF$_SGB 30                    /* Segment binding definition       */
#define DDIF$_TYD 31                    /* Type definition                  */
#define DDIF$_CTS 32                    /* Counter style                    */
#define DDIF$_OCC 33                    /* Occurrence definition            */
#define DDIF$_RCD 34                    /* Record definition                */
#define DDIF$_RGB 35                    /* RGB lookup table entry           */
#define DDIF$_TRN 36                    /* Transform                        */
#define DDIF$_LG1 37                    /* Generic layout I                 */
#define DDIF$_LS1 38                    /* Specific layout I                */
#define DDIF$_LW1 39                    /* Wrap attributes I                */
#define DDIF$_LL1 40                    /* Layout attributes I              */
#define DDIF$_GLA 41                    /* Galley attributes                */
#define DDIF$_PGD 42                    /* Page description                 */
#define DDIF$_PGL 43                    /* Page layout                      */
#define DDIF$_PGS 44                    /* Page select                      */
#define DDIF$_TBS 45                    /* Tab stop                         */
#define DDIF$_MAX 46                    /* Maximum code plus 1              */
/* Item codes for all aggregates.  DDIF$_AGGREGATE_TYPE is read-only.       */
#define DDIF$_USER_CONTEXT 1            /* User context			Longword */
#define DDIF$_AGGREGATE_TYPE 2          /* Aggregate type code		Word */
#define DDIF$_ALL_MAX 3                 /* Maximum code plus 1              */
/* Values of data type enumeration for Measurement and Expression.          */
#define DDIF$K_VALUE_CONSTANT 0         /*				Integer */
#define DDIF$K_VALUE_VARIABLE 1         /*				String */
/* Values of data type enumeration for AngleRef.                            */
#define DDIF$K_ANGLE_CONSTANT 0         /*				Single precision floating */
#define DDIF$K_ANGLE_VARIABLE 1         /*				String */
/* Item codes for DDIF Document Root aggregate.                             */
#define DDIF$_DDF_DESCRIPTOR 257        /* Document descriptor		DDIF$_DSC */
#define DDIF$_DDF_HEADER 258            /* Document header		DDIF$_DHD */
#define DDIF$_DDF_CONTENT 259           /* Document content		DDIF$_SEG */
#define DDIF$_DDF_MAX 260               /* Maximum code plus 1              */
/* Item codes for Document Descriptor aggregate.  During CDA$PUT_AGGREGATE, the values of DDIF$_DSC_MAJOR_VERSION and */
/* DDIF$_DSC_MINOR_VERSION are not used.  The document always contains the current values for major and minor version. */
#define DDIF$_DSC_MAJOR_VERSION 513     /* Major version		Integer */
#define DDIF$_DSC_MINOR_VERSION 514     /* Minor version		Integer */
#define DDIF$_DSC_PRODUCT_IDENTIFIER 515 /* Product identifier		String */
#define DDIF$_DSC_PRODUCT_NAME 516      /* Product name			Array of character string */
#define DDIF$_DSC_MAX 517               /* Maximum code plus 1              */
/* Current values for major and minor standard version.                     */
#define DDIF$K_MAJOR_VERSION 1
#define DDIF$K_MINOR_VERSION 0
/* Item codes for Document Header aggregate.                                */
#define DDIF$_DHD_PRIVATE_DATA 769      /* Private header data		Sequence of DDIF$_PVT */
#define DDIF$_DHD_TITLE 770             /* Title			Array of character string */
#define DDIF$_DHD_AUTHOR 771            /* Author			Array of character string */
#define DDIF$_DHD_VERSION 772           /* Version			Array of character string */
#define DDIF$_DHD_DATE 773              /* Date				String */
#define DDIF$_DHD_CONFORMANCE_TAGS 774  /* Conformance tags		Array of string with add-info */
#define DDIF$_DHD_EXTERNAL_REFERENCES 775 /* External references		Sequence of DDIF$_ERF */
#define DDIF$_DHD_LANGUAGES_C 776       /* Languages			Array of enumeration */
#define DDIF$_DHD_LANGUAGES 777         /*				Array of variable */
#define DDIF$_DHD_STYLE_GUIDE 778       /* Style guide			Integer */
#define DDIF$_DHD_MAX 779               /* Maximum code plus 1              */
/* Values of the add-info parameter for DDIF$_DHD_CONFORMANCE_TAGS.         */
#define DDIF$K_PRIVATE_CONFORMANCE 0    /* Nonstandard                      */
#define DDIF$K_SRQ_CONFORMANCE 1        /* "$SRQ" (structure required)      */
/* Values of DDIF$_DHD_LANGUAGES_C.                                         */
#define DDIF$K_ISO_639_LANGUAGE 0       /* ISO 639 language name	String */
#define DDIF$K_OTHER_LANGUAGE 1         /* Other language name		Character string */
/* Item codes for Document Segment aggregate.                               */
#define DDIF$_SEG_ID 1025               /* Segment ID			String */
#define DDIF$_SEG_USER_LABEL 1026       /* User label			Array of character string */
#define DDIF$_SEG_SEGMENT_TYPE 1027     /* Segment type			String */
#define DDIF$_SEG_SPECIFIC_ATTRIBUTES 1028 /* Specific attributes		DDIF$_SGA */
#define DDIF$_SEG_GENERIC_LAYOUT 1029   /* Generic layout		DDIF$_LG1 */
#define DDIF$_SEG_SPECIFIC_LAYOUT 1030  /* Specific layout		DDIF$_LS1 */
#define DDIF$_SEG_CONTENT 1031          /* Segment content		Sequence of content */
#define DDIF$_SEG_MAX 1032              /* Maximum code plus 1              */
/* Item codes for Latin-1 Text Content aggregate.                           */
#define DDIF$_TXT_CONTENT 1281          /* Text content			String */
#define DDIF$_TXT_MAX 1282              /* Maximum code plus 1              */
/* Item codes for General Text Content aggregate.                           */
#define DDIF$_GTX_CONTENT 1537          /* Text content			Character string */
#define DDIF$_GTX_MAX 1538              /* Maximum code plus 1              */
/* Item codes for Hard Directive aggregate.                                 */
#define DDIF$_HRD_DIRECTIVE 1793        /* Hard directive		Enumeration */
#define DDIF$_HRD_MAX 1794              /* Maximum code plus 1              */
/* Item codes for Soft Directive aggregate.                                 */
#define DDIF$_SFT_DIRECTIVE 2049        /* Soft directive		Enumeration */
#define DDIF$_SFT_MAX 2050              /* Maximum code plus 1              */
/* Values of DDIF$_HRD_DIRECTIVE, DDIF$_SFT_DIRECTIVE,			DDIF conforming */
/* DDIF$_LL1_INITIAL_DIRECTIVE.                                             */
#define DDIF$K_DIR_NEW_PAGE 1           /* New page                         */
#define DDIF$K_DIR_NEW_LINE 2           /* New line                         */
#define DDIF$K_DIR_NEW_GALLEY 3         /* New galley                       */
#define DDIF$K_DIR_TAB 4                /* Tab                              */
#define DDIF$K_DIR_SPACE 5              /* Space                            */
#define DDIF$K_DIR_HYPHEN_NEW_LINE 6    /* Hyphen and new line              */
#define DDIF$K_DIR_WORD_BREAK_POINT 7   /* Word break point                 */
#define DDIF$K_DIR_LEADERS 8            /* Leaders                          */
#define DDIF$K_DIR_BACKSPACE 9          /* Backspace                        */
#define DDIF$K_DIR_NULL 10              /* Null                             */
#define DDIF$K_DIR_NO_HYPHEN_WORD 11    /* No hyphenation in next word      */
/* Item codes for Hard Value Directive aggregate.                           */
#define DDIF$_HRV_C 2305                /* Directive choice		Enumeration */
#define DDIF$_HRV_ESC_RATIO_N 2306      /* Escapement ratio		Integer */
#define DDIF$_HRV_ESC_RATIO_D 2307      /*				Integer */
#define DDIF$_HRV_ESC_CONSTANT_C 2308   /* Escapement constant		Measurement enumeration */
#define DDIF$_HRV_ESC_CONSTANT 2309     /*				Variable */
#define DDIF$_HRV_RESET_VARIABLE 2310   /* Reset variable		String */
#define DDIF$_HRV_RESET_VALUE_C 2311    /* Reset value			Expression enumeration */
#define DDIF$_HRV_RESET_VALUE 2312      /*				Variable */
#define DDIF$_HRV_MAX 2313              /* Maximum code plus 1              */
/* Item codes for Soft Value Directive aggregate.                           */
#define DDIF$_SFV_C 2561                /* Directive choice		Enumeration */
#define DDIF$_SFV_ESC_RATIO_N 2562      /* Escapement ratio		Integer */
#define DDIF$_SFV_ESC_RATIO_D 2563      /*				Integer */
#define DDIF$_SFV_ESC_CONSTANT_C 2564   /* Escapement constant		Measurement enumeration */
#define DDIF$_SFV_ESC_CONSTANT 2565     /*				Variable */
#define DDIF$_SFV_RESET_VARIABLE 2566   /* Reset variable		String */
#define DDIF$_SFV_RESET_VALUE_C 2567    /* Reset value			Expression enumeration */
#define DDIF$_SFV_RESET_VALUE 2568      /*				Variable */
#define DDIF$_SFV_MAX 2569              /* Maximum code plus 1              */
/* Values of DDIF$_HRV_C, DDIF$_SFV_C.                                      */
#define DDIF$K_DIR_ESCAPEMENT 0         /* Escapement directive		HRV_ESC_RATIO_N to HRV_ESC_CONSTANT */
/*				SFV_ESC_RATIO_N to SFV_ESC_CONSTANT         */
#define DDIF$K_DIR_VARIABLE_RESET 1     /* Variable reset		HRV_RESET_VARIABLE to HRV_RESET_VALUE */
/*				SFV_RESET_VARIABLE to SFV_RESET_VALUE       */
/* Item codes for Bezier Curve Content aggregate.                           */
#define DDIF$_BEZ_FLAGS 2817            /* Flags			Longword */
#define DDIF$_BEZ_PATH_C 2818           /* Path				Array of Measurement enumeration */
#define DDIF$_BEZ_PATH 2819             /*				Array of variable */
#define DDIF$_BEZ_MAX 2820              /* Maximum code plus 1              */
/* Bit definitions for DDIF$_BEZ_FLAGS.					DDIF conforming */
#define ddif$m_bez_draw_curve 1
#define ddif$m_bez_fill_curve 2
#define ddif$m_bez_close_curve 4
struct bez_flags {
    unsigned ddif$v_bez_draw_curve : 1; /* Draw curve                       */
    unsigned ddif$v_bez_fill_curve : 1; /* Fill curve                       */
    unsigned ddif$v_bez_close_curve : 1; /* Close curve                     */
    unsigned ddif$v_bez_fill : 29;
    } ;
/* Item codes for Polyline Content aggregate.                               */
#define DDIF$_LIN_FLAGS 3073            /* Flags			Longword */
#define DDIF$_LIN_DRAW_PATTERN 3074     /* Draw pattern			Bit string */
#define DDIF$_LIN_PATH_C 3075           /* Path				Array of Measurement enumeration */
#define DDIF$_LIN_PATH 3076             /*				Array of variable */
#define DDIF$_LIN_MAX 3077              /* Maximum code plus 1              */
/* Bit definitions for DDIF$_LIN_FLAGS.					DDIF conforming */
#define ddif$m_lin_draw_polyline 1
#define ddif$m_lin_fill_polyline 2
#define ddif$m_lin_draw_markers 4
#define ddif$m_lin_regular_polygon 8
#define ddif$m_lin_close_polyline 16
#define ddif$m_lin_rounded_polyline 32
#define ddif$m_lin_rectangular_polygon 64
struct lin_flags {
    unsigned ddif$v_lin_draw_polyline : 1; /* Draw polyline                 */
    unsigned ddif$v_lin_fill_polyline : 1; /* Fill polyline                 */
    unsigned ddif$v_lin_draw_markers : 1; /* Draw markers                   */
    unsigned ddif$v_lin_regular_polygon : 1; /* Regular polygon             */
    unsigned ddif$v_lin_close_polyline : 1; /* Close polyline               */
    unsigned ddif$v_lin_rounded_polyline : 1; /* Rounded polyline           */
    unsigned ddif$v_lin_rectangular_polygon : 1; /* Rectangular polygon     */
    unsigned ddif$v_lin_fill : 25;
    } ;
/* Item codes for Arc Content aggregate.                                    */
#define DDIF$_ARC_FLAGS 3329            /* Flags			Longword */
#define DDIF$_ARC_CENTER_X_C 3330       /* Center X			Measurement enumeration */
#define DDIF$_ARC_CENTER_X 3331         /*				Variable */
#define DDIF$_ARC_CENTER_Y_C 3332       /* Center Y			Measurement enumeration */
#define DDIF$_ARC_CENTER_Y 3333         /*				Variable */
#define DDIF$_ARC_RADIUS_X_C 3334       /* Radius X			Measurement enumeration */
#define DDIF$_ARC_RADIUS_X 3335         /*				Variable */
#define DDIF$_ARC_RADIUS_DELTA_Y_C 3336 /* Radius delta Y		Measurement enumeration */
#define DDIF$_ARC_RADIUS_DELTA_Y 3337   /*				Variable */
#define DDIF$_ARC_START_C 3338          /* Start angle			AngleRef enumeration */
#define DDIF$_ARC_START 3339            /*				Variable */
#define DDIF$_ARC_EXTENT_C 3340         /* Extent			AngleRef enumeration */
#define DDIF$_ARC_EXTENT 3341           /*				Variable */
#define DDIF$_ARC_ROTATION_C 3342       /* Rotation			AngleRef enumeration */
#define DDIF$_ARC_ROTATION 3343         /*				Variable */
#define DDIF$_ARC_MAX 3344              /* Maximum code plus 1              */
/* Bit definitions for DDIF$_ARC_FLAGS.					DDIF conforming */
#define ddif$m_arc_draw_arc 1
#define ddif$m_arc_fill_arc 2
#define ddif$m_arc_pie_arc 4
#define ddif$m_arc_close_arc 8
struct arc_flags {
    unsigned ddif$v_arc_draw_arc : 1;   /* Draw arc                         */
    unsigned ddif$v_arc_fill_arc : 1;   /* Fill arc                         */
    unsigned ddif$v_arc_pie_arc : 1;    /* Pie arc                          */
    unsigned ddif$v_arc_close_arc : 1;  /* Close arc                        */
    unsigned ddif$v_arc_flags_fill : 28;
    } ;
/* Item codes for Fill Area Set Content aggregate.                          */
#define DDIF$_FAS_FLAGS 3585            /* Flags			Longword */
#define DDIF$_FAS_PATH 3586             /* Path    			Sequence of DDIF$_PTH */
#define DDIF$_FAS_MAX 3587              /* Maximum code plus 1              */
/* Bit definitions for DDIF$_FAS_FLAGS.					DDIF conforming */
#define ddif$m_fas_co_draw_border 1
#define ddif$m_fas_co_fill_area 2
struct fas_flags {
    unsigned ddif$v_fas_co_draw_border : 1; /* Co-draw border               */
    unsigned ddif$v_fas_co_fill_area : 1; /* Co-fill area                   */
    unsigned ddif$v_fas_fill : 30;
    } ;
/* Item codes for Image Content aggregate.                                  */
#define DDIF$_IMG_CONTENT 3841          /* Image content		Sequence of DDIF$_IDU */
#define DDIF$_IMG_MAX 3842              /* Maximum code plus 1              */
/* Item codes for Content Reference aggregate.                              */
#define DDIF$_CRF_TRANSFORM 4097        /* Content transform		Sequence of DDIF$_TRN */
#define DDIF$_CRF_REFERENCE 4098        /* Content reference		String */
#define DDIF$_CRF_MAX 4099              /* Maximum code plus 1              */
/* Item codes for External Content aggregate.                               */
#define DDIF$_EXT_DIRECT_REFERENCE 4353 /* Direct reference		Object identifier */
#define DDIF$_EXT_INDIRECT_REFERENCE 4354 /* Indirect reference		Integer */
#define DDIF$_EXT_DATA_VALUE_DESCRIPTOR 4355 /* Data value descriptor	String */
#define DDIF$_EXT_ENCODING_C 4356       /* Encoding			Enumeration */
#define DDIF$_EXT_ENCODING 4357         /*				Variable */
#define DDIF$_EXT_ENCODING_L 4358       /*     Length (on input)	Integer */
#define DDIF$_EXT_MAX 4359              /* Maximum code plus 1              */
/* Values of DDIF$_EXT_ENCODING_C.                                          */
#define DDIF$K_DOCUMENT_ENCODING 0      /* Nested document		Document root aggregate */
#define DDIF$K_DDIS_ENCODING 1          /* Nested document		DDIS encoding */
#define DDIF$K_OCTET_ENCODING 2         /* Octet aligned		String */
#define DDIF$K_ARBITRARY_ENCODING 3     /* Arbitrary			Bit string */
/* Item codes for Private Content aggregate.                                */
#define DDIF$_PVT_NAME 4609             /* Value name			String */
#define DDIF$_PVT_DATA_C 4610           /* Value data			Enumeration */
#define DDIF$_PVT_DATA 4611             /*				Variable */
#define DDIF$_PVT_REFERENCE_ERF_INDEX 4612 /*     Reference index		Integer */
#define DDIF$_PVT_MAX 4613              /* Maximum code plus 1              */
/* Values of DDIF$_PVT_DATA_C.                                              */
#define DDIF$K_VALUE_BOOLEAN 0          /*				Boolean */
#define DDIF$K_VALUE_INTEGER 1          /*				Integer */
#define DDIF$K_VALUE_TEXT 2             /*				Array of character string */
#define DDIF$K_VALUE_GENERAL 3          /*				String */
#define DDIF$K_VALUE_REFERENCE 4        /*				String (DDIF$_PVT_REFERENCE_ERF_INDEX used) */
#define DDIF$K_VALUE_LIST 5             /*				Sequence of DDIF$_PVT */
#define DDIF$K_VALUE_EXTERNAL 6         /*				DDIF$_EXT */
/* Item codes for Layout Galley aggregate.                                  */
#define DDIF$_GLY_ID 4865               /* Galley ID			String */
#define DDIF$_GLY_BOUNDING_BOX_LL_X_C 4866 /* Galley bounding box		Measurement enumeration */
#define DDIF$_GLY_BOUNDING_BOX_LL_X 4867 /*     Lower left X coordinate	Variable */
#define DDIF$_GLY_BOUNDING_BOX_LL_Y_C 4868 /*				Measurement enumeration */
#define DDIF$_GLY_BOUNDING_BOX_LL_Y 4869 /*     Lower left Y coordinate	Variable */
#define DDIF$_GLY_BOUNDING_BOX_UR_X_C 4870 /*				Measurement enumeration */
#define DDIF$_GLY_BOUNDING_BOX_UR_X 4871 /*     Upper right X coordinate	Variable */
#define DDIF$_GLY_BOUNDING_BOX_UR_Y_C 4872 /*				Measurement enumeration */
#define DDIF$_GLY_BOUNDING_BOX_UR_Y 4873 /*     Upper right Y coordinate	Variable */
#define DDIF$_GLY_OUTLINE 4874          /* Galley outline		Sequence of DDIF$_PTH */
#define DDIF$_GLY_FLAGS 4875            /* Galley flags			Longword */
#define DDIF$_GLY_STREAMS 4876          /* Galley streams		Array of string */
#define DDIF$_GLY_SUCCESSOR_C 4877      /* Successor			Enumeration */
#define DDIF$_GLY_SUCCESSOR 4878        /*				Variable */
#define DDIF$_GLY_MAX 4879              /* Maximum code plus 1              */
/* Bit definitions for DDIF$_GLY_FLAGS.					DDIF conforming */
#define ddif$m_gly_vertical_align 1
#define ddif$m_gly_border 2
#define ddif$m_gly_autoconnect 4
#define ddif$m_gly_background_fill 8
struct gly_flags {
    unsigned ddif$v_gly_vertical_align : 1; /* Vertical align               */
    unsigned ddif$v_gly_border : 1;     /* Border                           */
    unsigned ddif$v_gly_autoconnect : 1; /* Autoconnect                     */
    unsigned ddif$v_gly_background_fill : 1; /* Background fill             */
    unsigned ddif$v_gly_fill : 28;
    } ;
/* Values of DDIF$_GLY_SUCCESSOR_C.                                         */
#define DDIF$K_GENERIC_GALLEY 0         /* Generic galley		String */
#define DDIF$K_SPECIFIC_GALLEY 1        /* Specific galley		String */
#define DDIF$K_NO_SUCCESSOR_GALLEY 2    /* No successor galley		None */
/* Item codes for External Reference aggregate.                             */
#define DDIF$_ERF_DATA_TYPE 5377        /* Data type			Object identifier */
#define DDIF$_ERF_DESCRIPTOR 5378       /* Descriptor			Array of character string */
#define DDIF$_ERF_LABEL 5379            /* Label			Character string */
#define DDIF$_ERF_LABEL_TYPE 5380       /* Label type			String with add-info */
#define DDIF$_ERF_CONTROL 5381          /* Control			Enumeration */
#define DDIF$_ERF_MAX 5382              /* Maximum code plus 1              */
/* Values of the add-info parameter for DDIF$_ERF_LABEL_TYPE.               */
#define DDIF$K_PRIVATE_LABEL_TYPE 0     /* Private label type               */
#define DDIF$K_RMS_LABEL_TYPE 1         /* RMS file specification ("$RMS")  */
#define DDIF$K_UTX_LABEL_TYPE 2         /* ULTRIX file specification ("$UTX") */
#define DDIF$K_MDS_LABEL_TYPE 3         /* MS-DOS file specification ("$MDS") */
#define DDIF$K_STYLE_LABEL_TYPE 4       /* Style-guide file specification ("$STYLE") */
#define DDIF$K_OS2_LABEL_TYPE 5         /* OS/2 file specification ("$OS2") */
/* Values of DDIF$_ERF_CONTROL.						DDIF conforming */
#define DDIF$K_COPY_REFERENCE 1         /* Copy on reference                */
#define DDIF$K_NO_COPY_REFERENCE 2      /* No copy on reference             */
/* Item codes for Image Data Unit aggregate.                                */
#define DDIF$_IDU_PRIVATE_CODING_ATTR 5633 /* Private coding attributes	Sequence of DDIF$_PVT */
#define DDIF$_IDU_PIXELS_PER_LINE 5634  /* Pixels per line		Integer */
#define DDIF$_IDU_NUMBER_OF_LINES 5635  /* Number of lines		Integer */
#define DDIF$_IDU_COMPRESSION_TYPE 5636 /* Compression type		Enumeration */
#define DDIF$_IDU_COMPRESSION_PARAMS 5637 /* Compression parameters	Sequence of DDIF$_PVT */
#define DDIF$_IDU_DATA_OFFSET 5638      /* Data offset			Integer */
#define DDIF$_IDU_PIXEL_STRIDE 5639     /* Pixel stride			Integer */
#define DDIF$_IDU_SCANLINE_STRIDE 5640  /* Scanline stride		Integer */
#define DDIF$_IDU_PIXEL_ORDER 5641      /* Pixel order			Enumeration */
#define DDIF$_IDU_BITS_PER_PIXEL 5642   /* Plane bits per pixel		Integer */
#define DDIF$_IDU_PLANE_DATA 5643       /* Plane data			String */
#define DDIF$_IDU_MAX 5644              /* Maximum code plus 1              */
/* Values of DDIF$_IDU_COMPRESSION_TYPE.				DDIF conforming */
#define DDIF$K_PRIVATE_COMPRESSION 1    /* Private                          */
#define DDIF$K_PCM_COMPRESSION 2        /* Raw bitmap                       */
#define DDIF$K_G31D_COMPRESSION 3       /* CCITT Group 3 1 dimensional      */
#define DDIF$K_G32D_COMPRESSION 4       /* CCITT Group 3 2 dimensional      */
#define DDIF$K_G42D_COMPRESSION 5       /* CCITT Group 4 2 dimensional      */
/* Values of DDIF$_IDU_PIXEL_ORDER.					DDIF conforming */
#define DDIF$K_STANDARD_PIXEL_ORDER 1   /* Standard pixel order             */
#define DDIF$K_REVERSE_PIXEL_ORDER 2    /* Reverse pixel order              */
/* Item codes for Composite Path aggregate.                                 */
#define DDIF$_PTH_C 5889                /* Path choice			Enumeration */
#define DDIF$_PTH_LIN_PATH_C 5890       /* Line path			Array of Measurement enumeration */
#define DDIF$_PTH_LIN_PATH 5891         /*				Array of variable */
#define DDIF$_PTH_BEZ_PATH_C 5892       /* Cubic Bezier path		Array of Measurement enumeration */
#define DDIF$_PTH_BEZ_PATH 5893         /*				Array of variable */
#define DDIF$_PTH_ARC_CENTER_X_C 5894   /* Center X			Measurement enumeration */
#define DDIF$_PTH_ARC_CENTER_X 5895     /*				Variable */
#define DDIF$_PTH_ARC_CENTER_Y_C 5896   /* Center Y			Measurement enumeration */
#define DDIF$_PTH_ARC_CENTER_Y 5897     /*				Variable */
#define DDIF$_PTH_ARC_RADIUS_X_C 5898   /* Radius X			Measurement enumeration */
#define DDIF$_PTH_ARC_RADIUS_X 5899     /*				Variable */
#define DDIF$_PTH_ARC_RADIUS_DELTA_Y_C 5900 /* Radius delta Y		Measurement enumeration */
#define DDIF$_PTH_ARC_RADIUS_DELTA_Y 5901 /*				Variable */
#define DDIF$_PTH_ARC_START_C 5902      /* Start angle			AngleRef enumeration */
#define DDIF$_PTH_ARC_START 5903        /*				Variable */
#define DDIF$_PTH_ARC_EXTENT_C 5904     /* Extent			AngleRef enumeration */
#define DDIF$_PTH_ARC_EXTENT 5905       /*				Variable */
#define DDIF$_PTH_ARC_ROTATION_C 5906   /* Rotation			AngleRef enumeration */
#define DDIF$_PTH_ARC_ROTATION 5907     /*				Variable */
#define DDIF$_PTH_REFERENCE 5908        /* Path reference		Integer */
#define DDIF$_PTH_MAX 5909              /* Maximum code plus 1              */
/* Values of DDIF$_PTH_C.                                                   */
#define DDIF$K_PATH_LINE 0              /*				PTH_LIN_PATH_C to PTH_LIN_PATH */
#define DDIF$K_PATH_BEZIER 1            /*				PTH_BEZ_PATH_C to PTH_BEZ_PATH */
#define DDIF$K_PATH_ARC 2               /*				PTH_ARC_CENTER_X_C to PTH_ARC_ROTATION */
#define DDIF$K_PATH_REFERENCE 3         /*				PTH_REFERENCE */
/* Item codes for Segment Attributes aggregate.  SGA_ITEM_CHANGE_LIST is read-only. */
#define DDIF$_SGA_PRIVATE_DATA 6145     /* Private attributes		Sequence of DDIF$_PVT */
#define DDIF$_SGA_CONTENT_STREAMS 6146  /* Content streams		Array of string */
#define DDIF$_SGA_CONTENT_CATEGORY 6147 /* Content category		String with add-info */
#define DDIF$_SGA_SEGMENT_TAGS 6148     /* Segment tags			Array of string with add-info */
#define DDIF$_SGA_BINDING_DEFNS 6149    /* Segment bindings		Sequence of DDIF$_SGB */
#define DDIF$_SGA_COMPUTE_C 6150        /* Computed content choice	Enumeration */
#define DDIF$_SGA_CPTCPY_TARGET 6151    /* Reference target		String */
#define DDIF$_SGA_CPTCPY_ERF_INDEX 6152 /* Reference external index	Integer */
#define DDIF$_SGA_CPTVAR_VARIABLE 6153  /* Variable name		String */
#define DDIF$_SGA_CPTXRF_TARGET 6154    /* Cross-reference target	String */
#define DDIF$_SGA_CPTXRF_ERF_INDEX 6155 /* Cross-reference index	Integer */
#define DDIF$_SGA_CPTXRF_VARIABLE 6156  /* Variable name		String */
#define DDIF$_SGA_CPTFNC_NAME 6157      /* Function name		String */
#define DDIF$_SGA_CPTFNC_PARAMETERS 6158 /* Function parameters		Sequence of DDIF$_PVT */
#define DDIF$_SGA_STRUCTURE_DESC_C 6159 /* Structure description	Enumeration */
#define DDIF$_SGA_STRUCTURE_DESC 6160   /* 				Sequence of DDIF$_OCC */
#define DDIF$_SGA_LANGUAGE 6161         /* Language			Integer */
#define DDIF$_SGA_LEGEND_UNIT_N 6162    /* Legend units			Integer */
#define DDIF$_SGA_LEGEND_UNIT_D 6163    /*				Integer */
#define DDIF$_SGA_LEGEND_UNIT_NAME 6164 /* Legend name			Array of character string */
#define DDIF$_SGA_UNITS_PER_MEASURE 6165 /* Units per measurement	Integer */
#define DDIF$_SGA_UNIT_NAME 6166        /* Units name			Array of character string */
#define DDIF$_SGA_ALT_PRESENTATION 6167 /* Alternate presentation	Array of character string */
#define DDIF$_SGA_LAYOUT_C 6168         /* Layout choice		Enumeration */
#define DDIF$_SGA_LAYGLY_WRAP 6169      /* Galley wrap attributes	DDIF$_LW1 */
#define DDIF$_SGA_LAYGLY_LAYOUT 6170    /* Galley layout attributes	DDIF$_LL1 */
#define DDIF$_SGA_LAYPTH_PATH 6171      /* String layout path		Sequence of DDIF$_PTH */
#define DDIF$_SGA_LAYPTH_FORMAT 6172    /* String layout format		Enumeration */
#define DDIF$_SGA_LAYPTH_ORIENTATION_C 6173 /* Character orientation	Enumeration */
#define DDIF$_SGA_LAYPTH_ORIENTATION 6174 /*				Variable */
#define DDIF$_SGA_LAYPTH_H_ALIGN 6175   /* Character horizontal align	Enumeration */
#define DDIF$_SGA_LAYPTH_V_ALIGN 6176   /* Character vertical align	Enumeration */
#define DDIF$_SGA_LAYREL_H_RATIO_N 6177 /* Horiz escapement ratio	Integer */
#define DDIF$_SGA_LAYREL_H_RATIO_D 6178 /*				Integer */
#define DDIF$_SGA_LAYREL_H_CONSTANT_C 6179 /* Horiz escapement constant	Measurement enumeration */
#define DDIF$_SGA_LAYREL_H_CONSTANT 6180 /*				Variable */
#define DDIF$_SGA_LAYREL_V_RATIO_N 6181 /* Vert escapement ratio	Integer */
#define DDIF$_SGA_LAYREL_V_RATIO_D 6182 /*				Integer */
#define DDIF$_SGA_LAYREL_V_CONSTANT_C 6183 /* Vert escapement constant	Measurement enumeration */
#define DDIF$_SGA_LAYREL_V_CONSTANT 6184 /*				Variable */
#define DDIF$_SGA_LAYPOS_TEXT_POSITION 6185 /* Text position		Enumeration */
#define DDIF$_SGA_FONT_DEFNS 6186       /* Font definitions		Sequence of DDIF$_FTD */
#define DDIF$_SGA_PATTERN_DEFNS 6187    /* Pattern definitions		Sequence of DDIF$_PTD */
#define DDIF$_SGA_PATH_DEFNS 6188       /* Path definitions		Sequence of DDIF$_PHD */
#define DDIF$_SGA_LINE_STYLE_DEFNS 6189 /* Line style definitions	Sequence of DDIF$_LSD */
#define DDIF$_SGA_CONTENT_DEFNS 6190    /* Content definitions		Sequence of DDIF$_CTD */
#define DDIF$_SGA_TYPE_DEFNS 6191       /* Type definitions		Sequence of DDIF$_TYD */
#define DDIF$_SGA_TXT_MASK_PATTERN 6192 /* Text mask pattern		Integer */
#define DDIF$_SGA_TXT_FONT 6193         /* Text font			Integer */
#define DDIF$_SGA_TXT_RENDITION 6194    /* Text rendition		Array of enumeration */
#define DDIF$_SGA_TXT_HEIGHT_C 6195     /* Text height			Measurement enumeration */
#define DDIF$_SGA_TXT_HEIGHT 6196       /* 				Variable */
#define DDIF$_SGA_TXT_SET_SIZE_N 6197   /* Text set size		Integer */
#define DDIF$_SGA_TXT_SET_SIZE_D 6198   /* Text set size		Integer */
#define DDIF$_SGA_TXT_DIRECTION 6199    /* Text direction		Enumeration */
#define DDIF$_SGA_TXT_DEC_ALIGNMENT 6200 /* Decimal align characters	Array of character string */
#define DDIF$_SGA_TXT_LEADER_SPACE_C 6201 /* Leader space			Measurement enumeration */
#define DDIF$_SGA_TXT_LEADER_SPACE 6202 /* 				Variable */
#define DDIF$_SGA_TXT_LEADER_BULLET 6203 /* Leader bullet		Character string */
#define DDIF$_SGA_TXT_LEADER_ALIGN 6204 /* Leader alignment		Enumeration */
#define DDIF$_SGA_TXT_LEADER_STYLE 6205 /* Leader style			Enumeration */
#define DDIF$_SGA_TXT_PAIR_KERNING 6206 /* Pair kerning			Boolean */
#define DDIF$_SGA_LIN_WIDTH_C 6207      /* Line width			Measurement enumeration */
#define DDIF$_SGA_LIN_WIDTH 6208        /* 				Variable */
#define DDIF$_SGA_LIN_STYLE 6209        /* Line style			Integer */
#define DDIF$_SGA_LIN_PATTERN_SIZE_C 6210 /* Line pattern size		Measurement enumeration */
#define DDIF$_SGA_LIN_PATTERN_SIZE 6211 /* 				Variable */
#define DDIF$_SGA_LIN_MASK_PATTERN 6212 /* Line mask pattern		Integer */
#define DDIF$_SGA_LIN_END_START 6213    /* Line end start		Enumeration */
#define DDIF$_SGA_LIN_END_FINISH 6214   /* Line end finish		Enumeration */
#define DDIF$_SGA_LIN_END_SIZE_C 6215   /* Line end size		Measurement enumeration */
#define DDIF$_SGA_LIN_END_SIZE 6216     /*				Variable */
#define DDIF$_SGA_LIN_JOIN 6217         /* Line join			Enumeration */
#define DDIF$_SGA_LIN_MITER_LIMIT_N 6218 /* Line miter limit		Integer */
#define DDIF$_SGA_LIN_MITER_LIMIT_D 6219 /*				Integer */
#define DDIF$_SGA_LIN_INTERIOR_PATTERN 6220 /* Line interior pattern	Integer */
#define DDIF$_SGA_MKR_STYLE 6221        /* Marker style			Enumeration */
#define DDIF$_SGA_MKR_MASK_PATTERN 6222 /* Marker mask pattern		Integer */
#define DDIF$_SGA_MKR_SIZE_C 6223       /* Marker size			Measurement enumeration */
#define DDIF$_SGA_MKR_SIZE 6224         /*	 			Variable */
#define DDIF$_SGA_GLY_ATTRIBUTES 6225   /* Galley attributes		DDIF$_GLA */
#define DDIF$_SGA_IMG_PRIVATE_DATA 6226 /* Image private data		Sequence of DDIF$_PVT */
#define DDIF$_SGA_IMG_PIXEL_PATH 6227   /* Pixel path			Integer */
#define DDIF$_SGA_IMG_LINE_PROGRESSION 6228 /* Line progression		Integer */
#define DDIF$_SGA_IMG_PP_PIXEL_DIST 6229 /* Asp ratio, pixel path	Integer */
#define DDIF$_SGA_IMG_LP_PIXEL_DIST 6230 /* Asp ratio, line progression	Integer */
#define DDIF$_SGA_IMG_BRT_POLARITY 6231 /* Brightness polarity		Enumeration */
#define DDIF$_SGA_IMG_GRID_TYPE 6232    /* Grid type			Enumeration */
#define DDIF$_SGA_IMG_TIMING_DESC 6233  /* Timing descriptor		Binary relative time */
#define DDIF$_SGA_IMG_SPECTRAL_MAPPING 6234 /* Spectral component mapping	Enumeration */
#define DDIF$_SGA_IMG_LOOKUP_TABLES_C 6235 /* Lookup tables		Enumeration */
#define DDIF$_SGA_IMG_LOOKUP_TABLES 6236 /*				Variable */
#define DDIF$_SGA_IMG_COMP_WAVELENGTH_C 6237 /* Component wavelength info	Enumeration */
#define DDIF$_SGA_IMG_COMP_WAVELENGTH 6238 /*				Variable */
#define DDIF$_SGA_IMG_COMP_SPACE_ORG 6239 /* Component space organization	Enumeration */
#define DDIF$_SGA_IMG_PLANES_PER_PIXEL 6240 /* Data planes per pixel	Integer */
#define DDIF$_SGA_IMG_PLANE_SIGNIF 6241 /* Data plane significance	Enumeration */
#define DDIF$_SGA_IMG_NUMBER_OF_COMP 6242 /* Number of components		Integer */
#define DDIF$_SGA_IMG_BITS_PER_COMP 6243 /* Bits per component		Array of integer */
#define DDIF$_SGA_FRM_FLAGS 6244        /* Frame flags			Longword */
#define DDIF$_SGA_FRM_BOX_LL_X_C 6245   /* Frame bounding box		Measurement enumeration */
#define DDIF$_SGA_FRM_BOX_LL_X 6246     /*     Lower left X coordinate	Variable */
#define DDIF$_SGA_FRM_BOX_LL_Y_C 6247   /*				Measurement enumeration */
#define DDIF$_SGA_FRM_BOX_LL_Y 6248     /*     Lower left Y coordinate	Variable */
#define DDIF$_SGA_FRM_BOX_UR_X_C 6249   /*				Measurement enumeration */
#define DDIF$_SGA_FRM_BOX_UR_X 6250     /*     Upper right X coordinate	Variable */
#define DDIF$_SGA_FRM_BOX_UR_Y_C 6251   /*				Measurement enumeration */
#define DDIF$_SGA_FRM_BOX_UR_Y 6252     /*     Upper right Y coordinate	Variable */
#define DDIF$_SGA_FRM_OUTLINE 6253      /* Frame outline		Sequence of DDIF$_PTH */
#define DDIF$_SGA_FRM_CLIPPING 6254     /* Frame clipping		Sequence of DDIF$_PTH */
#define DDIF$_SGA_FRM_POSITION_C 6255   /* Frame position choice	Enumeration */
#define DDIF$_SGA_FRMFXD_POSITION_X_C 6256 /* Frame fixed position		Measurement enumeration */
#define DDIF$_SGA_FRMFXD_POSITION_X 6257 /*     X coordinate		Variable */
#define DDIF$_SGA_FRMFXD_POSITION_Y_C 6258 /* Frame fixed position		Measurement enumeration */
#define DDIF$_SGA_FRMFXD_POSITION_Y 6259 /*     Y coordinate		Variable */
#define DDIF$_SGA_FRMINL_BASE_OFFSET_C 6260 /* Inline base offset		Measurement enumeration */
#define DDIF$_SGA_FRMINL_BASE_OFFSET 6261 /*				Variable */
#define DDIF$_SGA_FRMGLY_VERTICAL 6262  /* Galley vertical position	Enumeration */
#define DDIF$_SGA_FRMGLY_HORIZONTAL 6263 /* Galley horizontal position	Enumeration */
#define DDIF$_SGA_FRMMAR_BASE_OFFSET_C 6264 /* Margin base offset		Measurement enumeration */
#define DDIF$_SGA_FRMMAR_BASE_OFFSET 6265 /*				Variable */
#define DDIF$_SGA_FRMMAR_NEAR_OFFSET_C 6266 /* Margin near offset		Measurement enumeration */
#define DDIF$_SGA_FRMMAR_NEAR_OFFSET 6267 /*				Variable */
#define DDIF$_SGA_FRMMAR_HORIZONTAL 6268 /* Margin horizontal position	Enumeration */
#define DDIF$_SGA_FRM_TRANSFORM 6269    /* Frame content transform	Sequence of DDIF$_TRN */
#define DDIF$_SGA_ITEM_CHANGE_LIST 6270 /* Item change list		Item change list */
#define DDIF$_SGA_MAX 6271              /* Maximum code plus 1              */
/* Values of the add-info parameter for DDIF$_SGA_CONTENT_CATEGORY.         */
#define DDIF$K_PRIVATE_CATEGORY 0       /* Nonstandard                      */
#define DDIF$K_I_CATEGORY 1             /* "$I" (image)                     */
#define DDIF$K_2D_CATEGORY 2            /* "$2D" (graphics)                 */
#define DDIF$K_T_CATEGORY 3             /* "$T" (text)                      */
#define DDIF$K_TBL_CATEGORY 4           /* "$TBL" (table)                   */
#define DDIF$K_PDL_CATEGORY 5           /* "$PDL" (page description language) */
/* Values of the add-info parameter for DDIF$_SGA_SEGMENT_TAGS.             */
#define DDIF$K_PRIVATE_TAG 0            /* Nonstandard                      */
#define DDIF$K_CRF_TAG 1                /* "$CRF" (cross-reference)         */
#define DDIF$K_F_TAG 2                  /* "$F" (figure)                    */
#define DDIF$K_P_TAG 3                  /* "$P" (paragraph)                 */
#define DDIF$K_S_TAG 4                  /* "$S" (section)                   */
#define DDIF$K_I_TAG 5                  /* "$I" (index)                     */
#define DDIF$K_E_TAG 6                  /* "$E" (emphasized)                */
#define DDIF$K_L_TAG 7                  /* "$L" (list)                      */
#define DDIF$K_LE_TAG 8                 /* "$LE" (list element)             */
#define DDIF$K_LIT_TAG 9                /* "$LIT" (literal)                 */
#define DDIF$K_FN_TAG 10                /* "$FN" (footnote)                 */
#define DDIF$K_AN_TAG 11                /* "$AN" (annotation)               */
#define DDIF$K_LBL_TAG 12               /* "$LBL" (label)                   */
#define DDIF$K_TTL_TAG 13               /* "$TTL" (title)                   */
#define DDIF$K_GRP_TAG 14               /* "$GRP" (group member)            */
#define DDIF$K_GO_TAG 15                /* "$GO" (graphics object)          */
/* Values of DDIF$_SGA_COMPUTE_C.                                           */
#define DDIF$K_COPY_COMPUTE 0           /* Copy locally			SGA_CPTCPY_TARGET to SGA_CPTCPY_ERF_INDEX */
#define DDIF$K_REMOTE_COMPUTE 1         /* Copy remotely		SGA_CPTCPY_TARGET to SGA_CPTCPY_ERF_INDEX */
#define DDIF$K_VARIABLE_COMPUTE 2       /* Variable			SGA_CPTVAR_VARIABLE */
#define DDIF$K_XREF_COMPUTE 3           /* Cross-reference		SGA_CPTXRF_SEGMENT to SGA_CPTXRF_VARIABLE */
#define DDIF$K_FUNCTION_COMPUTE 4       /* Function link		SGA_CPTFNC_NAME to SGA_CPTFNC_PARAMETERS */
/* Values of DDIF$_SGA_STRUCTURE_DESC_C and DDIF$_OCC_STRUCTURE_ELEMENT_C.  */
#define DDIF$K_SEQUENCE_STRUCTURE 0     /* Sequence structure		Sequence of DDIF$_OCC */
#define DDIF$K_SET_STRUCTURE 1          /* Set structure		Sequence of DDIF$_OCC */
#define DDIF$K_CHOICE_STRUCTURE 2       /* Choice structure		Sequence of DDIF$_OCC */
#define DDIF$K_REFERENCED_TYPE 3        /* Referenced type		String (not for DDIF$_SGA_STRUCTURE_DESC_C) */
/* Values of DDIF$_SGA_LAYOUT_C.                                            */
#define DDIF$K_GALLEY_LAYOUT 0          /* Galley-based layout		SGA_LAYGLY_WRAP to SGA_LAYGLY_LAYOUT */
#define DDIF$K_PATH_LAYOUT 1            /* Path-based layout		SGA_LAYPTH_PATH to SGA_LAYPTH_V_ALIGN */
#define DDIF$K_RELATIVE_LAYOUT 2        /* Position-relative layout	SGA_LAYREL_H_RATIO_N to SGA_LAYREL_V_CONSTANT */
#define DDIF$K_POSITION_LAYOUT 3        /* Position-based layout	SGA_LAYPOS_TEXT_POSITION */
/* Values of DDIF$_SGA_LAYPTH_FORMAT, DDIF$_SGA_FRMGLY_HORIZONTAL,	DDIF conforming */
/* DDIF$_LW1_WRAP_FORMAT, DDIF$_LW1_QUAD_FORMAT.                            */
#define DDIF$K_FMT_FLUSH_PATH_BEGIN 1   /* Flush with beginning of path     */
#define DDIF$K_FMT_CENTER_OF_PATH 2     /* Centered on path                 */
#define DDIF$K_FMT_FLUSH_PATH_END 3     /* Flush with end of path           */
#define DDIF$K_FMT_FLUSH_PATH_BOTH 4    /* Flush with both ends of path     */
/* Values of DDIF$_SGA_LAYPTH_ORIENTATION_C.                                */
#define DDIF$K_PATH_FIXED 0             /* Fixed frame-relative		Single precision floating */
#define DDIF$K_PATH_RELATIVE 1          /* Path relative		Enumeration */
/* Values of DDIF$_SGA_LAYPTH_ORIENTATION for DDIF$K_PATH_RELATIVE.	DDIF conforming */
#define DDIF$K_RIGHT_ANGLE_RIGHT 1      /* Right                            */
#define DDIF$K_RIGHT_ANGLE_LEFT 2       /* Left                             */
#define DDIF$K_RIGHT_ANGLE_UP 3         /* Up                               */
#define DDIF$K_RIGHT_ANGLE_DOWN 4       /* Down                             */
/* Values of DDIF$_SGA_LAYPTH_H_ALIGN.					DDIF conforming */
#define DDIF$K_PATH_NORMAL_HORIZONTAL 1 /* Normal horizontal                */
#define DDIF$K_PATH_LEFTLINE 2          /* Left line                        */
#define DDIF$K_PATH_CENTERLINE 3        /* Center line                      */
#define DDIF$K_PATH_RIGHTLINE 4         /* Right line                       */
/* Values of DDIF$_SGA_LAYPTH_V_ALIGN.					DDIF conforming */
#define DDIF$K_PATH_NORMAL_VERTICAL 1   /* Normal vertical                  */
#define DDIF$K_PATH_BASELINE 2          /* Base line                        */
#define DDIF$K_PATH_CAPLINE 3           /* Cap line                         */
#define DDIF$K_PATH_BOTTOMLINE 4        /* Bottom line                      */
#define DDIF$K_PATH_HALFLINE 5          /* Half line                        */
#define DDIF$K_PATH_TOPLINE 6           /* Top line                         */
/* Values of DDIF$_SGA_LAYPOS_TEXT_POSITION.				DDIF conforming */
#define DDIF$K_TEXT_POS_BASE 1          /* Base                             */
#define DDIF$K_TEXT_POS_L_SUBSCRIPT 2   /* Left subscript                   */
#define DDIF$K_TEXT_POS_L_SUPERSCRIPT 3 /* Left superscript                 */
#define DDIF$K_TEXT_POS_R_SUBSCRIPT 4   /* Right subscript                  */
#define DDIF$K_TEXT_POS_R_SUPERSCRIPT 5 /* Right superscript                */
#define DDIF$K_TEXT_POS_TOP_CENTER 6    /* Top center                       */
#define DDIF$K_TEXT_POS_BOTTOM_CENTER 7 /* Bottom center                    */
#define DDIF$K_TEXT_POS_RUBI 8          /* Rubi                             */
/* Predefined values of DDIF$_SGA_TXT_MASK_PATTERN, DDIF$_SGA_LIN_MASK_PATTERN, DDIF$_SGA_LIN_INTERIOR_PATTERN, */
/* DDIF$_SGA_MKR_MASK_PATTERN, DDIF$_PTD_NUMBER, DDIF$_PTD_PAT_COLORS.      */
#define DDIF$K_PATT_TRANSPARENT 0
#define DDIF$K_PATT_BACKGROUND 1
#define DDIF$K_PATT_FOREGROUND 2
#define DDIF$K_PATT_VERT1_1 3
#define DDIF$K_PATT_VERT1_3 4
#define DDIF$K_PATT_VERT2_2 5
#define DDIF$K_PATT_VERT3_1 6
#define DDIF$K_PATT_VERT1_7 7
#define DDIF$K_PATT_VERT2_6 8
#define DDIF$K_PATT_VERT4_4 9
#define DDIF$K_PATT_VERT6_2 10
#define DDIF$K_PATT_HORIZ1_1 11
#define DDIF$K_PATT_HORIZ1_3 12
#define DDIF$K_PATT_HORIZ2_2 13
#define DDIF$K_PATT_HORIZ3_1 14
#define DDIF$K_PATT_HORIZ1_7 15
#define DDIF$K_PATT_HORIZ2_6 16
#define DDIF$K_PATT_HORIZ4_4 17
#define DDIF$K_PATT_HORIZ6_2 18
#define DDIF$K_PATT_GRID4 19
#define DDIF$K_PATT_GRID8 20
#define DDIF$K_PATT_UPDIAG1_3 21
#define DDIF$K_PATT_UPDIAG2_2 22
#define DDIF$K_PATT_UPDIAG3_1 23
#define DDIF$K_PATT_UPDIAG1_7 24
#define DDIF$K_PATT_UPDIAG2_6 25
#define DDIF$K_PATT_UPDIAG4_4 26
#define DDIF$K_PATT_UPDIAG6_2 27
#define DDIF$K_PATT_DOWNDIAG1_3 28
#define DDIF$K_PATT_DOWNDIAG2_2 29
#define DDIF$K_PATT_DOWNDIAG3_1 30
#define DDIF$K_PATT_DOWNDIAG1_7 31
#define DDIF$K_PATT_DOWNDIAG2_6 32
#define DDIF$K_PATT_DOWNDIAG4_4 33
#define DDIF$K_PATT_DOWNDIAG6_2 34
#define DDIF$K_PATT_BRICK_HORIZ 35
#define DDIF$K_PATT_BRICK_VERT 36
#define DDIF$K_PATT_BRICK_DOWNDIAG 37
#define DDIF$K_PATT_BRICK_UPDIAG 38
#define DDIF$K_PATT_GREY4_16D 39
#define DDIF$K_PATT_GREY12_16D 40
#define DDIF$K_PATT_BASKET_WEAVE 41
#define DDIF$K_PATT_SCALE_DOWN 42
#define DDIF$K_PATT_SCALE_UP 43
#define DDIF$K_PATT_SCALE_RIGHT 44
#define DDIF$K_PATT_SCALE_LEFT 45
#define DDIF$K_PATT_FILLER6 46
#define DDIF$K_PATT_FILLER7 47
#define DDIF$K_PATT_GREY1_16 48
#define DDIF$K_PATT_GREY2_16 49
#define DDIF$K_PATT_GREY3_16 50
#define DDIF$K_PATT_GREY4_16 51
#define DDIF$K_PATT_GREY5_16 52
#define DDIF$K_PATT_GREY6_16 53
#define DDIF$K_PATT_GREY7_16 54
#define DDIF$K_PATT_GREY8_16 55
#define DDIF$K_PATT_GREY9_16 56
#define DDIF$K_PATT_GREY10_16 57
#define DDIF$K_PATT_GREY11_16 58
#define DDIF$K_PATT_GREY12_16 59
#define DDIF$K_PATT_GREY13_16 60
#define DDIF$K_PATT_GREY14_16 61
#define DDIF$K_PATT_GREY15_16 62
/* Values of DDIF$_SGA_TXT_RENDITION. 					DDIF conforming */
#define DDIF$K_RND_DEFAULT 0            /* Default rendition                */
#define DDIF$K_RND_HIGHLIGHT 1          /* Highlighted intensity            */
#define DDIF$K_RND_FAINT 2              /* Faint intensity                  */
#define DDIF$K_RND_ITALIC 3             /* Italic rendition                 */
#define DDIF$K_RND_NORMAL 22            /* Normal intensity                 */
#define DDIF$K_RND_SLOW_BLINK 5         /* Slow blinking                    */
#define DDIF$K_RND_FAST_BLINK 6         /* Rapid blinking                   */
#define DDIF$K_RND_NO_BLINK 25          /* Steady (no blinking)             */
#define DDIF$K_RND_NEGATIVE 7           /* Negative image                   */
#define DDIF$K_RND_POSITIVE 27          /* Positive image                   */
#define DDIF$K_RND_CONCEAL 8            /* Concealed characters             */
#define DDIF$K_RND_NO_CONCEAL 28        /* Revealed characters              */
#define DDIF$K_RND_UNDERLINE 4          /* Underlined                       */
#define DDIF$K_RND_2_UNDERLINE 21       /* Double underlined                */
#define DDIF$K_RND_NO_UNDERLINE 24      /* Not underlined                   */
#define DDIF$K_RND_CROSS_OUT 9          /* Crossed out                      */
#define DDIF$K_RND_BOX 51               /* Boxed                            */
#define DDIF$K_RND_ENCIRCLE 52          /* Encircled                        */
#define DDIF$K_RND_OVERLINE 53          /* Overlined                        */
#define DDIF$K_RND_IDEO_UNDERLINE 60    /* Ideogram underlined              */
#define DDIF$K_RND_IDEO_2_UNDERLINE 61  /* Ideogram double underlined       */
#define DDIF$K_RND_IDEO_OVERLINE 62     /* Ideogram overlined               */
#define DDIF$K_RND_IDEO_2_OVERLINE 63   /* Ideogram double overlined        */
#define DDIF$K_RND_IDEO_STRESS 64       /* Ideogram stress marking          */
/* Values of DDIF$_SGA_TXT_DIRECTION.					DDIF conforming */
#define DDIF$K_TXT_DIR_FORWARD 1        /* Forward direction                */
#define DDIF$K_TXT_DIR_BACKWARD 2       /* Backward direction               */
/* Values of DDIF$_SGA_TXT_LEADER_ALIGN.				DDIF conforming */
#define DDIF$K_ALIGNED_LEADER 1         /* Aligned leader                   */
#define DDIF$K_STAGGERED_LEADER 2       /* Staggered leader                 */
#define DDIF$K_NON_ALIGNED_LEADER 3     /* No specification                 */
/* Values of DDIF$_SGA_TXT_LEADER_STYLE.				DDIF conforming */
#define DDIF$K_X_RULE_LEADER 1          /* X rule                           */
#define DDIF$K_BULLET_LEADER 2          /* Bullet                           */
/* Predefined values of DDIF$_SGA_LIN_STYLE.				DDIF conforming */
#define DDIF$K_SOLID_LINE_STYLE 1       /* Solid                            */
#define DDIF$K_DASH_LINE_STYLE 2        /* Dash                             */
#define DDIF$K_DOT_LINE_STYLE 3         /* Dot                              */
#define DDIF$K_DASH_DOT_LINE_STYLE 4    /* Dash-dot                         */
/* Values of DDIF$_SGA_LIN_END_START, DDIF$_SGA_LIN_END_FINISH.		DDIF conforming */
#define DDIF$K_BUTT_LINE_END 1          /* Butt line end                    */
#define DDIF$K_ROUND_LINE_END 2         /* Round line end                   */
#define DDIF$K_SQUARE_LINE_END 3        /* Square line end                  */
#define DDIF$K_ARROW_LINE_END 4         /* Arrow line end                   */
/* Values of DDIF$_SGA_LIN_JOIN.					DDIF conforming */
#define DDIF$K_MITERED_LINE_JOIN 1      /* Mitered line join                */
#define DDIF$K_ROUNDED_LINE_JOIN 2      /* Rounded line join                */
#define DDIF$K_BEVELED_LINE_JOIN 3      /* Beveled line join                */
/* Values of DDIF$_SGA_MKR_STYLE.					DDIF conforming */
#define DDIF$K_DOT_MARKER 1             /* Dot                              */
#define DDIF$K_PLUS_MARKER 2            /* Plus sign                        */
#define DDIF$K_ASTERISK_MARKER 3        /* Asterisk                         */
#define DDIF$K_CIRCLE_MARKER 4          /* Circle                           */
#define DDIF$K_CROSS_MARKER 5           /* Diagonal cross                   */
/* Values of DDIF$_SGA_IMG_BRT_POLARITY.				DDIF conforming */
#define DDIF$K_ZERO_MAX_INTENSITY 1     /* Zero maximum intensity           */
#define DDIF$K_ZERO_MIN_INTENSITY 2     /* Zero minimum intensity           */
/* Values of DDIF$_SGA_IMG_GRID_TYPE.					DDIF conforming */
#define DDIF$K_RECTANGULAR_GRID 1       /* Rectangular grid                 */
#define DDIF$K_HEX_EVEN_INDENT 2        /* Hexagonal grid, indent even      */
#define DDIF$K_HEX_ODD_INDENT 3         /* Hexagonal grid, indent odd       */
/* Values of DDIF$_SGA_IMG_SPECTRAL_MAPPING.				DDIF conforming */
#define DDIF$K_PRIVATE_MAP 1            /* Privately mapped                 */
#define DDIF$K_MONOCHROME_MAP 2         /* Monochrome mapped                */
#define DDIF$K_GENERAL_MAP 3            /* General multispectral            */
#define DDIF$K_LUT_MAP 4                /* Lookup table mapped              */
#define DDIF$K_RGB_MAP 5                /* RGB mapped                       */
#define DDIF$K_CMY_MAP 6                /* CMY mapped                       */
#define DDIF$K_YUV_MAP 7                /* YUV mapped                       */
#define DDIF$K_HSV_MAP 8                /* HSV mapped                       */
#define DDIF$K_HLS_MAP 9                /* HLS mapped                       */
#define DDIF$K_YIQ_MAP 10               /* YIQ mapped                       */
/* Values of DDIF$_SGA_IMG_LOOKUP_TABLES_C.                                 */
#define DDIF$K_PRIVATE_LUT 0            /* Private LUT data		Sequence of DDIF$_PVT */
#define DDIF$K_RGB_LUT 1                /* RGB LUT data			Sequence of DDIF$_RGB */
/* Values of DDIF$_SGA_IMG_COMP_WAVELENGTH_C.                               */
#define DDIF$K_APPLICATION_WAVELENGTH 0 /* Application wavelength	Array of string */
#define DDIF$K_WAVELENGTH_MEASURE 1     /* Wavelength measure		Array of integer */
#define DDIF$K_WAVELENGTH_BAND_ID 2     /* Wavelength band ID		Array of string */
/* Values of DDIF$_SGA_IMG_COMP_SPACE_ORG.				DDIF conforming */
#define DDIF$K_FULL_COMPACTION 1        /* Full pixel compaction            */
#define DDIF$K_PARTIAL_EXPANSION 2      /* Partial pixel expansion          */
#define DDIF$K_FULL_EXPANSION 3         /* Full pixel expansion             */
/* Values of DDIF$_SGA_IMG_PLANE_SIGNIF.				DDIF conforming */
#define DDIF$K_LSB_MSB 1                /* LSB to MSB                       */
#define DDIF$K_MSB_LSB 2                /* MSB to LSB                       */
/* Bit definitions for DDIF$_FRM_FLAGS.					DDIF conforming */
#define ddif$m_flow_around 1
#define ddif$m_frame_border 2
#define ddif$m_frame_background_fill 4
struct frm_flags {
    unsigned ddif$v_flow_around : 1;    /* Flow around                      */
    unsigned ddif$v_frame_border : 1;   /* Frame border                     */
    unsigned ddif$v_frame_background_fill : 1; /* Frame background fill     */
    unsigned ddif$v_frm_fill : 29;
    } ;
/* Values of DDIF$_SGA_FRM_POSITION_C.                                      */
#define DDIF$K_FRAME_FIXED 0            /* Fixed position		FRMFXD_POSITION_X_C to FRMFXD_POSITION_Y */
#define DDIF$K_FRAME_INLINE 1           /* Inline position		FRMINL_BASE_OFFSET_C to FRMINL_BASE_OFFSET */
#define DDIF$K_FRAME_GALLEY 2           /* Galley position		FRMGLY_VERTICAL to FRMGLY_HORIZONTAL */
#define DDIF$K_FRAME_MARGIN 3           /* Margin position		FRMMAR_BASE_OFFSET_C to FRMMAR_HORIZONTAL */
/* Values of DDIF$_SGA_FRMGLY_VERTICAL.					DDIF conforming */
#define DDIF$K_FRMGLY_BELOW_CURRENT 1   /* Below current line               */
#define DDIF$K_FRMGLY_BOTTOM 2          /* Bottom of galley                 */
#define DDIF$K_FRMGLY_TOP 3             /* Top of galley                    */
/* Values of DDIF$_SGA_FRMMAR_HORIZONTAL.				DDIF conforming */
#define DDIF$K_FRMMAR_CLOSEST_EDGE 1    /* Side closest edge                */
#define DDIF$K_FRMMAR_FURTHEST_EDGE 2   /* Side furthest edge               */
#define DDIF$K_FRMMAR_LEFT 3            /* Left of galleys                  */
#define DDIF$K_FRMMAR_RIGHT 4           /* Right of galleys                 */
/* Item codes for Content Definition aggregate.                             */
#define DDIF$_CTD_LABEL 6401            /* Content label		String */
#define DDIF$_CTD_EXTERNAL_TARGET 6402  /* Content reference target	String */
#define DDIF$_CTD_EXTERNAL_ERF_INDEX 6403 /* Content reference index	Integer */
#define DDIF$_CTD_VALUE 6404            /* Content value		Sequence of content */
#define DDIF$_CTD_PRIVATE_DATA 6405     /* Content private data		Sequence of DDIF$_PVT */
#define DDIF$_CTD_MAX 6406              /* Maximum code plus 1              */
/* Item codes for Font Definition aggregate.                                */
#define DDIF$_FTD_NUMBER 6657           /* Font number			Integer */
#define DDIF$_FTD_IDENTIFIER 6658       /* Font identifier		String */
#define DDIF$_FTD_PRIVATE_DATA 6659     /* Font private data		Sequence of DDIF$_PVT */
#define DDIF$_FTD_MAX 6660              /* Maximum code plus 1              */
/* Item codes for Line Style Definition aggregate.                          */
#define DDIF$_LSD_NUMBER 6913           /* Line style number		Integer */
#define DDIF$_LSD_PATTERN 6914          /* Line style pattern		Array of integer */
#define DDIF$_LSD_PRIVATE_DATA 6915     /* Line style private data	Sequence of DDIF$_PVT */
#define DDIF$_LSD_MAX 6916              /* Maximum code plus 1              */
/* Item codes for Path Definition aggregate.                                */
#define DDIF$_PHD_NUMBER 7169           /* Path number			Integer */
#define DDIF$_PHD_DESCRIPTION 7170      /* Path description		Sequence of DDIF$_PTH */
#define DDIF$_PHD_PRIVATE_DATA 7171     /* Path private data		Sequence of DDIF$_PVT */
#define DDIF$_PHD_MAX 7172              /* Maximum code plus 1              */
/* Item codes for Pattern Definition aggregate.                             */
#define DDIF$_PTD_NUMBER 7425           /* Pattern number		Integer */
#define DDIF$_PTD_DEFN_C 7426           /* Pattern definition choice	Enumeration */
#define DDIF$_PTD_SOL_COLOR_C 7427      /* Color choice			Enumeration */
#define DDIF$_PTD_SOL_COLOR_R 7428      /* Color red intensity		Single precision floating */
#define DDIF$_PTD_SOL_COLOR_G 7429      /* Color green intensity	Single precision floating */
#define DDIF$_PTD_SOL_COLOR_B 7430      /* Color blue intensity		Single precision floating */
#define DDIF$_PTD_PAT_NUMBER 7431       /* Pattern number		Integer */
#define DDIF$_PTD_PAT_COLORS 7432       /* Pattern colors		Array of integer */
#define DDIF$_PTD_RAS_PATTERN 7433      /* Pattern image		DDIF$_IDU */
#define DDIF$_PTD_PRIVATE_DATA 7434     /* Pattern private data		Sequence of DDIF$_PVT */
#define DDIF$_PTD_MAX 7435              /* Maximum code plus 1              */
/* Values of DDIF$_PTD_DEFN_C.                                              */
#define DDIF$K_SOLID_COLOR 0            /* Solid color			PTD_SOL_COLOR_C to PTD_SOL_COLOR_B */
#define DDIF$K_STANDARD_PATTERN 1       /* Standard pattern		PTD_PAT_NUMBER to PTD_PAT_COLORS */
#define DDIF$K_RASTER_PATTERN 2         /* Raster pattern		PTD_RAS_PATTERN */
/* Values of DDIF$_PTD_SOL_COLOR_C.                                         */
#define DDIF$K_RGB_COLOR 0              /* RGB color			PTD_SOL_COLOR_R to PTD_SOL_COLOR_B */
#define DDIF$K_TRANSPARENCY 1           /* Transparency			None */
/* Item codes for Segment Binding aggregate.                                */
#define DDIF$_SGB_VARIABLE_NAME 7681    /* Variable name		String */
#define DDIF$_SGB_VARIABLE_VALUE_C 7682 /* Variable value choice	Enumeration */
#define DDIF$_SGB_CTR_TRIGGER_C 7683    /* Counter trigger		Enumeration */
#define DDIF$_SGB_CTR_TRIGGER 7684      /*				Variable */
#define DDIF$_SGB_CTR_INIT_C 7685       /* Counter initializer		Expression enumeration */
#define DDIF$_SGB_CTR_INIT 7686         /*				Variable */
#define DDIF$_SGB_CTR_STYLE 7687        /* Counter style		Sequence of DDIF$_CTS */
#define DDIF$_SGB_CTR_TYPE 7688         /* Counter type			Enumeration */
#define DDIF$_SGB_COM_STRING_EXPR_C 7689 /* Computed string expression	Array of enumeration */
#define DDIF$_SGB_COM_STRING_EXPR 7690  /*				Array of variable */
#define DDIF$_SGB_RCD_LIST 7691         /* Record definition list	Sequence of DDIF$_RCD */
#define DDIF$_SGB_MAX 7692              /* Maximum code plus 1              */
/* Values of DDIF$_SGB_VARIABLE_VALUE_C.                                    */
#define DDIF$K_COUNTER_VARIABLE 0       /* Counter variable		SGB_CTR_TRIGGER_C to SGB_CTR_TYPE */
#define DDIF$K_COMPUTED_VARIABLE 1      /* Computed variable		SGB_COM_STRING_EXPR_C to SGB_COM_STRING_EXPR */
#define DDIF$K_LIST_VARIABLE 2          /* List variable		SGB_RCD_LIST */
/* Values of DDIF$_SGB_CTR_TRIGGER_C.                                       */
#define DDIF$K_TAGGED_SEGMENT_TRIGGER 0 /* Counts tagged segments	String */
#define DDIF$K_LAYOUT_OBJECT_TRIGGER 1  /* Counts layout objects	Enumeration */
/* Values of DDIF$_SGB_CTR_TRIGGER for DDIF$K_OBJECT_TRIGGER.		DDIF conforming */
#define DDIF$K_DOCUMENT_LAYOUT_OBJECT 1 /* Document layout object           */
#define DDIF$K_PAGE_SET_LAYOUT_OBJECT 2 /* Page set layout object           */
#define DDIF$K_PAGE_LAYOUT_OBJECT 3     /* Page layout object               */
#define DDIF$K_FRAME_LAYOUT_OBJECT 4    /* Frame layout object              */
#define DDIF$K_BLOCK_LAYOUT_OBJECT 5    /* Block layout object              */
#define DDIF$K_LINE_LAYOUT_OBJECT 6     /* Line layout object               */
/* Values of DDIF$_SGB_CTR_TYPE.					DDIF conforming */
#define DDIF$K_MILITARY_COUNTER 1       /* Military                         */
#define DDIF$K_OFFICE_COUNTER 2         /* Office                           */
#define DDIF$K_PAGE_RELATIVE_COUNTER 3  /* Page relative                    */
/* Values of DDIF$_SGB_COM_STRING_EXPR_C.                                   */
#define DDIF$K_TEXT_ELEMENT 0           /* Text element			Character string */
#define DDIF$K_VARIABLE_ELEMENT 1       /* Variable reference element	String */
/* Item codes for Type Definition aggregate.                                */
#define DDIF$_TYD_LABEL 7937            /* Type label			String */
#define DDIF$_TYD_PARENT 7938           /* Type parent			String */
#define DDIF$_TYD_ATTRIBUTES 7939       /* Type attributes		DDIF$_SGA */
#define DDIF$_TYD_PRIVATE_DATA 7940     /* Type private data		Sequence of DDIF$_PVT */
#define DDIF$_TYD_MAX 7941              /* Maximum code plus 1              */
/* Item codes for Counter Style aggregate.                                  */
#define DDIF$_CTS_STYLE_C 8193          /* Counter style		Enumeration */
#define DDIF$_CTS_STYLE 8194            /*				Variable */
#define DDIF$_CTS_MAX 8195              /* Maximum code plus 1              */
/* Values of DDIF$_CTS_STYLE_C.                                             */
#define DDIF$K_NUMBER_STYLE 0           /* Number style entry		Enumeration */
#define DDIF$K_BULLET_STYLE 1           /* Bullet style entry		Array of character string */
#define DDIF$K_STYLE_SEPARATOR 2        /* Style separator entry	Character string */
/* Values of DDIF$_CTS_STYLE for DDIF$K_NUMBER_STYLE.			DDIF conforming */
#define DDIF$K_ARABIC_COUNTER 1         /* Arabic                           */
#define DDIF$K_L_ROMAN_COUNTER 2        /* Lowercase roman                  */
#define DDIF$K_U_ROMAN_COUNTER 3        /* Uppercase roman                  */
#define DDIF$K_L_LATIN_COUNTER 4        /* Lowercase latin                  */
#define DDIF$K_U_LATIN_COUNTER 5        /* Uppercase latin                  */
#define DDIF$K_W_ARABIC_COUNTER 6       /* Wide arabic                      */
#define DDIF$K_WL_ROMAN_COUNTER 7       /* Wide lowercase roman             */
#define DDIF$K_WU_ROMAN_COUNTER 8       /* Wide uppercase roman             */
#define DDIF$K_WL_LATIN_COUNTER 9       /* Wide lowercase latin             */
#define DDIF$K_WU_LATIN_COUNTER 10      /* Wide uppercase latin             */
#define DDIF$K_WK_50_COUNTER 11         /* Wide katakana 50                 */
#define DDIF$K_WK_IROHA_COUNTER 12      /* Wide katakana iroha              */
#define DDIF$K_HEBREW_COUNTER 13        /* Hebrew                           */
/* Item codes for Occurrence Definition aggregate.                          */
#define DDIF$_OCC_OCCURRENCE_C 8449     /* Occurrence choice		Enumeration */
#define DDIF$_OCC_STRUCTURE_ELEMENT_C 8450 /* Structure element choice	Enumeration */
#define DDIF$_OCC_STRUCTURE_ELEMENT 8451 /*				Variable */
#define DDIF$_OCC_MAX 8452              /* Maximum code plus 1              */
/* Values of DDIF$_OCC_OCCURRENCE_C.                                        */
#define DDIF$K_REQUIRED_OCCURRENCE 0    /* Required occurrence              */
#define DDIF$K_OPTIONAL_OCCURRENCE 1    /* Optional occurrence              */
#define DDIF$K_REPEAT_OCCURRENCE 2      /* Repeated occurrence              */
#define DDIF$K_OPT_RPT_OCCURRENCE 3     /* Optional repeated occurrence     */
/* Item codes for Record Definition aggregate.                              */
#define DDIF$_RCD_TYPE 8705             /* Record type			String */
#define DDIF$_RCD_TAG 8706              /* Record tag			String */
#define DDIF$_RCD_CONTENTS 8707         /* Record contents		Array of string */
#define DDIF$_RCD_MAX 8708              /* Maximum code plus 1              */
/* Item codes for RGB Lookup Table Entry aggregate.                         */
#define DDIF$_RGB_LUT_INDEX 8961        /* LUT index			Integer */
#define DDIF$_RGB_RED_VALUE 8962        /* Red value			Single precision floating */
#define DDIF$_RGB_GREEN_VALUE 8963      /* Green value			Single precision floating */
#define DDIF$_RGB_BLUE_VALUE 8964       /* Blue value			Single precision floating */
#define DDIF$_RGB_MAX 8965              /* Maximum code plus 1              */
/* Item codes for Transform aggregate.                                      */
#define DDIF$_TRN_PARAMETER_C 9217      /* Transform element		Enumeration */
#define DDIF$_TRN_PARAMETER 9218        /*				Variable */
#define DDIF$_TRN_MAX 9219              /* Maximum code plus 1              */
/* Values of DDIF$_TRN_PARAMETER_C.                                         */
#define DDIF$K_X_SCALE 0                /* X scale factor		Single precision floating */
#define DDIF$K_Y_SCALE 1                /* Y scale factor		Single precision floating */
#define DDIF$K_X_TRANSLATE 2            /* X translation		Single precision floating */
#define DDIF$K_Y_TRANSLATE 3            /* Y translation		Single precision floating */
#define DDIF$K_ROTATE 4                 /* Rotation			Single precision floating */
#define DDIF$K_SKEW 5                   /* Skew				Single precision floating */
#define DDIF$K_MATRIX_2_BY_3 6          /* 2 by 3 matrix		Array[6] of single precision floating */
#define DDIF$K_MATRIX_3_BY_3 7          /* 3 by 3 matrix		Array[9] of single precision floating */
/* Item codes for Generic Layout I aggregate.                               */
#define DDIF$_LG1_PRIVATE_DATA 9473     /* Private data			Sequence of DDIF$_PVT */
#define DDIF$_LG1_PAGE_DESCRIPTIONS 9474 /* Page descriptions		Sequence of DDIF$_PGD */
#define DDIF$_LG1_MAX 9475              /* Maximum code plus 1              */
/* Item codes for Specific Layout I aggregate.                              */
#define DDIF$_LS1_LAYOUT_C 9729         /* Layout choice		Array of enumeration */
#define DDIF$_LS1_LAYOUT 9730           /* Layout description		Array of variable */
#define DDIF$_LS1_MAX 9731              /* Maximum code plus 1              */
/* Values of DDIF$_LS1_LAYOUT_C.                                            */
#define DDIF$K_SPECIFIC_PAGE 0          /* Specific page		DDIF$_PGD */
#define DDIF$K_REFERENCED_PAGE 1        /* Referenced page		String */
/* Item codes for Wrap Attributes I aggregate.                              */
#define DDIF$_LW1_WRAP_FORMAT 9985      /* Wrap format			Enumeration */
#define DDIF$_LW1_QUAD_FORMAT 9986      /* Quad format			Enumeration */
#define DDIF$_LW1_HYPHENATION_FLAGS 9987 /* Hyphenation flags		Longword */
#define DDIF$_LW1_MAXIMUM_HYPH_LINES 9988 /* Maximum hyphen lines		Integer */
#define DDIF$_LW1_MAXIMUM_ORPHAN_SIZE 9989 /* Maximum orphan size		Integer */
#define DDIF$_LW1_MAXIMUM_WIDOW_SIZE 9990 /* Maximum widow size		Integer */
#define DDIF$_LW1_MAX 9991              /* Maximum code plus 1              */
/* Bit definitions for DDIF$_LW1_HYPHENATION_FLAGS.			DDIF conforming */
#define ddif$m_hyph_allowed 1
#define ddif$m_hyph_paragraph_end 2
#define ddif$m_hyph_galley_end 4
#define ddif$m_hyph_page_end 8
#define ddif$m_hyph_capitalized_word 16
struct lw1_hyphen_flags {
    unsigned ddif$v_hyph_allowed : 1;   /* Hyphenation allowed              */
    unsigned ddif$v_hyph_paragraph_end : 1; /* Paragraph end                */
    unsigned ddif$v_hyph_galley_end : 1; /* Galley end                      */
    unsigned ddif$v_hyph_page_end : 1;  /* Page end                         */
    unsigned ddif$v_hyph_capitalized_word : 1; /* Capitalized word          */
    unsigned ddif$v_lw1_fill : 27;
    } ;
/* Item codes for Layout Attributes I aggregate.                            */
#define DDIF$_LL1_INITIAL_DIRECTIVE 10241 /* Initial directive		Enumeration */
#define DDIF$_LL1_GALLEY_SELECT 10242   /* Galley select		String */
#define DDIF$_LL1_BREAK_BEFORE 10243    /* Break before			Enumeration */
#define DDIF$_LL1_BREAK_WITHIN 10244    /* Break within			Enumeration */
#define DDIF$_LL1_BREAK_AFTER 10245     /* Break after			Enumeration */
#define DDIF$_LL1_INITIAL_INDENT_C 10246 /* Initial indent		Measurement enumeration */
#define DDIF$_LL1_INITIAL_INDENT 10247  /*				Variable */
#define DDIF$_LL1_LEFT_INDENT_C 10248   /* Left indent			Measurement enumeration */
#define DDIF$_LL1_LEFT_INDENT 10249     /*				Variable */
#define DDIF$_LL1_RIGHT_INDENT_C 10250  /* Right indent			Measurement enumeration */
#define DDIF$_LL1_RIGHT_INDENT 10251    /*				Variable */
#define DDIF$_LL1_SPACE_BEFORE_C 10252  /* Space before			Measurement enumeration */
#define DDIF$_LL1_SPACE_BEFORE 10253    /*				Variable */
#define DDIF$_LL1_SPACE_AFTER_C 10254   /* Space after			Measurement enumeration */
#define DDIF$_LL1_SPACE_AFTER 10255     /*				Variable */
#define DDIF$_LL1_LEADING_RATIO_N 10256 /* Leading ratio		Integer */
#define DDIF$_LL1_LEADING_RATIO_D 10257 /*				Integer */
#define DDIF$_LL1_LEADING_CONSTANT_C 10258 /* Leading constant		Measurement enumeration */
#define DDIF$_LL1_LEADING_CONSTANT 10259 /*				Variable */
#define DDIF$_LL1_TAB_STOPS 10260       /* Tab stops			Sequence of DDIF$_TBS */
#define DDIF$_LL1_MAX 10261             /* Maximum code plus 1              */
/* Values of DDIF$_LL1_BREAK_BEFORE, DDIF$_LL1_BREAK_WITHIN,		DDIF conforming */
/* DDIF$_LL1_BREAK_AFTER.                                                   */
#define DDIF$K_BREAK_ALWAYS 1           /* Break always                     */
#define DDIF$K_BREAK_NEVER 2            /* Break never                      */
#define DDIF$K_BREAK_IF_NEEDED 3        /* Break if needed                  */
/* Item codes for Galley Attributes aggregate.                              */
#define DDIF$_GLA_TOP_MARGIN_C 10497    /* Galley top margin		Measurement enumeration */
#define DDIF$_GLA_TOP_MARGIN 10498      /*				Variable */
#define DDIF$_GLA_LEFT_MARGIN_C 10499   /* Galley left margin		Measurement enumeration */
#define DDIF$_GLA_LEFT_MARGIN 10500     /*				Variable */
#define DDIF$_GLA_RIGHT_MARGIN_C 10501  /* Galley right margin		Measurement enumeration */
#define DDIF$_GLA_RIGHT_MARGIN 10502    /*				Variable */
#define DDIF$_GLA_BOTTOM_MARGIN_C 10503 /* Galley bottom margin		Measurement enumeration */
#define DDIF$_GLA_BOTTOM_MARGIN 10504   /*				Variable */
#define DDIF$_GLA_MAX 10505             /* Maximum code plus 1              */
/* Item codes for Page Description aggregate.                               */
#define DDIF$_PGD_LABEL 10753           /* Label			String */
#define DDIF$_PGD_PRIVATE_DATA 10754    /* Private data			Sequence of DDIF$_PVT */
#define DDIF$_PGD_DESC_C 10755          /* Page description		Enumeration */
#define DDIF$_PGD_DESC 10756            /*				Variable */
#define DDIF$_PGD_MAX 10757             /* Maximum code plus 1              */
/* Values of DDIF$_PGD_DESC_C.                                              */
#define DDIF$K_PAGE_SET_DESC 0          /* Page set description		Sequence of DDIF$_PGS */
#define DDIF$K_PAGE_LAYOUT 1            /* Page layout			DDIF$_PGL */
/* Item codes for Page Layout aggregate.                                    */
#define DDIF$_PGL_LAYOUT_ID 11009       /* Page layout ID		String */
#define DDIF$_PGL_SIZE_X_NOM_C 11010    /* Page size			Measurement enumeration */
#define DDIF$_PGL_SIZE_X_NOM 11011      /*	X nominal		Variable */
#define DDIF$_PGL_SIZE_X_STR_C 11012    /*				Measurement enumeration */
#define DDIF$_PGL_SIZE_X_STR 11013      /*	X stretch		Variable */
#define DDIF$_PGL_SIZE_X_SHR_C 11014    /*				Measurement enumeration */
#define DDIF$_PGL_SIZE_X_SHR 11015      /*	X shrink		Variable */
#define DDIF$_PGL_SIZE_Y_NOM_C 11016    /*				Measurement enumeration */
#define DDIF$_PGL_SIZE_Y_NOM 11017      /*	Y nominal		Variable */
#define DDIF$_PGL_SIZE_Y_STR_C 11018    /*				Measurement enumeration */
#define DDIF$_PGL_SIZE_Y_STR 11019      /*	Y stretch		Variable */
#define DDIF$_PGL_SIZE_Y_SHR_C 11020    /*				Measurement enumeration */
#define DDIF$_PGL_SIZE_Y_SHR 11021      /*	Y shrink		Variable */
#define DDIF$_PGL_ORIENTATION 11022     /* Page orientation		Enumeration */
#define DDIF$_PGL_PROTOTYPE 11023       /* Page prototype		String */
#define DDIF$_PGL_CONTENT 11024         /* Page content			Sequence of content */
#define DDIF$_PGL_MAX 11025             /* Maximum code plus 1              */
/* Values of DDIF$_PGL_ORIENTATION.					DDIF conforming */
#define DDIF$K_PORTRAIT_ORIENT 1        /* Portrait orientation             */
#define DDIF$K_LANDSCAPE_ORIENT 2       /* Landscape orientation            */
/* Item codes for Page Select aggregate.                                    */
#define DDIF$_PGS_PAGE_SIDE_CRITERIA 11265 /* Page side criteria		Enumeration */
#define DDIF$_PGS_SELECT_PAGE_LAYOUT_C 11266 /* Selected page layout		Enumeration */
#define DDIF$_PGS_SELECT_PAGE_LAYOUT 11267 /* 				Variable */
#define DDIF$_PGS_MAX 11268             /* Maximum code plus 1              */
/* Values of DDIF$_PGS_PAGE_SIDE_CRITERIA.				DDIF conforming */
#define DDIF$K_LEFT_PAGE 1              /* Left page                        */
#define DDIF$K_RIGHT_PAGE 2             /* Right page                       */
#define DDIF$K_EITHER_PAGE 3            /* Either page                      */
/* Values of DDIF$_PGS_SELECT_PAGE_LAYOUT_C.                                */
#define DDIF$K_SELECT_BY_LABEL 0        /* Select by label		String */
#define DDIF$K_SELECT_BY_DEFN 1         /* Select by definition		DDIF$_PGL */
/* Item codes for Tab Stop aggregate.                                       */
#define DDIF$_TBS_HORIZONTAL_POSITION_C 11521 /* Horizontal position		Measurement enumeration */
#define DDIF$_TBS_HORIZONTAL_POSITION 11522 /*				Variable */
#define DDIF$_TBS_TYPE 11523            /* Tab stop type		Enumeration */
#define DDIF$_TBS_LEADER 11524          /* Tab stop leader		Character string */
#define DDIF$_TBS_MAX 11525             /* Maximum code plus 1              */
/* Values of DDIF$_TBS_TYPE.						DDIF conforming */
#define DDIF$K_LEFT_TAB 1               /* Left tab                         */
#define DDIF$K_CENTER_TAB 2             /* Center tab                       */
#define DDIF$K_RIGHT_TAB 3              /* Right tab                        */
#define DDIF$K_DECIMAL_TAB 4            /* Decimal tab                      */
/* Header file modified for bigendian by BigEndian_H. */
/*	Run on Mon Dec  5 15:49:46 1994
 */
/********************************************************************************************************************************/
/* Created  5-DEC-1994 15:48:18 by VAX SDL V3.2-10     Source:  8-JUL-1992 10:30:37 DECW$LIBSRESD:[CDALIB.SRC]DDIFDEF.SDL;1 */
/********************************************************************************************************************************/
/*** MODULE DDIF_DEFINITIONS IDENT V1-005 ***/
#ifndef _ddifdef_
#define _ddifdef_
/*++                                                                        */
/*                                                                          */
/*  COPYRIGHT (c) 1987, 1992 BY                                             */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.                  */
/*  ALL RIGHTS RESERVED.                                                    */
/*                                                                          */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  */
/*  TRANSFERRED.                                                            */
/*                                                                          */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  */
/*  CORPORATION.                                                            */
/*                                                                          */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 */
/*                                                                          */
/* Item codes for cda_create_root_aggregate processing-options parameter.   */
#define DDIF_INHERIT_ATTRIBUTES 1       /* Inherit segment attributes       */
#define DDIF_RETAIN_DEFINITIONS 2       /* Enable ddif_find_definition      */
#define DDIF_EVALUATE_CONTENT 3         /* Evaluate generic content references */
#define DDIF_DISCARD_I_SEGMENTS 4       /* Discard image data segments      */
#define DDIF_DISCARD_2D_SEGMENTS 5      /* Discard graphics data segments   */
#define DDIF_DISCARD_T_SEGMENTS 6       /* Discard text data segments       */
#define DDIF_DISCARD_TBL_SEGMENTS 7     /* Discard table data segments      */
#define DDIF_DISCARD_PDL_SEGMENTS 8     /* Discard page description language segments */
#define DDIF_ENABLE_INHERIT_STATUS 9    /* Enable CDA_INHERIT status        */
#define DDIF_MERGE_TYD_DIRECTIVES 10    /* If INHERIT_ATTRIBUTES set, also merge TYD directives */
#define DDIF_RESERVED_OPTION_1 11
#define DDIF_RESERVED_OPTION_2 12
/* Scope codes for cda_enter_scope and cda_leave_scope.                     */
/* If an aggregate type is listed, it must be presented with cda_enter_scope. */
#define DDIF_K_DOCUMENT_SCOPE 0         /* Document scope                   */
#define DDIF_K_CONTENT_SCOPE 1          /* Content scope                    */
#define DDIF_K_SEGMENT_SCOPE 2          /* Segment scope		DDIF_SEG */
#define DDIF_K_EXTERNAL_SCOPE 3         /* External scope		DDIF_EXT */
/* Aggregate type codes.                                                    */
#define DDIF_DDF 1                      /* DDIF document root               */
#define DDIF_DSC 2                      /* Document descriptor              */
#define DDIF_DHD 3                      /* Document header                  */
#define DDIF_SEG 4                      /* Document segment                 */
#define DDIF_TXT 5                      /* Latin-1 text content             */
#define DDIF_GTX 6                      /* General text content             */
#define DDIF_HRD 7                      /* Hard directive                   */
#define DDIF_SFT 8                      /* Soft directive                   */
#define DDIF_HRV 9                      /* Hard value directive             */
#define DDIF_SFV 10                     /* Soft value directive             */
#define DDIF_BEZ 11                     /* Bezier curve content             */
#define DDIF_LIN 12                     /* Polyline content                 */
#define DDIF_ARC 13                     /* Arc content                      */
#define DDIF_FAS 14                     /* Fill area set content            */
#define DDIF_IMG 15                     /* Image content                    */
#define DDIF_CRF 16                     /* Content reference                */
#define DDIF_EXT 17                     /* External content                 */
#define DDIF_PVT 18                     /* Private content                  */
#define DDIF_GLY 19                     /* Layout galley                    */
#define DDIF_EOS 20                     /* End of segment                   */
#define DDIF_ERF 21                     /* External reference               */
#define DDIF_IDU 22                     /* Image data unit                  */
#define DDIF_PTH 23                     /* Composite path element           */
#define DDIF_SGA 24                     /* Segment attributes               */
#define DDIF_CTD 25                     /* Content definition               */
#define DDIF_FTD 26                     /* Font definition                  */
#define DDIF_LSD 27                     /* Line style definition            */
#define DDIF_PHD 28                     /* Path definition                  */
#define DDIF_PTD 29                     /* Pattern definition               */
#define DDIF_SGB 30                     /* Segment binding definition       */
#define DDIF_TYD 31                     /* Type definition                  */
#define DDIF_CTS 32                     /* Counter style                    */
#define DDIF_OCC 33                     /* Occurrence definition            */
#define DDIF_RCD 34                     /* Record definition                */
#define DDIF_RGB 35                     /* RGB lookup table entry           */
#define DDIF_TRN 36                     /* Transform                        */
#define DDIF_LG1 37                     /* Generic layout I                 */
#define DDIF_LS1 38                     /* Specific layout I                */
#define DDIF_LW1 39                     /* Wrap attributes I                */
#define DDIF_LL1 40                     /* Layout attributes I              */
#define DDIF_GLA 41                     /* Galley attributes                */
#define DDIF_PGD 42                     /* Page description                 */
#define DDIF_PGL 43                     /* Page layout                      */
#define DDIF_PGS 44                     /* Page select                      */
#define DDIF_TBS 45                     /* Tab stop                         */
#define DDIF_CPH 46                     /* Composite path                   */
#define DDIF_AUD 47                     /* Audio content                    */
#define DDIF_ADF 48                     /* Audio data frame                 */
#define DDIF_PLJ 49                     /* Polyline join description        */
#define DDIF_PJD 50                     /* Polyline join definition         */
#define DDIF_MAX 51                     /* Maximum code plus 1              */
/* Item codes for all aggregates.  DDIF_AGGREGATE_TYPE is read-only.        */
#define DDIF_USER_CONTEXT 1             /* User context			Longword */
#define DDIF_AGGREGATE_TYPE 2           /* Aggregate type code		Word */
#define DDIF_ALL_MAX 3                  /* Maximum code plus 1              */
/* Values of data type enumeration for Measurement and Expression.          */
#define DDIF_K_VALUE_CONSTANT 0         /*				Integer */
#define DDIF_K_VALUE_VARIABLE 1         /*				String */
/* Values of data type enumeration for AngleRef.                            */
#define DDIF_K_ANGLE_CONSTANT 0         /*				Single precision floating */
#define DDIF_K_ANGLE_VARIABLE 1         /*				String */
/* Item codes for DDIF Document Root aggregate.                             */
#define DDIF_DDF_DESCRIPTOR 257         /* Document descriptor		DDIF_DSC */
#define DDIF_DDF_HEADER 258             /* Document header		DDIF_DHD */
#define DDIF_DDF_CONTENT 259            /* Document content		DDIF_SEG */
#define DDIF_DDF_MAX 260                /* Maximum code plus 1              */
/* Item codes for Document Descriptor aggregate.  During cda_put_aggregate, the values of DDIF_DSC_MAJOR_VERSION and */
/* DDIF_DSC_MINOR_VERSION are not used.  The document always contains the current values for major and minor version. */
#define DDIF_DSC_MAJOR_VERSION 513      /* Major version		Integer */
#define DDIF_DSC_MINOR_VERSION 514      /* Minor version		Integer */
#define DDIF_DSC_PRODUCT_IDENTIFIER 515 /* Product identifier		String */
#define DDIF_DSC_PRODUCT_NAME 516       /* Product name			Array of character string */
#define DDIF_DSC_MAX 517                /* Maximum code plus 1              */
/* Current values for major and minor standard version.                     */
#define DDIF_K_MAJOR_VERSION 1
#define DDIF_K_MINOR_VERSION 4
/* Item codes for Document Header aggregate.                                */
#define DDIF_DHD_PRIVATE_DATA 769       /* Private header data		Sequence of DDIF_PVT */
#define DDIF_DHD_TITLE 770              /* Title			Array of character string */
#define DDIF_DHD_AUTHOR 771             /* Author			Array of character string */
#define DDIF_DHD_VERSION 772            /* Version			Array of character string */
#define DDIF_DHD_DATE 773               /* Date				String */
#define DDIF_DHD_CONFORMANCE_TAGS 774   /* Conformance tags		Array of string with add-info */
#define DDIF_DHD_EXTERNAL_REFERENCES 775 /* External references		Sequence of DDIF_ERF */
#define DDIF_DHD_LANGUAGES_C 776        /* Languages			Array of enumeration */
#define DDIF_DHD_LANGUAGES 777          /*				Array of variable */
#define DDIF_DHD_STYLE_GUIDE 778        /* Style guide			Integer */
#define DDIF_DHD_GENERAL_TEXT_CCS_C 779 /* General text coded char.set  Array of enumeration */
#define DDIF_DHD_GENERAL_TEXT_CCS 780   /*				Array of variable */
#define DDIF_DHD_MAX 781                /* Maximum code plus 1              */
/* Values of the add-info parameter for DDIF_DHD_CONFORMANCE_TAGS.          */
#define DDIF_K_PRIVATE_CONFORMANCE 0    /* Nonstandard                      */
#define DDIF_K_SRQ_CONFORMANCE 1        /* "SRQ" (structure required)       */
/* Values of DDIF_DHD_LANGUAGES_C.                                          */
#define DDIF_K_ISO_639_LANGUAGE 0       /* ISO 639 language name	String */
#define DDIF_K_OTHER_LANGUAGE 1         /* Other language name		Character string */
/* Values of DDIF_DHD_GENERAL_TEXT_CCS_C.                                   */
#define DDIF_K_CCS_VACANT 1             /* Vacant			None (null string) */
#define DDIF_K_CCS_UNKNOWN 2            /* Unknown			String */
#define DDIF_K_CCS_ASCII_GL 3           /* ASCII gl			String */
#define DDIF_K_CCS_1_OCTET 4            /* One octet			String */
#define DDIF_K_CCS_2_OCTET 5            /* Two octets			String */
#define DDIF_K_CCS_4_OCTET 6            /* Four octets			String */
/* Item codes for Document Segment aggregate.                               */
#define DDIF_SEG_ID 1025                /* Segment ID			String */
#define DDIF_SEG_USER_LABEL 1026        /* User label			Array of character string */
#define DDIF_SEG_SEGMENT_TYPE 1027      /* Segment type			String */
#define DDIF_SEG_SPECIFIC_ATTRIBUTES 1028 /* Specific attributes		DDIF_SGA */
#define DDIF_SEG_GENERIC_LAYOUT 1029    /* Generic layout		DDIF_LG1 */
#define DDIF_SEG_SPECIFIC_LAYOUT 1030   /* Specific layout		DDIF_LS1 */
#define DDIF_SEG_CONTENT 1031           /* Segment content		Sequence of content */
#define DDIF_SEG_MAX 1032               /* Maximum code plus 1              */
/* Item codes for Latin-1 Text Content aggregate.                           */
#define DDIF_TXT_CONTENT 1281           /* Text content			String */
#define DDIF_TXT_MAX 1282               /* Maximum code plus 1              */
/* Item codes for General Text Content aggregate.                           */
#define DDIF_GTX_CONTENT 1537           /* Text content			Character string */
#define DDIF_GTX_MAX 1538               /* Maximum code plus 1              */
/* Item codes for Hard Directive aggregate.                                 */
#define DDIF_HRD_DIRECTIVE 1793         /* Hard directive		Enumeration */
#define DDIF_HRD_MAX 1794               /* Maximum code plus 1              */
/* Item codes for Soft Directive aggregate.                                 */
#define DDIF_SFT_DIRECTIVE 2049         /* Soft directive		Enumeration */
#define DDIF_SFT_MAX 2050               /* Maximum code plus 1              */
/* Values of DDIF_HRD_DIRECTIVE, DDIF_SFT_DIRECTIVE,			DDIF conforming */
/* DDIF_LL1_INITIAL_DIRECTIVE.                                              */
#define DDIF_K_DIR_NEW_PAGE 1           /* New page                         */
#define DDIF_K_DIR_NEW_LINE 2           /* New line                         */
#define DDIF_K_DIR_NEW_GALLEY 3         /* New galley                       */
#define DDIF_K_DIR_TAB 4                /* Tab                              */
#define DDIF_K_DIR_SPACE 5              /* Space                            */
#define DDIF_K_DIR_HYPHEN_NEW_LINE 6    /* Hyphen and new line              */
#define DDIF_K_DIR_WORD_BREAK_POINT 7   /* Word break point                 */
#define DDIF_K_DIR_LEADERS 8            /* Leaders                          */
#define DDIF_K_DIR_BACKSPACE 9          /* Backspace                        */
#define DDIF_K_DIR_NULL 10              /* Null                             */
#define DDIF_K_DIR_NO_HYPHEN_WORD 11    /* No hyphenation in next word      */
#define DDIF_K_DIR_NEW_LEFTPAGE 16      /* New left page                    */
#define DDIF_K_DIR_NEW_RIGHTPAGE 17     /* New right page                   */
#define DDIF_K_DIR_LEFT_NEW_LINE 18     /* Left new line (obsolete)         */
#define DDIF_K_DIR_RIGHT_NEW_LINE 19    /* Right new line (obsolete)        */
#define DDIF_K_DIR_CENTERED_NEW_LINE 20 /* Centered new line (obsolete)     */
#define DDIF_K_DIR_JUSTIFIED_NEW_LINE 21 /* Fully justified new line (obsolete) */
/* Item codes for Hard Value Directive aggregate.                           */
#define DDIF_HRV_C 2305                 /* Directive choice		Enumeration */
#define DDIF_HRV_ESC_RATIO_N 2306       /* Escapement ratio		Integer */
#define DDIF_HRV_ESC_RATIO_D 2307       /*				Integer */
#define DDIF_HRV_ESC_CONSTANT_C 2308    /* Escapement constant		Measurement enumeration */
#define DDIF_HRV_ESC_CONSTANT 2309      /*				Variable */
#define DDIF_HRV_RESET_VARIABLE 2310    /* Reset variable		String */
#define DDIF_HRV_RESET_VALUE_C 2311     /* Reset value			Expression enumeration */
#define DDIF_HRV_RESET_VALUE 2312       /*				Variable */
#define DDIF_HRV_MAX 2313               /* Maximum code plus 1              */
/* Item codes for Soft Value Directive aggregate.                           */
#define DDIF_SFV_C 2561                 /* Directive choice		Enumeration */
#define DDIF_SFV_ESC_RATIO_N 2562       /* Escapement ratio		Integer */
#define DDIF_SFV_ESC_RATIO_D 2563       /*				Integer */
#define DDIF_SFV_ESC_CONSTANT_C 2564    /* Escapement constant		Measurement enumeration */
#define DDIF_SFV_ESC_CONSTANT 2565      /*				Variable */
#define DDIF_SFV_RESET_VARIABLE 2566    /* Reset variable		String */
#define DDIF_SFV_RESET_VALUE_C 2567     /* Reset value			Expression enumeration */
#define DDIF_SFV_RESET_VALUE 2568       /*				Variable */
#define DDIF_SFV_MAX 2569               /* Maximum code plus 1              */
/* Values of DDIF_HRV_C, DDIF_SFV_C.                                        */
#define DDIF_K_DIR_ESCAPEMENT 0         /* Escapement directive		HRV_ESC_RATIO_N to HRV_ESC_CONSTANT */
/*				SFV_ESC_RATIO_N to SFV_ESC_CONSTANT         */
#define DDIF_K_DIR_VARIABLE_RESET 1     /* Variable reset		HRV_RESET_VARIABLE to HRV_RESET_VALUE */
/*				SFV_RESET_VARIABLE to SFV_RESET_VALUE       */
/* Item codes for Bezier Curve Content aggregate.                           */
#define DDIF_BEZ_FLAGS 2817             /* Flags			Longword */
#define DDIF_BEZ_PATH_C 2818            /* Path				Array of Measurement enumeration */
#define DDIF_BEZ_PATH 2819              /*				Array of variable */
#define DDIF_BEZ_MAX 2820               /* Maximum code plus 1              */
/* Bit definitions for DDIF_BEZ_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_bez_draw_curve 0x80000000
#else
#define ddif_m_bez_draw_curve 1
#endif
#ifdef CDAbig_endian
#define ddif_m_bez_fill_curve 0x40000000
#else
#define ddif_m_bez_fill_curve 2
#endif
#ifdef CDAbig_endian
#define ddif_m_bez_close_curve 0x20000000
#else
#define ddif_m_bez_close_curve 4
#endif
struct bez_flags {
    unsigned ddif_v_bez_draw_curve : 1; /* Draw curve                       */
    unsigned ddif_v_bez_fill_curve : 1; /* Fill curve                       */
    unsigned ddif_v_bez_close_curve : 1; /* Close curve                     */
    unsigned ddif_v_bez_fill_0 : 13;
    unsigned ddif_v_bez_fill : 16;
    } ;
/* Item codes for Polyline Content aggregate.                               */
#define DDIF_LIN_FLAGS 3073             /* Flags			Longword */
#define DDIF_LIN_DRAW_PATTERN 3074      /* Draw pattern			Bit string */
#define DDIF_LIN_PATH_C 3075            /* Path				Array of Measurement enumeration */
#define DDIF_LIN_PATH 3076              /*				Array of variable */
#define DDIF_LIN_JOINS_C 3077           /* Polyline joins		Array of enumeration */
#define DDIF_LIN_JOINS 3078             /*				Array of variable */
#define DDIF_LIN_MAX 3079               /* Maximum code plus 1              */
/* Bit definitions for DDIF_LIN_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_lin_draw_polyline 0x80000000
#else
#define ddif_m_lin_draw_polyline 1
#endif
#ifdef CDAbig_endian
#define ddif_m_lin_fill_polyline 0x40000000
#else
#define ddif_m_lin_fill_polyline 2
#endif
#ifdef CDAbig_endian
#define ddif_m_lin_draw_markers 0x20000000
#else
#define ddif_m_lin_draw_markers 4
#endif
#ifdef CDAbig_endian
#define ddif_m_lin_regular_polygon 0x10000000
#else
#define ddif_m_lin_regular_polygon 8
#endif
#ifdef CDAbig_endian
#define ddif_m_lin_close_polyline 0x8000000
#else
#define ddif_m_lin_close_polyline 16
#endif
#ifdef CDAbig_endian
#define ddif_m_lin_rounded_polyline 0x4000000
#else
#define ddif_m_lin_rounded_polyline 32
#endif
#ifdef CDAbig_endian
#define ddif_m_lin_rectangular_polygon 0x2000000
#else
#define ddif_m_lin_rectangular_polygon 64
#endif
struct lin_flags {
    unsigned ddif_v_lin_draw_polyline : 1; /* Draw polyline                 */
    unsigned ddif_v_lin_fill_polyline : 1; /* Fill polyline                 */
    unsigned ddif_v_lin_draw_markers : 1; /* Draw markers                   */
    unsigned ddif_v_lin_regular_polygon : 1; /* Regular polygon             */
    unsigned ddif_v_lin_close_polyline : 1; /* Close polyline               */
    unsigned ddif_v_lin_rounded_polyline : 1; /* Rounded polyline           */
    unsigned ddif_v_lin_rectangular_polygon : 1; /* Rectangular polygon     */
    unsigned ddif_v_lin_fill_0 : 9;
    unsigned ddif_v_lin_fill : 16;
    } ;
/* Renamed flag value introduced in V1.4                                    */
#ifdef CDAbig_endian
#define ddif_m_lin_smoothed_polyline 0x4000000
#else
#define ddif_m_lin_smoothed_polyline 32
#endif
/* Values of DDIF_LIN_JOINS_C and DDIF_PTH_JOINED_LINE_JOINS_C.             */
#define DDIF_K_DIRECT_JOIN 0            /* Join directly specified	DDIF_PLJ */
#define DDIF_K_INDIRECT_JOIN 1          /* Join definition referenced	String */
/* Item codes for Arc Content aggregate.                                    */
#define DDIF_ARC_FLAGS 3329             /* Flags			Longword */
#define DDIF_ARC_CENTER_X_C 3330        /* Center X			Measurement enumeration */
#define DDIF_ARC_CENTER_X 3331          /*				Variable */
#define DDIF_ARC_CENTER_Y_C 3332        /* Center Y			Measurement enumeration */
#define DDIF_ARC_CENTER_Y 3333          /*				Variable */
#define DDIF_ARC_RADIUS_X_C 3334        /* Radius X			Measurement enumeration */
#define DDIF_ARC_RADIUS_X 3335          /*				Variable */
#define DDIF_ARC_RADIUS_DELTA_Y_C 3336  /* Radius delta Y		Measurement enumeration */
#define DDIF_ARC_RADIUS_DELTA_Y 3337    /*				Variable */
#define DDIF_ARC_START_C 3338           /* Start angle			AngleRef enumeration */
#define DDIF_ARC_START 3339             /*				Variable */
#define DDIF_ARC_EXTENT_C 3340          /* Extent			AngleRef enumeration */
#define DDIF_ARC_EXTENT 3341            /*				Variable */
#define DDIF_ARC_ROTATION_C 3342        /* Rotation			AngleRef enumeration */
#define DDIF_ARC_ROTATION 3343          /*				Variable */
#define DDIF_ARC_MAX 3344               /* Maximum code plus 1              */
/* Bit definitions for DDIF_ARC_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_arc_draw_arc 0x80000000
#else
#define ddif_m_arc_draw_arc 1
#endif
#ifdef CDAbig_endian
#define ddif_m_arc_fill_arc 0x40000000
#else
#define ddif_m_arc_fill_arc 2
#endif
#ifdef CDAbig_endian
#define ddif_m_arc_pie_arc 0x20000000
#else
#define ddif_m_arc_pie_arc 4
#endif
#ifdef CDAbig_endian
#define ddif_m_arc_close_arc 0x10000000
#else
#define ddif_m_arc_close_arc 8
#endif
struct arc_flags {
    unsigned ddif_v_arc_draw_arc : 1;   /* Draw arc                         */
    unsigned ddif_v_arc_fill_arc : 1;   /* Fill arc                         */
    unsigned ddif_v_arc_pie_arc : 1;    /* Pie arc                          */
    unsigned ddif_v_arc_close_arc : 1;  /* Close arc                        */
    unsigned ddif_v_arc_flags_fill_0 : 12;
    unsigned ddif_v_arc_flags_fill : 16;
    } ;
/* Item codes for Fill Area Set Content aggregate.                          */
#define DDIF_FAS_FLAGS 3585             /* Flags			Longword */
#define DDIF_FAS_PATH 3586              /* Path    			Sequence of DDIF_PTH */
#define DDIF_FAS_MORE_PATHS 3587        /* More paths			Sequence of DDIF_CPH */
#define DDIF_FAS_MAX 3588               /* Maximum code plus 1              */
/* Bit definitions for DDIF_FAS_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_fas_co_draw_border 0x80000000
#else
#define ddif_m_fas_co_draw_border 1
#endif
#ifdef CDAbig_endian
#define ddif_m_fas_co_fill_area 0x40000000
#else
#define ddif_m_fas_co_fill_area 2
#endif
struct fas_flags {
    unsigned ddif_v_fas_co_draw_border : 1; /* Co-draw border               */
    unsigned ddif_v_fas_co_fill_area : 1; /* Co-fill area                   */
    unsigned ddif_v_fas_fill_0 : 14;
    unsigned ddif_v_fas_fill : 16;
    } ;
/* Item codes for Image Content aggregate.                                  */
#define DDIF_IMG_CONTENT 3841           /* Image content		Sequence of DDIF_IDU */
#define DDIF_IMG_MAX 3842               /* Maximum code plus 1              */
/* Item codes for Content Reference aggregate.                              */
#define DDIF_CRF_TRANSFORM 4097         /* Content transform		Sequence of DDIF_TRN */
#define DDIF_CRF_REFERENCE 4098         /* Content reference		String */
#define DDIF_CRF_MAX 4099               /* Maximum code plus 1              */
/* Item codes for External Content aggregate.                               */
#define DDIF_EXT_DIRECT_REFERENCE 4353  /* Direct reference		Object identifier */
#define DDIF_EXT_INDIRECT_REFERENCE 4354 /* Indirect reference		Integer */
#define DDIF_EXT_DATA_VALUE_DESCRIPTOR 4355 /* Data value descriptor	String */
#define DDIF_EXT_ENCODING_C 4356        /* Encoding			Enumeration */
#define DDIF_EXT_ENCODING 4357          /*				Variable */
#define DDIF_EXT_ENCODING_L 4358        /*     Length (on input)	Integer */
#define DDIF_EXT_MAX 4359               /* Maximum code plus 1              */
/* Values of DDIF_EXT_ENCODING_C.                                           */
#define DDIF_K_DOCUMENT_ENCODING 0      /* Nested document		Document root aggregate */
#define DDIF_K_DDIS_ENCODING 1          /* Nested document		DDIS encoding */
#define DDIF_K_OCTET_ENCODING 2         /* Octet aligned		String */
#define DDIF_K_ARBITRARY_ENCODING 3     /* Arbitrary			Bit string */
/* Item codes for Private Content aggregate.                                */
#define DDIF_PVT_NAME 4609              /* Value name			String */
#define DDIF_PVT_DATA_C 4610            /* Value data			Enumeration */
#define DDIF_PVT_DATA 4611              /*				Variable */
#define DDIF_PVT_REFERENCE_ERF_INDEX 4612 /*     Reference index		Integer */
#define DDIF_PVT_MAX 4613               /* Maximum code plus 1              */
/* Values of DDIF_PVT_DATA_C.                                               */
#define DDIF_K_VALUE_BOOLEAN 0          /*				Boolean */
#define DDIF_K_VALUE_INTEGER 1          /*				Integer */
#define DDIF_K_VALUE_TEXT 2             /*				Array of character string */
#define DDIF_K_VALUE_GENERAL 3          /*				String */
#define DDIF_K_VALUE_REFERENCE 4        /*				String (DDIF_PVT_REFERENCE_ERF_INDEX used) */
#define DDIF_K_VALUE_LIST 5             /*				Sequence of DDIF_PVT */
#define DDIF_K_VALUE_EXTERNAL 6         /*				DDIF_EXT */
/* Item codes for Layout Galley aggregate.                                  */
#define DDIF_GLY_ID 4865                /* Galley ID			String */
#define DDIF_GLY_BOUNDING_BOX_LL_X_C 4866 /* Galley bounding box		Measurement enumeration */
#define DDIF_GLY_BOUNDING_BOX_LL_X 4867 /*     Lower left X coordinate	Variable */
#define DDIF_GLY_BOUNDING_BOX_LL_Y_C 4868 /*				Measurement enumeration */
#define DDIF_GLY_BOUNDING_BOX_LL_Y 4869 /*     Lower left Y coordinate	Variable */
#define DDIF_GLY_BOUNDING_BOX_UR_X_C 4870 /*				Measurement enumeration */
#define DDIF_GLY_BOUNDING_BOX_UR_X 4871 /*     Upper right X coordinate	Variable */
#define DDIF_GLY_BOUNDING_BOX_UR_Y_C 4872 /*				Measurement enumeration */
#define DDIF_GLY_BOUNDING_BOX_UR_Y 4873 /*     Upper right Y coordinate	Variable */
#define DDIF_GLY_OUTLINE 4874           /* Galley outline		Sequence of DDIF_PTH */
#define DDIF_GLY_FLAGS 4875             /* Galley flags			Longword */
#define DDIF_GLY_STREAMS 4876           /* Galley streams		Array of string */
#define DDIF_GLY_SUCCESSOR_C 4877       /* Successor			Enumeration */
#define DDIF_GLY_SUCCESSOR 4878         /*				Variable */
#define DDIF_GLY_MAX 4879               /* Maximum code plus 1              */
/* Bit definitions for DDIF_GLY_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_gly_vertical_align 0x80000000
#else
#define ddif_m_gly_vertical_align 1
#endif
#ifdef CDAbig_endian
#define ddif_m_gly_border 0x40000000
#else
#define ddif_m_gly_border 2
#endif
#ifdef CDAbig_endian
#define ddif_m_gly_autoconnect 0x20000000
#else
#define ddif_m_gly_autoconnect 4
#endif
#ifdef CDAbig_endian
#define ddif_m_gly_background_fill 0x10000000
#else
#define ddif_m_gly_background_fill 8
#endif
#ifdef CDAbig_endian
#define ddif_m_gly_reserved 0x8000000
#else
#define ddif_m_gly_reserved 16
#endif
#ifdef CDAbig_endian
#define ddif_m_gly_nonimaged_proto 0x4000000
#else
#define ddif_m_gly_nonimaged_proto 32
#endif
#ifdef CDAbig_endian
#define ddif_m_gly_current_value 0x2000000
#else
#define ddif_m_gly_current_value 64
#endif
struct gly_flags {
    unsigned ddif_v_gly_vertical_align : 1; /* Vertical align               */
    unsigned ddif_v_gly_border : 1;     /* Border                           */
    unsigned ddif_v_gly_autoconnect : 1; /* Autoconnect                     */
    unsigned ddif_v_gly_background_fill : 1; /* Background fill             */
    unsigned ddif_v_gly_reserved : 1;   /* Reserved for future use          */
    unsigned ddif_v_gly_nonimaged_proto : 1; /* Nonimaged proto             */
    unsigned ddif_v_gly_current_value : 1; /* Current value                 */
    unsigned ddif_v_gly_fill_0 : 9;
    unsigned ddif_v_gly_fill : 16;
    } ;
/* Values of DDIF_GLY_SUCCESSOR_C.                                          */
#define DDIF_K_GENERIC_GALLEY 0         /* Generic galley		String */
#define DDIF_K_SPECIFIC_GALLEY 1        /* Specific galley		String */
#define DDIF_K_NO_SUCCESSOR_GALLEY 2    /* No successor galley		None */
/* Item codes for External Reference aggregate.                             */
#define DDIF_ERF_DATA_TYPE 5377         /* Data type			Object identifier */
#define DDIF_ERF_DESCRIPTOR 5378        /* Descriptor			Array of character string */
#define DDIF_ERF_LABEL 5379             /* Label			Character string */
#define DDIF_ERF_LABEL_TYPE 5380        /* Label type			String with add-info */
#define DDIF_ERF_CONTROL 5381           /* Control			Enumeration */
#define DDIF_ERF_MAX 5382               /* Maximum code plus 1              */
/* Values of the add-info parameter for DDIF_ERF_LABEL_TYPE.  Must be identical */
/* to values for DTIF_ERF_LABEL_TYPE and DOTS_RTE_NAME_TYPE.                */
#define DDIF_K_PRIVATE_LABEL_TYPE 0     /* Private label type               */
#define DDIF_K_RMS_LABEL_TYPE 1         /* RMS file specification ("$RMS")  */
#define DDIF_K_UTX_LABEL_TYPE 2         /* ULTRIX file specification ("$UTX") */
#define DDIF_K_MDS_LABEL_TYPE 3         /* MS-DOS file specification ("$MDS") */
#define DDIF_K_STYLE_LABEL_TYPE 4       /* Style-guide file specification ("$STYLE") */
#define DDIF_K_OS2_LABEL_TYPE 5         /* OS/2 file specification ("$OS2") */
#define DDIF_K_OA_LABEL_TYPE 6          /* ALL-IN-1 file specification ("$OA") */
#define DDIF_K_PACKED_STYLE_LABEL_TYPE 7 /* Style-guide file specification ("$STYLE") (used when */
/* NO_COPY style guide packed by DOTS)                                      */
/* Values of DDIF_ERF_CONTROL.						DDIF conforming */
#define DDIF_K_COPY_REFERENCE 1         /* Copy on reference                */
#define DDIF_K_NO_COPY_REFERENCE 2      /* No copy on reference             */
/* Item codes for Image Data Unit aggregate.                                */
#define DDIF_IDU_PRIVATE_CODING_ATTR 5633 /* Private coding attributes	Sequence of DDIF_PVT */
#define DDIF_IDU_PIXELS_PER_LINE 5634   /* Pixels per line		Integer */
#define DDIF_IDU_NUMBER_OF_LINES 5635   /* Number of lines		Integer */
#define DDIF_IDU_COMPRESSION_TYPE 5636  /* Compression type		Enumeration */
#define DDIF_IDU_COMPRESSION_PARAMS 5637 /* Compression parameters	Sequence of DDIF_PVT */
#define DDIF_IDU_DATA_OFFSET 5638       /* Data offset			Integer */
#define DDIF_IDU_PIXEL_STRIDE 5639      /* Pixel stride			Integer */
#define DDIF_IDU_SCANLINE_STRIDE 5640   /* Scanline stride		Integer */
#define DDIF_IDU_BIT_ORDER 5641         /* Bit order			Enumeration */
#define DDIF_IDU_BITS_PER_PIXEL 5642    /* Plane bits per pixel		Integer */
#define DDIF_IDU_PLANE_DATA 5643        /* Plane data			String */
#define DDIF_IDU_BYTE_UNIT 5644         /* Byte unit			Integer */
#define DDIF_IDU_BYTE_ORDER 5645        /* Byte order			Enumeration */
#define DDIF_IDU_DATA_TYPE 5646         /* Data type			Enumeration */
#define DDIF_IDU_MAX 5647               /* Maximum code plus 1              */
/* AX04 item code retained for upward compatibility.                        */
#define DDIF_IDU_PIXEL_ORDER 5641       /* Pixel order                      */
/* Values of DDIF_IDU_COMPRESSION_TYPE.				DDIF conforming */
#define DDIF_K_PRIVATE_COMPRESSION 1    /* Private                          */
#define DDIF_K_PCM_COMPRESSION 2        /* Raw bitmap                       */
#define DDIF_K_G31D_COMPRESSION 3       /* CCITT Group 3 1 dimensional      */
#define DDIF_K_G32D_COMPRESSION 4       /* CCITT Group 3 2 dimensional      */
#define DDIF_K_G42D_COMPRESSION 5       /* CCITT Group 4 2 dimensional      */
#define DDIF_K_MONO_COMPRESSION 6       /* Mono compression                 */
#define DDIF_K_DCT_COMPRESSION 7        /* DCT compression                  */
/* Values of DDIF_IDU_BIT_ORDER and DDIF_AUD_BIT_ORDER.		DDIF conforming */
#define DDIF_K_LSBIT_FIRST 1            /* Least significant bit first      */
#define DDIF_K_MSBIT_FIRST 2            /* Most significant bit first       */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_K_STANDARD_PIXEL_ORDER 1   /* Standard pixel order             */
#define DDIF_K_REVERSE_PIXEL_ORDER 2    /* Reverse pixel order              */
/* Values of DDIF_IDU_BYTE_ORDER and DDIF_AUD_BYTE_ORDER		DDIF conforming */
#define DDIF_K_LSBYTE_FIRST 1           /* Least significant byte first     */
#define DDIF_K_MSBYTE_FIRST 2           /* Most significatn byte first      */
/* Values of DDIF_IDU_DATA_TYPE.					DDIF conforming */
#define DDIF_K_PRIVATE 1                /* Private                          */
#define DDIF_K_BITSTREAM 2              /* Bitstream                        */
#define DDIF_K_INTEGER 3                /* Integer                          */
/* Item codes for Composite Path aggregate.                                 */
#define DDIF_PTH_C 5889                 /* Path choice			Enumeration */
#define DDIF_PTH_LIN_PATH_C 5890        /* Line path			Array of Measurement enumeration */
#define DDIF_PTH_LIN_PATH 5891          /*				Array of variable */
#define DDIF_PTH_BEZ_PATH_C 5892        /* Cubic Bezier path		Array of Measurement enumeration */
#define DDIF_PTH_BEZ_PATH 5893          /*				Array of variable */
#define DDIF_PTH_ARC_CENTER_X_C 5894    /* Center X			Measurement enumeration */
#define DDIF_PTH_ARC_CENTER_X 5895      /*				Variable */
#define DDIF_PTH_ARC_CENTER_Y_C 5896    /* Center Y			Measurement enumeration */
#define DDIF_PTH_ARC_CENTER_Y 5897      /*				Variable */
#define DDIF_PTH_ARC_RADIUS_X_C 5898    /* Radius X			Measurement enumeration */
#define DDIF_PTH_ARC_RADIUS_X 5899      /*				Variable */
#define DDIF_PTH_ARC_RADIUS_DELTA_Y_C 5900 /* Radius delta Y		Measurement enumeration */
#define DDIF_PTH_ARC_RADIUS_DELTA_Y 5901 /*				Variable */
#define DDIF_PTH_ARC_START_C 5902       /* Start angle			AngleRef enumeration */
#define DDIF_PTH_ARC_START 5903         /*				Variable */
#define DDIF_PTH_ARC_EXTENT_C 5904      /* Extent			AngleRef enumeration */
#define DDIF_PTH_ARC_EXTENT 5905        /*				Variable */
#define DDIF_PTH_ARC_ROTATION_C 5906    /* Rotation			AngleRef enumeration */
#define DDIF_PTH_ARC_ROTATION 5907      /*				Variable */
#define DDIF_PTH_REFERENCE 5908         /* Path reference		Integer */
#define DDIF_PTH_JOINED_LINE_PATH_C 5909 /* Joined line path		Array of Measurement enumeration */
#define DDIF_PTH_JOINED_LINE_PATH 5910  /*				Array of Variable */
#define DDIF_PTH_JOINED_LINE_JOINS_C 5911 /* Joined line joins		Array of enumeration */
#define DDIF_PTH_JOINED_LINE_JOINS 5912 /*				Array of variable */
#define DDIF_PTH_MAX 5913               /* Maximum code plus 1              */
/* Values of DDIF_PTH_C.                                                    */
#define DDIF_K_PATH_LINE 0              /*				PTH_LIN_PATH_C to PTH_LIN_PATH */
#define DDIF_K_PATH_BEZIER 1            /*				PTH_BEZ_PATH_C to PTH_BEZ_PATH */
#define DDIF_K_PATH_ARC 2               /*				PTH_ARC_CENTER_X_C to PTH_ARC_ROTATION */
#define DDIF_K_PATH_REFERENCE 3         /*				PTH_REFERENCE */
#define DDIF_K_PATH_JOINED_LINE 4       /*				PTH_JOINED_LINE_PATH_C to PTH_JOINED_LINE_JOINS */
/* Item codes for Segment Attributes aggregate.  SGA_ITEM_CHANGE_LIST is read-only. */
#define DDIF_SGA_PRIVATE_DATA 6145      /* Private attributes		Sequence of DDIF_PVT */
#define DDIF_SGA_CONTENT_STREAMS 6146   /* Content streams		Array of string */
#define DDIF_SGA_CONTENT_CATEGORY 6147  /* Content category		String with add-info */
#define DDIF_SGA_SEGMENT_TAGS 6148      /* Segment tags			Array of string with add-info */
#define DDIF_SGA_BINDING_DEFNS 6149     /* Segment bindings		Sequence of DDIF_SGB */
#define DDIF_SGA_COMPUTE_C 6150         /* Computed content choice	Enumeration */
#define DDIF_SGA_CPTCPY_TARGET 6151     /* Reference target		String */
#define DDIF_SGA_CPTCPY_ERF_INDEX 6152  /* Reference external index	Integer */
#define DDIF_SGA_CPTVAR_VARIABLE 6153   /* Variable name		String */
#define DDIF_SGA_CPTXRF_TARGET 6154     /* Cross-reference target	String */
#define DDIF_SGA_CPTXRF_ERF_INDEX 6155  /* Cross-reference index	Integer */
#define DDIF_SGA_CPTXRF_VARIABLE 6156   /* Variable name		String */
#define DDIF_SGA_CPTFNC_NAME 6157       /* Function name		String */
#define DDIF_SGA_CPTFNC_PARAMETERS 6158 /* Function parameters		Sequence of DDIF_PVT */
#define DDIF_SGA_STRUCTURE_DESC_C 6159  /* Structure description	Enumeration */
#define DDIF_SGA_STRUCTURE_DESC 6160    /* 				Sequence of DDIF_OCC */
#define DDIF_SGA_LANGUAGE 6161          /* Language			Integer */
#define DDIF_SGA_LEGEND_UNIT_N 6162     /* Legend units			Integer */
#define DDIF_SGA_LEGEND_UNIT_D 6163     /*				Integer */
#define DDIF_SGA_LEGEND_UNIT_NAME 6164  /* Legend name			Array of character string */
#define DDIF_SGA_UNITS_PER_MEASURE 6165 /* Units per measurement	Integer */
#define DDIF_SGA_UNIT_NAME 6166         /* Units name			Array of character string */
#define DDIF_SGA_ALT_PRESENTATION 6167  /* Alternate presentation	Array of character string */
#define DDIF_SGA_LAYOUT_C 6168          /* Layout choice		Enumeration */
#define DDIF_SGA_LAYGLY_WRAP 6169       /* Galley wrap attributes	DDIF_LW1 */
#define DDIF_SGA_LAYGLY_LAYOUT 6170     /* Galley layout attributes	DDIF_LL1 */
#define DDIF_SGA_LAYPTH_PATH 6171       /* String layout path		Sequence of DDIF_PTH */
#define DDIF_SGA_LAYPTH_FORMAT 6172     /* String layout format		Enumeration */
#define DDIF_SGA_LAYPTH_ORIENTATION_C 6173 /* Character orientation	Enumeration */
#define DDIF_SGA_LAYPTH_ORIENTATION 6174 /*				Variable */
#define DDIF_SGA_LAYPTH_H_ALIGN 6175    /* Character horizontal align	Enumeration */
#define DDIF_SGA_LAYPTH_V_ALIGN 6176    /* Character vertical align	Enumeration */
#define DDIF_SGA_LAYREL_H_RATIO_N 6177  /* Horiz escapement ratio	Integer */
#define DDIF_SGA_LAYREL_H_RATIO_D 6178  /*				Integer */
#define DDIF_SGA_LAYREL_H_CONSTANT_C 6179 /* Horiz escapement constant	Measurement enumeration */
#define DDIF_SGA_LAYREL_H_CONSTANT 6180 /*				Variable */
#define DDIF_SGA_LAYREL_V_RATIO_N 6181  /* Vert escapement ratio	Integer */
#define DDIF_SGA_LAYREL_V_RATIO_D 6182  /*				Integer */
#define DDIF_SGA_LAYREL_V_CONSTANT_C 6183 /* Vert escapement constant	Measurement enumeration */
#define DDIF_SGA_LAYREL_V_CONSTANT 6184 /*				Variable */
#define DDIF_SGA_LAYPOS_TEXT_POSITION 6185 /* Text position		Enumeration */
#define DDIF_SGA_FONT_DEFNS 6186        /* Font definitions		Sequence of DDIF_FTD */
#define DDIF_SGA_PATTERN_DEFNS 6187     /* Pattern definitions		Sequence of DDIF_PTD */
#define DDIF_SGA_PATH_DEFNS 6188        /* Path definitions		Sequence of DDIF_PHD */
#define DDIF_SGA_LINE_STYLE_DEFNS 6189  /* Line style definitions	Sequence of DDIF_LSD */
#define DDIF_SGA_CONTENT_DEFNS 6190     /* Content definitions		Sequence of DDIF_CTD */
#define DDIF_SGA_TYPE_DEFNS 6191        /* Type definitions		Sequence of DDIF_TYD */
#define DDIF_SGA_TXT_MASK_PATTERN 6192  /* Text mask pattern		Integer */
#define DDIF_SGA_TXT_FONT 6193          /* Text font			Integer */
#define DDIF_SGA_TXT_RENDITION 6194     /* Text rendition		Array of enumeration */
#define DDIF_SGA_TXT_HEIGHT_C 6195      /* Text height			Measurement enumeration */
#define DDIF_SGA_TXT_HEIGHT 6196        /* 				Variable */
#define DDIF_SGA_TXT_SET_SIZE_N 6197    /* Text set size		Integer */
#define DDIF_SGA_TXT_SET_SIZE_D 6198    /* Text set size		Integer */
#define DDIF_SGA_TXT_DIRECTION 6199     /* Text direction		Enumeration */
#define DDIF_SGA_TXT_DEC_ALIGNMENT 6200 /* Decimal align characters	Array of character string */
#define DDIF_SGA_TXT_LEADER_SPACE_C 6201 /* Leader space			Measurement enumeration */
#define DDIF_SGA_TXT_LEADER_SPACE 6202  /* 				Variable */
#define DDIF_SGA_TXT_LEADER_BULLET 6203 /* Leader bullet		Character string */
#define DDIF_SGA_TXT_LEADER_ALIGN 6204  /* Leader alignment		Enumeration */
#define DDIF_SGA_TXT_LEADER_STYLE 6205  /* Leader style			Enumeration */
#define DDIF_SGA_TXT_PAIR_KERNING 6206  /* Pair kerning			Boolean */
#define DDIF_SGA_LIN_WIDTH_C 6207       /* Line width			Measurement enumeration */
#define DDIF_SGA_LIN_WIDTH 6208         /* 				Variable */
#define DDIF_SGA_LIN_STYLE 6209         /* Line style			Integer */
#define DDIF_SGA_LIN_PATTERN_SIZE_C 6210 /* Line pattern size		Measurement enumeration */
#define DDIF_SGA_LIN_PATTERN_SIZE 6211  /* 				Variable */
#define DDIF_SGA_LIN_MASK_PATTERN 6212  /* Line mask pattern		Integer */
#define DDIF_SGA_LIN_END_START 6213     /* Line end start		Enumeration */
#define DDIF_SGA_LIN_END_FINISH 6214    /* Line end finish		Enumeration */
#define DDIF_SGA_LIN_END_SIZE_C 6215    /* Line end size		Measurement enumeration */
#define DDIF_SGA_LIN_END_SIZE 6216      /*				Variable */
#define DDIF_SGA_LIN_JOIN 6217          /* Line join			Enumeration */
#define DDIF_SGA_LIN_MITER_LIMIT_N 6218 /* Line miter limit		Integer */
#define DDIF_SGA_LIN_MITER_LIMIT_D 6219 /*				Integer */
#define DDIF_SGA_LIN_INTERIOR_PATTERN 6220 /* Line interior pattern	Integer */
#define DDIF_SGA_MKR_STYLE 6221         /* Marker style			Enumeration */
#define DDIF_SGA_MKR_MASK_PATTERN 6222  /* Marker mask pattern		Integer */
#define DDIF_SGA_MKR_SIZE_C 6223        /* Marker size			Measurement enumeration */
#define DDIF_SGA_MKR_SIZE 6224          /*	 			Variable */
#define DDIF_SGA_GLY_ATTRIBUTES 6225    /* Galley attributes		DDIF_GLA */
#define DDIF_SGA_IMG_PRIVATE_DATA 6226  /* Image private data		Sequence of DDIF_PVT */
#define DDIF_SGA_IMG_PIXEL_PATH 6227    /* Pixel path			Integer */
#define DDIF_SGA_IMG_LINE_PROGRESSION 6228 /* Line progression		Integer */
#define DDIF_SGA_IMG_PP_PIXEL_DIST 6229 /* Asp ratio, pixel path	Integer */
#define DDIF_SGA_IMG_LP_PIXEL_DIST 6230 /* Asp ratio, line progression	Integer */
#define DDIF_SGA_IMG_BRT_POLARITY 6231  /* Brightness polarity		Enumeration */
#define DDIF_SGA_IMG_GRID_TYPE 6232     /* Grid type			Enumeration */
#define DDIF_SGA_IMG_TIMING_DESC 6233   /* Timing descriptor		Binary relative time */
#define DDIF_SGA_IMG_SPECTRAL_MAPPING 6234 /* Spectral component mapping	Enumeration */
#define DDIF_SGA_IMG_LOOKUP_TABLES_C 6235 /* Lookup tables		Enumeration */
#define DDIF_SGA_IMG_LOOKUP_TABLES 6236 /*				Variable */
#define DDIF_SGA_IMG_COMP_WAVELENGTH_C 6237 /* Component wavelength info	Enumeration */
#define DDIF_SGA_IMG_COMP_WAVELENGTH 6238 /*				Variable */
#define DDIF_SGA_IMG_COMP_SPACE_ORG 6239 /* Component space organization	Enumeration */
#define DDIF_SGA_IMG_PLANES_PER_PIXEL 6240 /* Data planes per pixel	Integer */
#define DDIF_SGA_IMG_PLANE_SIGNIF 6241  /* Data plane significance	Enumeration */
#define DDIF_SGA_IMG_NUMBER_OF_COMP 6242 /* Number of components		Integer */
#define DDIF_SGA_IMG_BITS_PER_COMP 6243 /* Bits per component		Array of integer */
#define DDIF_SGA_FRM_FLAGS 6244         /* Frame flags			Longword */
#define DDIF_SGA_FRM_BOX_LL_X_C 6245    /* Frame bounding box		Measurement enumeration */
#define DDIF_SGA_FRM_BOX_LL_X 6246      /*     Lower left X coordinate	Variable */
#define DDIF_SGA_FRM_BOX_LL_Y_C 6247    /*				Measurement enumeration */
#define DDIF_SGA_FRM_BOX_LL_Y 6248      /*     Lower left Y coordinate	Variable */
#define DDIF_SGA_FRM_BOX_UR_X_C 6249    /*				Measurement enumeration */
#define DDIF_SGA_FRM_BOX_UR_X 6250      /*     Upper right X coordinate	Variable */
#define DDIF_SGA_FRM_BOX_UR_Y_C 6251    /*				Measurement enumeration */
#define DDIF_SGA_FRM_BOX_UR_Y 6252      /*     Upper right Y coordinate	Variable */
#define DDIF_SGA_FRM_OUTLINE 6253       /* Frame outline		Sequence of DDIF_PTH */
#define DDIF_SGA_FRM_CLIPPING 6254      /* Frame clipping		Sequence of DDIF_PTH */
#define DDIF_SGA_FRM_POSITION_C 6255    /* Frame position choice	Enumeration */
#define DDIF_SGA_FRMFXD_POSITION_X_C 6256 /* Frame fixed position		Measurement enumeration */
#define DDIF_SGA_FRMFXD_POSITION_X 6257 /*     X coordinate		Variable */
#define DDIF_SGA_FRMFXD_POSITION_Y_C 6258 /* Frame fixed position		Measurement enumeration */
#define DDIF_SGA_FRMFXD_POSITION_Y 6259 /*     Y coordinate		Variable */
#define DDIF_SGA_FRMINL_BASE_OFFSET_C 6260 /* Inline base offset		Measurement enumeration */
#define DDIF_SGA_FRMINL_BASE_OFFSET 6261 /*				Variable */
#define DDIF_SGA_FRMGLY_VERTICAL 6262   /* Galley vertical position	Enumeration */
#define DDIF_SGA_FRMGLY_HORIZONTAL 6263 /* Galley horizontal position	Enumeration */
#define DDIF_SGA_FRMMAR_BASE_OFFSET_C 6264 /* Margin base offset		Measurement enumeration */
#define DDIF_SGA_FRMMAR_BASE_OFFSET 6265 /*				Variable */
#define DDIF_SGA_FRMMAR_NEAR_OFFSET_C 6266 /* Margin near offset		Measurement enumeration */
#define DDIF_SGA_FRMMAR_NEAR_OFFSET 6267 /*				Variable */
#define DDIF_SGA_FRMMAR_HORIZONTAL 6268 /* Margin horizontal position	Enumeration */
#define DDIF_SGA_FRM_TRANSFORM 6269     /* Frame content transform	Sequence of DDIF_TRN */
#define DDIF_SGA_ITEM_CHANGE_LIST 6270  /* Item change list		Item change list */
#define DDIF_SGA_LAYPTH_REVERSE_PATH 6271 /* Reverse path			Boolean */
#define DDIF_SGA_TXT_BACKGROUND 6272    /* Text background		Integer */
#define DDIF_SGA_TXT_FORCE_HORIZONTAL 6273 /* Force text horizontal	Boolean */
#define DDIF_SGA_IMG_PIXEL_GRP_SIZE 6274 /* Pixel group size		Integer */
#define DDIF_SGA_IMG_PIXEL_GRP_ORDER 6275 /* Pixel group order		Enumeration */
#define DDIF_SGA_IMG_COMP_QUANT_LEVELS 6276 /* Component quantize levels	Array of Integer */
#define DDIF_SGA_FRMGLY_H_OFFSET_C 6277 /* Horizontal offset		Measurement enumeration */
#define DDIF_SGA_FRMGLY_H_OFFSET 6278   /*				Variable */
#define DDIF_SGA_FRMGLY_V_OFFSET_C 6279 /* Vertical offset		Measurement enumeration */
#define DDIF_SGA_FRMGLY_V_OFFSET 6280   /* 				Variable */
#define DDIF_SGA_TIME_RTU_FREQ 6281     /* RTU Frequency		Integer */
#define DDIF_SGA_POLY_JOIN_DEFNS 6282   /* Polyline join definitions	Sequence of DDIF_PJD */
#define DDIF_SGA_CPTCRF_CONTREF 6283    /* Content reference primitive	DDIF_CRF */
#define DDIF_SGA_MAX 6284               /* Maximum code plus 1              */
/* Values of the add-info parameter for DDIF_SGA_CONTENT_CATEGORY.          */
#define DDIF_K_PRIVATE_CATEGORY 0       /* Nonstandard                      */
#define DDIF_K_I_CATEGORY 1             /* "$I" (image)                     */
#define DDIF_K_2D_CATEGORY 2            /* "$2D" (graphics)                 */
#define DDIF_K_T_CATEGORY 3             /* "$T" (text)                      */
#define DDIF_K_TBL_CATEGORY 4           /* "$TBL" (table)                   */
#define DDIF_K_PDL_CATEGORY 5           /* "$PDL" (page description language) */
#define DDIF_K_A_CATEGORY 6             /* "$A" (audio)                     */
/* Values of the add-info parameter for DDIF_SGA_SEGMENT_TAGS.              */
#define DDIF_K_PRIVATE_TAG 0            /* Nonstandard                      */
#define DDIF_K_CRF_TAG 1                /* "$CRF" (cross-reference)         */
#define DDIF_K_F_TAG 2                  /* "$F" (figure)                    */
#define DDIF_K_P_TAG 3                  /* "$P" (paragraph)                 */
#define DDIF_K_S_TAG 4                  /* "$S" (section)                   */
#define DDIF_K_I_TAG 5                  /* "$I" (index)                     */
#define DDIF_K_E_TAG 6                  /* "$E" (emphasized)                */
#define DDIF_K_L_TAG 7                  /* "$L" (list)                      */
#define DDIF_K_LE_TAG 8                 /* "$LE" (list element)             */
#define DDIF_K_LIT_TAG 9                /* "$LIT" (literal)                 */
#define DDIF_K_FN_TAG 10                /* "$FN" (footnote)                 */
#define DDIF_K_AN_TAG 11                /* "$AN" (annotation)               */
#define DDIF_K_LBL_TAG 12               /* "$LBL" (label)                   */
#define DDIF_K_TTL_TAG 13               /* "$TTL" (title)                   */
#define DDIF_K_GRP_TAG 14               /* "$GRP" (group member)            */
#define DDIF_K_GO_TAG 15                /* "$GO" (graphics object)          */
#define DDIF_K_EN_TAG 16                /* "$EN" (end note)                 */
#define DDIF_K_APP_TAG 17               /* "$APP" (appendix)                */
#define DDIF_K_HDR_TAG 18               /* "$HDR" (header)                  */
#define DDIF_K_FTR_TAG 19               /* "$FTR" (footer)                  */
#define DDIF_K_TOC_TAG 20               /* "$TOC" (table of contents)       */
/* Values of DDIF_SGA_COMPUTE_C.                                            */
#define DDIF_K_COPY_COMPUTE 0           /* Copy locally			SGA_CPTCPY_TARGET to SGA_CPTCPY_ERF_INDEX */
#define DDIF_K_REMOTE_COMPUTE 1         /* Copy remotely		SGA_CPTCPY_TARGET to SGA_CPTCPY_ERF_INDEX */
#define DDIF_K_VARIABLE_COMPUTE 2       /* Variable			SGA_CPTVAR_VARIABLE */
#define DDIF_K_XREF_COMPUTE 3           /* Cross-reference		SGA_CPTXRF_TARGET to SGA_CPTXRF_VARIABLE */
#define DDIF_K_FUNCTION_COMPUTE 4       /* Function link		SGA_CPTFNC_NAME to SGA_CPTFNC_PARAMETERS */
#define DDIF_K_CONTENT_REF_COMPUTE 5    /* Content ref. primitive	SGA_CPTCRF_CONTREF */
/* Values of DDIF_SGA_STRUCTURE_DESC_C and DDIF_OCC_STRUCTURE_ELEMENT_C.    */
#define DDIF_K_SEQUENCE_STRUCTURE 0     /* Sequence structure		Sequence of DDIF_OCC */
#define DDIF_K_SET_STRUCTURE 1          /* Set structure		Sequence of DDIF_OCC */
#define DDIF_K_CHOICE_STRUCTURE 2       /* Choice structure		Sequence of DDIF_OCC */
#define DDIF_K_REFERENCED_TYPE 3        /* Referenced type		String (not for DDIF_SGA_STRUCTURE_DESC_C) */
/* Values of DDIF_SGA_LAYOUT_C.                                             */
#define DDIF_K_GALLEY_LAYOUT 0          /* Galley-based layout		SGA_LAYGLY_WRAP to SGA_LAYGLY_LAYOUT */
#define DDIF_K_PATH_LAYOUT 1            /* Path-based layout		SGA_LAYPTH_PATH to SGA_LAYPTH_V_ALIGN */
#define DDIF_K_RELATIVE_LAYOUT 2        /* Position-relative layout	SGA_LAYREL_H_RATIO_N to SGA_LAYREL_V_CONSTANT */
#define DDIF_K_POSITION_LAYOUT 3        /* Position-based layout	SGA_LAYPOS_TEXT_POSITION */
/* Values of DDIF_SGA_LAYPTH_FORMAT, DDIF_SGA_FRMGLY_HORIZONTAL,	DDIF conforming */
/* DDIF_LW1_WRAP_FORMAT, DDIF_LW1_QUAD_FORMAT.                              */
#define DDIF_K_FMT_FLUSH_PATH_BEGIN 1   /* Flush with beginning of path     */
#define DDIF_K_FMT_CENTER_OF_PATH 2     /* Centered on path                 */
#define DDIF_K_FMT_FLUSH_PATH_END 3     /* Flush with end of path           */
#define DDIF_K_FMT_FLUSH_PATH_BOTH 4    /* Flush with both ends of path     */
/* Values of DDIF_SGA_LAYPTH_ORIENTATION_C.                                 */
#define DDIF_K_PATH_FIXED 0             /* Fixed frame-relative		Single precision floating */
#define DDIF_K_PATH_RELATIVE 1          /* Path relative		Enumeration */
/* Values of DDIF_SGA_LAYPTH_ORIENTATION for DDIF_K_PATH_RELATIVE.	DDIF conforming */
#define DDIF_K_RIGHT_ANGLE_RIGHT 1      /* Right                            */
#define DDIF_K_RIGHT_ANGLE_LEFT 2       /* Left                             */
#define DDIF_K_RIGHT_ANGLE_UP 3         /* Up                               */
#define DDIF_K_RIGHT_ANGLE_DOWN 4       /* Down                             */
/* Values of DDIF_SGA_LAYPTH_H_ALIGN.					DDIF conforming */
#define DDIF_K_PATH_NORMAL_HORIZONTAL 1 /* Normal horizontal                */
#define DDIF_K_PATH_LEFTLINE 2          /* Left line                        */
#define DDIF_K_PATH_CENTERLINE 3        /* Center line                      */
#define DDIF_K_PATH_RIGHTLINE 4         /* Right line                       */
/* Values of DDIF_SGA_LAYPTH_V_ALIGN.					DDIF conforming */
#define DDIF_K_PATH_NORMAL_VERTICAL 1   /* Normal vertical                  */
#define DDIF_K_PATH_BASELINE 2          /* Base line                        */
#define DDIF_K_PATH_CAPLINE 3           /* Cap line                         */
#define DDIF_K_PATH_BOTTOMLINE 4        /* Bottom line                      */
#define DDIF_K_PATH_HALFLINE 5          /* Half line                        */
#define DDIF_K_PATH_TOPLINE 6           /* Top line                         */
/* Values of DDIF_SGA_LAYPOS_TEXT_POSITION.				DDIF conforming */
#define DDIF_K_TEXT_POS_BASE 1          /* Base                             */
#define DDIF_K_TEXT_POS_LD_SUBSCRIPT 2  /* Leading subscript                */
#define DDIF_K_TEXT_POS_LD_SUPERSCRIPT 3 /* Leading superscript             */
#define DDIF_K_TEXT_POS_TR_SUBSCRIPT 4  /* Trailing subscript               */
#define DDIF_K_TEXT_POS_TR_SUPERSCRIPT 5 /* Trailing superscript            */
#define DDIF_K_TEXT_POS_TOP_CENTER 6    /* Top center                       */
#define DDIF_K_TEXT_POS_BOTTOM_CENTER 7 /* Bottom center                    */
#define DDIF_K_TEXT_POS_RUBI 8          /* Rubi                             */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_K_TEXT_POS_L_SUBSCRIPT 2   /* Left subscript                   */
#define DDIF_K_TEXT_POS_L_SUPERSCRIPT 3 /* Left superscript                 */
#define DDIF_K_TEXT_POS_R_SUBSCRIPT 4   /* Right subscript                  */
#define DDIF_K_TEXT_POS_R_SUPERSCRIPT 5 /* Right superscript                */
/* Predefined values of DDIF_SGA_TXT_MASK_PATTERN, DDIF_SGA_LIN_MASK_PATTERN, DDIF_SGA_LIN_INTERIOR_PATTERN, */
/* DDIF_SGA_MKR_MASK_PATTERN, DDIF_PTD_NUMBER, DDIF_PTD_PAT_COLORS.         */
#define DDIF_K_PATT_TRANSPARENT 0
#define DDIF_K_PATT_BACKGROUND 1
#define DDIF_K_PATT_FOREGROUND 2
#define DDIF_K_PATT_VERT1_1 3
#define DDIF_K_PATT_VERT1_3 4
#define DDIF_K_PATT_VERT2_2 5
#define DDIF_K_PATT_VERT3_1 6
#define DDIF_K_PATT_VERT1_7 7
#define DDIF_K_PATT_VERT2_6 8
#define DDIF_K_PATT_VERT4_4 9
#define DDIF_K_PATT_VERT6_2 10
#define DDIF_K_PATT_HORIZ1_1 11
#define DDIF_K_PATT_HORIZ1_3 12
#define DDIF_K_PATT_HORIZ2_2 13
#define DDIF_K_PATT_HORIZ3_1 14
#define DDIF_K_PATT_HORIZ1_7 15
#define DDIF_K_PATT_HORIZ2_6 16
#define DDIF_K_PATT_HORIZ4_4 17
#define DDIF_K_PATT_HORIZ6_2 18
#define DDIF_K_PATT_GRID4 19
#define DDIF_K_PATT_GRID8 20
#define DDIF_K_PATT_UPDIAG1_3 21
#define DDIF_K_PATT_UPDIAG2_2 22
#define DDIF_K_PATT_UPDIAG3_1 23
#define DDIF_K_PATT_UPDIAG1_7 24
#define DDIF_K_PATT_UPDIAG2_6 25
#define DDIF_K_PATT_UPDIAG4_4 26
#define DDIF_K_PATT_UPDIAG6_2 27
#define DDIF_K_PATT_DOWNDIAG1_3 28
#define DDIF_K_PATT_DOWNDIAG2_2 29
#define DDIF_K_PATT_DOWNDIAG3_1 30
#define DDIF_K_PATT_DOWNDIAG1_7 31
#define DDIF_K_PATT_DOWNDIAG2_6 32
#define DDIF_K_PATT_DOWNDIAG4_4 33
#define DDIF_K_PATT_DOWNDIAG6_2 34
#define DDIF_K_PATT_BRICK_HORIZ 35
#define DDIF_K_PATT_BRICK_VERT 36
#define DDIF_K_PATT_BRICK_DOWNDIAG 37
#define DDIF_K_PATT_BRICK_UPDIAG 38
#define DDIF_K_PATT_GREY4_16D 39
#define DDIF_K_PATT_GREY12_16D 40
#define DDIF_K_PATT_BASKET_WEAVE 41
#define DDIF_K_PATT_SCALE_DOWN 42
#define DDIF_K_PATT_SCALE_UP 43
#define DDIF_K_PATT_SCALE_RIGHT 44
#define DDIF_K_PATT_SCALE_LEFT 45
#define DDIF_K_PATT_FILLER6 46
#define DDIF_K_PATT_FILLER7 47
#define DDIF_K_PATT_GREY1_16 48
#define DDIF_K_PATT_GREY2_16 49
#define DDIF_K_PATT_GREY3_16 50
#define DDIF_K_PATT_GREY4_16 51
#define DDIF_K_PATT_GREY5_16 52
#define DDIF_K_PATT_GREY6_16 53
#define DDIF_K_PATT_GREY7_16 54
#define DDIF_K_PATT_GREY8_16 55
#define DDIF_K_PATT_GREY9_16 56
#define DDIF_K_PATT_GREY10_16 57
#define DDIF_K_PATT_GREY11_16 58
#define DDIF_K_PATT_GREY12_16 59
#define DDIF_K_PATT_GREY13_16 60
#define DDIF_K_PATT_GREY14_16 61
#define DDIF_K_PATT_GREY15_16 62
/* Values of DDIF_SGA_TXT_RENDITION. 					DDIF conforming */
#define DDIF_K_RND_DEFAULT 0            /* Default rendition                */
#define DDIF_K_RND_HIGHLIGHT 1          /* Highlighted intensity            */
#define DDIF_K_RND_FAINT 2              /* Faint intensity                  */
#define DDIF_K_RND_ITALIC 3             /* Italic rendition                 */
#define DDIF_K_RND_NORMAL 22            /* Normal intensity                 */
#define DDIF_K_RND_SLOW_BLINK 5         /* Slow blinking                    */
#define DDIF_K_RND_FAST_BLINK 6         /* Rapid blinking                   */
#define DDIF_K_RND_NO_BLINK 25          /* Steady (no blinking)             */
#define DDIF_K_RND_NEGATIVE 7           /* Negative image                   */
#define DDIF_K_RND_POSITIVE 27          /* Positive image                   */
#define DDIF_K_RND_CONCEAL 8            /* Concealed characters             */
#define DDIF_K_RND_NO_CONCEAL 28        /* Revealed characters              */
#define DDIF_K_RND_UNDERLINE 4          /* Underlined                       */
#define DDIF_K_RND_2_UNDERLINE 21       /* Double underlined                */
#define DDIF_K_RND_NO_UNDERLINE 24      /* Not underlined                   */
#define DDIF_K_RND_CROSS_OUT 9          /* Crossed out                      */
#define DDIF_K_RND_BOX 51               /* Boxed                            */
#define DDIF_K_RND_ENCIRCLE 52          /* Encircled                        */
#define DDIF_K_RND_OVERLINE 53          /* Overlined                        */
#define DDIF_K_RND_IDEO_UNDERLINE 60    /* Ideogram underlined              */
#define DDIF_K_RND_IDEO_2_UNDERLINE 61  /* Ideogram double underlined       */
#define DDIF_K_RND_IDEO_OVERLINE 62     /* Ideogram overlined               */
#define DDIF_K_RND_IDEO_2_OVERLINE 63   /* Ideogram double overlined        */
#define DDIF_K_RND_IDEO_STRESS 64       /* Ideogram stress marking          */
#define DDIF_K_RND_FC_UNDERLINE 65      /* Fancy underline                  */
#define DDIF_K_RND_FC_OVERLINE 66       /* Fancy overline                   */
#define DDIF_K_RND_FC_IDEO_UNDERLINE 67 /* Fancy ideogram underline         */
#define DDIF_K_RND_FC_IDEO_OVERLINE 68  /* Fancy ideogram overline          */
#define DDIF_K_RND_FC_IDEO_2_UNDERLINE 69 /* Fancy ideogram double underline */
#define DDIF_K_RND_FC_IDEO_2_OVERLINE 70 /* Fancy ideogram double overline  */
#define DDIF_K_RND_CHANGEBARS 257       /* Change bars                      */
/* Values of DDIF_SGA_TXT_DIRECTION.					DDIF conforming */
#define DDIF_K_TXT_DIR_LTOR 1           /* Direction left to right          */
#define DDIF_K_TXT_DIR_RTOL 2           /* Direction right to left          */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_K_TXT_DIR_FORWARD 1        /* Forward direction                */
#define DDIF_K_TXT_DIR_BACKWARD 2       /* Backward direction               */
/* Values of DDIF_SGA_TXT_LEADER_ALIGN.				DDIF conforming */
#define DDIF_K_ALIGNED_LEADER 1         /* Aligned leader                   */
#define DDIF_K_STAGGERED_LEADER 2       /* Staggered leader                 */
#define DDIF_K_NON_ALIGNED_LEADER 3     /* No specification                 */
/* Values of DDIF_SGA_TXT_LEADER_STYLE.				DDIF conforming */
#define DDIF_K_X_RULE_LEADER 1          /* X rule                           */
#define DDIF_K_BULLET_LEADER 2          /* Bullet                           */
/* Predefined values of DDIF_SGA_LIN_STYLE.				DDIF conforming */
#define DDIF_K_SOLID_LINE_STYLE 1       /* Solid                            */
#define DDIF_K_DASH_LINE_STYLE 2        /* Dash                             */
#define DDIF_K_DOT_LINE_STYLE 3         /* Dot                              */
#define DDIF_K_DASH_DOT_LINE_STYLE 4    /* Dash-dot                         */
/* Values of DDIF_SGA_LIN_END_START, DDIF_SGA_LIN_END_FINISH.		DDIF conforming */
#define DDIF_K_BUTT_LINE_END 1          /* Butt line end                    */
#define DDIF_K_ROUND_LINE_END 2         /* Round line end                   */
#define DDIF_K_SQUARE_LINE_END 3        /* Square line end                  */
#define DDIF_K_ARROW_LINE_END 4         /* Arrow line end                   */
#define DDIF_K_UNFILLED_ARROW_LINE_END 5 /* Unfilled arrow line end         */
/* Values of DDIF_SGA_LIN_JOIN.					DDIF conforming */
#define DDIF_K_MITERED_LINE_JOIN 1      /* Mitered line join                */
#define DDIF_K_ROUNDED_LINE_JOIN 2      /* Rounded line join                */
#define DDIF_K_BEVELED_LINE_JOIN 3      /* Beveled line join                */
/* Values of DDIF_SGA_MKR_STYLE.					DDIF conforming */
#define DDIF_K_DOT_MARKER 1             /* Dot                              */
#define DDIF_K_PLUS_MARKER 2            /* Plus sign                        */
#define DDIF_K_ASTERISK_MARKER 3        /* Asterisk                         */
#define DDIF_K_CIRCLE_MARKER 4          /* Circle                           */
#define DDIF_K_CROSS_MARKER 5           /* Diagonal cross                   */
/* Values of DDIF_SGA_IMG_BRT_POLARITY.				DDIF conforming */
#define DDIF_K_ZERO_MAX_INTENSITY 1     /* Zero maximum intensity           */
#define DDIF_K_ZERO_MIN_INTENSITY 2     /* Zero minimum intensity           */
/* Values of DDIF_SGA_IMG_GRID_TYPE.					DDIF conforming */
#define DDIF_K_RECTANGULAR_GRID 1       /* Rectangular grid                 */
#define DDIF_K_HEX_EVEN_INDENT 2        /* Hexagonal grid, indent even      */
#define DDIF_K_HEX_ODD_INDENT 3         /* Hexagonal grid, indent odd       */
/* Values of DDIF_SGA_IMG_SPECTRAL_MAPPING.				DDIF conforming */
#define DDIF_K_PRIVATE_MAP 1            /* Privately mapped                 */
#define DDIF_K_MONOCHROME_MAP 2         /* Monochrome mapped                */
#define DDIF_K_GENERAL_MAP 3            /* General multispectral            */
#define DDIF_K_LUT_MAP 4                /* Lookup table mapped              */
#define DDIF_K_RGB_MAP 5                /* RGB mapped                       */
#define DDIF_K_CMY_MAP 6                /* CMY mapped                       */
#define DDIF_K_YUV_MAP 7                /* YUV mapped                       */
#define DDIF_K_HSV_MAP 8                /* HSV mapped                       */
#define DDIF_K_HLS_MAP 9                /* HLS mapped                       */
#define DDIF_K_YIQ_MAP 10               /* YIQ mapped                       */
/* Values of DDIF_SGA_IMG_LOOKUP_TABLES_C.                                  */
#define DDIF_K_PRIVATE_LUT 0            /* Private LUT data		Sequence of DDIF_PVT */
#define DDIF_K_RGB_LUT 1                /* RGB LUT data			Sequence of DDIF_RGB */
/* Values of DDIF_SGA_IMG_COMP_WAVELENGTH_C.                                */
#define DDIF_K_APPLICATION_WAVELENGTH 0 /* Application wavelength	Array of string */
#define DDIF_K_WAVELENGTH_MEASURE 1     /* Wavelength measure		Array of integer */
#define DDIF_K_WAVELENGTH_BAND_ID 2     /* Wavelength band ID		Array of string */
/* Values of DDIF_SGA_IMG_COMP_SPACE_ORG.				DDIF conforming */
#define DDIF_K_BAND_INTERLEAVE_BY_PIXEL 1 /* Band interleaved by pixel      */
#define DDIF_K_BAND_SEQ_BY_PLANE 2      /* Band sequence by plane           */
#define DDIF_K_BIT_SEQ_BY_PLANE 3       /* Bit sequence by plane            */
#define DDIF_K_BAND_INTERLEAVE_BY_LINE 4 /* Band interleave by line         */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_K_FULL_COMPACTION 1        /* Full pixel compaction            */
#define DDIF_K_PARTIAL_EXPANSION 2      /* Partial pixel expansion          */
#define DDIF_K_FULL_EXPANSION 3         /* Full pixel expansion             */
/* Values of DDIF_SGA_IMG_PLANE_SIGNIF.				DDIF conforming */
#define DDIF_K_LSB_FIRST 1              /* LSB first                        */
#define DDIF_K_MSB_FIRST 2              /* MSB first                        */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_K_LSB_MSB 1                /* LSB to MSB                       */
#define DDIF_K_MSB_LSB 2                /* MSB to LSB                       */
/* Bit definitions for DDIF_FRM_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_flow_around 0x80000000
#else
#define ddif_m_flow_around 1
#endif
#ifdef CDAbig_endian
#define ddif_m_frame_border 0x40000000
#else
#define ddif_m_frame_border 2
#endif
#ifdef CDAbig_endian
#define ddif_m_frame_background_fill 0x20000000
#else
#define ddif_m_frame_background_fill 4
#endif
struct frm_flags {
    unsigned ddif_v_flow_around : 1;    /* Flow around                      */
    unsigned ddif_v_frame_border : 1;   /* Frame border                     */
    unsigned ddif_v_frame_background_fill : 1; /* Frame background fill     */
    unsigned ddif_v_frm_fill_0 : 13;
    unsigned ddif_v_frm_fill : 16;
    } ;
/* Values of DDIF_SGA_FRM_POSITION_C.                                       */
#define DDIF_K_FRAME_FIXED 0            /* Fixed position		FRMFXD_POSITION_X_C to FRMFXD_POSITION_Y */
#define DDIF_K_FRAME_INLINE 1           /* Inline position		FRMINL_BASE_OFFSET_C to FRMINL_BASE_OFFSET */
#define DDIF_K_FRAME_GALLEY 2           /* Galley position		FRMGLY_VERTICAL to FRMGLY_HORIZONTAL */
#define DDIF_K_FRAME_MARGIN 3           /* Margin position		FRMMAR_BASE_OFFSET_C to FRMMAR_HORIZONTAL */
/* Values of DDIF_SGA_FRMGLY_VERTICAL.					DDIF conforming */
#define DDIF_K_FRMGLY_BELOW_CURRENT 1   /* Below current line               */
#define DDIF_K_FRMGLY_BOTTOM 2          /* Bottom of galley                 */
#define DDIF_K_FRMGLY_TOP 3             /* Top of galley                    */
#define DDIF_K_FRMGLY_ABOVE_CURRENT 4   /* Above current line               */
/* Values of DDIF_SGA_FRMMAR_HORIZONTAL.				DDIF conforming */
#define DDIF_K_FRMMAR_CLOSEST_EDGE 1    /* Side closest edge                */
#define DDIF_K_FRMMAR_FURTHEST_EDGE 2   /* Side furthest edge               */
#define DDIF_K_FRMMAR_LEFT 3            /* Left of galleys                  */
#define DDIF_K_FRMMAR_RIGHT 4           /* Right of galleys                 */
/* Values of DDIF_SGA_IMG_PIXEL_GRP_ORDER.				DDIF conforming */
#define DDIF_K_STD_PIXEL_ORDER 1        /* Standard pixel order             */
#define DDIF_K_REV_PIXEL_ORDER 2        /* Reverse pixel order              */
/* Item codes for Content Definition aggregate.                             */
#define DDIF_CTD_LABEL 6401             /* Content label		String */
#define DDIF_CTD_EXTERNAL_TARGET 6402   /* Content reference target	String */
#define DDIF_CTD_EXTERNAL_ERF_INDEX 6403 /* Content reference index	Integer */
#define DDIF_CTD_VALUE 6404             /* Content value		Sequence of content */
#define DDIF_CTD_PRIVATE_DATA 6405      /* Content private data		Sequence of DDIF_PVT */
#define DDIF_CTD_MAX 6406               /* Maximum code plus 1              */
/* Item codes for Font Definition aggregate.                                */
#define DDIF_FTD_NUMBER 6657            /* Font number			Integer */
#define DDIF_FTD_IDENTIFIER 6658        /* Font identifier		String */
#define DDIF_FTD_PRIVATE_DATA 6659      /* Font private data		Sequence of DDIF_PVT */
#define DDIF_FTD_MAX 6660               /* Maximum code plus 1              */
/* Item codes for Line Style Definition aggregate.                          */
#define DDIF_LSD_NUMBER 6913            /* Line style number		Integer */
#define DDIF_LSD_PATTERN 6914           /* Line style pattern		Array of integer */
#define DDIF_LSD_PRIVATE_DATA 6915      /* Line style private data	Sequence of DDIF_PVT */
#define DDIF_LSD_MAX 6916               /* Maximum code plus 1              */
/* Item codes for Path Definition aggregate.                                */
#define DDIF_PHD_NUMBER 7169            /* Path number			Integer */
#define DDIF_PHD_DESCRIPTION 7170       /* Path description		Sequence of DDIF_PTH */
#define DDIF_PHD_PRIVATE_DATA 7171      /* Path private data		Sequence of DDIF_PVT */
#define DDIF_PHD_MAX 7172               /* Maximum code plus 1              */
/* Item codes for Pattern Definition aggregate.                             */
#define DDIF_PTD_NUMBER 7425            /* Pattern number		Integer */
#define DDIF_PTD_DEFN_C 7426            /* Pattern definition choice	Enumeration */
#define DDIF_PTD_SOL_COLOR_C 7427       /* Color choice			Enumeration */
#define DDIF_PTD_SOL_COLOR_R 7428       /* Color red intensity		Single precision floating */
#define DDIF_PTD_SOL_COLOR_G 7429       /* Color green intensity	Single precision floating */
#define DDIF_PTD_SOL_COLOR_B 7430       /* Color blue intensity		Single precision floating */
#define DDIF_PTD_PAT_NUMBER 7431        /* Pattern number		Integer */
#define DDIF_PTD_PAT_COLORS 7432        /* Pattern colors		Array of integer */
#define DDIF_PTD_RAS_PATTERN 7433       /* Pattern image		DDIF_IDU */
#define DDIF_PTD_PRIVATE_DATA 7434      /* Pattern private data		Sequence of DDIF_PVT */
#define DDIF_PTD_MAX 7435               /* Maximum code plus 1              */
/* Values of DDIF_PTD_DEFN_C.                                               */
#define DDIF_K_SOLID_COLOR 0            /* Solid color			PTD_SOL_COLOR_C to PTD_SOL_COLOR_B */
#define DDIF_K_STANDARD_PATTERN 1       /* Standard pattern		PTD_PAT_NUMBER to PTD_PAT_COLORS */
#define DDIF_K_RASTER_PATTERN 2         /* Raster pattern		PTD_RAS_PATTERN */
/* Values of DDIF_PTD_SOL_COLOR_C.                                          */
#define DDIF_K_RGB_COLOR 0              /* RGB color			PTD_SOL_COLOR_R to PTD_SOL_COLOR_B */
#define DDIF_K_TRANSPARENCY 1           /* Transparency			None */
/* Item codes for Segment Binding aggregate.                                */
#define DDIF_SGB_VARIABLE_NAME 7681     /* Variable name		String */
#define DDIF_SGB_VARIABLE_VALUE_C 7682  /* Variable value choice	Enumeration */
#define DDIF_SGB_CTR_TRIGGER_C 7683     /* Counter trigger		Enumeration */
#define DDIF_SGB_CTR_TRIGGER 7684       /*				Variable */
#define DDIF_SGB_CTR_INIT_C 7685        /* Counter initializer		Expression enumeration */
#define DDIF_SGB_CTR_INIT 7686          /*				Variable */
#define DDIF_SGB_CTR_STYLE 7687         /* Counter style		Sequence of DDIF_CTS */
#define DDIF_SGB_CTR_TYPE 7688          /* Counter type			Enumeration */
#define DDIF_SGB_COM_STRING_EXPR_C 7689 /* Computed string expression	Array of enumeration */
#define DDIF_SGB_COM_STRING_EXPR 7690   /*				Array of variable */
#define DDIF_SGB_RCD_LIST 7691          /* Record definition list	Sequence of DDIF_RCD */
#define DDIF_SGB_CTR_RESET_C 7692       /* Counter reset                Array of Enumeration */
#define DDIF_SGB_CTR_RESET 7693         /*				Array of Variable */
#define DDIF_SGB_MAX 7694               /* Maximum code plus 1              */
/* Values of DDIF_SGB_VARIABLE_VALUE_C.                                     */
#define DDIF_K_COUNTER_VARIABLE 0       /* Counter variable		SGB_CTR_TRIGGER_C to SGB_CTR_TYPE, */
/*				SGB_CTR_RESET_C and SGB_CTR_RESET           */
#define DDIF_K_COMPUTED_VARIABLE 1      /* Computed variable		SGB_COM_STRING_EXPR_C to SGB_COM_STRING_EXPR */
#define DDIF_K_LIST_VARIABLE 2          /* List variable		SGB_RCD_LIST */
/* Values of DDIF_SGB_CTR_TRIGGER_C.                                        */
#define DDIF_K_TAGGED_SEGMENT_TRIGGER 0 /* Counts tagged segments	String */
#define DDIF_K_LAYOUT_OBJECT_TRIGGER 1  /* Counts layout objects	Enumeration */
/* Values of DDIF_SGB_CTR_TRIGGER for DDIF_K_LAYOUT_OBJECT_TRIGGER          */
/* and of DDIF_SGB_CTR_RESET for DDIF_K_LAYOUT_OBJECT_RESET.			DDIF conforming */
#define DDIF_K_DOCUMENT_LAYOUT_OBJECT 1 /* Document layout object           */
#define DDIF_K_PAGE_SET_LAYOUT_OBJECT 2 /* Page set layout object           */
#define DDIF_K_PAGE_LAYOUT_OBJECT 3     /* Page layout object               */
#define DDIF_K_FRAME_LAYOUT_OBJECT 4    /* Frame layout object              */
#define DDIF_K_BLOCK_LAYOUT_OBJECT 5    /* Block layout object              */
#define DDIF_K_LINE_LAYOUT_OBJECT 6     /* Line layout object               */
#define DDIF_K_POINT_PAGE_OBJECT 7      /* Point page object                */
/* Values of DDIF_SGB_CTR_TYPE.					DDIF conforming */
#define DDIF_K_MILITARY_COUNTER 1       /* Military                         */
#define DDIF_K_OFFICE_COUNTER 2         /* Office                           */
#define DDIF_K_PAGE_RELATIVE_COUNTER 3  /* Page relative                    */
#define DDIF_K_CONDITIONAL_COUNTER 4    /* Conditional                      */
/* Values of DDIF_SGB_COM_STRING_EXPR_C.                                    */
#define DDIF_K_TEXT_ELEMENT 0           /* Text element			Character string */
#define DDIF_K_VARIABLE_ELEMENT 1       /* Variable reference element	String */
/* Values of DDIF_SGB_CTR_RESET_C.                                          */
#define DDIF_K_TAGGED_SEGMENT_RESET 0   /* Resets tagged segments	String */
#define DDIF_K_LAYOUT_OBJECT_RESET 1    /* Resets layout objects	Enumeration */
/* Item codes for Type Definition aggregate.                                */
#define DDIF_TYD_LABEL 7937             /* Type label			String */
#define DDIF_TYD_PARENT 7938            /* Type parent			String */
#define DDIF_TYD_ATTRIBUTES 7939        /* Type attributes		DDIF_SGA */
#define DDIF_TYD_PRIVATE_DATA 7940      /* Type private data		Sequence of DDIF_PVT */
#define DDIF_TYD_MAX 7941               /* Maximum code plus 1              */
/* Item codes for Counter Style aggregate.                                  */
#define DDIF_CTS_STYLE_C 8193           /* Counter style		Enumeration */
#define DDIF_CTS_STYLE 8194             /*				Variable */
#define DDIF_CTS_MAX 8195               /* Maximum code plus 1              */
/* Values of DDIF_CTS_STYLE_C.                                              */
#define DDIF_K_NUMBER_STYLE 0           /* Number style entry		Enumeration */
#define DDIF_K_BULLET_STYLE 1           /* Bullet style entry		Array of character string */
#define DDIF_K_STYLE_SEPARATOR 2        /* Style separator entry	Character string */
/* Values of DDIF_CTS_STYLE for DDIF_K_NUMBER_STYLE.			DDIF conforming */
#define DDIF_K_ARABIC_COUNTER 1         /* Arabic                           */
#define DDIF_K_L_ROMAN_COUNTER 2        /* Lowercase roman                  */
#define DDIF_K_U_ROMAN_COUNTER 3        /* Uppercase roman                  */
#define DDIF_K_L_LATIN_COUNTER 4        /* Lowercase latin                  */
#define DDIF_K_U_LATIN_COUNTER 5        /* Uppercase latin                  */
#define DDIF_K_W_ARABIC_COUNTER 6       /* Wide arabic                      */
#define DDIF_K_WL_ROMAN_COUNTER 7       /* Wide lowercase roman             */
#define DDIF_K_WU_ROMAN_COUNTER 8       /* Wide uppercase roman             */
#define DDIF_K_WL_LATIN_COUNTER 9       /* Wide lowercase latin             */
#define DDIF_K_WU_LATIN_COUNTER 10      /* Wide uppercase latin             */
#define DDIF_K_WK_50_COUNTER 11         /* Wide katakana 50                 */
#define DDIF_K_WK_IROHA_COUNTER 12      /* Wide katakana iroha              */
#define DDIF_K_HEBREW_COUNTER 13        /* Hebrew                           */
#define DDIF_K_HANGUL_COUNTER 14        /* Hangul                           */
#define DDIF_K_HANZI_COMPLEX_COUNTER 15 /* Hanzi complex                    */
#define DDIF_K_HANZI_SIMPLE_COUNTER 16  /* Hanzi simple                     */
#define DDIF_K_HANZI_OLD_COUNTER 17     /* Hanzi old                        */
#define DDIF_K_HANYU_COMPLEX_COUNTER 18 /* Hanyu complex                    */
#define DDIF_K_HANYU_SIMPLE_COUNTER 19  /* Hanyu simple                     */
#define DDIF_K_HANYU_OLD_COUNTER 20     /* Hanyu old                        */
#define DDIF_K_HANYU_COMPLEX_FULL_CTR 21 /* Hanyu complex full              */
#define DDIF_K_HANYU_SIMPLE_FULL_CTR 22 /* Hanyu simple full                */
#define DDIF_K_HANZI_COMPLEX_FULL_CTR 23 /* Hanzi complex full              */
#define DDIF_K_HANZI_SIMPLE_FULL_CTR 24 /* Hanzi simple full                */
/* Item codes for Occurrence Definition aggregate.                          */
#define DDIF_OCC_OCCURRENCE_C 8449      /* Occurrence choice		Enumeration */
#define DDIF_OCC_STRUCTURE_ELEMENT_C 8450 /* Structure element choice	Enumeration */
#define DDIF_OCC_STRUCTURE_ELEMENT 8451 /*				Variable */
#define DDIF_OCC_MAX 8452               /* Maximum code plus 1              */
/* Values of DDIF_OCC_OCCURRENCE_C.                                         */
#define DDIF_K_REQUIRED_OCCURRENCE 0    /* Required occurrence              */
#define DDIF_K_OPTIONAL_OCCURRENCE 1    /* Optional occurrence              */
#define DDIF_K_REPEAT_OCCURRENCE 2      /* Repeated occurrence              */
#define DDIF_K_OPT_RPT_OCCURRENCE 3     /* Optional repeated occurrence     */
/* Item codes for Record Definition aggregate.                              */
#define DDIF_RCD_TYPE 8705              /* Record type			String */
#define DDIF_RCD_TAG 8706               /* Record tag			String */
#define DDIF_RCD_CONTENTS 8707          /* Record contents		Array of string */
#define DDIF_RCD_MAX 8708               /* Maximum code plus 1              */
/* Item codes for RGB Lookup Table Entry aggregate.                         */
#define DDIF_RGB_LUT_INDEX 8961         /* LUT index			Integer */
#define DDIF_RGB_RED_VALUE 8962         /* Red value			Single precision floating */
#define DDIF_RGB_GREEN_VALUE 8963       /* Green value			Single precision floating */
#define DDIF_RGB_BLUE_VALUE 8964        /* Blue value			Single precision floating */
#define DDIF_RGB_MAX 8965               /* Maximum code plus 1              */
/* Item codes for Transform aggregate.                                      */
#define DDIF_TRN_PARAMETER_C 9217       /* Transform element		Enumeration */
#define DDIF_TRN_PARAMETER 9218         /*				Variable */
#define DDIF_TRN_MAX 9219               /* Maximum code plus 1              */
/* Values of DDIF_TRN_PARAMETER_C.                                          */
#define DDIF_K_X_SCALE 0                /* X scale factor		Single precision floating */
#define DDIF_K_Y_SCALE 1                /* Y scale factor		Single precision floating */
#define DDIF_K_X_TRANSLATE 2            /* X translation		Single precision floating */
#define DDIF_K_Y_TRANSLATE 3            /* Y translation		Single precision floating */
#define DDIF_K_ROTATE 4                 /* Rotation			Single precision floating */
#define DDIF_K_SKEW 5                   /* Skew				Single precision floating */
#define DDIF_K_MATRIX_2_BY_3 6          /* 2 by 3 matrix		Array[6] of single precision floating */
#define DDIF_K_MATRIX_3_BY_3 7          /* 3 by 3 matrix		Array[9] of single precision floating */
/* Item codes for Generic Layout I aggregate.                               */
#define DDIF_LG1_PRIVATE_DATA 9473      /* Private data			Sequence of DDIF_PVT */
#define DDIF_LG1_PAGE_DESCRIPTIONS 9474 /* Page descriptions		Sequence of DDIF_PGD */
#define DDIF_LG1_MAX 9475               /* Maximum code plus 1              */
/* Item codes for Specific Layout I aggregate.                              */
#define DDIF_LS1_LAYOUT_C 9729          /* Layout choice		Array of enumeration */
#define DDIF_LS1_LAYOUT 9730            /* Layout description		Array of variable */
#define DDIF_LS1_MAX 9731               /* Maximum code plus 1              */
/* Values of DDIF_LS1_LAYOUT_C.                                             */
#define DDIF_K_SPECIFIC_PAGE 0          /* Specific page		DDIF_PGD */
#define DDIF_K_REFERENCED_PAGE 1        /* Referenced page		String */
/* Item codes for Wrap Attributes I aggregate.                              */
#define DDIF_LW1_WRAP_FORMAT 9985       /* Wrap format			Enumeration */
#define DDIF_LW1_QUAD_FORMAT 9986       /* Quad format			Enumeration */
#define DDIF_LW1_HYPHENATION_FLAGS 9987 /* Hyphenation flags		Longword */
#define DDIF_LW1_MAXIMUM_HYPH_LINES 9988 /* Maximum hyphen lines		Integer */
#define DDIF_LW1_MINIMUM_ORPHAN_SIZE 9989 /* Minimum orphan size		Integer */
#define DDIF_LW1_MINIMUM_WIDOW_SIZE 9990 /* Minimum widow size		Integer */
#define DDIF_LW1_PRES_DIR 9991          /* Present direction		Enumeration */
#define DDIF_LW1_ITEM_CHANGE_LIST 9992  /* Item change list             Item change list */
#define DDIF_LW1_MAX 9993               /* Maximum code plus 1              */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_LW1_MAXIMUM_ORPHAN_SIZE 9989 /* Maximum orphan size            */
#define DDIF_LW1_MAXIMUM_WIDOW_SIZE 9990 /* Maximum widow size              */
/* Bit definitions for DDIF_LW1_HYPHENATION_FLAGS.			DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_hyph_allowed 0x80000000
#else
#define ddif_m_hyph_allowed 1
#endif
#ifdef CDAbig_endian
#define ddif_m_hyph_paragraph_end 0x40000000
#else
#define ddif_m_hyph_paragraph_end 2
#endif
#ifdef CDAbig_endian
#define ddif_m_hyph_galley_end 0x20000000
#else
#define ddif_m_hyph_galley_end 4
#endif
#ifdef CDAbig_endian
#define ddif_m_hyph_page_end 0x10000000
#else
#define ddif_m_hyph_page_end 8
#endif
#ifdef CDAbig_endian
#define ddif_m_hyph_capitalized_word 0x8000000
#else
#define ddif_m_hyph_capitalized_word 16
#endif
struct lw1_hyphen_flags {
    unsigned ddif_v_hyph_allowed : 1;   /* Hyphenation allowed              */
    unsigned ddif_v_hyph_paragraph_end : 1; /* Paragraph end                */
    unsigned ddif_v_hyph_galley_end : 1; /* Galley end                      */
    unsigned ddif_v_hyph_page_end : 1;  /* Page end                         */
    unsigned ddif_v_hyph_capitalized_word : 1; /* Capitalized word          */
    unsigned ddif_v_lw1_fill_0 : 11;
    unsigned ddif_v_lw1_fill : 16;
    } ;
/* Values of DDIF_LW1_PRES_DIR and DDIF_GLA_PRES_DIR.                       */
#define DDIF_K_GALLEY_DEFAULT 0         /* Galley default (only in DDIF_LW1_PRES_DIR item) */
#define DDIF_K_HORIZ_LEFT_TO_RIGHT 1    /* Horizontal left to right         */
#define DDIF_K_HORIZ_RIGHT_TO_LEFT 2    /* Horizontal right to left         */
#define DDIF_K_VERT_TOP_TO_BOTTOM 3     /* Vertical top to bottom           */
/* Item codes for Layout Attributes I aggregate.                            */
#define DDIF_LL1_INITIAL_DIRECTIVE 10241 /* Initial directive		Enumeration */
#define DDIF_LL1_GALLEY_SELECT 10242    /* Galley select		String */
#define DDIF_LL1_BREAK_BEFORE 10243     /* Break before			Enumeration */
#define DDIF_LL1_BREAK_WITHIN 10244     /* Break within			Enumeration */
#define DDIF_LL1_BREAK_AFTER 10245      /* Break after			Enumeration */
#define DDIF_LL1_INITIAL_INDENT_C 10246 /* Initial indent		Measurement enumeration */
#define DDIF_LL1_INITIAL_INDENT 10247   /*				Variable */
#define DDIF_LL1_BEGIN_INDENT_C 10248   /* Begin indent			Measurement enumeration */
#define DDIF_LL1_BEGIN_INDENT 10249     /*				Variable */
#define DDIF_LL1_END_INDENT_C 10250     /* End indent			Measurement enumeration */
#define DDIF_LL1_END_INDENT 10251       /*				Variable */
#define DDIF_LL1_SPACE_BEFORE_C 10252   /* Space before			Measurement enumeration */
#define DDIF_LL1_SPACE_BEFORE 10253     /*				Variable */
#define DDIF_LL1_SPACE_AFTER_C 10254    /* Space after			Measurement enumeration */
#define DDIF_LL1_SPACE_AFTER 10255      /*				Variable */
#define DDIF_LL1_LEADING_RATIO_N 10256  /* Leading ratio		Integer */
#define DDIF_LL1_LEADING_RATIO_D 10257  /*				Integer */
#define DDIF_LL1_LEADING_CONSTANT_C 10258 /* Leading constant		Measurement enumeration */
#define DDIF_LL1_LEADING_CONSTANT 10259 /*				Variable */
#define DDIF_LL1_TAB_STOPS 10260        /* Tab stops			Sequence of DDIF_TBS */
#define DDIF_LL1_ITEM_CHANGE_LIST 10261 /* Item change list             Item change list */
#define DDIF_LL1_MAX 10262              /* Maximum code plus 1              */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_LL1_LEFT_INDENT_C 10248    /* Left indent                      */
#define DDIF_LL1_LEFT_INDENT 10249      /*                                  */
#define DDIF_LL1_RIGHT_INDENT_C 10250   /* Right indent                     */
#define DDIF_LL1_RIGHT_INDENT 10251     /*                                  */
/* Values of DDIF_LL1_BREAK_BEFORE, DDIF_LL1_BREAK_WITHIN,		DDIF conforming */
/* DDIF_LL1_BREAK_AFTER.                                                    */
#define DDIF_K_BREAK_ALWAYS 1           /* Break always                     */
#define DDIF_K_BREAK_NEVER 2            /* Break never                      */
#define DDIF_K_BREAK_IF_NEEDED 3        /* Break if needed                  */
#define DDIF_K_BREAK_TO_PAGE 4          /* Break to page                    */
#define DDIF_K_BREAK_TO_LEFTPAGE 5      /* Break to left page               */
#define DDIF_K_BREAK_TO_RIGHTPAGE 6     /* Break to right page              */
/* Item codes for Galley Attributes aggregate.                              */
#define DDIF_GLA_TOP_MARGIN_C 10497     /* Galley top margin		Measurement enumeration */
#define DDIF_GLA_TOP_MARGIN 10498       /*				Variable */
#define DDIF_GLA_LEFT_MARGIN_C 10499    /* Galley left margin		Measurement enumeration */
#define DDIF_GLA_LEFT_MARGIN 10500      /*				Variable */
#define DDIF_GLA_RIGHT_MARGIN_C 10501   /* Galley right margin		Measurement enumeration */
#define DDIF_GLA_RIGHT_MARGIN 10502     /*				Variable */
#define DDIF_GLA_BOTTOM_MARGIN_C 10503  /* Galley bottom margin		Measurement enumeration */
#define DDIF_GLA_BOTTOM_MARGIN 10504    /*				Variable */
#define DDIF_GLA_PRES_DIR 10505         /* Galley present direction	Enumeration */
#define DDIF_GLA_ITEM_CHANGE_LIST 10506 /* Item change list             Item change list */
#define DDIF_GLA_MAX 10507              /* Maximum code plus 1              */
/* Item codes for Page Description aggregate.                               */
#define DDIF_PGD_LABEL 10753            /* Label			String */
#define DDIF_PGD_PRIVATE_DATA 10754     /* Private data			Sequence of DDIF_PVT */
#define DDIF_PGD_DESC_C 10755           /* Page description		Enumeration */
#define DDIF_PGD_DESC 10756             /*				Variable */
#define DDIF_PGD_FLAGS 10757            /* Flags			Longword */
#define DDIF_PGD_MAX 10758              /* Maximum code plus 1              */
/* Values of DDIF_PGD_DESC_C.                                               */
#define DDIF_K_PAGE_SET_DESC 0          /* Page set description		Sequence of DDIF_PGS */
#define DDIF_K_PAGE_LAYOUT 1            /* Page layout			DDIF_PGL */
/* Bit definitions for DDIF_PGD_FLAGS.					DDIF conforming */
#ifdef CDAbig_endian
#define ddif_m_pgd_point_page 0x80000000
#else
#define ddif_m_pgd_point_page 1
#endif
struct pgd_flags {
    unsigned ddif_v_pgd_point_page : 1; /* Point page                       */
    unsigned ddif_v_pgd_fill_0 : 15;
    unsigned ddif_v_pgd_fill : 16;
    } ;
/* Item codes for Page Layout aggregate.                                    */
#define DDIF_PGL_LAYOUT_ID 11009        /* Page layout ID		String */
#define DDIF_PGL_SIZE_X_NOM_C 11010     /* Page size			Measurement enumeration */
#define DDIF_PGL_SIZE_X_NOM 11011       /*	X nominal		Variable */
#define DDIF_PGL_SIZE_X_STR_C 11012     /*				Measurement enumeration */
#define DDIF_PGL_SIZE_X_STR 11013       /*	X stretch		Variable */
#define DDIF_PGL_SIZE_X_SHR_C 11014     /*				Measurement enumeration */
#define DDIF_PGL_SIZE_X_SHR 11015       /*	X shrink		Variable */
#define DDIF_PGL_SIZE_Y_NOM_C 11016     /*				Measurement enumeration */
#define DDIF_PGL_SIZE_Y_NOM 11017       /*	Y nominal		Variable */
#define DDIF_PGL_SIZE_Y_STR_C 11018     /*				Measurement enumeration */
#define DDIF_PGL_SIZE_Y_STR 11019       /*	Y stretch		Variable */
#define DDIF_PGL_SIZE_Y_SHR_C 11020     /*				Measurement enumeration */
#define DDIF_PGL_SIZE_Y_SHR 11021       /*	Y shrink		Variable */
#define DDIF_PGL_ORIENTATION 11022      /* Page orientation		Enumeration */
#define DDIF_PGL_PROTOTYPE 11023        /* Page prototype		String */
#define DDIF_PGL_CONTENT 11024          /* Page content			Sequence of content */
#define DDIF_PGL_MAX 11025              /* Maximum code plus 1              */
/* Values of DDIF_PGL_ORIENTATION.					DDIF conforming */
#define DDIF_K_PORTRAIT_ORIENT 1        /* Portrait orientation             */
#define DDIF_K_LANDSCAPE_ORIENT 2       /* Landscape orientation            */
/* Item codes for Page Select aggregate.                                    */
#define DDIF_PGS_PAGE_SIDE_CRITERIA 11265 /* Page side criteria		Enumeration */
#define DDIF_PGS_SELECT_PAGE_LAYOUT_C 11266 /* Selected page layout		Enumeration */
#define DDIF_PGS_SELECT_PAGE_LAYOUT 11267 /* 				Variable */
#define DDIF_PGS_MAX 11268              /* Maximum code plus 1              */
/* Values of DDIF_PGS_PAGE_SIDE_CRITERIA.				DDIF conforming */
#define DDIF_K_LEFT_PAGE 1              /* Left page                        */
#define DDIF_K_RIGHT_PAGE 2             /* Right page                       */
#define DDIF_K_EITHER_PAGE 3            /* Either page                      */
/* Values of DDIF_PGS_SELECT_PAGE_LAYOUT_C.                                 */
#define DDIF_K_SELECT_BY_LABEL 0        /* Select by label		String */
#define DDIF_K_SELECT_BY_DEFN 1         /* Select by definition		DDIF_PGL */
/* Item codes for Tab Stop aggregate.                                       */
#define DDIF_TBS_POSITION_C 11521       /* Position			Measurement enumeration */
#define DDIF_TBS_POSITION 11522         /*				Variable */
#define DDIF_TBS_TYPE 11523             /* Tab stop type		Enumeration */
#define DDIF_TBS_LEADER 11524           /* Tab stop leader		Character string */
#define DDIF_TBS_MAX 11525              /* Maximum code plus 1              */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_TBS_HORIZONTAL_POSITION_C 11521 /* Horizontal position         */
#define DDIF_TBS_HORIZONTAL_POSITION 11522 /*                               */
/* Values of DDIF_TBS_TYPE.						DDIF conforming */
#define DDIF_K_BEGIN_TAB 1              /* Begin tab                        */
#define DDIF_K_CENTER_TAB 2             /* Center tab                       */
#define DDIF_K_END_TAB 3                /* End tab                          */
#define DDIF_K_DECIMAL_TAB 4            /* Decimal tab                      */
/* AX04 values retained for upward compatibility.                           */
#define DDIF_K_LEFT_TAB 1               /* Left tab                         */
#define DDIF_K_RIGHT_TAB 3              /* Right tab                        */
/* Item codes for Sequence of Composite Paths aggregate.                    */
#define DDIF_CPH_PATH_ELEMENTS 11777    /* Path elements		Sequence of DDIF_PTH */
#define DDIF_CPH_MAX 11778              /* Maximum code plus 1              */
/* Item codes for Audio content aggregate.                                  */
#define DDIF_AUD_DURATION_C 12033       /* Duration			Enumeration */
#define DDIF_AUD_DURATION 12034         /*				Variable */
#define DDIF_AUD_SAMPLE_RATE_C 12035    /* Sample rate			Enumeration */
#define DDIF_AUD_SAMPLE_RATE 12036      /*				Variable */
#define DDIF_AUD_CHANNELS 12037         /* Channels			Integer */
#define DDIF_AUD_COMPRESSION_TYPE 12038 /* Compression type		Enumeration */
#define DDIF_AUD_BIT_ORDER 12039        /* Bit order			Enumeration */
#define DDIF_AUD_BYTE_ORDER 12040       /* Byte order			Enumeration */
#define DDIF_AUD_PRIVATE_DATA 12041     /* Private data			Sequence of DDIF_PVT */
#define DDIF_AUD_DESCRIPTION 12042      /* Description			Array of character string */
#define DDIF_AUD_DATA_C 12043           /* Audio data			Enumeration */
#define DDIF_AUD_DATA 12044             /*				Variable */
#define DDIF_AUD_MAX 12045              /* Maximum code plus 1              */
/* Values of DDIF_AUD_DURATION_C.                                           */
#define DDIF_K_RTUS 0                   /* RTUs				Integer */
/* Values of DDIF_AUD_SAMPLE_RATE_C.                                        */
#define DDIF_K_HERTZ 0                  /* Hertz			Single precision floating */
/* Values of DDIF_AUD_COMPRESSION_TYPE					DDIF Conforming */
#define DDIF_K_AUD_PRIVATE 1            /* private encoding type            */
#define DDIF_K_AUD_LIN_PCM_8_BIT 2      /* 8 bit linear pcm                 */
#define DDIF_K_AUD_LIN_PCM_16_BIT 3     /* 16 bit linear pcm                */
#define DDIF_K_AUD_ULAW_PCM 4           /* ulaw pcm                         */
#define DDIF_K_AUD_ALAW_PCM 5           /* alaw pcm                         */
#define DDIF_K_AUD_CCITT_32K 6          /* 32K CCITT                        */
#define DDIF_K_AUD_CCITT_24K 7          /* 24K CCITT                        */
/* Values of DDIF_AUD_DATA_C.                                               */
#define DDIF_K_DATA_FRAMES 0            /* Data frames			Sequence of DDIF_ADF */
/* Item codes for Audio data frame aggregate.                               */
#define DDIF_ADF_TIME_OFFSET 12289      /* Time offset			Integer */
#define DDIF_ADF_SILENCE_LEVEL 12290    /* Silence level		Single precision floating */
#define DDIF_ADF_FRAME_DATA 12291       /* Audio frame data		String */
#define DDIF_ADF_MAX 12292              /* Maximum code plus 1              */
/* Item codes for Polyline join description aggregate.                      */
#define DDIF_PLJ_PRIVATE_DATA 12545     /* Private data			Sequence of DDIF_PVT */
#define DDIF_PLJ_CURVE_RATIO 12546      /* Curve ratio			Single precision floating */
#define DDIF_PLJ_1ST_ABSOLUTE_C 12547   /* 1st absolute offset		Measurement enumeration */
#define DDIF_PLJ_1ST_ABSOLUTE 12548     /*				Variable */
#define DDIF_PLJ_2ND_ABSOLUTE_C 12549   /* 2nd absolute			Measurement enumeration */
#define DDIF_PLJ_2ND_ABSOLUTE 12550     /*				Variable */
#define DDIF_PLJ_1ST_PERCENT 12551      /* 1st percent			Single precision floating */
#define DDIF_PLJ_2ND_PERCENT 12552      /* 2nd percent			Single precision floating */
#define DDIF_PLJ_MAX 12553              /* Maximum code plus 1              */
/* Item codes for Polyine join definition aggregate.                        */
#define DDIF_PJD_LABEL 12801            /* Join definition label	String */
#define DDIF_PJD_JOINS 12802            /* Join definition joins	Sequence of DDIF_PLJ */
#define DDIF_PJD_MAX 12803              /* Maximum code plus 1              */
#endif
#define decw$c_num_glyphs 	        56
#define decw$c_select_cursor             0
#define decw$c_leftselect_cursor         0
#define decw$c_help_select_cursor        2
#define decw$c_wait_cursor               4
#define decw$c_inactive_cursor           6
#define decw$c_resize_cursor             8
#define decw$c_vpane_cursor             10
#define decw$c_hpane_cursor             12
#define decw$c_text_insertion_cursor    14
#define decw$c_text_insertion_bl_cursor 16
#define decw$c_cross_hair_cursor        18
#define decw$c_draw_cursor	        20
#define decw$c_pencil_cursor	        22
#define decw$c_rpencil_cursor	        22
#define decw$c_center_cursor	        24
#define decw$c_rightselect_cursor       26
#define decw$c_wselect_cursor	        28
#define decw$c_eselect_cursor	        30
#define decw$c_x_cursor		        32
#define decw$c_circle_cursor	        34
#define decw$c_mouse_cursor	        36
#define decw$c_lpencil_cursor	        38
#define decw$c_leftgrab_cursor	        40
#define decw$c_grabhand_cursor	        42
#define decw$c_rightgrab_cursor	        44
#define decw$c_leftpointing_cursor      46
#define decw$c_uppointing_cursor        48
#define decw$c_rightpointing_cursor     50
#define decw$c_check_cursor             52
#define decw$c_questionmark_cursor      54
/********************************************************************************************************************************/
/* Created  5-DEC-1994 15:49:05 by VAX SDL V3.2-10     Source:  5-DEC-1994 15:48:59 DECW$LIBSRESD:[XLIB.OBJ]DECW$XLIBMSG.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $XDEF ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  5-DEC-1994 15:49:00.52 */
/*                                                                          */
/*                                                                          */
/* VERSION:	'V3-006'                                                    */
/*                                                                          */
/***************************************************************************** */
/**                                                                          * */
/**                         COPYRIGHT (C) 1987 BY                            * */
/**             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                * */
/**			   ALL RIGHTS RESERVED                              * */
/**                                                                          * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  * */
/**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  * */
/**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  * */
/**  TRANSFERRED.                                                            * */
/**                                                                          * */
/**  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  * */
/**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  * */
/**  CORPORATION.                                                            * */
/**                                                                          * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 * */
/**                                                                          * */
/***************************************************************************** */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	V3-006	SGH006		SAM HARDY		15-AUG-1990         */
/*		ADD MAXOPENDSP SYMBOL.                                      */
/*                                                                          */
/*	V1-004	VRO001		VINCE ORGOVAN		21-MAY-1988         */
/*		CHANGE IOERROR AND LIBABORT FROM ERROR TO FATAL.            */
/*                                                                          */
/*	V1-003	JMG001		JACKIE GRANFIELD	10-MAR-1987         */
/*		ADD OBSOLETE SYMBOL                                         */
/*                                                                          */
/*	V1-002  JMG002		JACKIE GRANFIELD	13-JUL-1987         */
/*		ADD NOMORE SYMBOL.                                          */
/*                                                                          */
/*	V1-001	JMG001		JACKIE GRANFIELD	09-JUL-1987         */
/*		INITIAL VERSION.                                            */
/*                                                                          */
/*---                                                                       */
/*                                                                          */
/* DEFINE XLIB RELATED STATUS VALUES                                        */
/*                                                                          */
/* XLIB USES ERROR CODES WITH A BASE BETWEEN 0-256 WITHIN THE FACILITY      */
/* RANGE. THE XLIB RANGE IS EVENLY DIVIDED INTO WARNINGS, ERRORS,           */
/* INFORMATIONAL, AND SUCCESS CODES.                                        */
/*                                                                          */
/* NOTE THAT POSITIONS IN THIS TABLE ARE FIXED, AND THE NEW ERROR CODES     */
/* SHOULD ONLY BE ADDED TO END OF EACH SEVERITY SECTION. THE ORDER OF       */
/* EXISTING ENTRIES SHOULD NOT BE ALTERED.                                  */
/*                                                                          */
#define XLIB$_FACILITY 731
#define X$_BADPARAM 47939592
#define X$_ERROREPLY 47939600
#define X$_NOMORE 47939608
#define X$_NOTFOUND 47939616
#define X$_PROPUNDEF 47939624
#define X$_TRUNCATED 47939632
#define X$_UNKNEVNT 47939640
#define X$_MAXOPENDSP 47939648
/*                                                                          */
/* DEFINE XLIB RELATED "ERROR" LEVEL ERROR CODES                            */
/*	BEGIN ERROR CODE 64 FROM WARNING TO                                 */
/*	LEAVE ROOM FOR 64 WARNINGS.                                         */
/*                                                                          */
#define X$_CANTOPEN 47940098
#define X$_INSFMEM 47940106
#define X$_INVBUFFER 47940114
#define X$_IOERROR 47940124
#define X$_LIBABORT 47940132
#define X$_ERROREVENT 47940138
#define X$_OBSOLETE 47940146
/*                                                                          */
/* DEFINE INFORMATIONAL MESSAGES.                                           */
/*                                                                          */
#define X$_NOHOSTS 47940611
/*                                                                          */
/* DEFINE SUCCESSFUL MESSAGES                                               */
/*                                                                          */
/********************************************************************************************************************************/
/* Created  6-AUG-1993 14:03:46 by VAX SDL V3.2-10     Source:  5-OCT-1987 15:28:55 DECW$COMMONRESD:[TRANSPORT.SRC]XPORTCOM.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $xportcom IDENT v01-0001 ***/
#define xtcq$m_ewq_flag 1
#define xtcq$m_efsq_flag 2
#define xtcq$m_eflq_flag 4
#define xtcq$m_rwq_flag 8
#define xtcq$m_rfsq_flag 16
#define xtcq$m_rflq_flag 32
#define xtcq$m_abort_flag 64
#define XTCQ$C_LENGTH 52
struct xtcq$com_queue {
    unsigned long int xtcq$l_ew_rflink;
    unsigned long int xtcq$l_ew_rblink;
    unsigned long int xtcq$l_efs_rflink;
    unsigned long int xtcq$l_efs_rblink;
    unsigned long int xtcq$l_efl_rflink;
    unsigned long int xtcq$l_efl_rblink;
    unsigned long int xtcq$l_rw_rflink;
    unsigned long int xtcq$l_rw_rblink;
    unsigned long int xtcq$l_rfs_rflink;
    unsigned long int xtcq$l_rfs_rblink;
    unsigned long int xtcq$l_rfl_rflink;
    unsigned long int xtcq$l_rfl_rblink;
    union  {
        long int xtcq$l_flags;
        struct  {
            unsigned xtcq$v_ewq_flag : 1;
            unsigned xtcq$v_efsq_flag : 1;
            unsigned xtcq$v_eflq_flag : 1;
            unsigned xtcq$v_rwq_flag : 1;
            unsigned xtcq$v_rfsq_flag : 1;
            unsigned xtcq$v_rflq_flag : 1;
            unsigned xtcq$v_abort_flag : 1;
            unsigned xtcq$v_fill_0 : 1;
            } xtcq$r_flags_bits;
        } xtcq$r_flags_union;
    } ;
#define xtpb$m_mode 3
#define xtpb$m_valid 4
#define xtpb$m_inner_mode 8
#define XTPB$C_LENGTH 32
struct xtpb$parameter_block {
    struct xtpb$parameter_block *xtpb$a_flink;
    struct xtpb$parameter_block *xtpb$a_blink;
    unsigned short int xtpb$w_size;
    unsigned char xtpb$b_type;
    unsigned char xtpb$b_subtype;
    union  {
        short int xtpb$w_flags;
        struct  {
            unsigned xtpb$v_mode : 2;
            unsigned xtpb$v_valid : 1;
            unsigned xtpb$v_inner_mode : 1;
            unsigned xtpb$v_fill_1 : 4;
            } xtpb$r_flags_bits;
        } xtpb$r_flags_union;
    unsigned short int xtpb$w_display_num;
    int (*xtpb$a_i_notify_rtnadr)();
    long int xtpb$l_i_notify_rtnprm;
    int (*xtpb$a_o_notify_rtnadr)();
    long int xtpb$l_o_notify_rtnprm;
    } ;
#define XTCB$C_LENGTH 28
struct xtcb$com_buffer {
    unsigned long int xtcb$l_rflink;
    unsigned long int xtcb$l_rblink;
    unsigned short int xtcb$w_size;
    unsigned char xtcb$b_type;
    unsigned char xtcb$b_subtype;
    unsigned short int xtcb$w_iosb [4];
    char *xtcb$a_pointer;
    unsigned long int xtcb$l_length;
    char xtcb$t_data;
    } ;
#define xtcc$m_mode 3
#define xtcc$m_active 4
#define xtcc$m_dying 8
#define xtcc$m_input_in_prog 16
#define xtcc$m_output_in_prog 32
#define xtcc$m_mark_for_close 64
#define xtcc$m_user_thread_ctl 128
#define xtcc$m_err_sts_valid 256
#define xtcc$m_lrp_on_input 512
#define xtcc$m_lrp_on_output 1024
#define xtcc$m_wait_on_write 2048
#define xtcc$m_in_ast_in_prog 4096
#define xtcc$m_out_ast_in_prog 8192
#define XTCC$C_LENGTH 124
struct xtcc$connection_context {
    struct xtcc$connection_context *xtcc$a_flink;
    struct xtcc$connection_context *xtcc$a_blink;
    unsigned short int xtcc$w_size;
    unsigned char xtcc$b_type;
    unsigned char xtcc$b_subtype;
    union  {
        long int xtcc$l_flags;
        struct  {
            unsigned xtcc$v_mode : 2;
            unsigned xtcc$v_active : 1;
            unsigned xtcc$v_dying : 1;
            unsigned xtcc$v_input_in_prog : 1;
            unsigned xtcc$v_output_in_prog : 1;
            unsigned xtcc$v_mark_for_close : 1;
            unsigned xtcc$v_user_thread_ctl : 1;
            unsigned xtcc$v_err_sts_valid : 1;
            unsigned xtcc$v_lrp_on_input : 1;
            unsigned xtcc$v_lrp_on_output : 1;
            unsigned xtcc$v_wait_on_write : 1;
            unsigned xtcc$v_in_ast_in_prog : 1;
            unsigned xtcc$v_out_ast_in_prog : 1;
            unsigned xtcc$v_fill_2 : 2;
            } xtcc$r_flags_bits;
        } xtcc$r_flags_union;
    struct xtcq$com_queue *xtcc$a_tcq;
    struct xtpb$parameter_block *xtcc$a_tpb;
    unsigned long int xtcc$l_ici;
    unsigned int (*xtcc$a_iw_queue) [2];
    unsigned int (*xtcc$a_ifs_queue) [2];
    unsigned int (*xtcc$a_ifl_queue) [2];
    unsigned int (*xtcc$a_ow_queue) [2];
    unsigned int (*xtcc$a_ofs_queue) [2];
    unsigned int (*xtcc$a_ofl_queue) [2];
    unsigned long int *xtcc$a_tcq_flags;
    unsigned long int xtcc$l_iwq_flag;
    unsigned long int xtcc$l_ifsq_flag;
    unsigned long int xtcc$l_iflq_flag;
    unsigned long int xtcc$l_owq_flag;
    unsigned long int xtcc$l_ofsq_flag;
    unsigned long int xtcc$l_oflq_flag;
    int xtcc$q_pad [2];
    int xtcc$q_user_reserved [2];
    unsigned long int xtcc$l_err_status;
    unsigned long int xtcc$l_rem_user_len;
    char *xtcc$a_rem_user;
    unsigned long int xtcc$l_rem_node_len;
    char *xtcc$a_rem_node;
    unsigned long int xtcc$l_lcl_user_len;
    char *xtcc$a_lcl_user;
    } ;
#define IXTCC$C_LENGTH 116
struct ixtcc$internal_xtcc {
    struct xtcc$connection_context *ixtcc$a_flink;
    struct xtcc$connection_context *ixtcc$a_blink;
    unsigned short int ixtcc$w_size;
    unsigned char ixtcc$b_type;
    unsigned char ixtcc$b_subtype;
    struct xtcq$com_queue *ixtcc$a_tcq;
    struct xtpb$parameter_block *ixtcc$a_tpb;
    long int *ixtcc$a_tdb;
    struct xtcc$connection_context *ixtcc$a_tcc;
    char *ixtcc$a_user_region [2];
    char *ixtcc$a_buffer_region [2];
    unsigned long int ixtcc$l_ici;
    unsigned int (*ixtcc$a_iw_queue) [2];
    unsigned int (*ixtcc$a_ifs_queue) [2];
    unsigned int (*ixtcc$a_ifl_queue) [2];
    unsigned int (*ixtcc$a_ow_queue) [2];
    unsigned int (*ixtcc$a_ofs_queue) [2];
    unsigned int (*ixtcc$a_ofl_queue) [2];
    unsigned long int *ixtcc$a_tcq_flags;
    unsigned long int ixtcc$l_iwq_flag;
    unsigned long int ixtcc$l_ifsq_flag;
    unsigned long int ixtcc$l_iflq_flag;
    unsigned long int ixtcc$l_owq_flag;
    unsigned long int ixtcc$l_ofsq_flag;
    unsigned long int ixtcc$l_oflq_flag;
    char *ixtcc$a_dec_extended;
    int ixtcc$q_xport_reserved [2];
    long int ixtcc$l_dec_reserved;
    } ;
#define IXTCC_EXT$C_LENGTH 12
struct ixtcc_ext$extended {
    unsigned int (*ixtcc_ext$a_user_iosb) [2];
    long int ixtcc_ext$l_user_reserved0;
    long int ixtcc_ext$l_user_reserved1;
    } ;
#define xtdb$m_mode 3
#define xtdb$m_active 4
#define xtdb$m_dying 8
#define xtdb$m_check_access 16
#define xtdb$m_rundown 32
#define XTDB$C_LENGTH 72
struct xtdb$transport_desc {
    struct xtdb$transport_desc *xtdb$a_flink;
    struct xtdb$transport_desc *xtdb$a_blink;
    unsigned short int xtdb$w_size;
    unsigned char xtdb$b_type;
    unsigned char xtdb$b_subtype;
    union  {
        long int xtdb$l_flags;
        struct  {
            unsigned xtdb$v_mode : 2;
            unsigned xtdb$v_active : 1;
            unsigned xtdb$v_dying : 1;
            unsigned xtdb$v_check_access : 1;
            unsigned xtdb$v_rundown : 1;
            unsigned xtdb$v_fill_3 : 2;
            } xtdb$r_flags_bits;
        } xtdb$r_flags_union;
    struct xtpb$parameter_block *xtdb$a_tpb;
    unsigned long int xtdb$l_ref_count;
    int xtdb$q_reserved [2];
    long int xtdb$l_dec_reserved;
    struct ixtcc$internal_xtcc *xtdb$a_itcc_flink;
    struct ixtcc$internal_xtcc *xtdb$a_itcc_blink;
    int (*xtdb$a_connect_abort)();
    int (*xtdb$a_connect_request)();
    unsigned long int xtdb$l_family_name_len;
    char xtdb$t_family_name [16];
    } ;
#define DECW$C_DYN_XTCC 1
#define DECW$C_DYN_XTCQ 2
#define DECW$C_DYN_XTCB_SRP 3
#define DECW$C_DYN_XTCB_LRP 4
#define DECW$C_DYN_XTDB 5
#define DECW$C_DYN_XTFT 6
#define DECW$C_DYN_XTPB 7
#define DECW$C_DYN_IXTCC 8
#define DECW$C_DYN_LAST 8
#define DECW$K_WRITE_MORE 0
#define DECW$K_WRITE_DONE 1
#define DECW$K_WRITE_HOLD 2
#define DECW$V_MODE_NOBLOCK 0
#define DECW$M_MODE_NOBLOCK 1
#define DECW$V_MODE_CLEAN 1
#define DECW$M_MODE_CLEAN 2
#define DECW$V_MODE_NOWRTBLOCK 2
#define DECW$M_MODE_NOWRTBLOCK 4
#define DECW$V_MODE_DETECT_REENTRANCY 3
#define DECW$M_MODE_DETECT_REENTRANCY 8
#define DECW$M_XPORT_CLIENT 1
#define DECW$M_XPORT_LOCAL 2
#define DECW$K_XPORT_CLIENT 1
#define DECW$K_XPORT_LOCAL 2
#define DECW$K_XPORT_SERVER 0
#define DECW$K_XPORT_REMOTE 0
#define DECW$K_XPORT_REMOTE_SERVER 0
#define DECW$K_XPORT_REMOTE_CLIENT 1
#define DECW$K_XPORT_LOCAL_SERVER 2
#define DECW$K_XPORT_LOCAL_CLIENT 3
#define DECW$C_XPORT_EOL 0
#define DECW$C_XPORT_IN_NOTIFY_RTNADR 1
#define DECW$C_XPORT_OUT_NOTIFY_RTNADR 2
#define DECW$C_XPORT_LRP_SIZE 3
#define DECW$C_XPORT_SRP_SIZE 4
#define DECW$C_XPORT_OUT_WAIT_EFN 5
#define DECW$C_XPORT_IN_WAIT_EFN 6
#define DECW$C_XPORT_TIMEOUT 7
#define DECW$C_XPORT_IN_LRP_COUNT 8
#define DECW$C_XPORT_IN_SRP_COUNT 9
#define DECW$C_XPORT_OUT_LRP_COUNT 10
#define DECW$C_XPORT_OUT_SRP_COUNT 11
#define DECW$C_XPORT_INNER_MODE 12
#define DECW$C_XPORT_USER_0 13
#define DECW$C_XPORT_USER_1 14
#define DECW$C_XPORT_REM_NODE 15
#define DECW$C_XPORT_REM_USER 16
#define DECW$C_XPORT_LCL_USER 17
#define DECW$C_XPORT_TRANSPORT_NAME 18
#define DECW$C_XPORT_IN_TIMEOUT 19
#define DECW$C_XPORT_OUT_TIMEOUT 20
#define DECW$C_XPORT_PUTMSG_CALLBACK 21
#define DECW$C_XPORT_REENTRANCY_CONTEXT 22
#define DECW$C_XPORT_SOFT_AST_LOCK_DPTH 23
#define DECW$C_XPORT_SOFT_AST_LIB_LOCK 24
#define DECW$C_XPORT_MEM_ALLOC_SIZE 25
#define DECW$C_XPORT_MEM_EXT_SIZE 26
#define DECW$C_XPORT_MAX_ITEM 26
#define DECW$C_XPORT_WRITE_EOL 0
#define DECW$C_XPORT_WRITE_NOP 1
#define DECW$C_XPORT_WRITE_XTCB 2
#define DECW$C_XPORT_WRITE_USER 3
#define DECW$C_XPORT_WRITE_RETRY 4
#define DECW$C_XPORT_WRITE_MAX_ITEM 4
#define DECW$C_XPORT_BUFFER_SRP 0
#define DECW$C_XPORT_BUFFER_LRP 1
#define DECW$K_XPORT_DEF_SRP_SIZE 1408
#define DECW$K_XPORT_DEF_SRP_REQUESTS 2
#define DECW$K_XPORT_DEF_SRP_EVENTS 8
#define DECW$K_XPORT_DEF_LRP_SIZE 16384
#define DECW$K_XPORT_DEF_LRP_REQUESTS 2
#define DECW$K_XPORT_DEF_LRP_EVENTS 1
#define DECW$K_XPORT_DEF_MEM_ALLOC_SIZE 0
#define DECW$K_XPORT_DEF_MEM_EXT_SIZE 625
#define XTFT$K_REQUIRED0 -1515870811
#define XTFT$K_REQUIRED1 -1768515946
#define XTFT$C_LENGTH 64
struct xtft$function_table {
    long int xtft$l_required0;
    long int xtft$l_reserved0;
    int (*xtft$a_execute_write)();
    int (*xtft$a_write)();
    int (*xtft$a_write_user)();
    int (*xtft$a_execute_free)();
    int (*xtft$a_free_input_buffer)();
    int (*xtft$a_close)();
    int (*xtft$a_open)();
    int (*xtft$a_attach_transport)();
    int (*xtft$a_rundown)();
    long int xtft$l_xtcc_length;
    long int xtft$l_xtpb_length;
    long int xtft$l_xtdb_length;
    long int xtft$l_ixtcc_length;
    long int xtft$l_required1;
    } ;
#define XTPB$C_COMMON_LENGTH 64
struct xtpb$common {
    struct xtpb$parameter_block xtpb$r_parameter_block;
    unsigned short int xtpb$w_in_efn;
    unsigned short int xtpb$w_on_efn;
    unsigned short int xtpb$w_srp_size;
    unsigned short int xtpb$w_lrp_size;
    long int xtpb$l_i_timeout;
    unsigned short int xtpb$w_i_srp_count;
    unsigned short int xtpb$w_i_lrp_count;
    unsigned short int xtpb$w_o_srp_count;
    unsigned short int xtpb$w_o_lrp_count;
    long int xtpb$l_o_timeout;
    long int xtpb$l_i_ticks;
    long int xtpb$l_o_ticks;
    } ;
#define XTCC$C_COMMON_LENGTH 160
struct xtcc$common {
    struct xtcc$connection_context xtcc$r_connection_context;
    unsigned short int xtcc$w_in_iosb [4];
    unsigned short int xtcc$w_on_iosb [4];
    unsigned short int xtcc$w_ow_iosb [4];
    long int xtcc$l_in_wait_ticks;
    long int xtcc$l_out_wait_ticks;
    unsigned long int xtcc$l_out_free_space;
    } ;
#define IXTCC$C_COMMON_LENGTH 120
struct ixtcc$common {
    struct ixtcc$internal_xtcc ixtcc$r_connection_context;
    struct xtft$function_table *ixtcc$a_xport_table;
    } ;
#define XTDB$C_COMMON_LENGTH 96
struct xtdb$common {
    struct xtdb$transport_desc xtdb$r_transport_desc;
    unsigned long int xtdb$l_chk_objtyp;
    long int xtdb$l_chk_objnam_len;
    char *xtdb$a_chk_objnam_adr;
    unsigned long int xtdb$l_chk_access;
    unsigned long int xtdb$l_chk_flags;
    struct xtft$function_table *xtdb$a_xport_table;
    } ;
struct xmem$memory_desc {
    struct xmem$memory_desc *xmem$a_flink;
    struct xmem$memory_desc *xmem$a_blink;
    unsigned short int xmem$w_size;
    unsigned char xmem$b_type;
    unsigned char xmem$b_subtype;
    int *xmem$a_base;
    unsigned long int xmem$L_LENGTH;
    } ;
#define XMSG$C_LENGTH 16
struct xmsg$message_block {
    struct xmsg$message_block *xmsg$a_flink;
    struct xmsg$message_block *xmsg$a_blink;
    unsigned short int xmsg$w_size;
    unsigned char xmsg$b_type;
    unsigned char xmsg$b_subtype;
    unsigned long int xmsg$l_registration;
    char xmsg$t_message;
    } ;
#define DECW$C_DYN_XMEM 9
#define DECW$C_DYN_XMSG 10
#define XTML$C_LENGTH 16
struct xtml$memory_list {
    unsigned long int xtml$l_flink;
    unsigned long int xtml$l_tpb;
    unsigned long int xtml$l_alloc_size;
    unsigned long int xtml$l_ext_size;
    } ;
/********************************************************************************************************************************/
/* Created  6-AUG-1993 14:04:22 by VAX SDL V3.2-10     Source: 11-MAY-1988 10:56:36 DECW$COMMONRESD:[STRUCT.SRC]XPORTDEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $xportdef IDENT X1-4 ***/
#define xtcq$m_ewq_flag 1
#define xtcq$m_efsq_flag 2
#define xtcq$m_eflq_flag 4
#define xtcq$m_rwq_flag 8
#define xtcq$m_rfsq_flag 16
#define xtcq$m_rflq_flag 32
#define xtcq$m_abort_flag 64
#define XTCQ$C_LENGTH 52
struct xtcq$com_queue {
    unsigned long int xtcq$l_ew_rflink;
    unsigned long int xtcq$l_ew_rblink;
    unsigned long int xtcq$l_efs_rflink;
    unsigned long int xtcq$l_efs_rblink;
    unsigned long int xtcq$l_efl_rflink;
    unsigned long int xtcq$l_efl_rblink;
    unsigned long int xtcq$l_rw_rflink;
    unsigned long int xtcq$l_rw_rblink;
    unsigned long int xtcq$l_rfs_rflink;
    unsigned long int xtcq$l_rfs_rblink;
    unsigned long int xtcq$l_rfl_rflink;
    unsigned long int xtcq$l_rfl_rblink;
    union  {
        long int xtcq$l_flags;
        struct  {
            unsigned xtcq$v_ewq_flag : 1;
            unsigned xtcq$v_efsq_flag : 1;
            unsigned xtcq$v_eflq_flag : 1;
            unsigned xtcq$v_rwq_flag : 1;
            unsigned xtcq$v_rfsq_flag : 1;
            unsigned xtcq$v_rflq_flag : 1;
            unsigned xtcq$v_abort_flag : 1;
            unsigned xtcq$v_fill_0 : 1;
            } xtcq$r_flags_bits;
        } xtcq$r_flags_union;
    } ;
#define xtpb$m_mode 3
#define xtpb$m_valid 4
#define xtpb$m_inner_mode 8
#define XTPB$C_LENGTH 32
struct xtpb$parameter_block {
    struct xtpb$parameter_block *xtpb$a_flink;
    struct xtpb$parameter_block *xtpb$a_blink;
    unsigned short int xtpb$w_size;
    unsigned char xtpb$b_type;
    unsigned char xtpb$b_subtype;
    union  {
        short int xtpb$w_flags;
        struct  {
            unsigned xtpb$v_mode : 2;
            unsigned xtpb$v_valid : 1;
            unsigned xtpb$v_inner_mode : 1;
            unsigned xtpb$v_fill_1 : 4;
            } xtpb$r_flags_bits;
        } xtpb$r_flags_union;
    unsigned short int xtpb$w_display_num;
    int (*xtpb$a_i_notify_rtnadr)();
    long int xtpb$l_i_notify_rtnprm;
    int (*xtpb$a_o_notify_rtnadr)();
    long int xtpb$l_o_notify_rtnprm;
    } ;
#define XTCB$C_LENGTH 28
struct xtcb$com_buffer {
    unsigned long int xtcb$l_rflink;
    unsigned long int xtcb$l_rblink;
    unsigned short int xtcb$w_size;
    unsigned char xtcb$b_type;
    unsigned char xtcb$b_subtype;
    unsigned short int xtcb$w_iosb [4];
    char *xtcb$a_pointer;
    unsigned long int xtcb$l_length;
    char xtcb$t_data;
    } ;
#define xtcc$m_mode 3
#define xtcc$m_active 4
#define xtcc$m_dying 8
#define xtcc$m_input_in_prog 16
#define xtcc$m_output_in_prog 32
#define xtcc$m_mark_for_close 64
#define xtcc$m_user_thread_ctl 128
#define xtcc$m_err_sts_valid 256
#define xtcc$m_lrp_on_input 512
#define xtcc$m_lrp_on_output 1024
#define xtcc$m_wait_on_write 2048
#define xtcc$m_in_ast_in_prog 4096
#define xtcc$m_out_ast_in_prog 8192
#define XTCC$C_LENGTH 124
struct xtcc$connection_context {
    struct xtcc$connection_context *xtcc$a_flink;
    struct xtcc$connection_context *xtcc$a_blink;
    unsigned short int xtcc$w_size;
    unsigned char xtcc$b_type;
    unsigned char xtcc$b_subtype;
    union  {
        long int xtcc$l_flags;
        struct  {
            unsigned xtcc$v_mode : 2;
            unsigned xtcc$v_active : 1;
            unsigned xtcc$v_dying : 1;
            unsigned xtcc$v_input_in_prog : 1;
            unsigned xtcc$v_output_in_prog : 1;
            unsigned xtcc$v_mark_for_close : 1;
            unsigned xtcc$v_user_thread_ctl : 1;
            unsigned xtcc$v_err_sts_valid : 1;
            unsigned xtcc$v_lrp_on_input : 1;
            unsigned xtcc$v_lrp_on_output : 1;
            unsigned xtcc$v_wait_on_write : 1;
            unsigned xtcc$v_in_ast_in_prog : 1;
            unsigned xtcc$v_out_ast_in_prog : 1;
            unsigned xtcc$v_fill_2 : 2;
            } xtcc$r_flags_bits;
        } xtcc$r_flags_union;
    struct xtcq$com_queue *xtcc$a_tcq;
    struct xtpb$parameter_block *xtcc$a_tpb;
    unsigned long int xtcc$l_ici;
    unsigned int (*xtcc$a_iw_queue) [2];
    unsigned int (*xtcc$a_ifs_queue) [2];
    unsigned int (*xtcc$a_ifl_queue) [2];
    unsigned int (*xtcc$a_ow_queue) [2];
    unsigned int (*xtcc$a_ofs_queue) [2];
    unsigned int (*xtcc$a_ofl_queue) [2];
    unsigned long int *xtcc$a_tcq_flags;
    unsigned long int xtcc$l_iwq_flag;
    unsigned long int xtcc$l_ifsq_flag;
    unsigned long int xtcc$l_iflq_flag;
    unsigned long int xtcc$l_owq_flag;
    unsigned long int xtcc$l_ofsq_flag;
    unsigned long int xtcc$l_oflq_flag;
    int xtcc$q_pad [2];
    int xtcc$q_user_reserved [2];
    unsigned long int xtcc$l_err_status;
    unsigned long int xtcc$l_rem_user_len;
    char *xtcc$a_rem_user;
    unsigned long int xtcc$l_rem_node_len;
    char *xtcc$a_rem_node;
    unsigned long int xtcc$l_lcl_user_len;
    char *xtcc$a_lcl_user;
    } ;
#define IXTCC$C_LENGTH 116
struct ixtcc$internal_xtcc {
    struct xtcc$connection_context *ixtcc$a_flink;
    struct xtcc$connection_context *ixtcc$a_blink;
    unsigned short int ixtcc$w_size;
    unsigned char ixtcc$b_type;
    unsigned char ixtcc$b_subtype;
    struct xtcq$com_queue *ixtcc$a_tcq;
    struct xtpb$parameter_block *ixtcc$a_tpb;
    long int *ixtcc$a_tdb;
    struct xtcc$connection_context *ixtcc$a_tcc;
    char *ixtcc$a_user_region [2];
    char *ixtcc$a_buffer_region [2];
    unsigned long int ixtcc$l_ici;
    unsigned int (*ixtcc$a_iw_queue) [2];
    unsigned int (*ixtcc$a_ifs_queue) [2];
    unsigned int (*ixtcc$a_ifl_queue) [2];
    unsigned int (*ixtcc$a_ow_queue) [2];
    unsigned int (*ixtcc$a_ofs_queue) [2];
    unsigned int (*ixtcc$a_ofl_queue) [2];
    unsigned long int *ixtcc$a_tcq_flags;
    unsigned long int ixtcc$l_iwq_flag;
    unsigned long int ixtcc$l_ifsq_flag;
    unsigned long int ixtcc$l_iflq_flag;
    unsigned long int ixtcc$l_owq_flag;
    unsigned long int ixtcc$l_ofsq_flag;
    unsigned long int ixtcc$l_oflq_flag;
    char *ixtcc$a_dec_extended;
    int ixtcc$q_xport_reserved [2];
    long int ixtcc$l_dec_reserved;
    } ;
#define IXTCC_EXT$C_LENGTH 12
struct ixtcc_ext$extended {
    unsigned int (*ixtcc_ext$a_user_iosb) [2];
    long int ixtcc_ext$l_user_reserved0;
    long int ixtcc_ext$l_user_reserved1;
    } ;
#define xtdb$m_mode 3
#define xtdb$m_active 4
#define xtdb$m_dying 8
#define xtdb$m_check_access 16
#define xtdb$m_rundown 32
#define XTDB$C_LENGTH 72
struct xtdb$transport_desc {
    struct xtdb$transport_desc *xtdb$a_flink;
    struct xtdb$transport_desc *xtdb$a_blink;
    unsigned short int xtdb$w_size;
    unsigned char xtdb$b_type;
    unsigned char xtdb$b_subtype;
    union  {
        long int xtdb$l_flags;
        struct  {
            unsigned xtdb$v_mode : 2;
            unsigned xtdb$v_active : 1;
            unsigned xtdb$v_dying : 1;
            unsigned xtdb$v_check_access : 1;
            unsigned xtdb$v_rundown : 1;
            unsigned xtdb$v_fill_3 : 2;
            } xtdb$r_flags_bits;
        } xtdb$r_flags_union;
    struct xtpb$parameter_block *xtdb$a_tpb;
    unsigned long int xtdb$l_ref_count;
    int xtdb$q_reserved [2];
    long int xtdb$l_dec_reserved;
    struct ixtcc$internal_xtcc *xtdb$a_itcc_flink;
    struct ixtcc$internal_xtcc *xtdb$a_itcc_blink;
    int (*xtdb$a_connect_abort)();
    int (*xtdb$a_connect_request)();
    unsigned long int xtdb$l_family_name_len;
    char xtdb$t_family_name [16];
    } ;
#define DECW$C_DYN_XTCC 1
#define DECW$C_DYN_XTCQ 2
#define DECW$C_DYN_XTCB_SRP 3
#define DECW$C_DYN_XTCB_LRP 4
#define DECW$C_DYN_XTDB 5
#define DECW$C_DYN_XTFT 6
#define DECW$C_DYN_XTPB 7
#define DECW$C_DYN_IXTCC 8
#define DECW$C_DYN_LAST 8
#define DECW$K_WRITE_MORE 0
#define DECW$K_WRITE_DONE 1
#define DECW$K_WRITE_HOLD 2
#define DECW$V_MODE_NOBLOCK 0
#define DECW$M_MODE_NOBLOCK 1
#define DECW$V_MODE_CLEAN 1
#define DECW$M_MODE_CLEAN 2
#define DECW$V_MODE_NOWRTBLOCK 2
#define DECW$M_MODE_NOWRTBLOCK 4
#define DECW$V_MODE_DETECT_REENTRANCY 3
#define DECW$M_MODE_DETECT_REENTRANCY 8
#define DECW$M_XPORT_CLIENT 1
#define DECW$M_XPORT_LOCAL 2
#define DECW$K_XPORT_CLIENT 1
#define DECW$K_XPORT_LOCAL 2
#define DECW$K_XPORT_SERVER 0
#define DECW$K_XPORT_REMOTE 0
#define DECW$K_XPORT_REMOTE_SERVER 0
#define DECW$K_XPORT_REMOTE_CLIENT 1
#define DECW$K_XPORT_LOCAL_SERVER 2
#define DECW$K_XPORT_LOCAL_CLIENT 3
#define DECW$C_XPORT_EOL 0
#define DECW$C_XPORT_IN_NOTIFY_RTNADR 1
#define DECW$C_XPORT_OUT_NOTIFY_RTNADR 2
#define DECW$C_XPORT_LRP_SIZE 3
#define DECW$C_XPORT_SRP_SIZE 4
#define DECW$C_XPORT_OUT_WAIT_EFN 5
#define DECW$C_XPORT_IN_WAIT_EFN 6
#define DECW$C_XPORT_TIMEOUT 7
#define DECW$C_XPORT_IN_LRP_COUNT 8
#define DECW$C_XPORT_IN_SRP_COUNT 9
#define DECW$C_XPORT_OUT_LRP_COUNT 10
#define DECW$C_XPORT_OUT_SRP_COUNT 11
#define DECW$C_XPORT_INNER_MODE 12
#define DECW$C_XPORT_USER_0 13
#define DECW$C_XPORT_USER_1 14
#define DECW$C_XPORT_REM_NODE 15
#define DECW$C_XPORT_REM_USER 16
#define DECW$C_XPORT_LCL_USER 17
#define DECW$C_XPORT_TRANSPORT_NAME 18
#define DECW$C_XPORT_IN_TIMEOUT 19
#define DECW$C_XPORT_OUT_TIMEOUT 20
#define DECW$C_XPORT_PUTMSG_CALLBACK 21
#define DECW$C_XPORT_REENTRANCY_CONTEXT 22
#define DECW$C_XPORT_SOFT_AST_LOCK_DPTH 23
#define DECW$C_XPORT_SOFT_AST_LIB_LOCK 24
#define DECW$C_XPORT_MEM_ALLOC_SIZE 25
#define DECW$C_XPORT_MEM_EXT_SIZE 26
#define DECW$C_XPORT_MAX_ITEM 26
#define DECW$C_XPORT_WRITE_EOL 0
#define DECW$C_XPORT_WRITE_NOP 1
#define DECW$C_XPORT_WRITE_XTCB 2
#define DECW$C_XPORT_WRITE_USER 3
#define DECW$C_XPORT_WRITE_RETRY 4
#define DECW$C_XPORT_WRITE_MAX_ITEM 4
#define DECW$C_XPORT_BUFFER_SRP 0
#define DECW$C_XPORT_BUFFER_LRP 1
#define DECW$K_XPORT_DEF_SRP_SIZE 1408
#define DECW$K_XPORT_DEF_SRP_REQUESTS 2
#define DECW$K_XPORT_DEF_SRP_EVENTS 8
#define DECW$K_XPORT_DEF_LRP_SIZE 16384
#define DECW$K_XPORT_DEF_LRP_REQUESTS 2
#define DECW$K_XPORT_DEF_LRP_EVENTS 1
#define DECW$K_XPORT_DEF_MEM_ALLOC_SIZE 0
#define DECW$K_XPORT_DEF_MEM_EXT_SIZE 625
#ifndef __DESCRIP_LOADED
#define __DESCRIP_LOADED	1

/*
 *	DESCRIP.H - V3.0-003 - Argument Descriptor Formats
 *	(Based on the VAX Procedure Calling and Condition Handling Standard, Revision 9.4 [13 March 1984];
 *	 see the "Introduction to VMS System Routines" manual for further information.)
 */


/*
 *	Descriptor Prototype - each class of descriptor consists of at least the following fields:
 */
struct	dsc$descriptor
{
	unsigned short	dsc$w_length;	/* specific to descriptor class;  typically a 16-bit (unsigned) length */
	unsigned char	dsc$b_dtype;	/* data type code */
	unsigned char	dsc$b_class;	/* descriptor class code */
	char		*dsc$a_pointer;	/* address of first byte of data element */
};


/*
 *	Fixed-Length Descriptor:
 */
struct	dsc$descriptor_s
{
	unsigned short	dsc$w_length;	/* length of data item in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_V, bits,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	unsigned char	dsc$b_dtype;	/* data type code */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_S */
	char		*dsc$a_pointer;	/* address of first byte of data storage */
};


/*
 *	Dynamic String Descriptor:
 */
struct	dsc$descriptor_d
{
	unsigned short	dsc$w_length;	/* length of data item in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_V, bits,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	unsigned char	dsc$b_dtype;	/* data type code */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_D */
	char		*dsc$a_pointer;	/* address of first byte of data storage */
};


/*
 *	Array Descriptor:
 */
struct	dsc$descriptor_a
{
	unsigned short	dsc$w_length;	/* length of an array element in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_V, bits,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	unsigned char	dsc$b_dtype;	/* data type code */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_A */
	char		*dsc$a_pointer;	/* address of first actual byte of data storage */
	char		dsc$b_scale;	/* signed power-of-two or -ten multiplier, as specified by
					     dsc$v_fl_binscale, to convert from internal to external form */
	unsigned char	dsc$b_digits;	/* if nonzero, number of decimal digits in internal representation */
	struct
	{
		unsigned		 : 3;	/* reserved;  must be zero */
		unsigned dsc$v_fl_binscale : 1; /* if set, dsc$b_scale is a power-of-two, otherwise, -ten */
		unsigned dsc$v_fl_redim	 : 1;	/* if set, indicates the array can be redimensioned */
		unsigned dsc$v_fl_column : 1;	/* if set, indicates column-major order (FORTRAN) */
		unsigned dsc$v_fl_coeff  : 1;	/* if set, indicates the multipliers block is present */
		unsigned dsc$v_fl_bounds : 1;	/* if set, indicates the bounds block is present */
	}		dsc$b_aflags;	/* array flag bits */
	unsigned char	dsc$b_dimct;	/* number of dimensions */
	unsigned long	dsc$l_arsize;	/* total size of array in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	/*
	 * One or two optional blocks of information may follow contiguously at this point;
	 * the first block contains information about the dimension multipliers (if present,
	 * dsc$b_aflags.dsc$v_fl_coeff is set), the second block contains information about
	 * the dimension bounds (if present, dsc$b_aflags.dsc$v_fl_bounds is set).  If the
	 * bounds information is present, the multipliers information must also be present.
	 *
	 * The multipliers block has the following format:
	 *	char	*dsc$a_a0;		Address of the element whose subscripts are all zero
	 *	long	dsc$l_m [DIMCT];	Addressing coefficients (multipliers)
	 *
	 * The bounds block has the following format:
	 *	struct
	 *	{
	 *		long	dsc$l_l;	Lower bound
	 *		long	dsc$l_u;	Upper bound
	 *	} dsc$bounds [DIMCT];
	 *
	 * (DIMCT represents the value contained in dsc$b_dimct.)
	 */
};


/*
 *	Procedure Descriptor:
 */
struct	dsc$descriptor_p
{
	unsigned short	dsc$w_length;	/* length associated with the function value */
	unsigned char	dsc$b_dtype;	/* function value data type code */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_P */
	int		(*dsc$a_pointer)();	/* address of function entry mask */
};


/*
 *	Decimal String Descriptor:
 */
struct	dsc$descriptor_sd
{
	unsigned short	dsc$w_length;	/* length of data item in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_V, bits,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	unsigned char	dsc$b_dtype;	/* data type code */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_SD */
	char		*dsc$a_pointer;	/* address of first byte of data storage */
	char		dsc$b_scale;	/* signed power-of-two or -ten multiplier, as specified by
					     dsc$v_fl_binscale, to convert from internal to external form */
	unsigned char	dsc$b_digits;	/* if nonzero, number of decimal digits in internal representation */
	struct
	{
		unsigned		: 3;	/* reserved;  must be zero */
		unsigned dsc$v_fl_binscale : 1;	/* if set, dsc$b_scale is a power-of-two, otherwise, -ten */
		unsigned		: 4;	/* reserved;  must be zero */
	}		dsc$b_sflags;	/* scalar flag bits */
	unsigned	: 8;		/* reserved;  must be zero */
};


/*
 *	Noncontiguous Array Descriptor:
 */
struct	dsc$descriptor_nca
{
	unsigned short	dsc$w_length;	/* length of an array element in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_V, bits,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	unsigned char	dsc$b_dtype;	/* data type code */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_NCA */
	char		*dsc$a_pointer;	/* address of first actual byte of data storage */
	char		dsc$b_scale;	/* signed power-of-two or -ten multiplier, as specified by
					     dsc$v_fl_binscale, to convert from internal to external form */
	unsigned char	dsc$b_digits;	/* if nonzero, number of decimal digits in internal representation */
	struct
	{
		unsigned		 : 3;	/* reserved;  must be zero */
		unsigned dsc$v_fl_binscale : 1; /* if set, dsc$b_scale is a power-of-two, otherwise, -ten */
		unsigned dsc$v_fl_redim	 : 1;	/* must be zero */
		unsigned 		 : 3;	/* reserved;  must be zero */
	}		dsc$b_aflags;	/* array flag bits */
	unsigned char	dsc$b_dimct;	/* number of dimensions */
	unsigned long	dsc$l_arsize;	/* if elements are actually contiguous, total size of array in bytes,
					     or if dsc$b_dtype is DSC$K_DTYPE_P, digits (4 bits each) */
	/*
	 * Two blocks of information must follow contiguously at this point;  the first block
	 * contains information about the difference between the addresses of two adjacent
	 * elements in each dimension (the stride).  The second block contains information
	 * about the dimension bounds.
	 *
	 * The strides block has the following format:
	 *	char		*dsc$a_a0;		Address of the element whose subscripts are all zero
	 *	unsigned long	dsc$l_s [DIMCT];	Strides
	 *
	 * The bounds block has the following format:
	 *	struct
	 *	{
	 *		long	dsc$l_l;		Lower bound
	 *		long	dsc$l_u;		Upper bound
	 *	} dsc$bounds [DIMCT];
	 *
	 * (DIMCT represents the value contained in dsc$b_dimct.)
	 */
};


/*
 *	The Varying String Descriptor and Varying String Array Descriptor are used with strings
 *	of the following form:
 *
 *		struct
 *		{
 *			unsigned short	CURLEN;		The current length of BODY in bytes
 *			char	BODY [MAXSTRLEN];	A fixed-length area containing the string
 *		};
 *
 *	where MAXSTRLEN is the value contained in the dsc$w_maxstrlen field in the descriptor.
 */


/*
 *	Varying String Descriptor:
 */
struct	dsc$descriptor_vs
{
	unsigned short	dsc$w_maxstrlen; /* maximum length of the BODY field of the varying string in bytes */
	unsigned char	dsc$b_dtype;	/* data type code = DSC$K_DTYPE_VT */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_VS */
	char		*dsc$a_pointer;	/* address of the CURLEN field of the varying string */
};


/*
 *	Varying String Array Descriptor:
 */
struct	dsc$descriptor_vsa
{
	unsigned short	dsc$w_maxstrlen; /* maximum length of the BODY field of an array element in bytes */
	unsigned char	dsc$b_dtype;	/* data type code = DSC$K_DTYPE_VT */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_VSA */
	char		*dsc$a_pointer;	/* address of first actual byte of data storage */
	char		dsc$b_scale;	/* signed power-of-two or -ten multiplier, as specified by
					     dsc$v_fl_binscale, to convert from internal to external form */
	unsigned char	dsc$b_digits;	/* if nonzero, number of decimal digits in internal representation */
	struct
	{
		unsigned		 : 3;	/* reserved;  must be zero */
		unsigned dsc$v_fl_binscale : 1; /* if set, dsc$b_scale is a power-of-two, otherwise, -ten */
		unsigned dsc$v_fl_redim	 : 1;	/* must be zero */
		unsigned 		 : 3;	/* reserved;  must be zero */
	}		dsc$b_aflags;	/* array flag bits */
	unsigned char	dsc$b_dimct;	/* number of dimensions */
	unsigned long	dsc$l_arsize;	/* if elements are actually contiguous, total size of array in bytes */
	/*
	 * Two blocks of information must follow contiguously at this point;  the first block
	 * contains information about the difference between the addresses of two adjacent
	 * elements in each dimension (the stride).  The second block contains information
	 * about the dimension bounds.
	 *
	 * The strides block has the following format:
	 *	char		*dsc$a_a0;		Address of the element whose subscripts are all zero
	 *	unsigned long	dsc$l_s [DIMCT];	Strides
	 *
	 * The bounds block has the following format:
	 *	struct
	 *	{
	 *		long	dsc$l_l;		Lower bound
	 *		long	dsc$l_u;		Upper bound
	 *	} dsc$bounds [DIMCT];
	 *
	 * (DIMCT represents the value contained in dsc$b_dimct.)
	 */
};


/*
 *	Unaligned Bit String Descriptor:
 */
struct	dsc$descriptor_ubs
{
	unsigned short	dsc$w_length;	/* length of data item in bits */
	unsigned char	dsc$b_dtype;	/* data type code = DSC$K_DTYPE_VU */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_UBS */
	char		*dsc$a_base;	/* address to which dsc$l_pos is relative */
	long		dsc$l_pos;	/* bit position relative to dsc$a_base of first bit in string */
};


/*
 *	Unaligned Bit Array Descriptor:
 */
struct	dsc$descriptor_uba
{
	unsigned short	dsc$w_length;	/* length of data item in bits */
	unsigned char	dsc$b_dtype;	/* data type code = DSC$K_DTYPE_VU */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_UBA */
	char		*dsc$a_base;	/* address to which effective bit offset is relative */
	char		dsc$b_scale;	/* reserved;  must be zero */
	unsigned char	dsc$b_digits;	/* reserved;  must be zero */
	struct
	{
		unsigned		 : 3;	/* reserved;  must be zero */
		unsigned dsc$v_fl_binscale : 1;	/* must be zero */
		unsigned dsc$v_fl_redim	 : 1;	/* must be zero */
		unsigned 		 : 3;	/* reserved;  must be zero */
	}		dsc$b_aflags;	/* array flag bits */
	unsigned char	dsc$b_dimct;	/* number of dimensions */
	unsigned long	dsc$l_arsize;	/* total size of array in bits */
	/*
	 * Three blocks of information must follow contiguously at this point;  the first block
	 * contains information about the difference between the bit addresses of two adjacent
	 * elements in each dimension (the stride).  The second block contains information
	 * about the dimension bounds.  The third block is the relative bit position with
	 * respect to dsc$a_base of the first actual bit of the array.
	 *
	 * The strides block has the following format:
	 *	long		dsc$l_v0;		Bit offset of the element whose subscripts are all zero,
	 *						with respect to dsc$a_base
	 *	unsigned long	dsc$l_s [DIMCT];	Strides
	 *
	 * The bounds block has the following format:
	 *	struct
	 *	{
	 *		long	dsc$l_l;		Lower bound
	 *		long	dsc$l_u;		Upper bound
	 *	} dsc$bounds [DIMCT];
	 *
	 * The last block has the following format:
	 *	long	dsc$l_pos;
	 *
	 * (DIMCT represents the value contained in dsc$b_dimct.)
	 */
	};


/*
 *	String with Bounds Descriptor:
 */
struct	dsc$descriptor_sb
{
	unsigned short	dsc$w_length;	/* length of string in bytes */
	unsigned char	dsc$b_dtype;	/* data type code = DSC$K_DTYPE_T */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_SB */
	char		*dsc$a_pointer;	/* address of first byte of data storage */
	long		dsc$l_sb_l1;	/* lower bound */
	long		dsc$l_sb_u1;	/* upper bound */
};


/*
 *	Unaligned Bit String with Bounds Descriptor:
 */
struct	dsc$descriptor_ubsb
{
	unsigned short	dsc$w_length;	/* length of data item in bits */
	unsigned char	dsc$b_dtype;	/* data type code = DSC$K_DTYPE_VU */
	unsigned char	dsc$b_class;	/* descriptor class code = DSC$K_CLASS_UBSB */
	char		*dsc$a_base;	/* address to which dsc$l_pos is relative */
	long		dsc$l_pos;	/* bit position relative to dsc$a_base of first bit in string */
	long		dsc$l_ubsb_l1;	/* lower bound */
	long		dsc$l_ubsb_u1;	/* upper bound */
};


/*
 *	Codes for dsc$b_dtype:
 */

/*
 *	Atomic data types:
 */
#define DSC$K_DTYPE_Z	0		/* unspecified */
#define DSC$K_DTYPE_BU	2		/* byte (unsigned);  8-bit unsigned quantity */
#define DSC$K_DTYPE_WU	3		/* word (unsigned);  16-bit unsigned quantity */
#define DSC$K_DTYPE_LU	4		/* longword (unsigned);  32-bit unsigned quantity */
#define DSC$K_DTYPE_QU	5		/* quadword (unsigned);  64-bit unsigned quantity */
#define DSC$K_DTYPE_OU	25		/* octaword (unsigned);  128-bit unsigned quantity */
#define DSC$K_DTYPE_B	6		/* byte integer (signed);  8-bit signed 2's-complement integer */
#define DSC$K_DTYPE_W	7		/* word integer (signed);  16-bit signed 2's-complement integer */
#define DSC$K_DTYPE_L	8		/* longword integer (signed);  32-bit signed 2's-complement integer */
#define DSC$K_DTYPE_Q	9		/* quadword integer (signed);  64-bit signed 2's-complement integer */
#define DSC$K_DTYPE_O	26		/* octaword integer (signed);  128-bit signed 2's-complement integer */
#define DSC$K_DTYPE_F	10		/* F_floating;  32-bit single-precision floating point */
#define DSC$K_DTYPE_D	11		/* D_floating;  64-bit double-precision floating point */
#define DSC$K_DTYPE_G	27		/* G_floating;  64-bit double-precision floating point */
#define DSC$K_DTYPE_H	28		/* H_floating;  128-bit quadruple-precision floating point */
#define DSC$K_DTYPE_FC	12		/* F_floating complex */
#define DSC$K_DTYPE_DC	13		/* D_floating complex */
#define DSC$K_DTYPE_GC	29		/* G_floating complex */
#define DSC$K_DTYPE_HC	30		/* H_floating complex */
#define DSC$K_DTYPE_CIT	31		/* COBOL Intermediate Temporary */
/*
 *	String data types:
 */
#define DSC$K_DTYPE_T	14		/* character string;  a single 8-bit character or a sequence of characters */
#define DSC$K_DTYPE_VT	37		/* varying character string;  16-bit count, followed by a string */
#define DSC$K_DTYPE_NU	15		/* numeric string, unsigned */
#define DSC$K_DTYPE_NL	16		/* numeric string, left separate sign */
#define DSC$K_DTYPE_NLO	17		/* numeric string, left overpunched sign */
#define DSC$K_DTYPE_NR	18		/* numeric string, right separate sign */
#define DSC$K_DTYPE_NRO	19		/* numeric string, right overpunched sign */
#define DSC$K_DTYPE_NZ	20		/* numeric string, zoned sign */
#define DSC$K_DTYPE_P	21		/* packed decimal string */
#define DSC$K_DTYPE_V	1		/* aligned bit string */
#define DSC$K_DTYPE_VU	34		/* unaligned bit string */
/*
 *	Miscellaneous data types:
 */
#define DSC$K_DTYPE_ZI	22		/* sequence of instructions */
#define DSC$K_DTYPE_ZEM	23		/* procedure entry mask */
#define DSC$K_DTYPE_DSC	24		/* descriptor */
#define DSC$K_DTYPE_BPV	32		/* bound procedure value */
#define DSC$K_DTYPE_BLV	33		/* bound label value */
#define DSC$K_DTYPE_ADT	35		/* absolute date and time */
/*
 *	Reserved data type codes:
 *	codes 38-191 are reserved to DIGITAL;
 *	codes 160-191 are reserved to DIGITAL facilities for facility-specific purposes;
 *	codes 192-255 are reserved for DIGITAL's Computer Special Systems Group
 *	  and for customers for their own use.
 */


/*
 *	Codes for dsc$b_class:
 */
#define DSC$K_CLASS_S	1		/* fixed-length descriptor */
#define DSC$K_CLASS_D	2		/* dynamic string descriptor */
/*	DSC$K_CLASS_V			** variable buffer descriptor;  reserved for use by DIGITAL */
#define DSC$K_CLASS_A	4		/* array descriptor */
#define DSC$K_CLASS_P	5		/* procedure descriptor */
/*	DSC$K_CLASS_PI			** procedure incarnation descriptor;  obsolete */
/*	DSC$K_CLASS_J			** label descriptor;  reserved for use by the VMS Debugger */
/*	DSC$K_CLASS_JI			** label incarnation descriptor;  obsolete */
#define DSC$K_CLASS_SD	9		/* decimal string descriptor */
#define DSC$K_CLASS_NCA	10		/* noncontiguous array descriptor */
#define DSC$K_CLASS_VS	11		/* varying string descriptor */
#define DSC$K_CLASS_VSA	12		/* varying string array descriptor */
#define DSC$K_CLASS_UBS	13		/* unaligned bit string descriptor */
#define DSC$K_CLASS_UBA	14		/* unaligned bit array descriptor */
#define DSC$K_CLASS_SB	15		/* string with bounds descriptor */
#define DSC$K_CLASS_UBSB 16		/* unaligned bit string with bounds descriptor */
/*
 *	Reserved descriptor class codes:
 *	codes 15-191 are reserved to DIGITAL;
 *	codes 160-191 are reserved to DIGITAL facilities for facility-specific purposes;
 *	codes 192-255 are reserved for DIGITAL's Computer Special Systems Group
 *	  and for customers for their own use.
 */


/*
 *	A simple macro to construct a string descriptor:
 */
#define $DESCRIPTOR(name,string)	struct dsc$descriptor_s name = { sizeof(string)-1, DSC$K_DTYPE_T, DSC$K_CLASS_S, string }

#endif					/* __DESCRIP_LOADED */
#ifndef __DEVDEF_LOADED
#define __DEVDEF_LOADED	1

/*** MODULE $devdef ***/
/*                                                                          */
/*  THE FOLLOWING BITS DEFINE THE DEVICE CHARACTERISTICS FOR                */
/*  BOTH THE UCBS AND RMS.                                                  */
/*                                                                          */
#define DEV$M_REC 1
#define DEV$M_CCL 2
#define DEV$M_TRM 4
#define DEV$M_DIR 8
#define DEV$M_SDI 16
#define DEV$M_SQD 32
#define DEV$M_SPL 64
#define DEV$M_OPR 128
#define DEV$M_RCT 256
#define DEV$M_NET 8192
#define DEV$M_FOD 16384
#define DEV$M_DUA 32768
#define DEV$M_SHR 65536
#define DEV$M_GEN 131072
#define DEV$M_AVL 262144
#define DEV$M_MNT 524288
#define DEV$M_MBX 1048576
#define DEV$M_DMT 2097152
#define DEV$M_ELG 4194304
#define DEV$M_ALL 8388608
#define DEV$M_FOR 16777216
#define DEV$M_SWL 33554432
#define DEV$M_IDV 67108864
#define DEV$M_ODV 134217728
#define DEV$M_RND 268435456
#define DEV$M_RTM 536870912
#define DEV$M_RCK 1073741824
#define DEV$M_WCK -2147483648
#define DEV$M_CLU 1
#define DEV$M_DET 2
#define DEV$M_RTT 4
#define DEV$M_CDP 8
#define DEV$M_2P 16
#define DEV$M_MSCP 32
#define DEV$M_SSM 64
#define DEV$M_SRV 128
#define DEV$M_RED 256
#define DEV$M_NNM 512
#define DEV$M_WBC 1024
#define DEV$M_WTC 2048
#define DEV$M_HOC 4096
#define DEV$M_LOC 8192
#pragma nostandard
union devdef {
    variant_struct  {
        unsigned dev$v_rec : 1;         /* DEVICE RECORD ORIENTED           */
        unsigned dev$v_ccl : 1;         /* CARRIAGE CONTROL DEVICE          */
        unsigned dev$v_trm : 1;         /* DEVICE IS A TERMINAL             */
        unsigned dev$v_dir : 1;         /* DEVICE IS DIRECTORY STRUCTURED   */
        unsigned dev$v_sdi : 1;         /* DEVICE IS SINGLE DIRECTORY STRUCTURED  */
        unsigned dev$v_sqd : 1;         /* SEQUENTIAL BLOCK-ORIENTED DEVICE (I.E., MAGTAPE)  */
        unsigned dev$v_spl : 1;         /* DEVICE BEING SPOOLED             */
        unsigned dev$v_opr : 1;         /* DEVICE IS AN OPERATOR            */
        unsigned dev$v_rct : 1;         /* DISK CONTAINS RCT (DEC STANDARD 166 DISK)  */
        unsigned devdef$$_fill_1 : 4;   /* SPARES TO CORRESPOND WITH RSX11M  */
        unsigned dev$v_net : 1;         /* NETWORK DEVICE                   */
        unsigned dev$v_fod : 1;         /* FILES-ORIENTED DEVICE (I.E., DISK AND MT)  */
        unsigned dev$v_dua : 1;         /* DEVICE IS DUAL PORTED            */
        unsigned dev$v_shr : 1;         /* DEVICE SHAREABLE                 */
        unsigned dev$v_gen : 1;         /* DEVICE IS A GENERIC DEVICE       */
        unsigned dev$v_avl : 1;         /* DEVICE AVAILABLE FOR USE         */
        unsigned dev$v_mnt : 1;         /* DEVICE IS MOUNTED                */
        unsigned dev$v_mbx : 1;         /* DEVICE IS A MAILBOX              */
        unsigned dev$v_dmt : 1;         /* DEVICE MARKED FOR DISMOUNT       */
        unsigned dev$v_elg : 1;         /* DEVICE HAS ERROR LOGGING ENABLED  */
        unsigned dev$v_all : 1;         /* DEVICE IS ALLOCATED              */
        unsigned dev$v_for : 1;         /* DEVICE IS MOUNTED FOREIGN (I.E., NON-FILE STRUCTURED)  */
        unsigned dev$v_swl : 1;         /* DEVICE IS SOFTWARE WRITE LOCKED  */
        unsigned dev$v_idv : 1;         /* DEVICE CAPABLE OF PROVIDING INPUT  */
        unsigned dev$v_odv : 1;         /* DEVICE CAPABLE OF PROVIDING OUTPUT  */
        unsigned dev$v_rnd : 1;         /* DEVICE ALLOWS RANDOM ACCESS      */
        unsigned dev$v_rtm : 1;         /* DEVICE IS REALTIME IN NATURE     */
        unsigned dev$v_rck : 1;         /* DEVICE HAS READ CHECKING ENABLED  */
        unsigned dev$v_wck : 1;         /* DEVICE HAS WRITE CHECKING ENABLED  */
        } dev$r_devdef_bits0;
    variant_struct  {
        unsigned dev$v_clu : 1;         /* DEVICE IS AVAILABLE CLUSTER-WIDE */
        unsigned dev$v_det : 1;         /* DEVICE IS DETACHED TERMINAL      */
        unsigned dev$v_rtt : 1;         /* DEVICE HAS REMOTE TERMINAL UCB EXTENSION */
        unsigned dev$v_cdp : 1;         /* DUAL PATH DEVICE WITH 2 UCBs     */
        unsigned dev$v_2p : 1;          /* TWO PATHS ARE KNOWN TO THIS DEVICE */
        unsigned dev$v_mscp : 1;        /* DEVICE ACCESSED USING MSCP (disk or tape) */
        unsigned dev$v_ssm : 1;         /* DEVICE IS A SHADOW SET MEMBER    */
        unsigned dev$v_srv : 1;         /* DEVICE IS SERVED VIA THE MSCP SERVER */
        unsigned dev$v_red : 1;         /* DEVICE IS redirected terminal    */
        unsigned dev$v_nnm : 1;         /* DEVICE HAS "node$" PREFIX        */
        unsigned dev$v_wbc : 1;         /* DEVICE SUPPORTS WRITE-BACK CACHING */
        unsigned dev$v_wtc : 1;         /* DEVICE SUPPORTS WRITE-THROUGH CACHING */
        unsigned dev$v_hoc : 1;         /* DEVICE SUPPORTS HOST CACHING     */
        unsigned dev$v_loc : 1;         /* DEVICE ACCESSIBLE VIA LOCAL (NON-EMULATED) CONTROLLER */
        unsigned dev$v_fill_27 : 2;
        } dev$r_devdef_bits1;
    } ;
#pragma standard

#endif					/* __DEVDEF_LOADED */
#ifndef __DIBDEF_LOADED
#define __DIBDEF_LOADED	1

/*** MODULE $dibdef ***/
/*+                                                                         */
/* DEVICE INFORMATION BLOCK DEFINITIONS                                     */
/*-                                                                         */
#define DIB$K_LENGTH 116                /*LENGTH OF TOTAL BUFFER            */
#define DIB$C_LENGTH 116                /*LENGTH OF TOTAL BUFFER            */
#pragma nostandard
struct dibdef {
    unsigned long int dib$l_devchar;    /*DEVICE CHARACTERISTICS            */
    unsigned char dib$b_devclass;       /*DEVICE CLASS                      */
    unsigned char dib$b_devtype;        /*DEVICE TYPE                       */
    unsigned short int dib$w_devbufsiz; /*DEVICE BUFFER SIZE                */
    variant_union  {
        unsigned long int dib$l_devdepend; /*DEVICE DEPENDENT INFORMATION   */
        variant_struct  {
            unsigned char dib$b_sectors; /*(DISK ONLY) SECTORS PER TRACK    */
            unsigned char dib$b_tracks; /* " TRACKS PER CYLINDER            */
            unsigned short int dib$w_cylinders; /* " NUMBER OF CYLINDERS    */
            } dib$r_devdepend_fields;
        } dib$r_devdepend_overlay;
    unsigned short int dib$w_unit;      /*DEVICE UNIT NUMBER                */
    unsigned short int dib$w_devnamoff; /*OFFSET TO DEVICE NAME COUNTED STRING  */
    unsigned long int dib$l_pid;        /*DEVICE OWNER PROCESS IDENTIFICATION  */
    unsigned long int dib$l_ownuic;     /*DEVICE OWNER USER IDENTIFICATION CODE  */
    unsigned short int dib$w_vprot;     /*DEVICE PROTECTION MASK            */
    unsigned short int dib$w_errcnt;    /*DEVICE ERROR COUNT                */
    unsigned long int dib$l_opcnt;      /*DEVICE OPERATIONS COUNT           */
    unsigned short int dib$w_volnamoff; /*OFFSET TO VOLUME LABEL COUNTED STRING  */
    unsigned short int dib$w_recsiz;    /*BLOCKED RECORD SIZE               */
    char dib$t_devname [76];            /*SPACE FOR DEVNAME AND LABEL (64+12)  */
    unsigned long int dib$l_maxblock;   /*DISK VOLUME SIZE IN BLOCKS        */
    } ;
#pragma standard

#endif					/* __DIBDEF_LOADED */
#ifndef __DMPDEF_LOADED
#define __DMPDEF_LOADED	1

/*** MODULE $dmpdef ***/
/*                                                                          */
/* LAYOUT OF THE HEADER BLOCK OF THE SYSTEM DUMP FILE                       */
/* (WHICH IS THE FIRST DISK BLOCK OF SYS$SYSTEM:SYSDUMP.DMP)                */
/*                                                                          */
#define DMP$M_OLDDUMP 1
#define DMP$M_EMPTY 2
#define DMP$M_HDRBLK 4
#define DMP$M_ERRLOG 8
#define DMP$M_MEMORY 16
#define DMP$M_SPT 32
#define DMP$M_WRITECOMP 64
#define DMP$M_ERRLOGCOMP 128
#define DMP$M_DUMP_STYLE 3840
#define DMP$K_FULL_DUMP 0               /* FULL PHYSICAL MEMORY DUMP (OLD WAY) */
#define DMP$K_SUBSET_DUMP 1             /* SUBSETTED DUMP FILE (NOT ALL INFO SAVED) */
#define DMP$C_DUMP_LUMP 127             /* NUMBER OF SPTES REQUIRED FOR SUBSET DUMPS */
#define DMP$C_MEMDSCSIZ 8               /* SIZE OF ONE MEMORY DESCRIPTOR    */
#define DMP$C_NMEMDSC 8                 /* NUMBER OF MEMORY DESCRIPTORS     */
#define DMP$K_DUMPVER 1280              /* DUMP FILE VERSION NUMBER         */
#define DMP$K_LENGTH 132                /* LENGTH OF FILE HEADER            */
#define DMP$C_LENGTH 132                /* LENGTH OF FILE HEADER            */
#pragma nostandard
struct dmpdef {
    unsigned long int dmp$l_errseq;     /* LAST ERROR LOG SEQ. NUMBER       */
    variant_union  {
        unsigned long int dmp$l_flags;  /* DUMP FILE FLAGS                  */
        variant_struct  {
            unsigned dmp$v_olddump : 1; /* SET IF DUMP ALREADY ANALYZED     */
            unsigned dmp$v_empty : 1;   /* SET IF DUMP HAS NO DATA BLOCKS   */
            unsigned dmp$v_hdrblk : 1;  /* SET IF ERROR WRITING FIRST BLOCK OF DUMP HEADER */
            unsigned dmp$v_errlog : 1;  /* SET IF ERROR WRITING BLOCKS 2-3 OF DUMP HEADER */
            unsigned dmp$v_memory : 1;  /* SET IF ERROR WRITING MEMORY CONTENTS TO DUMP FILE */
            unsigned dmp$v_spt : 1;     /* SET IF ERROR WRITING SYSTEM PAGE TABLE BLOCKS TO DUMP FILE */
            unsigned dmp$v_writecomp : 1; /* SET IF DUMP WRITE WAS COMPLETED */
            unsigned dmp$v_errlogcomp : 1; /* SET IF HEADER/ERROR LOGS WRITE WAS COMPLETED */
            unsigned dmp$v_dump_style : 4; /* SET TO DIFFERENTIATE BETWEEN DIFFERENT STYLE DUMPS */
            unsigned dmp$v_fill_28 : 4;
            } dmp$r_flags_bits;
/* DUMP_STYLE BITFIELD SETTINGS                                             */
        } dmp$r_flags_overlay;
    unsigned long int dmp$l_sbr;        /* SYSTEM BASE REGISTER             */
    unsigned long int dmp$l_slr;        /* SYSTEM LENGTH REGISTER           */
    unsigned long int dmp$l_ksp;        /* KERNEL STACK POINTER             */
    unsigned long int dmp$l_esp;        /* EXECUTIVE STACK POINTER          */
    unsigned long int dmp$l_ssp;        /* SUPERVISOR STACK POINTER         */
    unsigned long int dmp$l_usp;        /* USER STACK POINTER               */
    unsigned long int dmp$l_isp;        /* INTERRUPT STACK POINTER          */
    variant_union  {
        unsigned long int dmp$l_memory_desc_space [16]; /* RESERVE SPACE FOR 8 MEMORY DESCRIPTORS (2 LONGWORDS EACH) */
        variant_union  {
            unsigned long int dmp$l_memdsc; /* 8 MEMORY DESCRIPTORS         */
            variant_struct  {
                unsigned dmp$v_pagcnt : 24; /* NUMBER OF PAGES IN MEMORY    */
                unsigned dmp$v_tr : 8;  /* TR NUMBER FOR MEMORY             */
                unsigned dmp$v_basepfn : 32; /* BASE PFN FOR MEMORY         */
                } dmp$r_memdsc_bits;
            } dmp$r_memdsc_overlay;
        } dmp$r_memory_desc;
    unsigned long int dmp$l_sysver;     /* SYSTEM VERSION NUMBER            */
    unsigned long int dmp$l_check;      /* ONES COMPLEMENT OF SYSVER        */
    unsigned short int dmp$w_dumpver;   /* DUMP FILE VERSION NUMBER         */
    unsigned short int dmp$w_erlbufcnt; /* NUMBER OF ERROR LOG BUFFERS      */
    unsigned short int dmp$w_erlbufhead; /* RING BUFFER HEAD INDEX          */
    unsigned short int dmp$w_erlbuftail; /* RING BUFFER TAIL INDEX          */
    unsigned long int dmp$l_errstatus;  /* LAST ERROR STATUS FROM DUMP WRITE */
    unsigned long int dmp$l_dumperrs;   /* COUNT OF ERRORS DURING DUMP WRITE */
    unsigned long int dmp$l_mempagcnt;  /* COUNT OF MEMORY PAGES DUMPED     */
    unsigned long int dmp$l_saveprccnt; /* COUNT OF SAVED PROCESSES (SUBSET DUMP) */
    unsigned long int dmp$l_crasherl;   /* SYSTEM CRASH ERR LOG ENTRY       */
    } ;
#pragma standard

#endif					/* __DMPDEF_LOADED */
#ifndef __DMTDEF_LOADED
#define __DMTDEF_LOADED	1

/*** MODULE $dmtdef ***/
/*                                                                          */
/* FLAG BITS FOR THE $DISMOU (DISMOUNT) SYSTEM SERVICE.                     */
/*                                                                          */
#define DMT$M_NOUNLOAD 1
#define DMT$M_UNIT 2
#define DMT$M_ABORT 4
#define DMT$M_CLUSTER 8
#pragma nostandard
union dmtdef {
    variant_struct  {
        unsigned dmt$v_nounload : 1;    /* DO NOT UNLOAD (SPIN DOWN) THE VOLUME  */
        unsigned dmt$v_unit : 1;        /* DISMOUNT ONLY THE SPECIFIED VOLUME  */
        unsigned dmt$v_abort : 1;       /* FORCED DISMOUNT	            */
        unsigned dmt$v_cluster : 1;     /* CLUSTER-WIDE DISMOUNT            */
        unsigned dmt$v_fill_29 : 4;
        } dmt$r_dmtdef_bits;
    } ;
#pragma standard

#endif					/* __DMTDEF_LOADED */
/********************************************************************************************************************************/
/* Created  7-JUL-1992 19:57:36 by VAX SDL T3.2-8      Source: 21-JAN-1992 18:56:52 _$22$DIA9:[DNS.SRC]DNSDEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE dns IDENT X-6 ***/
/*                                                                          */
/*                                                                          */
/************************************************************************** */
/*                         Copyright (C) 1987 by                          * */
/*              DIGITAL Equipment Corporation, Maynard, Mass.             * */
/*                                                                        * */
/* This software is furnished under a license and may be used and  copied * */
/* only  in  accordance  with  the  terms  of  such  license and with the * */
/* inclusion of the above copyright notice.  This software or  any  other * */
/* copies  thereof may not be provided or otherwise made available to any * */
/* other person.  No title to or  ownership of  the  software  is  hereby * */
/* transferred.                                                           * */
/*                                                                        * */
/* The information in this software is subject to change  without  notice * */
/* and  should  not  be  construed  as  a commitment by DIGITAL Equipment * */
/* Corporation.                                                           * */
/*                                                                        * */
/* DIGITAL assumes no responsibility for the use or  reliability  of  its * */
/* software on equipment which is not supplied by DIGITAL.                * */
/*                                                                        * */
/************************************************************************** */
/*                                                                          */
/*                                                                          */
/* FACILITY:	VMS Clerk for DNA Naming Service                            */
/*                                                                          */
/* ABSTRACT:	VMSclerk User accessible data structures                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*	Architectural Constants                                             */
/*                                                                          */
#define dns$k_simplestrmax 255          /* max size simple name string      */
#define dns$k_fullstrmax 512            /* max size full name string        */
#define dns$k_simplenamemax 257         /* max size of opaque simple name   */
#define dns$k_fullnamemax 402           /* max size of opaqaue full name    */
#define dns$k_classsize 31              /* max size of class name length    */
#define dns$k_maxattribute 4000         /* longest attribute member         */
#define dns$k_present 1                 /* Attr. Value is present           */
#define dns$k_absent 0                  /* Attr. Value is not present       */
#define dns$k_timeout_size 16           /* size of timeout opaque struct    */
#define dns$k_uid_length 14             /* size of DNS UIDs                 */
/*                                                                          */
/*	Function codes for $DNS service                                     */
/*                                                                          */
/*                                                                          */
#define dns$_enumerate_attributes 1
#define dns$_read_attribute 2
#define dns$_test_attribute 4
#define dns$_create_object 5
#define dns$_enumerate_objects 6
#define dns$_delete_object 7
#define dns$_create_directory 8
#define dns$_delete_directory 9
#define dns$_add_replica 10
#define dns$_remove_replica 11
#define dns$_enumerate_children 12
#define dns$_skulk 13
#define dns$_create_link 14
#define dns$_remove_link 15
#define dns$_delete_link 15
#define dns$_resolve_name 16
#define dns$_test_group 17
#define dns$_create_child_entry 18
#define dns$_enumerate_softlinks 19
#define dns$_delete_child_entry 20
#define dns$_read_replica 21
#define dns$_modify_replica 22
#define dns$_link_replica 23
#define dns$_combine 24
#define dns$_do_update 25
#define dns$_modify_attribute 30
#define dns$_parse_fullname_string 31
#define dns$_full_opaque_to_string 32
#define dns$_parse_simplename_string 33
#define dns$_simple_opaque_to_string 34
#define dns$_func_limit 35
/*                                                                          */
/*   Item list entries for parameters to the various Clerk calls            */
/*                                                                          */
#define dns$_attributename 3
#define dns$_class 9
#define dns$_classfilter 11
#define dns$_clearinghouse 13
#define dns$_conf 14
#define dns$_contextvarname 16
#define dns$_contextvartime 17
#define dns$_directory 19
#define dns$_entry 22
#define dns$_fromexternalname 24
#define dns$_fromfullname 25
#define dns$_fromsimplename 26
#define dns$_group 28
#define dns$_inoutdirect 29
#define dns$_linkname 31
#define dns$_lookingfor 32
#define dns$_maybemore 34
#define dns$_member 36
#define dns$_objectname 40
#define dns$_outattributeset 43
#define dns$_outchildren 45
#define dns$_outobjects 48
#define dns$_outvalues 50
#define dns$_outsoftlinks 53
#define dns$_targetname 58
#define dns$_timeout 59
#define dns$_toexternalname 60
#define dns$_tofullname 61
#define dns$_tosimplename 62
#define dns$_outname 64
#define dns$_outuid 65
#define dns$_value 68
#define dns$_version 69
#define dns$_wait 70
#define dns$_wildcard 72
#define dns$_modoperation 73
#define dns$_modvalue 74
#define dns$_attributetype 76
#define dns$_tostringname 77
#define dns$_fromstringname 78
#define dns$_nextchar_ptr 79
#define dns$_suppress_nsname 80
#define dns$_outvalset 81
#define dns$_param_limit 82
/*                                                                          */
/*	Definitions of confidence level parameter                           */
/*                                                                          */
#define dns$k_low 1                     /*                                  */
#define dns$k_medium 2                  /*                                  */
#define dns$k_high 3                    /*                                  */
/*                                                                          */
/*	Definitions of attribute types                                      */
/*                                                                          */
#define dns$k_single 2                  /* Single valued attribute          */
#define dns$k_set 3                     /* Set attribute                    */
/*                                                                          */
/*	Definitions of entry type for LookingFor parameter                  */
/*                                                                          */
#define dns$k_directory 1               /*                                  */
#define dns$k_object 2                  /*                                  */
#define dns$k_childdirectory 3          /*                                  */
#define dns$k_softlink 4                /*                                  */
#define dns$k_clearinghouse 5           /*                                  */
/*                                                                          */
/*	CLASSVERSION - DNS Class version structure                          */
/*                                                                          */
/*	Used by the create object call to indicate object version number.   */
/*	MAJOR_NUMBER.MINOR_NUMBER                                           */
/*	                                                                    */
/*                                                                          */
struct $dnscversdef {
    unsigned char dns$b_c_major;        /* Major number of class            */
    unsigned char dns$b_c_minor;        /* Minor number of class            */
    } ;
/*                                                                          */
/*	GRPMEM - DNS GroupMember structure                                  */
/*                                                                          */
/*	Used in the DNS$Members attribute of a group object to denote       */
/*	group membership.                                                   */
/*	                                                                    */
/*                                                                          */
#define dns$k_grpmem_not_group 0        /* member is not a group            */
#define dns$k_grpmem_is_group 1         /* member is a group                */
/*                                                                          */
struct $dnsgrpmemdef {
    unsigned char dns$b_grpmem_type;    /* indicates whether member is itself a group */
    char dns$a_grpmem_member [];        /* FullName of group member         */
    } ;
/*                                                                          */
/*	ATTRSPEC DNS attribute specifier structure.                         */
/*	Structure of values returned by the Enumerate_Attributes call.      */
/*                                                                          */
#define dns$k_spec_fixed 1              /* Length of fixed portion          */
struct $dnsattrspecdef {
    unsigned char dns$b_spec_flag;      /* type of attribute dns$k_single   */
/* or dns$k_set                                                             */
    char dns$a_spec_name [];            /* simplename of attribute          */
    } ;
/*                                                                          */
/*   itm - Generic item list entry                                          */
/*                                                                          */
#define dns$k_itm_length 12
struct $dnsitmdef {
    unsigned short int dns$w_itm_size;  /* Length in bytes of item          */
    unsigned short int dns$w_itm_code;  /* Item code                        */
    unsigned long int dns$a_itm_address; /* Address of item value           */
    unsigned long int dns$a_itm_ret_length; /* Address to return word length */
    } ;
/*                                                                          */
/* DNS request status block                                                 */
/*                                                                          */
struct $dnsb {
    unsigned long int dns$l_dnsb_status; /* DNSB completion status          */
    unsigned dns$v_dnsb_inoutdirect : 1; /*                                 */
    unsigned dns$v_dnsb_outlinked : 1;  /*                                  */
    unsigned dns$v_dnsb_filler : 30;
    } ;
/********************************************************************************************************************************/
/* Created 11-OCT-1991 19:49:59 by VAX SDL T3.2-8      Source: 11-OCT-1991 19:49:02 _$254$DUA99:[DNS.SRC]DNSMSG.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE DNS ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on 11-OCT-1991 19:49:04.41 */
/*                                                                          */
/*                                                                          */
/*************************************************************************** */
/**                         COPYRIGHT (C) 1986 BY                          * */
/**              DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.             * */
/**                                                                        * */
/** THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED * */
/** ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE * */
/** INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER * */
/** COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY * */
/** OTHER PERSON.  NO TITLE TO OR  OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY * */
/** TRANSFERRED.                                                           * */
/**                                                                        * */
/** THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE * */
/** AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT * */
/** CORPORATION.                                                           * */
/**                                                                        * */
/** DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS * */
/** SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                * */
/**                                                                        * */
/*************************************************************************** */
/*++                                                                        */
/* FACILITY:                                                                */
/*                                                                          */
/*   VMS CLERK FOR DNA NAMING SERVICE                                       */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*   STATUS CODES FOR DNS CLERK                                             */
/*                                                                          */
/*--                                                                        */
#define DNS$_FACILITY 478
#define DNS$_MOREDATA 31361377
#define DNS$_TRUE 31361385
#define DNS$_FALSE 31361393
#define DNS$_LINKED 31361401
#define DNS$_NOMOREDATA 31361409
/*                                                                          */
/*   ARCHITECTED ERRORS FROM THE TA                                         */
/*                                                                          */
#define DNS$_NAMESERVERERRORS 31358978
#define DNS$_INVALIDARGUMENT 31358986
#define DNS$_INVALIDNAME 31358994
#define DNS$_NONSRESOURCES 31359002
#define DNS$_NOCOMMUNICATION 31359010
#define DNS$_ACCESSDENIED 31359018
#define DNS$_CANNOTAUTHENTICATE 31359026
#define DNS$_CONFLICTINGARGUMENTS 31359034
#define DNS$_TIMEOUTNOTDONE 31359042
#define DNS$_TIMEOUTMAYBEDONE 31359050
#define DNS$_RESERVED 31359058
#define DNS$_ENTRYEXISTS 31359066
#define DNS$_UNKNOWNENTRY 31359074
#define DNS$_NOTSUPPORTED 31359082
#define DNS$_NOTIMPLEMENTED 31359090
#define DNS$_INVALIDUPDATE 31359098
#define DNS$_UNKNOWNCLEARINGHOUSE 31359106
#define DNS$_NOTAREPLICA 31359114
#define DNS$_ALREADYREPLICA 31359122
#define DNS$_CRUCIALREPLICA 31359130
#define DNS$_NOTEMPTY 31359138
#define DNS$_NOTLINKED 31359146
#define DNS$_POSSIBLECYCLE 31359154
#define DNS$_DANGLINGLINK 31359162
#define DNS$_NOTAGROUP 31359170
#define DNS$_CLEARINGHOUSEDOWN 31359178
#define DNS$_BADEPOCH 31359186
#define DNS$_BADCLOCK 31359194
#define DNS$_DATACORRUPTION 31359202
#define DNS$_WRONGATTRIBUTETYPE 31359210
#define DNS$_MORETHANONEREPLICA 31359218
#define DNS$_CANTPUTHERE 31359226
#define DNS$_OLDSKULK 31359234
#define DNS$_UNTRUSTEDCH 31359242
#define DNS$_NOTNAMESERVER 31359778
#define DNS$_WRONGSTATE 31359786
#define DNS$_BADNSNAME 31359794
#define DNS$_LOCALONLY 31359802
#define DNS$_NOTROOT 31359810
#define DNS$_NOTCHDIRECTORY 31359818
#define DNS$_ROOTLOST 31359826
/*                                                                          */
/*   CLERK GENERATED ERRORS                                                 */
/*                                                                          */
#define DNS$_ACCESSVIOLATION 31360578
#define DNS$_RESOURCEERROR 31360586
#define DNS$_INVALIDFUNCTION 31360594
#define DNS$_INVALIDITEM 31360602
#define DNS$_BADITEMBUFFER 31360610
#define DNS$_MISSINGITEM 31360618
#define DNS$_NOCACHE 31360626
#define DNS$_NONSNAME 31360634
#define DNS$_CACHELOCKED 31360642
#define DNS$_INVALID_DIRECTORYNAME 31360650
#define DNS$_INVALID_CLEARINGHOUSENAME 31360658
#define DNS$_INVALID_LINKNAME 31360666
#define DNS$_INVALID_TARGETNAME 31360674
#define DNS$_INVALID_OBJECTNAME 31360682
#define DNS$_INVALID_CLASSNAME 31360690
#define DNS$_INVALID_ENTRYNAME 31360698
#define DNS$_INVALID_CONTEXTNAME 31360706
#define DNS$_INVALID_WILDCARDNAME 31360714
#define DNS$_INVALID_GROUPNAME 31360722
#define DNS$_INVALID_MEMBERNAME 31360730
#define DNS$_INVALID_ATTRIBUTENAME 31360738
#define DNS$_INVALID_NSNAME 31360746
#define DNS$_LOGICAL_ERROR 31360754
/*                                                                          */
/*   NON ARCHITECTED NAMESERVER ERRORS                                      */
/*                                                                          */
#define DNS$_ABSENT 31362178
#define DNS$_CANCELLED 31362186
#define DNS$_CANTREADUIC 31362194
#define DNS$_CANTSTARTBACK 31362202
#define DNS$_CANTSTARTTA 31362210
#define DNS$_DEFAULTFORMAT 31362218
#define DNS$_GBLSECERROR 31362226
#define DNS$_NOETHERNET 31362234
#define DNS$_NOTFOUND 31362242
#define DNS$_NOUPDATES 31362250
#define DNS$_SOLICITMBXFORMAT 31362258
#define DNS$_ADFORMAT 31362266
#define DNS$_CANTCOMMADVER 31362274
/*                                                                          */
/*   INTERNAL PROGRAM ERRORS                                                */
/*                                                                          */
#define DNS$_CLERKBUG 31366962
#define DNS$_NAMESERVERBUG 31366970
#ifndef __DSTDEF_LOADED
#define __DSTDEF_LOADED	1

/*** MODULE $dstdef ***/
/* Use a K to indicate constant                                             */
#define DST$K_LOCOMMAND 0               /* Low value for range checking     */
#define DST$K_STA_R00 0                 /* Stack contents of R0             */
#define DST$K_STA_R01 1                 /* Stack contents of R1             */
#define DST$K_STA_R02 2                 /* Stack contents of R2             */
#define DST$K_STA_R03 3                 /* Stack contents of R3             */
#define DST$K_STA_R04 4                 /* Stack contents of R4             */
#define DST$K_STA_R05 5                 /* Stack contents of R5             */
#define DST$K_STA_R06 6                 /* Stack contents of R6             */
#define DST$K_STA_R07 7                 /* Stack contents of R7             */
#define DST$K_STA_R08 8                 /* Stack contents of R8             */
#define DST$K_STA_R09 9                 /* Stack contents of R9             */
#define DST$K_STA_R10 10                /* Stack contents of R10            */
#define DST$K_STA_R11 11                /* Stack contents of R11            */
#define DST$K_STA_R12 12                /* Stack contents of R12 (AP)       */
#define DST$K_STA_R13 13                /* Stack contents of R13 (FP)       */
#define DST$K_STA_R14 14                /* Stack contents of R14 (SP)       */
#define DST$K_STA_R15 15                /* Stack contents of R15 (PC)       */
#define DST$K_STA_IMM_B 16              /* Stack contents of byte operand   */
/*    sign extending to longword                                            */
#define DST$K_STA_IMM_W 17              /* Stack contents of word operand   */
/*    sign extending to longword                                            */
#define DST$K_STA_IMM_L 18              /* Stack contents of longword operand  */
#define DST$K_OPR_ADD 19                /* Pop two operands, add ,          */
/*    stack longword result                                                 */
#define DST$K_STA_REP_B 20              /* Pop top item and stack sign extended  */
/*    byte at that address                                                  */
#define DST$K_STA_REP_W 21              /* Pop top item and stack sign extended  */
/*    word at that address                                                  */
#define DST$K_STA_REP_L 22              /* Pop top item and stack longword at  */
/*    that address                                                          */
#define DST$K_OPR_STOP 23               /* Terminate command string. Longword  */
/*    at top of stack contains address                                      */
/*    of data item.                                                         */
#define DST$K_HICOMMAND 23              /* Hi value for range checking      */

#endif					/* __DSTDEF_LOADED */
/********************************************************************************************************************************/
/* Created 25-MAY-1990 18:35:07 by VAX SDL V3.2-10     Source: 28-NOV-1989 21:01:29 DECW$LIBSRESD:[DDIFLIB.SRC]DTIF$DEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE DTIF$DEFINITIONS IDENT V1-006 ***/
/*++                                                                        */
/*  COPYRIGHT (c) 1988, 1989 BY                                             */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.                  */
/*  ALL RIGHTS RESERVED.                                                    */
/*                                                                          */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   */
/*  ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   */
/*  OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY   */
/*  TRANSFERRED.                                                            */
/*                                                                          */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT   */
/*  CORPORATION.                                                            */
/*                                                                          */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 */
/*                                                                          */
/* Scope codes for the CDA$ENTER_SCOPE and CDA$LEAVE_SCOPE scope-code parameter. */
/* If an aggregate type is listed, it must be presented with CDA$ENTER_SCOPE. */
#define DTIF$K_DOCUMENT_SCOPE 512       /* Document scope                   */
#define DTIF$K_TABLE_SCOPE 513          /* Table scope			DTIF$_TBL */
#define DTIF$K_ROW_SCOPE 514            /* Row scope			DTIF$_ROW */
#define DTIF$K_CELLS_SCOPE 515          /* Cells scope                      */
/* Aggregate type codes for DTIF (Digital Table Interchange Format).        */
#define DTIF$_DTF 513                   /* DTIF document root               */
#define DTIF$_DSC 514                   /* Document descriptor              */
#define DTIF$_HDR 515                   /* Document header                  */
#define DTIF$_DAT 516                   /* Date and time                    */
#define DTIF$_ERF 517                   /* External reference               */
#define DTIF$_LPT 518                   /* Language preference table        */
#define DTIF$_NVL 519                   /* Named value                      */
#define DTIF$_NES 520                   /* Named edit string                */
#define DTIF$_CAT 521                   /* Column attributes                */
#define DTIF$_TBL 522                   /* Table definition                 */
#define DTIF$_TMD 523                   /* Table metadata                   */
#define DTIF$_WND 524                   /* Window definition                */
#define DTIF$_ROW 525                   /* Row definition                   */
#define DTIF$_CLD 526                   /* Cell data                        */
#define DTIF$_VTX 527                   /* Varying text                     */
#define DTIF$_ARD 528                   /* Array definition                 */
#define DTIF$_CFT 529                   /* Complex float                    */
#define DTIF$_FMI 530                   /* Format information               */
#define DTIF$_CCD 531                   /* Cell coordinates                 */
#define DTIF$_RNG 532                   /* Range definition                 */
#define DTIF$_CLR 533                   /* Cell range                       */
#define DTIF$_RWR 534                   /* Row range                        */
#define DTIF$_COR 535                   /* Column range                     */
#define DTIF$_NMR 536                   /* Named range                      */
#define DTIF$_EXT 537                   /* External                         */
#define DTIF$_MAX 538                   /* Maximum code plus 1              */
/* Item codes for all aggregates.  DTIF$_AGGREGATE_TYPE is read-only.       */
#define DTIF$_USER_CONTEXT 1            /* User context			Longword */
#define DTIF$_AGGREGATE_TYPE 2          /* Aggregate type code		Word */
#define DTIF$_ALL_MAX 3                 /* Maximum code plus 1              */
/* Item codes for DTIF Document Root aggregate.                             */
#define DTIF$_DTF_DESCRIPTOR 131329     /* Document descriptor		DTIF$_DSC */
#define DTIF$_DTF_HEADER 131330         /* Document header		DTIF$_HDR */
#define DTIF$_DTF_TABLES 131331         /* Tables			Sequence of DTIF$_TBL */
#define DTIF$_DTF_MAX 131332            /* Maximum code plus 1              */
/* Item codes for Document Descriptor aggregate.  During CDA$PUT_AGGREGATE, the values of DTIF$_DSC_ENCODE_MAJOR_VERSION and */
/* DTIF$_DSC_ENCODE_MINOR_VERSION are not used.  The document always contains the current values for major and minor version. */
#define DTIF$_DSC_MAJOR_VERSION 131585  /* Creator major version	Integer */
#define DTIF$_DSC_MINOR_VERSION 131586  /* Creator minor version	Integer */
#define DTIF$_DSC_PRODUCT_IDENTIFIER 131587 /* Product identifier		String */
#define DTIF$_DSC_PRODUCT_NAME 131588   /* Product name			Array of character string */
#define DTIF$_DSC_ENCODE_MAJOR_VERSION 131589 /* Encoding major version	Integer */
#define DTIF$_DSC_ENCODE_MINOR_VERSION 131590 /* Encoding minor version	Integer */
#define DTIF$_DSC_MAX 131591            /* Maximum code plus 1              */
/* Current values for major and minor encoding version.                     */
#define DTIF$K_MAJOR_VERSION 1
#define DTIF$K_MINOR_VERSION 0
/* Item codes for Document Header aggregate.                                */
#define DTIF$_HDR_PRIVATE_DATA 131841   /* Private header data		Sequence of DTIF$_NVL */
#define DTIF$_HDR_TITLE 131842          /* Title			Array of character string */
#define DTIF$_HDR_DATE 131843           /* Date				DTIF$_DAT */
#define DTIF$_HDR_EXTERNAL_REFERENCES 131844 /* External references		Sequence of DTIF$_ERF */
#define DTIF$_HDR_LANGUAGES_C 131845    /* Languages			Array of enumeration */
#define DTIF$_HDR_LANGUAGES 131846      /*				Array of variable */
#define DTIF$_HDR_LANGUAGE_PREF_TABLES 131847 /* Language preference tables	Sequence of DTIF$_LPT */
#define DTIF$_HDR_GENERIC_COLUMNS 131848 /* Generic column attributes	Sequence of DTIF$_CAT */
#define DTIF$_HDR_MAX 131849            /* Maximum code plus 1              */
/* Values of DTIF$_HDR_LANGUAGES_C.                                         */
#define DTIF$K_ISO_639_LANGUAGE 0       /* ISO 639 language name	String */
#define DTIF$K_OTHER_LANGUAGE 1         /* Other language name		Character string */
/* Item codes for Date and Time aggregate.                                  */
#define DTIF$_DAT_DATETIME 132097       /* Date and time		String */
#define DTIF$_DAT_TIME_DIFF_C 132098    /* Time difference		Enumeration */
#define DTIF$_DAT_TIME_DIFF 132099      /*				Variable */
#define DTIF$_DAT_MAX 132100            /* Maximum code plus 1              */
/* Values of DTIF$_DAT_TIME_DIFF_C.                                         */
#define DTIF$K_UTC_TIME 0               /* UTC time			None */
#define DTIF$K_PLUS_DIFF 1              /* Positive difference		String */
#define DTIF$K_NEG_DIFF 2               /* Negative difference		String */
/* Item codes for External Reference aggregate.                             */
#define DTIF$_ERF_DATA_TYPE 132353      /* Data type			Object identifier */
#define DTIF$_ERF_DESCRIPTOR 132354     /* Descriptor			Array of character string */
#define DTIF$_ERF_LABEL 132355          /* Label			Character string */
#define DTIF$_ERF_LABEL_TYPE 132356     /* Label type			String with add-info */
#define DTIF$_ERF_CONTROL 132357        /* Control			Enumeration */
#define DTIF$_ERF_MAX 132358            /* Maximum code plus 1              */
/* Values of the add-info parameter for DTIF$_ERF_LABEL_TYPE.               */
#define DTIF$K_PRIVATE_LABEL_TYPE 0     /* Private label type               */
#define DTIF$K_RMS_LABEL_TYPE 1         /* RMS file specification ("$RMS")  */
#define DTIF$K_UTX_LABEL_TYPE 2         /* ULTRIX file specification ("$UTX") */
#define DTIF$K_MDS_LABEL_TYPE 3         /* MS-DOS file specification ("$MDS") */
#define DTIF$K_STYLE_LABEL_TYPE 4       /* Style file specification ("$STYLE") */
#define DTIF$K_OS2_LABEL_TYPE 5         /* OS/2 file specification ("$OS2") */
/* Values of DTIF$_ERF_CONTROL.						DTIF conforming */
#define DTIF$K_COPY_REFERENCE 1         /* Copy on reference                */
#define DTIF$K_NO_COPY_REFERENCE 2      /* No copy on reference             */
/* Item codes for Language Preference Table aggregate.                      */
#define DTIF$_LPT_LANGUAGE_INDEX 132609 /* Language index		Integer */
#define DTIF$_LPT_APPL_PRIVATE 132610   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_LPT_ITEMS 132611          /* Named items			Sequence of DTIF$_NVL */
#define DTIF$_LPT_EDITSTRS 132612       /* Named edit strings		Sequence of DTIF$_NES */
#define DTIF$_LPT_COLLATE_SEQ 132613    /* Collating sequence		String with add-info */
#define DTIF$_LPT_COLLATE_TABLE 132614  /* Collating table		String */
#define DTIF$_LPT_MAX 132615            /* Maximum code plus 1              */
/* Values of the add-info parameter for DTIF$_LPT_COLLATE_SEQ.              */
#define DTIF$K_PRIVATE_COLLATE_SEQ 0    /* Private collating sequence       */
#define DTIF$K_ASCII_COLLATE_SEQ 1      /* ASCII collating sequence ("$ASCII") */
#define DTIF$K_MCS_COLLATE_SEQ 2        /* DEC Multinational collating sequence ("$MCS") */
#define DTIF$K_DANISH_COLLATE_SEQ 3     /* Danish collating sequence ("$DANISH") */
#define DTIF$K_FINSWD_COLLATE_SEQ 4     /* Finnish/Swedish collating sequence ("$FINSWD") */
#define DTIF$K_NORWEG_COLLATE_SEQ 5     /* Norwegian collating sequence ("$NORWEG") */
#define DTIF$K_SPANSH_COLLATE_SEQ 6     /* Spanish collating sequence ("$SPANSH") */
/* Item codes for Named Value aggregate.                                    */
#define DTIF$_NVL_NAME 132865           /* Value name			String */
#define DTIF$_NVL_VALUE_C 132866        /* Value data			Enumeration */
#define DTIF$_NVL_VALUE 132867          /* 				Variable */
#define DTIF$_NVL_MAX 132868            /* Maximum code plus 1              */
/* Values of DTIF$_NVL_VALUE_C.                                             */
#define DTIF$K_VALUE_BOOLEAN 0          /*				Boolean */
#define DTIF$K_VALUE_INTEGER 1          /*				Integer */
#define DTIF$K_VALUE_TEXT 2             /*				Array of character string */
#define DTIF$K_VALUE_GENERAL 3          /*				String */
#define DTIF$K_VALUE_LIST 4             /*				Sequence of DTIF$_NVL */
#define DTIF$K_VALUE_EXTERNAL 5         /*				DTIF$_EXT */
#define DTIF$K_VALUE_FLOAT 6            /*				General floating point */
#define DTIF$K_VALUE_DATE 7             /*				DTIF$_DAT */
#define DTIF$K_VALUE_EXPR 8             /*				CFE$_EXP */
/* Item codes for Named Edit String aggregate.                              */
#define DTIF$_NES_NAME 133121           /* Name				String */
#define DTIF$_NES_DEFN 133122           /* Definition			ESF$_EDS */
#define DTIF$_NES_MAX 133123            /* Maximum code plus 1              */
/* Item codes for Column Attributes aggregate.                              */
#define DTIF$_CAT_NAME 133377           /* Name				String */
#define DTIF$_CAT_ID 133378             /* Identifier			Integer */
#define DTIF$_CAT_APPL_PRIVATE 133379   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_CAT_GENERIC_REF 133380    /* Generic reference		Integer */
#define DTIF$_CAT_DESCRIPTION 133381    /* Description			Array of character string */
#define DTIF$_CAT_FORMATS 133382        /* Format information list	Sequence of DTIF$_FMI */
#define DTIF$_CAT_COMPUTED_BY 133383    /* Computed by expression	CFE$_EXP */
#define DTIF$_CAT_DEFAULT_VALUE_C 133384 /* Default value		Enumeration */
#define DTIF$_CAT_DEFAULT_VALUE 133385  /*				Variable */
#define DTIF$_CAT_MISSING_VALUE_C 133386 /* Missing value		Enumeration */
#define DTIF$_CAT_MISSING_VALUE 133387  /*				Variable */
#define DTIF$_CAT_QUERY_NAME 133388     /* Query name			Character string */
#define DTIF$_CAT_COLUMN_HDR 133389     /* Column header		Character string */
#define DTIF$_CAT_POSITION 133390       /* Position			Integer */
#define DTIF$_CAT_DATA_TYPE 133391      /* Data type			Enumeration */
#define DTIF$_CAT_DATA_LENGTH 133392    /* Data length (bytes)		Integer */
#define DTIF$_CAT_SCALE_FACTOR 133393   /* Scale factor			Integer */
#define DTIF$_CAT_FLAGS 133394          /* Flags			Longword */
#define DTIF$_CAT_MAX 133395            /* Maximum code plus 1              */
/* Values of DTIF$_CAT_DEFAULT_VALUE_C, DTIF$_CAT_MISSING_VALUE_C, DTIF$_CLD_VALUE_C. */
#define DTIF$K_CV_INTEGER 0             /* Integer			Variable integer */
#define DTIF$K_CV_LATIN1_TEXT 1         /* Latin-1 text			String */
#define DTIF$K_CV_SIMPLE_TEXT 2         /* Simple text			Character string */
#define DTIF$K_CV_DATE 3                /* Date				DTIF$_DAT */
#define DTIF$K_CV_SCALED_INTEGER 4      /* Scaled integer		Scaled integer */
#define DTIF$K_CV_VTEXT 5               /* Varying text 		DTIF$_VTX */
#define DTIF$K_CV_ARRAY 6               /* Array definition		DTIF$_ARD */
#define DTIF$K_CV_COMPLEX 7             /* Complex float		DTIF$_CFT */
#define DTIF$K_CV_FLOAT 8               /* Float			General floating point */
#define DTIF$K_CV_BOOLEAN 9             /* Boolean			Boolean */
/* Values of DTIF$_CAT_DATA_TYPE.					DTIF conforming */
#define DTIF$K_DT_UNKNOWN 0             /* Unknown                          */
#define DTIF$K_DT_WORD 1                /* Signed word integer              */
#define DTIF$K_DT_LONG 2                /* Signed longword integer          */
#define DTIF$K_DT_QUAD 3                /* Signed quadword integer          */
#define DTIF$K_DT_FFLOAT 4              /* VAX F-floating                   */
#define DTIF$K_DT_DFLOAT 5              /* VAX D-floating                   */
#define DTIF$K_DT_GFLOAT 6              /* VAX G-floating                   */
#define DTIF$K_DT_HFLOAT 7              /* VAX H-floating                   */
#define DTIF$K_DT_ABSDATE 8             /* Absolute date/time               */
#define DTIF$K_DT_TEXT 9                /* Text string                      */
#define DTIF$K_DT_VTEXT 10              /* Varying text string              */
#define DTIF$K_DT_SEGSTR 11             /* Segmented string                 */
/* Bit definitions for DTIF$_CAT_FLAGS.					DTIF conforming */
#define dtif$m_cat_autorecalc 1
#define dtif$m_cat_readonly 2
#define dtif$m_cat_annotation 4
struct cat_flags {
    unsigned dtif$v_cat_autorecalc : 1; /* Auto recalculate                 */
    unsigned dtif$v_cat_readonly : 1;   /* Read only                        */
    unsigned dtif$v_cat_annotation : 1; /* Annotation                       */
    unsigned dtif$v_cat_fill_1 : 29;
    } ;
/* Item codes for Table Definition aggregate.                               */
#define DTIF$_TBL_MAX_COLS 133633       /* Maximum columns		Integer */
#define DTIF$_TBL_MAX_ROWS 133634       /* Maximum rows			Integer */
#define DTIF$_TBL_APPL_PRIVATE 133635   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_TBL_METADATA 133636       /* Table metadata		DTIF$_TMD */
#define DTIF$_TBL_WINDOWS 133637        /* Window definitions		Sequence of DTIF$_WND */
#define DTIF$_TBL_ROWS 133638           /* Row data			Sequence of DTIF$_ROW */
#define DTIF$_TBL_MAX 133639            /* Maximum code plus 1              */
/* Item codes for Table Metadata aggregate.                                 */
#define DTIF$_TMD_NAME 133889           /* Name				Array of character string */
#define DTIF$_TMD_ID 133890             /* Identifier			Integer */
#define DTIF$_TMD_APPL_PRIVATE 133891   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_TMD_DESCRIPTION 133892    /* Description			Array of character string */
#define DTIF$_TMD_FLAGS 133893          /* Flags			Longword */
#define DTIF$_TMD_DEFAULT_FMTS 133894   /* Default formats		Sequence of DTIF$_FMI */
#define DTIF$_TMD_COLUMNS 133895        /* Column definitions		Sequence of DTIF$_CAT */
#define DTIF$_TMD_RANGES 133896         /* Range definitions		Sequence of DTIF$_RNG */
#define DTIF$_TMD_SYMBOLS 133897        /* Symbol definitions		Sequence of DTIF$_NVL */
#define DTIF$_TMD_MAX 133898            /* Maximum code plus 1              */
/* Bit definitions for DTIF$_TMD_FLAGS.					DTIF conforming */
#define dtif$m_tmd_autorecalc 1
#define dtif$m_tmd_autoresort 2
#define dtif$m_tmd_calcbycol 4
#define dtif$m_tmd_calcbyrow 8
#define dtif$m_tmd_calcnatural 16
#define dtif$m_tmd_fmtbycol 32
#define dtif$m_tmd_fmtbyrow 64
struct tmd_flags {
    unsigned dtif$v_tmd_autorecalc : 1;
    unsigned dtif$v_tmd_autoresort : 1;
    unsigned dtif$v_tmd_calcbycol : 1;
    unsigned dtif$v_tmd_calcbyrow : 1;
    unsigned dtif$v_tmd_calcnatural : 1;
    unsigned dtif$v_tmd_fmtbycol : 1;
    unsigned dtif$v_tmd_fmtbyrow : 1;
    unsigned dtif$v_tmd_fill_1 : 25;
    } ;
/* Item codes for Window Definition aggregate.                              */
#define DTIF$_WND_NAME 134145           /* Name				Array of character string */
#define DTIF$_WND_ID 134146             /* Identifier			Integer */
#define DTIF$_WND_APPL_PRIVATE 134147   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_WND_CARDINAL_NUM 134148   /* Cardinal number		Integer */
#define DTIF$_WND_DESCRIPTION 134149    /* Description			Array of character string */
#define DTIF$_WND_FLAGS 134150          /* Flags			Longword */
#define DTIF$_WND_FORMATS 134151        /* Format definitions		Sequence of DTIF$_FMI */
#define DTIF$_WND_RANGES 134152         /* Range definitions		Sequence of DTIF$_RNG */
#define DTIF$_WND_ACTIVE_LOC 134153     /* Active location		DTIF$_CCD */
#define DTIF$_WND_MAX 134154            /* Maximum code plus 1              */
/* Bit definitions for DTIF$_WND_FLAGS.					DTIF conforming */
#define dtif$m_wnd_active 1
#define dtif$m_wnd_hidden 2
#define dtif$m_wnd_formula_hidden 4
#define dtif$m_wnd_value_hidden 8
#define dtif$m_wnd_colhdr_hidden 16
#define dtif$m_wnd_rowhdr_hidden 32
#define dtif$m_wnd_lines_hidden 64
struct wnd_flags {
    unsigned dtif$v_wnd_active : 1;
    unsigned dtif$v_wnd_hidden : 1;
    unsigned dtif$v_wnd_formula_hidden : 1;
    unsigned dtif$v_wnd_value_hidden : 1;
    unsigned dtif$v_wnd_colhdr_hidden : 1;
    unsigned dtif$v_wnd_rowhdr_hidden : 1;
    unsigned dtif$v_wnd_lines_hidden : 1;
    unsigned dtif$v_wnd_fill_1 : 25;
    } ;
/* Item codes for Row Definition aggregate.                                 */
#define DTIF$_ROW_NUM 134401            /* Row number			Integer */
#define DTIF$_ROW_APPL_PRIVATE 134402   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_ROW_FORMATS 134403        /* Format definitions		Sequence of DTIF$_FMI */
#define DTIF$_ROW_FLAGS 134404          /* Flags			Longword */
#define DTIF$_ROW_CELLS 134405          /* Cell data			Sequence of DTIF$_CLD */
#define DTIF$_ROW_MAX 134406            /* Maximum code plus 1              */
/* Bit definitions for DTIF$_ROW_FLAGS.					DTIF conforming */
#define dtif$m_row_annotation 1
struct row_flags {
    unsigned dtif$v_row_annotation : 1;
    unsigned dtif$v_row_fill_1 : 31;
    } ;
/* Item codes for Cell Data aggregate.                                      */
#define DTIF$_CLD_COL_NUM 134657        /* Column number		Integer */
#define DTIF$_CLD_STATE 134658          /* State			Enumeration */
#define DTIF$_CLD_DESCRIPTION 134659    /* Description			Array of character string */
#define DTIF$_CLD_APPL_PRIVATE 134660   /* Application private		Sequence of DTIF$_NVL */
#define DTIF$_CLD_FORMATS 134661        /* Format definitions		Sequence of DTIF$_FMI */
#define DTIF$_CLD_VALUE_C 134662        /* Cell value			Enumeration */
#define DTIF$_CLD_VALUE 134663          /*				Variable */
#define DTIF$_CLD_FORMULA_CFE 134664    /* Cell formula			CFE$_EXP */
#define DTIF$_CLD_MAX 134665            /* Maximum code plus 1              */
/* Values of DTIF$_CLD_STATE.						DTIF conforming */
#define DTIF$K_CS_ISVALUE 0
#define DTIF$K_CS_ISNULL 1
#define DTIF$K_CS_ISERROR 2
#define DTIF$K_CS_ISNOVALUE 3
#define DTIF$K_CS_ISUNDERFLOW 10
#define DTIF$K_CS_ISOVERFLOW 11
#define DTIF$K_CS_ISUNDEFREF 12
#define DTIF$K_CS_ISDIVZERO 13
#define DTIF$K_CS_ISRECURSIVE 14
/* Item codes for Varying Text aggregate.                                   */
#define DTIF$_VTX_VTEXT_LEN 134913      /* Varying text length		Integer */
#define DTIF$_VTX_VTEXT_STR 134914      /* Varying text string		Character string */
#define DTIF$_VTX_MAX 134915            /* Maximum code plus 1              */
/* Item codes for Array Definition aggregate.                               */
#define DTIF$_ARD_DESCRIPTION 135169    /* Description			String */
#define DTIF$_ARD_ELEM_TYPE_SIZE_C 135170 /* Array element type size	Enumeration */
#define DTIF$_ARD_ELEM_TYPE_SIZE 135171 /*				Variable */
#define DTIF$_ARD_X_DIMENSION 135172    /* X dimension			Integer */
#define DTIF$_ARD_Y_DIMENSION 135173    /* Y dimension			Integer */
#define DTIF$_ARD_Z_DIMENSION 135174    /* Z dimension			Integer */
#define DTIF$_ARD_VALUES 135175         /* Values			String */
#define DTIF$_ARD_MAX 135176            /* Maximum code plus 1              */
/* Values of DTIF$_ARD_ELEM_TYPE_SIZE_C.                                    */
#define DTIF$K_STD_TYPE 0               /* Standard type size		Enumeration */
#define DTIF$K_VAR_TYPE 1               /* Variable type size		Integer */
/* Values of DTIF$_ARD_ELEM_TYPE_SIZE for DTIF$K_STD_TYPE.		DTIF conforming */
#define DTIF$K_ELEM_WORD 0              /* Word                             */
#define DTIF$K_ELEM_LONG 1              /* Longword                         */
#define DTIF$K_ELEM_FFLOAT 2            /* VAX F-floating                   */
#define DTIF$K_ELEM_DFLOAT 3            /* VAX D-floating                   */
#define DTIF$K_ELEM_GFLOAT 4            /* VAX G-floating                   */
#define DTIF$K_ELEM_HFLOAT 5            /* VAX H-floating                   */
/* Item codes for Complex Float aggregate.                                  */
#define DTIF$_CFT_REAL_PART 135425      /* Real part			General floating point */
#define DTIF$_CFT_IMAGINARY_PART 135426 /* Imaginary part 		General floating point */
#define DTIF$_CFT_MAX 135427            /* Maximum code plus 1              */
/* Item codes for Format Information aggregate.                             */
#define DTIF$_FMI_WINDOW_ID 135681      /* Window ID			Integer */
#define DTIF$_FMI_C 135682              /* Format choice		Enumeration */
#define DTIF$_FMI_NUM_DATATYPE 135683   /* Numeric data type		Longword */
#define DTIF$_FMI_NUM_C 135684          /* Numeric format		Enumeration */
#define DTIF$_FMI_NUMSTD_TYPE 135685    /* Numeric standard type	Enumeration */
#define DTIF$_FMI_NUMSTD_DIGITS 135686  /* Numeric standard digits	Integer */
#define DTIF$_FMI_NUMSTD_FRAC 135687    /* Numeric standard fraction	Integer */
#define DTIF$_FMI_NUMEDS_EDITSTR 135688 /* Numeric edit string		ESF$_EDS */
#define DTIF$_FMI_NUMEID_EDITSTR_ID 135689 /* Numeric edit string index	Integer */
#define DTIF$_FMI_NUM_RNDTRUNC 135690   /* Numeric rounding		Enumeration */
#define DTIF$_FMI_TXT_C 135691          /* Text format			Enumeration */
#define DTIF$_FMI_TXTSTD_TYPE 135692    /* Text standard type		Enumeration */
#define DTIF$_FMI_TXTEDS_EDITSTR 135693 /* Text edit string		ESF$_EDS */
#define DTIF$_FMI_TXTEID_EDITSTR_ID 135694 /* Text edit string index	Integer */
#define DTIF$_FMI_DAT_C 135695          /* Date format			Enumeration */
#define DTIF$_FMI_DATSTD_TYPE 135696    /* Date standard type		Enumeration */
#define DTIF$_FMI_DATSTD_ORDER 135697   /* Date standard order		Enumeration */
#define DTIF$_FMI_DATEDS_EDITSTR 135698 /* Date edit string		ESF$_EDS */
#define DTIF$_FMI_DATEID_EDITSTR_ID 135699 /* Date edit string index	Integer */
#define DTIF$_FMI_FLAGS 135700          /* Flags			Longword */
#define DTIF$_FMI_WIDTH 135701          /* Width			Integer */
#define DTIF$_FMI_LANG_ID 135702        /* Language index		Integer */
#define DTIF$_FMI_DIRECTION 135703      /* Direction			Enumeration */
#define DTIF$_FMI_UNIT_DESC 135704      /* Units description		Array of character string */
#define DTIF$_FMI_ALIGNMENT 135705      /* Alignment			Enumeration */
#define DTIF$_FMI_BORDER 135706         /* Border			Longword */
#define DTIF$_FMI_MAX 135707            /* Maximum code plus 1              */
/* Values of DTIF$_FMI_C.                                                   */
#define DTIF$K_NUMERIC_FORMAT 0         /* Numeric format		DTIF$_FMI_NUM_DATATYPE to DTIF$_FMI_NUM_RNDTRUNC */
#define DTIF$K_TEXT_FORMAT 1            /* Text format			DTIF$_FMI_TXT_C to DTIF$_FMI_TXTEID_EDITSTR_ID */
#define DTIF$K_DATE_FORMAT 2            /* Date format			DTIF$_FMI_DAT_C to DTIF$_FMI_DATEID_EDITSTR_ID */
/* Bit definitions for DTIF$_FMI_NUM_DATATYPE.				DTIF conforming */
#define dtif$m_fmi_num_all 1
#define dtif$m_fmi_num_integer 2
#define dtif$m_fmi_num_float 4
struct fmi_num_datatype {
    unsigned dtif$v_fmi_num_all : 1;
    unsigned dtif$v_fmi_num_integer : 1;
    unsigned dtif$v_fmi_num_float : 1;
    unsigned dtif$v_fmi_fill_1 : 29;
    } ;
/* Values of DTIF$K_FMI_NUM_C.                                              */
#define DTIF$K_NUM_STANDARD 0           /* Numeric standard format	DTIF$_FMI_NUMSTD_TYPE to DTIF$_FMI_NUMSTD_FRAC */
#define DTIF$K_NUM_EDITSTR 1            /* Numeric edit string		DTIF$_FMI_NUMEDS_EDITSTR */
#define DTIF$K_NUM_EDITSTR_ID 2         /* Numeric edit string index	DTIF$_FMI_NUMEID_EDITSTR_ID */
/* Values of DTIF$K_FMI_NUMSTD_TYPE.					DTIF conforming */
#define DTIF$K_NUMSTD_GENERAL 0         /* General format                   */
#define DTIF$K_NUMSTD_INTEGER 1         /* Integer format                   */
#define DTIF$K_NUMSTD_FIXEDPT 2         /* Fixed point format               */
#define DTIF$K_NUMSTD_SCIENTIFIC 3      /* Scientific format                */
#define DTIF$K_NUMSTD_MONEY 4           /* Money format                     */
#define DTIF$K_NUMSTD_COMMA 5           /* Comma format                     */
#define DTIF$K_NUMSTD_PERCENT 6         /* Percent format                   */
#define DTIF$K_NUMSTD_PHONE 7           /* Phone format                     */
#define DTIF$K_NUMSTD_BAR 8             /* Bar format                       */
#define DTIF$K_NUMSTD_TEXT 9            /* Text format                      */
/* Values of DTIF$K_FMI_NUM_RNDTRUNC.					DTIF conforming */
#define DTIF$K_NUM_ROUND 0              /* Round                            */
#define DTIF$K_NUM_TRUNCATE 1           /* Truncate                         */
/* Values of DTIF$K_FMI_TXT_C.                                              */
#define DTIF$K_TXT_STANDARD 0           /* Text standard format		DTIF$_FMI_TXTSTD_TYPE */
#define DTIF$K_TXT_EDITSTR 1            /* Text edit string		DTIF$_FMI_TXTEDS_EDITSTR */
#define DTIF$K_TXT_EDITSTR_ID 2         /* Text edit string index	DTIF$_FMI_TXTEID_EDITSTR_ID */
/* Values of DTIF$_FMI_TXTSTD_TYPE.					DTIF conforming */
#define DTIF$K_TXTSTD_PHONE 0           /* Telephone                        */
#define DTIF$K_TXTSTD_TEXT 1            /* Text                             */
#define DTIF$K_TXTSTD_REPEAT 2          /* Repeat                           */
/* Values of DTIF$K_FMI_DAT_C.                                              */
#define DTIF$K_DAT_STANDARD 0           /* Date standard format		DTIF$_FMI_DATSTD_TYPE to DTIF$_FMI_DATSTD_ORDER */
#define DTIF$K_DAT_EDITSTR 1            /* Date edit string		DTIF$_FMI_DATEDS_EDITSTR */
#define DTIF$K_DAT_EDITSTR_ID 2         /* Date edit string index	DTIF$_FMI_DATEID_EDITSTR_ID */
/* Values of DTIF$_FMI_DATSTD_TYPE.					DTIF conforming */
#define DTIF$K_DATSTD_DATEONLY 0        /* Date only                        */
#define DTIF$K_DATSTD_TIMEONLY 1        /* Time only                        */
#define DTIF$K_DATSTD_DATEANDTIME 2     /* Date and time                    */
/* Values of DTIF$_FMI_DATSTD_ORDER.					DTIF conforming */
#define DTIF$K_DATSTD_MDY 0             /* Month day year                   */
#define DTIF$K_DATSTD_DMY 1             /* Day month year                   */
/* Bit definitions for DTIF$_FMI_FLAGS.					DTIF conforming */
#define dtif$m_fmi_readonly 1
#define dtif$m_fmi_noreadonly 2
#define dtif$m_fmi_bold 4
#define dtif$m_fmi_nobold 8
#define dtif$m_fmi_italic 16
#define dtif$m_fmi_noitalic 32
#define dtif$m_fmi_underline 64
#define dtif$m_fmi_nounderline 128
#define dtif$m_fmi_valuehidden 256
#define dtif$m_fmi_novaluehidden 512
#define dtif$m_fmi_formulahidden 1024
#define dtif$m_fmi_noformulahidden 2048
#define dtif$m_fmi_running 4096
#define dtif$m_fmi_norunning 8192
struct fmi_flags {
    unsigned dtif$v_fmi_readonly : 1;
    unsigned dtif$v_fmi_noreadonly : 1;
    unsigned dtif$v_fmi_bold : 1;
    unsigned dtif$v_fmi_nobold : 1;
    unsigned dtif$v_fmi_italic : 1;
    unsigned dtif$v_fmi_noitalic : 1;
    unsigned dtif$v_fmi_underline : 1;
    unsigned dtif$v_fmi_nounderline : 1;
    unsigned dtif$v_fmi_valuehidden : 1;
    unsigned dtif$v_fmi_novaluehidden : 1;
    unsigned dtif$v_fmi_formulahidden : 1;
    unsigned dtif$v_fmi_noformulahidden : 1;
    unsigned dtif$v_fmi_running : 1;
    unsigned dtif$v_fmi_norunning : 1;
    unsigned dtif$v_fmi_fill_2 : 18;
    } ;
/* Values of DTIF$_FMI_DIRECTION.					DTIF conforming */
#define DTIF$K_DIR_OPPOSITE 0           /* Opposite direction               */
/* Values of DTIF$_FMI_ALIGNMENT.					DTIF conforming */
#define DTIF$K_ALIGN_LEFT 0             /* Left alignment                   */
#define DTIF$K_ALIGN_CENTER 1           /* Center alignment                 */
#define DTIF$K_ALIGN_RIGHT 2            /* Right alignment                  */
/* Bit definitions for DTIF$_FMI_BORDER.				DTIF conforming */
#define dtif$m_fmi_border_left 1
#define dtif$m_fmi_border_noleft 2
#define dtif$m_fmi_border_top 4
#define dtif$m_fmi_border_notop 8
#define dtif$m_fmi_border_right 16
#define dtif$m_fmi_border_noright 32
#define dtif$m_fmi_border_bottom 64
#define dtif$m_fmi_border_nobottom 128
struct fmi_border {
    unsigned dtif$v_fmi_border_left : 1;
    unsigned dtif$v_fmi_border_noleft : 1;
    unsigned dtif$v_fmi_border_top : 1;
    unsigned dtif$v_fmi_border_notop : 1;
    unsigned dtif$v_fmi_border_right : 1;
    unsigned dtif$v_fmi_border_noright : 1;
    unsigned dtif$v_fmi_border_bottom : 1;
    unsigned dtif$v_fmi_border_nobottom : 1;
    unsigned dtif$v_fmi_fill_3 : 24;
    } ;
/* Item codes for Cell Coordinates aggregate.                               */
#define DTIF$_CCD_ROW 135937            /* Row number			Integer */
#define DTIF$_CCD_COLUMN 135938         /* Column number		Integer */
#define DTIF$_CCD_FLAGS 135939          /* Flags			Enumeration */
#define DTIF$_CCD_MAX 135940            /* Maximum code plus 1              */
/* Values of DTIF$_CCD_FLAGS.						DTIF conforming */
#define DTIF$K_RELROW_RELCOL 0          /* Relative row, relative column    */
#define DTIF$K_RELROW_ABSCOL 1          /* Relative row, absolute column    */
#define DTIF$K_ABSROW_RELCOL 2          /* Absolute row, relative column    */
#define DTIF$K_ABSROW_ABSCOL 3          /* Absolute row, absolute column    */
/* Item codes for Range Definition aggregate.                               */
#define DTIF$_RNG_NAME 136193           /* Name				Array of character string */
#define DTIF$_RNG_TYPE 136194           /* Type				Enumeration */
#define DTIF$_RNG_REGION 136195         /* Region			Sequence of DTIF$_CLR, DTIF$_RWR, DTIF$_COR, DTIF$_NMR */
#define DTIF$_RNG_SORT_KEYNUM 136196    /* Sort key number		Integer */
#define DTIF$_RNG_MAX 136197            /* Maximum code plus 1              */
/* Values of DTIF$_RNG_TYPE.						DTIF conforming */
#define DTIF$K_RT_NAMED_RANGE 0         /* Named area                       */
#define DTIF$K_RT_VIEW_RANGE 1          /* View definition                  */
#define DTIF$K_RT_COL_TITLE 2           /* Column title section             */
#define DTIF$K_RT_ROW_TITLE 3           /* Row title section                */
#define DTIF$K_RT_DISPLAY_DATA 4        /* Displayed window range           */
#define DTIF$K_RT_DATA_RANGE 5          /* Maximum window range             */
#define DTIF$K_RT_SORT_RANGE 6          /* Sort range                       */
/* Item codes for Cell Range aggregate.                                     */
#define DTIF$_CLR_RANGE_BEGIN 136449    /* Beginning cell coordinates	DTIF$_CCD */
#define DTIF$_CLR_RANGE_END 136450      /* Ending cell coordinates	DTIF$_CCD */
#define DTIF$_CLR_MAX 136451            /* Maximum code plus 1              */
/* Item codes for Row Range aggregate.                                      */
#define DTIF$_RWR_ROW_BEGIN 136705      /* Beginning row number		Integer */
#define DTIF$_RWR_ROW_END 136706        /* Ending row number		Integer */
#define DTIF$_RWR_MAX 136707            /* Maximum code plus 1              */
/* Item codes for Column Range aggregate.                                   */
#define DTIF$_COR_COL_BEGIN 136961      /* Beginning column number	Integer */
#define DTIF$_COR_COL_END 136962        /* Ending column number		Integer */
#define DTIF$_COR_MAX 136963            /* Maximum code plus 1              */
/* Item codes for Named Range aggregate.                                    */
#define DTIF$_NMR_NAMEDRANGE 137217     /* Named range			Array of character string */
#define DTIF$_NMR_MAX 137218            /* Maximum code plus 1              */
/* Item codes for External aggregate.                                       */
#define DTIF$_EXT_DIRECT_REFERENCE 137473 /* Direct reference		Object identifier */
#define DTIF$_EXT_INDIRECT_REFERENCE 137474 /* Indirect reference		Integer */
#define DTIF$_EXT_DATA_VALUE_DESCRIPTOR 137475 /* Data value descriptor	String */
#define DTIF$_EXT_ENCODING_C 137476     /* Encoding			Enumeration */
#define DTIF$_EXT_ENCODING 137477       /* 				Variable */
#define DTIF$_EXT_ENCODING_L 137478     /*     Length (on input)	Integer */
#define DTIF$_EXT_MAX 137479            /* Maximum code plus 1              */
/* Values of DTIF$_EXT_ENCODING_C.                                          */
#define DTIF$K_DOCUMENT_ENCODING 0      /* Nested document		Document root aggregate */
#define DTIF$K_DDIS_ENCODING 1          /* Nested document		DDIS encoding */
#define DTIF$K_OCTET_ENCODING 2         /* Octet aligned		String */
#define DTIF$K_ARBITRARY_ENCODING 3     /* Arbitrary			Bit string */
/* Aggregate type codes for ESF (Edit String Format).                       */
#define ESF$_EDS 769                    /* Edit string                      */
#define ESF$_RPT 770                    /* Repeat                           */
#define ESF$_TXS 771                    /* Text string                      */
#define ESF$_NVL 772                    /* Named value                      */
#define ESF$_DAT 773                    /* Date and time                    */
#define ESF$_EXT 774                    /* External                         */
#define ESF$_MAX 775                    /* Maximum code plus 1              */
/* Item codes for all aggregates.  ESF$_AGGREGATE_TYPE is read-only.        */
#define ESF$_USER_CONTEXT 1             /* User context			Longword */
#define ESF$_AGGREGATE_TYPE 2           /* Aggregate type code		Word */
#define ESF$_ALL_MAX 3                  /* Maximum code plus 1              */
/* Item codes for Edit String aggregate.                                    */
#define ESF$_EDS_MAJOR_VERSION 196865   /* Major version		Integer */
#define ESF$_EDS_MINOR_VERSION 196866   /* Minor version		Integer */
#define ESF$_EDS_EDIT_STRING_C 196867   /* Edit string			Array of enumeration */
#define ESF$_EDS_EDIT_STRING 196868     /*				Array of variable */
#define ESF$_EDS_MAX 196869             /* Maximum code plus 1              */
/* Current values for major and minor encoding version.  Should be omitted when the edit string is embedded in a DTIF document. */
#define ESF$K_MAJOR_VERSION 1
#define ESF$K_MINOR_VERSION 0
/* Values of ESF$_EDS_EDIT_STRING_C and ESF$_RPT_SEQ_C.                     */
#define ESF$K_EDS_ALPHABETIC 0          /* Alphabetic			None */
#define ESF$K_EDS_AM_PM 1               /* AM PM			None */
#define ESF$K_EDS_ANY_CHAR 2            /* Any character		None */
#define ESF$K_EDS_ANY_CASE 3            /* Any case			None */
#define ESF$K_EDS_BINARY_DIGIT 4        /* Binary digit			None */
#define ESF$K_EDS_DIGIT_SEP 5           /* Digit separator		None */
#define ESF$K_EDS_DAY_NUMBER 6          /* Day number			None */
#define ESF$K_EDS_DECIMAL_DIGIT 7       /* Decimal digit		None */
#define ESF$K_EDS_RADIX_POINT 8         /* Radix point			None */
#define ESF$K_EDS_ENCODED_MINUS 9       /* Encoded minus		None */
#define ESF$K_EDS_ENCODED_PLUS 10       /* Encoded plus			None */
#define ESF$K_EDS_ENCODED_SIGN 11       /* Encoded sign			None */
#define ESF$K_EDS_EXPONENT 12           /* Exponent			None */
#define ESF$K_EDS_ZERO_REPLACE 13       /* Zero replace			ESF$_TXS */
#define ESF$K_EDS_CURRENCY 14           /* Currency			None */
#define ESF$K_EDS_MINUS 15              /* Minus			None */
#define ESF$K_EDS_PLUS 16               /* Plus				None */
#define ESF$K_EDS_SIGN 17               /* Sign				None */
#define ESF$K_EDS_FLOAT_BLANK_SUPR 18   /* Float blank suppress		None */
#define ESF$K_EDS_FRACTION_SECOND 19    /* Fraction second		None */
#define ESF$K_EDS_HEX_DIGIT 20          /* Hex digit			None */
#define ESF$K_EDS_HOUR_12 21            /* Hour (12 hour system)	None */
#define ESF$K_EDS_HOUR_24 22            /* Hour (24 hour system)	None */
#define ESF$K_EDS_JULIAN_DIGIT 23       /* Julian digit			None */
#define ESF$K_EDS_LOGICAL_CHAR 24       /* Logical character		None */
#define ESF$K_EDS_LONG_TEXT 25          /* Long text			None */
#define ESF$K_EDS_LOWERCASE 26          /* Lowercase			None */
#define ESF$K_EDS_MINUS_LITERAL 27      /* Minus literal begin		ESF$_TXS */
#define ESF$K_EDS_MINUS_LIT_END 28      /* Minus literal end		ESF$_TXS */
#define ESF$K_EDS_MINUTE 29             /* Minute			None */
#define ESF$K_EDS_MONTH_NAME 30         /* Month name			None */
#define ESF$K_EDS_MONTH_NUMBER 31       /* Month number			None */
#define ESF$K_EDS_OCTAL_DIGIT 32        /* Octal digit			None */
#define ESF$K_EDS_PLUS_LITERAL 33       /* Plus literal			ESF$_TXS */
#define ESF$K_EDS_REVERSE 34            /* Reverse			None */
#define ESF$K_EDS_SECOND 35             /* Second			None */
#define ESF$K_EDS_STR_LITERAL 36        /* String literal		ESF$_TXS */
#define ESF$K_EDS_MISSING_SEP 37        /* Missing separator		None */
#define ESF$K_EDS_UPPERCASE 38          /* Uppercase			None */
#define ESF$K_EDS_WEEKDAYNAME 39        /* Weekday name			None */
#define ESF$K_EDS_YEAR 40               /* Year				None */
#define ESF$K_EDS_APPL_PRIVATE 41       /* Application private		Sequence of ESF$_NVL */
#define ESF$K_EDS_DIGIT_SEP_LIT 42      /* Digit separator literal	ESF$_TXS */
#define ESF$K_EDS_RADIX_POINT_LIT 43    /* Radix point literal		ESF$_TXS */
#define ESF$K_EDS_CURRENCY_LIT 44       /* Currency sign literal	ESF$_TXS */
#define ESF$K_EDS_REPEAT 45             /* Repeat			ESF$_RPT (not for ESF$_RPT_SEQ_C) */
/* Item codes for Repeat aggregate.                                         */
#define ESF$_RPT_COUNT 197121           /* Repeat count			Integer */
#define ESF$_RPT_SEQ_C 197122           /* Repeat sequence		Enumeration */
#define ESF$_RPT_SEQ 197123             /*				Variable */
#define ESF$_RPT_MAX 197124             /* Maximum code plus 1              */
/* Item codes for Text String aggregate.                                    */
#define ESF$_TXS_TEXT_STRING 197377     /* Text string			Array of character string */
#define ESF$_TXS_MAX 197378             /* Maximum code plus 1              */
/* Item codes for Named Value aggregate.                                    */
#define ESF$_NVL_NAME 197633            /* Value name			String */
#define ESF$_NVL_VALUE_C 197634         /* Value data			Enumeration */
#define ESF$_NVL_VALUE 197635           /* 				Variable */
#define ESF$_NVL_MAX 197636             /* Maximum code plus 1              */
/* Values of ESF$_NVL_VALUE_C.                                              */
#define ESF$K_VALUE_BOOLEAN 0           /*				Boolean */
#define ESF$K_VALUE_INTEGER 1           /*				Integer */
#define ESF$K_VALUE_TEXT 2              /*				Array of character string */
#define ESF$K_VALUE_GENERAL 3           /*				String */
#define ESF$K_VALUE_LIST 4              /*				Sequence of ESF$_NVL */
#define ESF$K_VALUE_EXTERNAL 5          /*				ESF$_EXT */
#define ESF$K_VALUE_FLOAT 6             /*				General floating point */
#define ESF$K_VALUE_DATE 7              /*				ESF$_DAT */
#define ESF$K_VALUE_EXPR 8              /*				CFE$_EXP */
/* Item codes for Date and Time aggregate.                                  */
#define ESF$_DAT_DATETIME 197889        /* Date and time		String */
#define ESF$_DAT_TIME_DIFF_C 197890     /* Time difference		Enumeration */
#define ESF$_DAT_TIME_DIFF 197891       /*				Variable */
#define ESF$_DAT_MAX 197892             /* Maximum code plus 1              */
/* Values of ESF$_DAT_TIME_DIFF_C.                                          */
#define ESF$K_UTC_TIME 0                /* UTC time			None */
#define ESF$K_PLUS_DIFF 1               /* Positive difference		String */
#define ESF$K_NEG_DIFF 2                /* Negative difference		String */
/* Item codes for External aggregate.                                       */
#define ESF$_EXT_DIRECT_REFERENCE 198145 /* Direct reference		Object identifier */
#define ESF$_EXT_INDIRECT_REFERENCE 198146 /* Indirect reference		Integer */
#define ESF$_EXT_DATA_VALUE_DESCRIPTOR 198147 /* Data value descriptor	String */
#define ESF$_EXT_ENCODING_C 198148      /* Encoding			Enumeration */
#define ESF$_EXT_ENCODING 198149        /* 				Variable */
#define ESF$_EXT_ENCODING_L 198150      /*     Length (on input)	Integer */
#define ESF$_EXT_MAX 198151             /* Maximum code plus 1              */
/* Values of ESF$_EXT_ENCODING_C.                                           */
#define ESF$K_DOCUMENT_ENCODING 0       /* Nested document		Document root aggregate */
#define ESF$K_DDIS_ENCODING 1           /* Nested document		DDIS encoding */
#define ESF$K_OCTET_ENCODING 2          /* Octet aligned		String */
#define ESF$K_ARBITRARY_ENCODING 3      /* Arbitrary			Bit string */
/* Aggregate type codes for CFE (Canonical Format Expressions).             */
#define CFE$_EXP 1025                   /* Expression                       */
#define CFE$_EXL 1026                   /* Expression list                  */
#define CFE$_SLL 1027                   /* Selector list                    */
#define CFE$_CFT 1028                   /* Complex float                    */
#define CFE$_DAT 1029                   /* Date and time                    */
#define CFE$_TXC 1030                   /* Text choice                      */
#define CFE$_VTX 1031                   /* Varying text                     */
#define CFE$_FRF 1032                   /* Field reference                  */
#define CFE$_PEX 1033                   /* Parenthesized expression         */
#define CFE$_PFE 1034                   /* Private function expression      */
#define CFE$_STF 1035                   /* String format                    */
#define CFE$_STP 1036                   /* String pretty                    */
#define CFE$_NPM 1037                   /* Named parameter                  */
#define CFE$_CCD 1038                   /* Cell coordinates                 */
#define CFE$_CLR 1039                   /* Cell range                       */
#define CFE$_RWR 1040                   /* Row range                        */
#define CFE$_COR 1041                   /* Column range                     */
#define CFE$_MAX 1042                   /* Maximum code plus one            */
/* Item codes for all aggregates.  CFE$_AGGREGATE_TYPE is read-only.        */
#define CFE$_USER_CONTEXT 1             /* User context			Longword */
#define CFE$_AGGREGATE_TYPE 2           /* Aggregate type code		Word */
#define CFE$_ALL_MAX 3                  /* Maximum code plus 1              */
/* Item codes for Expression aggregate.                                     */
#define CFE$_EXP_MAJOR_VERSION 262401   /* Major version		Integer */
#define CFE$_EXP_MINOR_VERSION 262402   /* Minor version		Integer */
#define CFE$_EXP_LIST 262403            /* Expression list		Sequence of CFE$_EXL */
#define CFE$_EXP_MAX 262404             /* Maximum code plus 1              */
/* Current values for major and minor encoding version.  Should be omitted when the expression is embedded in a DTIF document. */
#define CFE$K_MAJOR_VERSION 1
#define CFE$K_MINOR_VERSION 0
/* Item codes for Expression List aggregate.                                */
#define CFE$_EXL_EXPR_C 262657          /* Expression choice		Enumeration */
#define CFE$_EXL_EXPR 262658            /*				Variable */
#define CFE$_EXL_MAX 262659             /* Maximum code plus 1              */
/* Values of CFE$_EXL_EXPR_C.                                               */
#define CFE$K_LIT_INTEGER 0             /* Literal integer		Integer */
#define CFE$K_LIT_FLOAT 1               /* Literal float		General floating point */
#define CFE$K_LIT_TEXT 2                /* Literal text			CFE$_TXC */
#define CFE$K_LIT_DATE 3                /* Literal date			CFE$_DAT */
#define CFE$K_LIT_SCALED_INTEGER 4      /* Literal scaled integer	Scaled integer */
#define CFE$K_LIT_COMPLEX_FLOAT 5       /* Literal complex float	CFE$_CFT */
#define CFE$K_LIT_VTEXT 6               /* Literal varying text		CFE$_VTX */
#define CFE$K_PARENTHESIZED 7           /* Parenthesized expression	CFE$_PEX */
#define CFE$K_CELL_COORD 8              /* Cell coordinates		CFE$_CCD */
#define CFE$K_CELL_RANGE 9              /* Cell range			CFE$_CLR */
#define CFE$K_ROW_RANGE 10              /* Row range			CFE$_RWR */
#define CFE$K_COL_RANGE 11              /* Column range			CFE$_COR */
#define CFE$K_NAMED_RANGE 12            /* Named range			Array of character string */
#define CFE$K_COL_NUM 13                /* Column number		Integer */
#define CFE$K_ROW_NUM 14                /* Row number			Integer */
#define CFE$K_COL_NAME 15               /* Column name			String */
#define CFE$K_NEGATE 16                 /* Negate			Sequence of CFE$_EXL */
#define CFE$K_ADD 17                    /* Add				Sequence of CFE$_EXL */
#define CFE$K_SUBTRACT 18               /* Subtract			Sequence of CFE$_EXL */
#define CFE$K_DIVIDE 19                 /* Divide			Sequence of CFE$_EXL */
#define CFE$K_MULTIPLY 20               /* Multiply			Sequence of CFE$_EXL */
#define CFE$K_POWER 21                  /* Raise to a power		Sequence of CFE$_EXL */
#define CFE$K_EXPONENT 22               /* Exponent			Sequence of CFE$_EXL */
#define CFE$K_IF_THEN_ELSE 23           /* If-then-else			Sequence of CFE$_EXL */
#define CFE$K_NOT 24                    /* Logical not			Sequence of CFE$_EXL */
#define CFE$K_AND 25                    /* Logical and 			Sequence of CFE$_EXL */
#define CFE$K_OR 26                     /* Logical or			Sequence of CFE$_EXL */
#define CFE$K_EQL 27                    /* Equal			Sequence of CFE$_EXL */
#define CFE$K_GTR 28                    /* Greater than			Sequence of CFE$_EXL */
#define CFE$K_GEQ 29                    /* Greater than or equal	Sequence of CFE$_EXL */
#define CFE$K_LSS 30                    /* Less than			Sequence of CFE$_EXL */
#define CFE$K_LEQ 31                    /* Less than or equal		Sequence of CFE$_EXL */
#define CFE$K_NEQ 32                    /* Not equal			Sequence of CFE$_EXL */
#define CFE$K_BETWEEN 33                /* Between			Sequence of CFE$_EXL */
#define CFE$K_ABS_VALUE 34              /* Absolute value		Sequence of CFE$_EXL */
#define CFE$K_MODULO 35                 /* Modulus			Sequence of CFE$_EXL */
#define CFE$K_SQRT 36                   /* Square root			Sequence of CFE$_EXL */
#define CFE$K_SUM 37                    /* Summation			CFE$_SLL */
#define CFE$K_AVG 38                    /* Average			CFE$_SLL */
#define CFE$K_COUNT 39                  /* Count			CFE$_SLL */
#define CFE$K_MIN 40                    /* Minimum			CFE$_SLL */
#define CFE$K_MAX 41                    /* Maximum			CFE$_SLL */
#define CFE$K_STDEV 42                  /* Standard deviation		CFE$_SLL */
#define CFE$K_VAR 43                    /* Variance			CFE$_SLL */
#define CFE$K_CVT_TO_VALUE 44           /* Convert to value		Sequence of CFE$_EXL */
#define CFE$K_ROUND 45                  /* Round			Sequence of CFE$_EXL */
#define CFE$K_TRUNCATE 46               /* Truncate			Sequence of CFE$_EXL */
#define CFE$K_INT 47                    /* Integerize			Sequence of CFE$_EXL */
#define CFE$K_ISERROR 48                /* Is error			Sequence of CFE$_EXL */
#define CFE$K_ISBLANK 49                /* Is blank			Sequence of CFE$_EXL */
#define CFE$K_ISNULL 50                 /* Is null			Sequence of CFE$_EXL */
#define CFE$K_ISDATE 51                 /* Is date			Sequence of CFE$_EXL */
#define CFE$K_ISNUMBER 52               /* Is number			Sequence of CFE$_EXL */
#define CFE$K_ISSTRING 53               /* Is string			Sequence of CFE$_EXL */
#define CFE$K_ISREF 54                  /* Is referenced		Sequence of CFE$_EXL */
#define CFE$K_STR_CHAR 55               /* String character		Sequence of CFE$_EXL */
#define CFE$K_STR_CODE 56               /* String character code	Sequence of CFE$_EXL */
#define CFE$K_STR_CONCAT 57             /* String concatenate		Sequence of CFE$_EXL */
#define CFE$K_STR_EXTRACT 58            /* String extract		Sequence of CFE$_EXL */
#define CFE$K_STR_FIND 59               /* String find substring	Sequence of CFE$_EXL */
#define CFE$K_STR_FIXED 60              /* String fixed			Sequence of CFE$_EXL */
#define CFE$K_STR_FORMAT 61             /* String edit			CFE$_STF */
#define CFE$K_STR_LEFT 62               /* Extract substring left	Sequence of CFE$_EXL */
#define CFE$K_STR_LENGTH 63             /* String length		Sequence of CFE$_EXL */
#define CFE$K_STR_LOWER 64              /* String lowercase		Sequence of CFE$_EXL */
#define CFE$K_STR_PRETTY 65             /* String pretty		CFE$_STP */
#define CFE$K_STR_PROPER 66             /* String proper		Sequence of CFE$_EXL */
#define CFE$K_STR_REPEAT 67             /* String repeat		Sequence of CFE$_EXL */
#define CFE$K_STR_REPLACE 68            /* String replace		Sequence of CFE$_EXL */
#define CFE$K_STR_REVERSE 69            /* String reverse		Sequence of CFE$_EXL */
#define CFE$K_STR_RIGHT 70              /* Extract substring right	Sequence of CFE$_EXL */
#define CFE$K_STR_TRIM 71               /* String trim			Sequence of CFE$_EXL */
#define CFE$K_STR_UPPER 72              /* String uppercase		Sequence of CFE$_EXL */
#define CFE$K_CHOOSE 73                 /* Choose			Sequence of CFE$_EXL */
#define CFE$K_INDEX 74                  /* Index			Sequence of CFE$_EXL */
#define CFE$K_VLOOKUP 75                /* Vertical lookup		Sequence of CFE$_EXL */
#define CFE$K_HLOOKUP 76                /* Horizontal lookup		Sequence of CFE$_EXL */
#define CFE$K_TABLE 77                  /* Table			Sequence of CFE$_EXL */
#define CFE$K_NAME_DAY 78               /* Date day of the week		Sequence of CFE$_EXL */
#define CFE$K_NAME_MONTH 79             /* Date month name		Sequence of CFE$_EXL */
#define CFE$K_NAME_DAYNUM 80            /* Day of the week		Sequence of CFE$_EXL */
#define CFE$K_NAME_MONTHNUM 81          /* Month name			Sequence of CFE$_EXL */
#define CFE$K_NOW 82                    /* Now				None */
#define CFE$K_TODAY 83                  /* Today			None */
#define CFE$K_TOMORROW 84               /* Tomorrow			None */
#define CFE$K_YESTERDAY 85              /* Yesterday			None */
#define CFE$K_EXT_DAY 86                /* Extract day			Sequence of CFE$_EXL */
#define CFE$K_EXT_MONTH 87              /* Extract month		Sequence of CFE$_EXL */
#define CFE$K_EXT_YEAR 88               /* Extract year			Sequence of CFE$_EXL */
#define CFE$K_EXT_HOUR 89               /* Extract hour			Sequence of CFE$_EXL */
#define CFE$K_EXT_MINUTE 90             /* Extract minute		Sequence of CFE$_EXL */
#define CFE$K_EXT_SECOND 91             /* Extract second		Sequence of CFE$_EXL */
#define CFE$K_DIFF_DAY 92               /* Difference day		Sequence of CFE$_EXL */
#define CFE$K_DIFF_WEEK 93              /* Difference week		Sequence of CFE$_EXL */
#define CFE$K_DIFF_MONTH 94             /* Difference month		Sequence of CFE$_EXL */
#define CFE$K_DIFF_YEAR 95              /* Difference year		Sequence of CFE$_EXL */
#define CFE$K_DIFF_HOUR 96              /* Difference hour		Sequence of CFE$_EXL */
#define CFE$K_DIFF_MIN 97               /* Difference minute		Sequence of CFE$_EXL */
#define CFE$K_DIFF_SEC 98               /* Difference second		Sequence of CFE$_EXL */
#define CFE$K_CVT_TO_DATE 99            /* String to date		Sequence of CFE$_EXL */
#define CFE$K_CVT_TO_TIME 100           /* String to time		Sequence of CFE$_EXL */
#define CFE$K_PLUS_DAYS 101             /* Plus days			Sequence of CFE$_EXL */
#define CFE$K_PLUS_WEEKS 102            /* Plus weeks			Sequence of CFE$_EXL */
#define CFE$K_PLUS_MONTHS 103           /* Plus months			Sequence of CFE$_EXL */
#define CFE$K_PLUS_YEARS 104            /* Plus years			Sequence of CFE$_EXL */
#define CFE$K_PLUS_HOURS 105            /* Plus hours			Sequence of CFE$_EXL */
#define CFE$K_PLUS_MINS 106             /* Plus minutes			Sequence of CFE$_EXL */
#define CFE$K_PLUS_SECS 107             /* Plus seconds			Sequence of CFE$_EXL */
#define CFE$K_ERROR 108                 /* Error			None */
#define CFE$K_NULL 109                  /* Null				None */
#define CFE$K_CUR_ROW 110               /* Current row			None */
#define CFE$K_CUR_COL 111               /* Current column		None */
#define CFE$K_CUR_CELL 112              /* Current cell			None */
#define CFE$K_CELL_ROW 113              /* Row portion of cell name	Sequence of CFE$_EXL */
#define CFE$K_CELL_COL 114              /* Column portion of cell name	Sequence of CFE$_EXL */
#define CFE$K_CELL_NAME 115             /* Constructed cell reference	Sequence of CFE$_EXL */
#define CFE$K_COUNT_ROWS 116            /* Count rows			Sequence of CFE$_EXL */
#define CFE$K_COUNT_COLS 117            /* Count columns		Sequence of CFE$_EXL */
#define CFE$K_CELL_EXTRACT 118          /* Cell extract			Sequence of CFE$_EXL */
#define CFE$K_APPREC 119                /* Appreciation			Sequence of CFE$_EXL */
#define CFE$K_DEP_CROSS 120             /* Depreciation declining balance crossover	Sequence of CFE$_EXL */
#define CFE$K_DEP_DB 121                /* Depreciation declining balance	Sequence of CFE$_EXL */
#define CFE$K_DEP_DDB 122               /* Depreciation double declining balance	Sequence of CFE$_EXL */
#define CFE$K_DEP_SLINE 123             /* Depreciation straight line	Sequence of CFE$_EXL */
#define CFE$K_DEP_SOYD 124              /* Depreciation sum of years	Sequence of CFE$_EXL */
#define CFE$K_DISCOUNT 125              /* Discount			Sequence of CFE$_EXL */
#define CFE$K_FV 126                    /* Future value			Sequence of CFE$_EXL */
#define CFE$K_FVA 127                   /* Future value of annuity	Sequence of CFE$_EXL */
#define CFE$K_FVPV 128                  /* Future value of single payment	Sequence of CFE$_EXL */
#define CFE$K_INTEREST 129              /* Interest payments		Sequence of CFE$_EXL */
#define CFE$K_IRR 130                   /* Internal rate of return	Sequence of CFE$_EXL */
#define CFE$K_MIRR 131                  /* Modified internal rate of return	Sequence of CFE$_EXL */
#define CFE$K_NPV 132                   /* Net present value		Sequence of CFE$_EXL */
#define CFE$K_PAYBACK 133               /* Payback			Sequence of CFE$_EXL */
#define CFE$K_PERPMT 134                /* Number periods to achieve future value	Sequence of CFE$_EXL */
#define CFE$K_PERPV 135                 /* Number periods given present value		Sequence of CFE$_EXL */
#define CFE$K_PMTPV 136                 /* Payment per period given present value	Sequence of CFE$_EXL */
#define CFE$K_PMTFV 137                 /* Payment per period to achieve future value	Sequence of CFE$_EXL */
#define CFE$K_PRINCIPAL 138             /* Principal			Sequence of CFE$_EXL */
#define CFE$K_PVA 139                   /* Present value of annuity	Sequence of CFE$_EXL */
#define CFE$K_PVFV 140                  /* Present value to achieve future value	Sequence of CFE$_EXL */
#define CFE$K_RATE 141                  /* Interest rate		Sequence of CFE$_EXL */
#define CFE$K_LOGEST 142                /* LogEst			Sequence of CFE$_EXL */
#define CFE$K_LSQR 143                  /* Least squares		Sequence of CFE$_EXL */
#define CFE$K_INTEGRATE 144             /* Integrate			Sequence of CFE$_EXL */
#define CFE$K_SIGMA 145                 /* Sigma			Sequence of CFE$_EXL */
#define CFE$K_TREND 146                 /* Trend			Sequence of CFE$_EXL */
#define CFE$K_LIT_TRUE 147              /* Literal true			None */
#define CFE$K_LIT_FALSE 148             /* Literal false		None */
#define CFE$K_LIT_PI 149                /* Literal pi			None */
#define CFE$K_RANDOM_U 150              /* Random number, uniformly distributed		None */
#define CFE$K_DECIMAL_STRING 151        /* Decimal string		String */
#define CFE$K_IN_TABLE 152              /* Field in table			Sequence of CFE$_EXL */
#define CFE$K_SIN 153                   /* Sine				Sequence of CFE$_EXL */
#define CFE$K_COS 154                   /* Cosine			Sequence of CFE$_EXL */
#define CFE$K_TAN 155                   /* Tangent			Sequence of CFE$_EXL */
#define CFE$K_ASIN 156                  /* Arc sine			Sequence of CFE$_EXL */
#define CFE$K_ACOS 157                  /* Arc cosine			Sequence of CFE$_EXL */
#define CFE$K_ATAN 158                  /* Arc tangent			Sequence of CFE$_EXL */
#define CFE$K_ATAN2 159                 /* Arc tangent 2		Sequence of CFE$_EXL */
#define CFE$K_LOG10 160                 /* Common logarithm		Sequence of CFE$_EXL */
#define CFE$K_LOGN 161                  /* Natural logarithm		Sequence of CFE$_EXL */
#define CFE$K_ALOG 162                  /* Antilogarithm		Sequence of CFE$_EXL */
#define CFE$K_FACTORIAL 163             /* Factorial			Sequence of CFE$_EXL */
#define CFE$K_ASL 164                   /* Arithmetic shift left	Sequence of CFE$_EXL */
#define CFE$K_ASR 165                   /* Arithmetic shift right	Sequence of CFE$_EXL */
#define CFE$K_ONES_CMP 166              /* Ones complement		Sequence of CFE$_EXL */
#define CFE$K_SIGN 167                  /* Sign				Sequence of CFE$_EXL */
#define CFE$K_CONTAINS 168              /* Contains substring		Sequence of CFE$_EXL */
#define CFE$K_MATCHES 169               /* Matches			Sequence of CFE$_EXL */
#define CFE$K_STARTS 170                /* String starts with		Sequence of CFE$_EXL */
#define CFE$K_UNARY_PLUS 171            /* Unary plus			Sequence of CFE$_EXL */
#define CFE$K_PERCENT 172               /* Percent			Sequence of CFE$_EXL */
#define CFE$K_ISNOT_AVAIL 173           /* Is not available		Sequence of CFE$_EXL */
#define CFE$K_ISNOT_CALC 174            /* Is not calculatable		Sequence of CFE$_EXL */
#define CFE$K_NOT_AVAIL 175             /* Not available		None */
#define CFE$K_NOT_CALC 176              /* Not calculatable		None */
#define CFE$K_CELL_INDIRECT 177         /* Cell indirection		Sequence of CFE$_EXL */
#define CFE$K_PERFV 178                 /* Periods to achieve future value	Sequence of CFE$_EXL */
#define CFE$K_CURRENT_VALUE 179         /* Current value		None */
#define CFE$K_IDENTIFIER 180            /* Identifier			CFE$_TXC */
#define CFE$K_PRIVATE_FUNCTION 181      /* Private function		CFE$_PFE */
#define CFE$K_FIELD_REFERENCE 182       /* Field reference		CFE$_FRF */
/* Item codes for Selector List aggregate.                                  */
#define CFE$_SLL_CRITERIA 262913        /* Criteria			Sequence of CFE$_EXL */
#define CFE$_SLL_SELECTION 262914       /* Selection			Sequence of CFE$_EXL */
#define CFE$_SLL_MAX 262915             /* Maximum code plus 1              */
/* Item codes for Complex Float aggregate.                                  */
#define CFE$_CFT_REAL_PART 263169       /* Real part			General floating point */
#define CFE$_CFT_IMAGINARY_PART 263170  /* Imaginary part		General floating point */
#define CFE$_CFT_MAX 263171             /* Maximum code plus 1              */
/* Item codes for Date and Time aggregate.                                  */
#define CFE$_DAT_DATETIME 263425        /* Date and time		String */
#define CFE$_DAT_TIME_DIFF_C 263426     /* Time difference		Enumeration */
#define CFE$_DAT_TIME_DIFF 263427       /*				Variable */
#define CFE$_DAT_MAX 263428             /* Maximum code plus 1              */
/* Values of CFE$_DAT_TIME_DIFF_C.                                          */
#define CFE$K_UTC_TIME 0                /* UTC time			None */
#define CFE$K_PLUS_DIFF 1               /* Positive difference		String */
#define CFE$K_NEG_DIFF 2                /* Negative difference		String */
/* Item codes for Text Choice aggregate.                                    */
#define CFE$_TXC_TEXT_C 263681          /* Text choice			Enumeration */
#define CFE$_TXC_TEXT 263682            /*				Variable */
#define CFE$_TXC_MAX 263683             /* Maximum code plus 1              */
/* Values of CFE$_TXC_TEXT_C.                                               */
#define CFE$K_LATIN1_TEXT 0             /* Latin-1 text			String */
#define CFE$K_SIMPLE_TEXT 1             /* Simple text			Character string */
#define CFE$K_COMPLEX_TEXT 2            /* Complex text			Array of character string */
/* Item codes for Varying Text Aggregate.                                   */
#define CFE$_VTX_VTEXT_LEN 263937       /* Varying Text Length		Integer */
#define CFE$_VTX_VTEXT_STR 263938       /* Varying Text String		Character-String */
#define CFE$_VTX_MAX 263939             /* Maximum code plus 1              */
/* Item codes for Field Reference aggregate.                                */
#define CFE$_FRF_FIELD_CONTEXT 264193   /* Field context		String */
#define CFE$_FRF_PATH 264194            /* Path				Array of string */
#define CFE$_FRF_MAX 264195             /* Maximum code plus 1              */
/* Item codes for Parenthesized Expression aggregate.                       */
#define CFE$_PEX_BEGIN_EXPR 264449      /* Begin expression 		Array of character string */
#define CFE$_PEX_VALUE_EXPR 264450      /* Value expression		Sequence of CFE$_EXL */
#define CFE$_PEX_END_EXPR 264451        /* End expression		Array of character string */
#define CFE$_PEX_MAX 264452             /* Maximum code plus 1              */
/* Item codes for Private Function Expression aggregate.                    */
#define CFE$_PFE_FACILITY 264705        /* Facility			String */
#define CFE$_PFE_NAME 264706            /* Function name		String */
#define CFE$_PFE_REF_LABEL 264707       /* Reference label		String */
#define CFE$_PFE_REF_LABEL_TYPE 264708  /* Reference label type		String with add-info */
#define CFE$_PFE_RETURN_TYPE 264709     /* Return type			Longword */
#define CFE$_PFE_PARAMS 264710          /* Parameters			Sequence of CFE$_NPM */
#define CFE$_PFE_MAX 264711             /* Maximum code plus 1              */
/* Values of the add-info parameter for CFE$_PFE_REF_LABEL_TYPE.            */
#define CFE$K_PRIVATE_LABEL_TYPE 0      /* Private label type               */
#define CFE$K_RMS_LABEL_TYPE 1          /* RMS file specification ("$RMS")  */
#define CFE$K_UTX_LABEL_TYPE 2          /* ULTRIX file specification ("$UTX") */
#define CFE$K_MDS_LABEL_TYPE 3          /* MS-DOS or OS/2 file specification ("$MDS") */
/* Bit definitions for CFE$_PFE_RET_TYPE.                                   */
#define cfe$m_pfe_fncret_numeric 1
#define cfe$m_pfe_fncret_boolean 2
#define cfe$m_pfe_fncret_date 4
#define cfe$m_pfe_fncret_text 8
struct pfe_type {
    unsigned cfe$v_pfe_fncret_numeric : 1;
    unsigned cfe$v_pfe_fncret_boolean : 1;
    unsigned cfe$v_pfe_fncret_date : 1;
    unsigned cfe$v_pfe_fncret_text : 1;
    unsigned cfe$v_pfe_fill : 28;
    } ;
/* Item codes for String Format aggregate.                                  */
#define CFE$_STF_SOURCE 264961          /* Source			Sequence of CFE$_EXL */
#define CFE$_STF_EDIT_STRING 264962     /* Edit string			ESF$_EDS */
#define CFE$_STF_MAX 264963             /* Maximum code plus 1              */
/* Item codes for String Pretty aggregate.                                  */
#define CFE$_STP_STRING_EXPR 265217     /* String expression		Sequence of CFE$_EXL */
#define CFE$_STP_PRETTY_FLAGS 265218    /* Flags			Longword */
#define CFE$_STP_MAX 265219             /* Maximum code plus 1              */
/* Bit definitions for CFE$_STP_PRETTY_FLAGS.                               */
#define cfe$m_pretty_collapse 1
#define cfe$m_pretty_compress 2
#define cfe$m_pretty_lowercase 4
#define cfe$m_pretty_trim 8
#define cfe$m_pretty_uncomment 16
#define cfe$m_pretty_upcase 32
struct stp_pretty_flags {
    unsigned cfe$v_pretty_collapse : 1;
    unsigned cfe$v_pretty_compress : 1;
    unsigned cfe$v_pretty_lowercase : 1;
    unsigned cfe$v_pretty_trim : 1;
    unsigned cfe$v_pretty_uncomment : 1;
    unsigned cfe$v_pretty_upcase : 1;
    unsigned cfe$v_pretty_fill_1 : 26;
    } ;
/* Item codes for Named Parameter aggregate.                                */
#define CFE$_NPM_NAME 265473            /* Parameter name		String */
#define CFE$_NPM_VALUE 265474           /* Parameter value		Sequence of CFE$_EXL */
#define CFE$_NPM_MAX 265475             /* Maximum code plus 1              */
/* Item codes for Cell Coordinates aggregate.                               */
#define CFE$_CCD_ROW 265729             /* Row number			Integer */
#define CFE$_CCD_COLUMN 265730          /* Column number		Integer */
#define CFE$_CCD_FLAGS 265731           /* Flags			Enumeration */
#define CFE$_CCD_MAX 265732             /* Maximum code plus 1              */
/* Values of CFE$_CCD_FLAGS.						DTIF defined */
#define CFE$K_RELROW_RELCOL 0           /* Relative row, relative column    */
#define CFE$K_RELROW_ABSCOL 1           /* Relative row, absolute column    */
#define CFE$K_ABSROW_RELCOL 2           /* Absolute row, relative column    */
#define CFE$K_ABSROW_ABSCOL 3           /* Absolute row, absolute column    */
/* Item codes for Cell Range aggregate.                                     */
#define CFE$_CLR_RANGE_BEGIN 265985     /* Beginning cell coordinates	CFE$_CCD */
#define CFE$_CLR_RANGE_END 265986       /* Ending cell coordinates	CFE$_CCD */
#define CFE$_CLR_MAX 265987             /* Maximum code plus 1              */
/* Item codes for Row Range aggregate.                                      */
#define CFE$_RWR_ROW_BEGIN 266241       /* Beginning row number		Integer */
#define CFE$_RWR_ROW_END 266242         /* Ending row number		Integer */
#define CFE$_RWR_MAX 266243             /* Maximum code plus 1              */
/* Item codes for Column Range aggregate.                                   */
#define CFE$_COR_COL_BEGIN 266497       /* Beginning column number	Integer */
#define CFE$_COR_COL_END 266498         /* Ending column number		Integer */
#define CFE$_COR_MAX 266499             /* Maximum code plus 1              */
/* Header file modified for bigendian by BigEndian_H. */
/*	Run on Mon Dec  5 15:50:02 1994
 */
/********************************************************************************************************************************/
/* Created  5-DEC-1994 15:48:55 by VAX SDL V3.2-10     Source: 24-MAR-1992 14:27:11 DECW$LIBSRESD:[CDALIB.SRC]DTIFDEF.SDL;1 */
/********************************************************************************************************************************/
/*** MODULE DTIF_DEFINITIONS IDENT V1-001 ***/
#ifndef _dtifdef_
#define _dtifdef_
/*++                                                                        */
/*  COPYRIGHT (c) 1988, 1992 BY                                             */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.                  */
/*  ALL RIGHTS RESERVED.                                                    */
/*                                                                          */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   */
/*  ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   */
/*  OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY   */
/*  TRANSFERRED.                                                            */
/*                                                                          */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT   */
/*  CORPORATION.                                                            */
/*                                                                          */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 */
/*                                                                          */
/* Item codes for cda_create_root_aggregate processing-options parameter.   */
#define DTIF_INHERIT_ATTRIBUTES 513     /* Inherit attributes to cols, rows, cells, etc. */
#define DTIF_INHERIT_ATTR_TO_ROW_COL 514 /* Inherit only to row-col level   */
#define DTIF_INHERIT_ATTR_FROM_ROW_COL 515 /* Inherit only from row-col level to cells */
#define DTIF_RETAIN_DEFINITIONS 516     /* Enable cda_find_definition       */
/* Scope codes for the cda_enter_scope and cda_leave_scope scope-code parameter. */
/* If an aggregate type is listed, it must be presented with CDA$ENTER_SCOPE. */
#define DTIF_K_DOCUMENT_SCOPE 512       /* Document scope                   */
#define DTIF_K_TABLE_SCOPE 513          /* Table scope			DTIF_TBL */
#define DTIF_K_ROW_SCOPE 514            /* Row scope			DTIF_ROW */
#define DTIF_K_CELLS_SCOPE 515          /* Cells scope                      */
/* Aggregate type codes for DTIF (Digital Table Interchange Format).        */
#define DTIF_DTF 513                    /* DTIF document root               */
#define DTIF_DSC 514                    /* Document descriptor              */
#define DTIF_HDR 515                    /* Document header                  */
#define DTIF_DAT 516                    /* Date and time                    */
#define DTIF_ERF 517                    /* External reference               */
#define DTIF_LPT 518                    /* Language preference table        */
#define DTIF_NVL 519                    /* Named value                      */
#define DTIF_NES 520                    /* Named edit string                */
#define DTIF_CAT 521                    /* Column attributes                */
#define DTIF_TBL 522                    /* Table definition                 */
#define DTIF_TMD 523                    /* Table metadata                   */
#define DTIF_WND 524                    /* Window definition                */
#define DTIF_ROW 525                    /* Row definition                   */
#define DTIF_CLD 526                    /* Cell data                        */
#define DTIF_VTX 527                    /* Varying text                     */
#define DTIF_ARD 528                    /* Array definition                 */
#define DTIF_CFT 529                    /* Complex float                    */
#define DTIF_FMI 530                    /* Format information               */
#define DTIF_CCD 531                    /* Cell coordinates                 */
#define DTIF_RNG 532                    /* Range definition                 */
#define DTIF_CLR 533                    /* Cell range                       */
#define DTIF_RWR 534                    /* Row range                        */
#define DTIF_COR 535                    /* Column range                     */
#define DTIF_NMR 536                    /* Named range                      */
#define DTIF_EXT 537                    /* External                         */
#define DTIF_RSQ 538                    /* Repeat sequence                  */
#define DTIF_FMC 539                    /* Format condition                 */
#define DTIF_RLT 540                    /* Relative time                    */
#define DTIF_ECC 541                    /* External cell coordinates        */
#define DTIF_ECR 542                    /* External cell range              */
#define DTIF_ENR 543                    /* External named range             */
#define DTIF_REF 544                    /* Reference                        */
#define DTIF_MAX 545                    /* Maximum code plus 1              */
/* Item codes for all aggregates.  DTIF_AGGREGATE_TYPE is read-only.        */
#define DTIF_USER_CONTEXT 1             /* User context	    		Longword */
#define DTIF_AGGREGATE_TYPE 2           /* Aggregate type code		Word */
#define DTIF_ALL_MAX 3                  /* Maximum code plus 1              */
/* Values for items of type 'Measurement enumeration' .                     */
#define DTIF_K_VALUE_CONSTANT 0         /*				Integer */
/*	VALUE_VARIABLE							String [Reserved for future use.] */
/* Item codes for DTIF Document Root aggregate.                             */
#define DTIF_DTF_DESCRIPTOR 131329      /* Document descriptor		DTIF_DSC */
#define DTIF_DTF_HEADER 131330          /* Document header		DTIF_HDR */
#define DTIF_DTF_TABLES 131331          /* Tables			Sequence of DTIF_TBL */
#define DTIF_DTF_MAX 131332             /* Maximum code plus 1              */
/* Item codes for Document Descriptor aggregate.  During cda_put_aggregate, the values of DTIF_DSC_ENCODE_MAJOR_VERSION and */
/* DTIF_DSC_ENCODE_MINOR_VERSION are not used.  The document always contains the current values for major and minor version. */
#define DTIF_DSC_MAJOR_VERSION 131585   /* Creator major version	Integer */
#define DTIF_DSC_MINOR_VERSION 131586   /* Creator minor version	Integer */
#define DTIF_DSC_PRODUCT_IDENTIFIER 131587 /* Product identifier		String */
#define DTIF_DSC_PRODUCT_NAME 131588    /* Product name			Array of character string */
#define DTIF_DSC_ENCODE_MAJOR_VERSION 131589 /* Encoding major version	Integer */
#define DTIF_DSC_ENCODE_MINOR_VERSION 131590 /* Encoding minor version	Integer */
#define DTIF_DSC_MAX 131591             /* Maximum code plus 1              */
/* Current values for major and minor encoding version.                     */
#define DTIF_K_MAJOR_VERSION 1
#define DTIF_K_MINOR_VERSION 4
/* Item codes for Document Header aggregate.                                */
#define DTIF_HDR_PRIVATE_DATA 131841    /* Private header data		Sequence of DTIF_NVL */
#define DTIF_HDR_TITLE 131842           /* Title			Array of character string */
#define DTIF_HDR_DATE 131843            /* Date				DTIF_DAT */
#define DTIF_HDR_EXTERNAL_REFERENCES 131844 /* External references		Sequence of DTIF_ERF */
#define DTIF_HDR_LANGUAGES_C 131845     /* Languages			Array of enumeration */
#define DTIF_HDR_LANGUAGES 131846       /*				Array of variable */
#define DTIF_HDR_LANGUAGE_PREF_TABLES 131847 /* Language preference tables	Sequence of DTIF_LPT */
#define DTIF_HDR_GENERIC_COLUMNS 131848 /* Generic column attributes	Sequence of DTIF_CAT */
#define DTIF_HDR_GENERAL_TEXT_CCS_C 131849 /* General text coded char.set  Array of enumeration */
#define DTIF_HDR_GENERAL_TEXT_CCS 131850 /*				Array of variable */
#define DTIF_HDR_PATTERN_LIST 131851    /* Pattern definition list	Sequence of DDIF_PTD */
#define DTIF_HDR_FONT_LIST 131852       /* Font definition list		Sequence of DDIF_FTD */
#define DTIF_HDR_DOC_RANGES 131853      /* Range definition list	Sequence of DTIF_RNG */
#define DTIF_HDR_MAX 131854             /* Maximum code plus 1              */
/* Values of DTIF_HDR_LANGUAGES_C.                                          */
#define DTIF_K_ISO_639_LANGUAGE 0       /* ISO 639 language name	String */
#define DTIF_K_OTHER_LANGUAGE 1         /* Other language name		Character string */
/* Values of DTIF_HDR_GENERAL_TEXT_CCS_C.                                   */
#define DTIF_K_CCS_VACANT 1             /* Vacant			None (null string) */
#define DTIF_K_CCS_UNKNOWN 2            /* Unknown			String */
#define DTIF_K_CCS_ASCII_GL 3           /* ASCII gl			String */
#define DTIF_K_CCS_1_OCTET 4            /* One octet			String */
#define DTIF_K_CCS_2_OCTET 5            /* Two octets			String */
#define DTIF_K_CCS_4_OCTET 6            /* Four octets			String */
/* Item codes for Date and Time aggregate.                                  */
#define DTIF_DAT_DATETIME 132097        /* Date and time		String */
#define DTIF_DAT_TIME_DIFF_C 132098     /* Time difference		Enumeration */
#define DTIF_DAT_TIME_DIFF 132099       /*				Variable */
#define DTIF_DAT_MAX 132100             /* Maximum code plus 1              */
/* Values of DTIF_DAT_TIME_DIFF_C.                                          */
#define DTIF_K_UTC_TIME 0               /* UTC time			None */
#define DTIF_K_PLUS_DIFF 1              /* Positive difference		String */
#define DTIF_K_NEG_DIFF 2               /* Negative difference		String */
/* Item codes for External Reference aggregate.                             */
#define DTIF_ERF_DATA_TYPE 132353       /* Data type			Object identifier */
#define DTIF_ERF_DESCRIPTOR 132354      /* Descriptor			Array of character string */
#define DTIF_ERF_LABEL 132355           /* Label			Character string */
#define DTIF_ERF_LABEL_TYPE 132356      /* Label type			String with add-info */
#define DTIF_ERF_CONTROL 132357         /* Control			Enumeration */
#define DTIF_ERF_MAX 132358             /* Maximum code plus 1              */
/* Values of the add-info parameter for DTIF_ERF_LABEL_TYPE.  Must be identical */
/* to values for DDIF_ERF_LABEL_TYPE and DOTS_RTE_NAME_TYPE.                */
#define DTIF_K_PRIVATE_LABEL_TYPE 0     /* Private label type               */
#define DTIF_K_RMS_LABEL_TYPE 1         /* RMS file specification ("$RMS")  */
#define DTIF_K_UTX_LABEL_TYPE 2         /* ULTRIX file specification ("$UTX") */
#define DTIF_K_MDS_LABEL_TYPE 3         /* MS-DOS file specification ("$MDS") */
#define DTIF_K_STYLE_LABEL_TYPE 4       /* Style file specification ("$STYLE") */
#define DTIF_K_OS2_LABEL_TYPE 5         /* OS/2 file specification ("$OS2") */
#define DTIF_K_OA_LABEL_TYPE 6          /* ALL-IN-1 file specification ("$OA") */
#define DTIF_K_PACKED_STYLE_LABEL_TYPE 7 /* Style-guide file specification ("$STYLE") (used when */
/* NO_COPY style guide packed by DOTS)                                      */
/* Values of DTIF_ERF_CONTROL.						DTIF conforming */
#define DTIF_K_COPY_REFERENCE 1         /* Copy on reference                */
#define DTIF_K_NO_COPY_REFERENCE 2      /* No copy on reference             */
/* Item codes for Language Preference Table aggregate.                      */
#define DTIF_LPT_LANGUAGE_INDEX 132609  /* Language index		Integer */
#define DTIF_LPT_APPL_PRIVATE 132610    /* Application private		Sequence of DTIF_NVL */
#define DTIF_LPT_ITEMS 132611           /* Named items			Sequence of DTIF_NVL */
#define DTIF_LPT_EDITSTRS 132612        /* Named edit strings		Sequence of DTIF_NES */
#define DTIF_LPT_COLLATE_SEQ 132613     /* Collating sequence		String with add-info */
#define DTIF_LPT_COLLATE_TABLE 132614   /* Collating table		String */
#define DTIF_LPT_MAX 132615             /* Maximum code plus 1              */
/* Values of the add-info parameter for DTIF_LPT_COLLATE_SEQ.               */
#define DTIF_K_PRIVATE_COLLATE_SEQ 0    /* Private collating sequence       */
#define DTIF_K_ASCII_COLLATE_SEQ 1      /* ASCII collating sequence ("$ASCII") */
#define DTIF_K_MCS_COLLATE_SEQ 2        /* DEC Multinational collating sequence ("$MCS") */
#define DTIF_K_DANISH_COLLATE_SEQ 3     /* Danish collating sequence ("$DANISH") */
#define DTIF_K_FINSWD_COLLATE_SEQ 4     /* Finnish/Swedish collating sequence ("$FINSWD") */
#define DTIF_K_NORWEG_COLLATE_SEQ 5     /* Norwegian collating sequence ("$NORWEG") */
#define DTIF_K_SPANSH_COLLATE_SEQ 6     /* Spanish collating sequence ("$SPANSH") */
/* Item codes for Named Value aggregate.                                    */
#define DTIF_NVL_NAME 132865            /* Value name			String */
#define DTIF_NVL_VALUE_C 132866         /* Value data			Enumeration */
#define DTIF_NVL_VALUE 132867           /* 				Variable */
#define DTIF_NVL_REFERENCE_ERF_INDEX 132868 /*				Integer */
#define DTIF_NVL_MAX 132869             /* Maximum code plus 1              */
/* Values of DTIF_NVL_VALUE_C.                                              */
#define DTIF_K_VALUE_BOOLEAN 0          /*				Boolean */
#define DTIF_K_VALUE_INTEGER 1          /*				Integer */
#define DTIF_K_VALUE_TEXT 2             /*				Array of character string */
#define DTIF_K_VALUE_GENERAL 3          /*				String */
#define DTIF_K_VALUE_LIST 4             /*				Sequence of DTIF_NVL */
#define DTIF_K_VALUE_EXTERNAL 5         /*				DTIF_EXT */
#define DTIF_K_VALUE_FLOAT 6            /*				General floating point */
#define DTIF_K_VALUE_DATE 7             /*				DTIF_DAT */
#define DTIF_K_VALUE_EXPR 8             /*				CFE_EXP */
#define DTIF_K_VALUE_RELTIME 9          /*				DTIF_RLT */
#define DTIF_K_VALUE_DDIF_DOC 10        /*				DDIF_DDF */
#define DTIF_K_VALUE_DTIF_DOC 11        /*				DTIF_DTF */
#define DTIF_K_VALUE_REFERENCE 12       /*				String (& DTIF_NVL_REFERENCE_ERF_INDEX used) */
/* Item codes for Named Edit String aggregate.                              */
#define DTIF_NES_NAME 133121            /* Name				String */
#define DTIF_NES_DEFN 133122            /* Definition			ESF_EDS */
#define DTIF_NES_MAX 133123             /* Maximum code plus 1              */
/* Item codes for Column Attributes aggregate.                              */
#define DTIF_CAT_NAME 133377            /* Name				String */
#define DTIF_CAT_ID 133378              /* Identifier			Integer */
#define DTIF_CAT_APPL_PRIVATE 133379    /* Application private		Sequence of DTIF_NVL */
#define DTIF_CAT_GENERIC_REF 133380     /* Generic reference		Integer */
#define DTIF_CAT_DESCRIPTION 133381     /* Description			Array of character string */
#define DTIF_CAT_FORMATS 133382         /* Format information list	Sequence of DTIF_FMI */
#define DTIF_CAT_COMPUTED_BY 133383     /* Computed by expression	CFE_EXP */
#define DTIF_CAT_DEFAULT_VALUE_C 133384 /* Default value		Enumeration */
#define DTIF_CAT_DEFAULT_VALUE 133385   /*				Variable */
#define DTIF_CAT_MISSING_VALUE_C 133386 /* Missing value		Enumeration */
#define DTIF_CAT_MISSING_VALUE 133387   /*				Variable */
#define DTIF_CAT_QUERY_NAME 133388      /* Query name			Character string */
#define DTIF_CAT_COLUMN_HDR 133389      /* Column header		Character string */
#define DTIF_CAT_POSITION 133390        /* Position  			Integer		*** OBSOLETE *** */
#define DTIF_CAT_DATA_TYPE 133391       /* Data type			Enumeration */
#define DTIF_CAT_DATA_LENGTH 133392     /* Data length (bytes)		Integer */
#define DTIF_CAT_SCALE_FACTOR 133393    /* Scale factor			Integer */
#define DTIF_CAT_FLAGS 133394           /* Flags			Longword */
#define DTIF_CAT_HDR_FORMAT 133395      /* Header format		DTIF_FMI */
#define DTIF_CAT_COMPUTED_SEQ 133396    /* Computed by repeating seq.   DTIF_RSQ */
#define DTIF_CAT_MAX 133397             /* Maximum code plus 1              */
/* Values of DTIF_CAT_DEFAULT_VALUE_C, DTIF_CAT_MISSING_VALUE_C, DTIF_CLD_VALUE_C, DTIF_FMC_REL_VALUE_C. */
#define DTIF_K_CV_INTEGER 0             /* Integer			Variable integer */
#define DTIF_K_CV_LATIN1_TEXT 1         /* Latin-1 text			String */
#define DTIF_K_CV_SIMPLE_TEXT 2         /* Simple text			Character string */
#define DTIF_K_CV_DATE 3                /* Date				DTIF_DAT */
#define DTIF_K_CV_SCALED_INTEGER 4      /* Scaled integer		Scaled integer */
#define DTIF_K_CV_VTEXT 5               /* Varying text 		DTIF_VTX */
#define DTIF_K_CV_ARRAY 6               /* Array definition	     	DTIF_ARD */
#define DTIF_K_CV_COMPLEX 7             /* Complex float		DTIF_CFT */
#define DTIF_K_CV_FLOAT 8               /* Float			General floating point */
#define DTIF_K_CV_BOOLEAN 9             /* Boolean			Boolean */
#define DTIF_K_CV_COMPLEX_TEXT 10       /* Complex text			Array of character string */
#define DTIF_K_CV_DDIF_DOC 11           /* DDIF Compound document	DDIF_DDF */
#define DTIF_K_CV_DTIF_DOC 12           /* DTIF Nested table            DTIF_DTF */
#define DTIF_K_CV_RELTIME 13            /* Relative time                DTIF_RLT */
#define DTIF_K_CV_EXTERNAL_DEF 14       /* External definition		DTIF_EXT */
#define DTIF_K_CV_UNKNOWN 15            /* Unknown			Sequence of DTIF_NVL */
/* Values of DTIF_CAT_DATA_TYPE and DTIF_ROW_DATA_TYPE.		     	DTIF conforming */
#define DTIF_K_DT_UNKNOWN 0             /* Unknown                          */
#define DTIF_K_DT_WORD 1                /* Signed word integer              */
#define DTIF_K_DT_LONG 2                /* Signed longword integer          */
#define DTIF_K_DT_QUAD 3                /* Signed quadword integer          */
#define DTIF_K_DT_FFLOAT 4              /* VAX F-floating                   */
#define DTIF_K_DT_DFLOAT 5              /* VAX D-floating                   */
#define DTIF_K_DT_GFLOAT 6              /* VAX G-floating                   */
#define DTIF_K_DT_HFLOAT 7              /* VAX H-floating                   */
#define DTIF_K_DT_ABSDATE 8             /* Absolute date/time               */
#define DTIF_K_DT_TEXT 9                /* Text string                      */
#define DTIF_K_DT_VTEXT 10              /* Varying text string              */
#define DTIF_K_DT_SEGSTR 11             /* Segmented string                 */
#define DTIF_K_DT_RELTIME 12            /* Relative time                    */
#define DTIF_K_DT_DDIF_DOC 13           /* DDIF Compound document           */
#define DTIF_K_DT_DTIF_DOC 14           /* DTIF Compound document           */
#define DTIF_K_DT_IEEE_S_FLOAT 15       /* IEEE S-float                     */
#define DTIF_K_DT_IEEE_D_FLOAT 16       /* IEEE D-float                     */
#define DTIF_K_DT_IEEE_SE_FLOAT 17      /* IEEE SE-float                    */
#define DTIF_K_DT_IEEE_DE_FLOAT 18      /* IEEE DE-float                    */
/* Bit definitions for DTIF_CAT_FLAGS.					DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_cat_autorecalc 0x80000000
#else
#define dtif_m_cat_autorecalc 1
#endif
#ifdef CDAbig_endian
#define dtif_m_cat_readonly 0x40000000
#else
#define dtif_m_cat_readonly 2
#endif
#ifdef CDAbig_endian
#define dtif_m_cat_annotation 0x20000000
#else
#define dtif_m_cat_annotation 4
#endif
#ifdef CDAbig_endian
#define dtif_m_cat_hidden 0x10000000
#else
#define dtif_m_cat_hidden 8
#endif
#ifdef CDAbig_endian
#define dtif_m_cat_dimension 0x8000000
#else
#define dtif_m_cat_dimension 16
#endif
struct cat_flags {
    unsigned dtif_v_cat_autorecalc : 1; /* Auto recalculate                 */
    unsigned dtif_v_cat_readonly : 1;   /* Read only                        */
    unsigned dtif_v_cat_annotation : 1; /* Annotation                       */
    unsigned dtif_v_cat_hidden : 1;     /* Hidden                           */
    unsigned dtif_v_cat_dimension : 1;  /* Dimension                        */
    unsigned dtif_v_cat_fill_0 : 11;
    unsigned dtif_v_cat_fill_1 : 16;
    } ;
/* Item codes for Table Definition aggregate.                               */
#define DTIF_TBL_MAX_COLS 133633        /* Maximum columns		Integer */
#define DTIF_TBL_MAX_ROWS 133634        /* Maximum rows			Integer */
#define DTIF_TBL_APPL_PRIVATE 133635    /* Application private		Sequence of DTIF_NVL */
#define DTIF_TBL_METADATA 133636        /* Table metadata		DTIF_TMD */
#define DTIF_TBL_WINDOWS 133637         /* Window definitions		Sequence of DTIF_WND */
#define DTIF_TBL_ROWS 133638            /* Row data			Sequence of DTIF_ROW */
#define DTIF_TBL_MAX 133639             /* Maximum code plus 1              */
/* Item codes for Table Metadata aggregate.                                 */
#define DTIF_TMD_NAME 133889            /* Name				Array of character string */
#define DTIF_TMD_ID 133890              /* Identifier			Integer */
#define DTIF_TMD_APPL_PRIVATE 133891    /* Application private		Sequence of DTIF_NVL */
#define DTIF_TMD_DESCRIPTION 133892     /* Description			Array of character string */
#define DTIF_TMD_FLAGS 133893           /* Flags			Longword */
#define DTIF_TMD_DEFAULT_FMTS 133894    /* Default formats		Sequence of DTIF_FMI */
#define DTIF_TMD_COLUMNS 133895         /* Column definitions		Sequence of DTIF_CAT */
#define DTIF_TMD_RANGES 133896          /* Range definitions		Sequence of DTIF_RNG */
#define DTIF_TMD_SYMBOLS 133897         /* Symbol definitions		Sequence of DTIF_NVL */
#define DTIF_TMD_NUM_DIMENSIONS 133898  /* Number of dimensions		Integer */
#define DTIF_TMD_NUM_VARIABLES 133899   /* Number of variables		Integer */
#define DTIF_TMD_UNITS_PER_MEASUREMENT 133900 /* Units per measurement	Integer */
#define DTIF_TMD_UNITS_NAME 133901      /* Units name			Array of character string */
#define DTIF_TMD_MAX 133902             /* Maximum code plus 1              */
/* Bit definitions for DTIF_TMD_FLAGS.					DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_tmd_autorecalc 0x80000000
#else
#define dtif_m_tmd_autorecalc 1
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_autoresort 0x40000000
#else
#define dtif_m_tmd_autoresort 2
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_calcbycol 0x20000000
#else
#define dtif_m_tmd_calcbycol 4
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_calcbyrow 0x10000000
#else
#define dtif_m_tmd_calcbyrow 8
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_calcnatural 0x8000000
#else
#define dtif_m_tmd_calcnatural 16
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_fmtbycol 0x4000000
#else
#define dtif_m_tmd_fmtbycol 32
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_fmtbyrow 0x2000000
#else
#define dtif_m_tmd_fmtbyrow 64
#endif
struct tmd_flags {
    unsigned dtif_v_tmd_autorecalc : 1;
    unsigned dtif_v_tmd_autoresort : 1;
    unsigned dtif_v_tmd_calcbycol : 1;
    unsigned dtif_v_tmd_calcbyrow : 1;
    unsigned dtif_v_tmd_calcnatural : 1;
    unsigned dtif_v_tmd_fmtbycol : 1;
    unsigned dtif_v_tmd_fmtbyrow : 1;
    unsigned dtif_v_tmd_fill_0 : 9;
    unsigned dtif_v_tmd_fill_1 : 16;
    } ;
/* Renamed flag values introduced in BX00.                                  */
#ifdef CDAbig_endian
#define dtif_m_tmd_precbycol 0x4000000
#else
#define dtif_m_tmd_precbycol 32
#endif
#ifdef CDAbig_endian
#define dtif_m_tmd_precbyrow 0x2000000
#else
#define dtif_m_tmd_precbyrow 64
#endif
/* Item codes for Window Definition aggregate.                              */
#define DTIF_WND_NAME 134145            /* Name				Array of character string */
#define DTIF_WND_ID 134146              /* Identifier			Integer */
#define DTIF_WND_APPL_PRIVATE 134147    /* Application private		Sequence of DTIF_NVL */
#define DTIF_WND_CARDINAL_NUM 134148    /* Cardinal number		Integer */
#define DTIF_WND_DESCRIPTION 134149     /* Description			Array of character string */
#define DTIF_WND_FLAGS 134150           /* Flags			Longword */
#define DTIF_WND_FORMATS 134151         /* Format definitions		Sequence of DTIF_FMI */
#define DTIF_WND_RANGES 134152          /* Range definitions		Sequence of DTIF_RNG */
#define DTIF_WND_ACTIVE_LOC 134153      /* Active location		DTIF_CCD */
#define DTIF_WND_MAX 134154             /* Maximum code plus 1              */
/* Bit definitions for DTIF_WND_FLAGS.					DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_wnd_active 0x80000000
#else
#define dtif_m_wnd_active 1
#endif
#ifdef CDAbig_endian
#define dtif_m_wnd_hidden 0x40000000
#else
#define dtif_m_wnd_hidden 2
#endif
#ifdef CDAbig_endian
#define dtif_m_wnd_formula_hidden 0x20000000
#else
#define dtif_m_wnd_formula_hidden 4
#endif
#ifdef CDAbig_endian
#define dtif_m_wnd_value_hidden 0x10000000
#else
#define dtif_m_wnd_value_hidden 8
#endif
#ifdef CDAbig_endian
#define dtif_m_wnd_colhdr_hidden 0x8000000
#else
#define dtif_m_wnd_colhdr_hidden 16
#endif
#ifdef CDAbig_endian
#define dtif_m_wnd_rowhdr_hidden 0x4000000
#else
#define dtif_m_wnd_rowhdr_hidden 32
#endif
#ifdef CDAbig_endian
#define dtif_m_wnd_lines_hidden 0x2000000
#else
#define dtif_m_wnd_lines_hidden 64
#endif
struct wnd_flags {
    unsigned dtif_v_wnd_active : 1;
    unsigned dtif_v_wnd_hidden : 1;
    unsigned dtif_v_wnd_formula_hidden : 1;
    unsigned dtif_v_wnd_value_hidden : 1;
    unsigned dtif_v_wnd_colhdr_hidden : 1;
    unsigned dtif_v_wnd_rowhdr_hidden : 1;
    unsigned dtif_v_wnd_lines_hidden : 1;
    unsigned dtif_v_wnd_fill_0 : 9;
    unsigned dtif_v_wnd_fill_1 : 16;
    } ;
/* Item codes for Row Definition aggregate.                                 */
#define DTIF_ROW_NUM 134401             /* Row number			Integer */
#define DTIF_ROW_APPL_PRIVATE 134402    /* Application private		Sequence of DTIF_NVL */
#define DTIF_ROW_FORMATS 134403         /* Format definitions		Sequence of DTIF_FMI */
#define DTIF_ROW_FLAGS 134404           /* Flags			Longword */
#define DTIF_ROW_CELLS 134405           /* Cell data		     	Sequence of DTIF_CLD */
#define DTIF_ROW_ROW_HDR 134406         /* Row header			Array of character string */
#define DTIF_ROW_HDR_FORMAT 134407      /* Row header format		DTIF_FMI */
#define DTIF_ROW_DATA_TYPE 134408       /* Row data type		Enumeration */
#define DTIF_ROW_COMPUTED_BY 134409     /* Computed by expression	CFE_EXP */
#define DTIF_ROW_COMPUTED_SEQ 134410    /* Computed by repeating seq.	DTIF_RSQ */
#define DTIF_ROW_MAX 134411             /* Maximum code plus 1              */
/* Bit definitions for DTIF_ROW_FLAGS.					DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_row_annotation 0x80000000
#else
#define dtif_m_row_annotation 1
#endif
#ifdef CDAbig_endian
#define dtif_m_row_hidden 0x40000000
#else
#define dtif_m_row_hidden 2
#endif
struct row_flags {
    unsigned dtif_v_row_annotation : 1;
    unsigned dtif_v_row_hidden : 1;
    unsigned dtif_v_row_fill_0 : 14;
    unsigned dtif_v_row_fill_1 : 16;
    } ;
/* Item codes for Cell Data aggregate.                                      */
#define DTIF_CLD_COL_NUM 134657         /* Column number		Integer */
#define DTIF_CLD_STATE 134658           /* State			Enumeration */
#define DTIF_CLD_DESCRIPTION 134659     /* Description			Array of character string */
#define DTIF_CLD_APPL_PRIVATE 134660    /* Application private		Sequence of DTIF_NVL */
#define DTIF_CLD_FORMATS 134661         /* Format definitions		Sequence of DTIF_FMI */
#define DTIF_CLD_VALUE_C 134662         /* Cell value			Enumeration */
#define DTIF_CLD_VALUE 134663           /*				Variable */
#define DTIF_CLD_FORMULA_CFE 134664     /* Cell formula			CFE_EXP */
#define DTIF_CLD_MAX 134665             /* Maximum code plus 1              */
/* Values of DTIF_CLD_STATE, DTIF_FMC_STATE.		    		DTIF conforming */
#define DTIF_K_CS_ISVALUE 0
#define DTIF_K_CS_ISNULL 1
#define DTIF_K_CS_ISERROR 2
#define DTIF_K_CS_ISNOVALUE 3
#define DTIF_K_CS_ISUNDERFLOW 10
#define DTIF_K_CS_ISOVERFLOW 11
#define DTIF_K_CS_ISUNDEFREF 12
#define DTIF_K_CS_ISDIVZERO 13
#define DTIF_K_CS_ISRECURSIVE 14
#define DTIF_K_CS_ISMISEXTREF 15
#define DTIF_K_CS_ISNOTNUMBER 16
/* Item codes for Varying Text aggregate.                                   */
#define DTIF_VTX_VTEXT_LEN 134913       /* Varying text length		Integer */
#define DTIF_VTX_VTEXT_STR 134914       /* Varying text string		Character string */
#define DTIF_VTX_MAX 134915             /* Maximum code plus 1              */
/* Item codes for Array Definition aggregate.                               */
#define DTIF_ARD_DESCRIPTION 135169     /* Description			String */
#define DTIF_ARD_ELEM_TYPE_SIZE_C 135170 /* Array element type size	Enumeration */
#define DTIF_ARD_ELEM_TYPE_SIZE 135171  /*				Variable */
#define DTIF_ARD_X_DIMENSION 135172     /* X dimension			Integer */
#define DTIF_ARD_Y_DIMENSION 135173     /* Y dimension			Integer */
#define DTIF_ARD_Z_DIMENSION 135174     /* Z dimension			Integer */
#define DTIF_ARD_VALUES 135175          /* Values			String */
#define DTIF_ARD_MAX 135176             /* Maximum code plus 1              */
/* Values of DTIF_ARD_ELEM_TYPE_SIZE_C.                                     */
#define DTIF_K_STD_TYPE 0               /* Standard type size		Enumeration */
#define DTIF_K_VAR_TYPE 1               /* Variable type size		Integer */
/* Values of DTIF_ARD_ELEM_TYPE_SIZE for DTIFK_STD_TYPE.		DTIF conforming */
#define DTIF_K_ELEM_WORD 0              /* Word                             */
#define DTIF_K_ELEM_LONG 1              /* Longword                         */
#define DTIF_K_ELEM_FFLOAT 2            /* VAX F-floating                   */
#define DTIF_K_ELEM_DFLOAT 3            /* VAX D-floating                   */
#define DTIF_K_ELEM_GFLOAT 4            /* VAX G-floating                   */
#define DTIF_K_ELEM_HFLOAT 5            /* VAX H-floating                   */
/* Item codes for Complex Float aggregate.                                  */
#define DTIF_CFT_REAL_PART 135425       /* Real part			General floating point */
#define DTIF_CFT_IMAGINARY_PART 135426  /* Imaginary part 		General floating point */
#define DTIF_CFT_MAX 135427             /* Maximum code plus 1              */
/* Item codes for Format Information aggregate.                             */
#define DTIF_FMI_WINDOW_ID 135681       /* Window ID			Integer */
#define DTIF_FMI_C 135682               /* Format choice		Enumeration */
#define DTIF_FMI_NUM_DATATYPE 135683    /* Numeric data type		Longword */
#define DTIF_FMI_NUM_C 135684           /* Numeric format		Enumeration */
#define DTIF_FMI_NUMSTD_TYPE 135685     /* Numeric standard type	Enumeration */
#define DTIF_FMI_NUMSTD_DIGITS 135686   /* Numeric standard digits	Integer */
#define DTIF_FMI_NUMSTD_FRAC 135687     /* Numeric standard fraction	Integer */
#define DTIF_FMI_NUMEDS_EDITSTR 135688  /* Numeric edit string		ESF_EDS */
#define DTIF_FMI_NUMEID_EDITSTR_ID 135689 /* Numeric edit string index	Integer */
#define DTIF_FMI_NUM_RNDTRUNC 135690    /* Numeric rounding		Enumeration */
#define DTIF_FMI_TXT_C 135691           /* Text format			Enumeration */
#define DTIF_FMI_TXTSTD_TYPE 135692     /* Text standard type		Enumeration */
#define DTIF_FMI_TXTEDS_EDITSTR 135693  /* Text edit string		ESF_EDS */
#define DTIF_FMI_TXTEID_EDITSTR_ID 135694 /* Text edit string index	Integer */
#define DTIF_FMI_DAT_C 135695           /* Date format			Enumeration */
#define DTIF_FMI_DATSTD_TYPE 135696     /* Date standard type		Enumeration */
#define DTIF_FMI_DATSTD_ORDER 135697    /* Date standard order		Enumeration */
#define DTIF_FMI_DATEDS_EDITSTR 135698  /* Date edit string		ESF_EDS */
#define DTIF_FMI_DATEID_EDITSTR_ID 135699 /* Date edit string index	Integer */
#define DTIF_FMI_FLAGS 135700           /* Flags			Longword */
#define DTIF_FMI_WIDTH 135701           /* Width			Integer */
#define DTIF_FMI_LANG_ID 135702         /* Language index		Integer */
#define DTIF_FMI_DIRECTION 135703       /* Direction			Enumeration */
#define DTIF_FMI_UNIT_DESC 135704       /* Units description		Array of character string */
#define DTIF_FMI_ALIGNMENT 135705       /* Alignment			Enumeration */
#define DTIF_FMI_BORDER 135706          /* Border			Longword */
#define DTIF_FMI_NUM_SCALE 135707       /* Numeric scale		Integer */
#define DTIF_FMI_CONDITION 135708       /* Condition			DTIF_FMC */
#define DTIF_FMI_FONT 135709            /* Font				Integer */
#define DTIF_FMI_TEXT_HEIGHT_C 135710   /* Text height			Measurement enumeration  */
#define DTIF_FMI_TEXT_HEIGHT 135711     /*				Variable */
#define DTIF_FMI_FOREGROUND 135712      /* Foreground pattern		Integer */
#define DTIF_FMI_BACKGROUND 135713      /* Background pattern		Integer */
#define DTIF_FMI_WIDTH_SIZE_C 135714    /* Width size			Measurement enumeration  */
#define DTIF_FMI_WIDTH_SIZE 135715      /*				Variable */
#define DTIF_FMI_HEIGHT_SIZE_C 135716   /* Height size			Measurement enumeration  */
#define DTIF_FMI_HEIGHT_SIZE 135717     /*				Variable */
#define DTIF_FMI_HEIGHT_LINES 135718    /* Height lines			Integer */
#define DTIF_FMI_MAX 135719             /* Maximum code plus 1              */
/* Values of DTIF_FMI_C.                                                    */
#define DTIF_K_NUMERIC_FORMAT 0         /* Numeric format		DTIF_FMI_NUM_DATATYPE to DTIF_FMI_NUM_RNDTRUNC, */
/*				and DTIF_FMI_NUM_SCALE                      */
#define DTIF_K_TEXT_FORMAT 1            /* Text format			DTIF_FMI_TXT_C to DTIF_FMI_TXTEID_EDITSTR_ID */
#define DTIF_K_DATE_FORMAT 2            /* Date format			DTIF_FMI_DAT_C to DTIF_FMI_DATEID_EDITSTR_ID */
/* Bit definitions for DTIF_FMI_NUM_DATATYPE.				DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_fmi_num_all 0x80000000
#else
#define dtif_m_fmi_num_all 1
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_num_integer 0x40000000
#else
#define dtif_m_fmi_num_integer 2
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_num_float 0x20000000
#else
#define dtif_m_fmi_num_float 4
#endif
struct fmi_num_datatype {
    unsigned dtif_v_fmi_num_all : 1;
    unsigned dtif_v_fmi_num_integer : 1;
    unsigned dtif_v_fmi_num_float : 1;
    unsigned dtif_v_fmi_fill_0 : 13;
    unsigned dtif_v_fmi_fill_1 : 16;
    } ;
/* Values of DTIF_FMI_NUM_C.                                                */
#define DTIF_K_NUM_STANDARD 0           /* Numeric standard format	DTIF_FMI_NUMSTD_TYPE to DTIF_FMI_NUMSTD_FRAC */
#define DTIF_K_NUM_EDITSTR 1            /* Numeric edit string		DTIF_FMI_NUMEDS_EDITSTR */
#define DTIF_K_NUM_EDITSTR_ID 2         /* Numeric edit string index	DTIF_FMI_NUMEID_EDITSTR_ID */
/* Values of DTIF_FMI_NUMSTD_TYPE.					DTIF conforming */
#define DTIF_K_NUMSTD_GENERAL 0         /* General format                   */
#define DTIF_K_NUMSTD_INTEGER 1         /* Integer format                   */
#define DTIF_K_NUMSTD_FIXEDPT 2         /* Fixed point format               */
#define DTIF_K_NUMSTD_SCIENTIFIC 3      /* Scientific format                */
#define DTIF_K_NUMSTD_MONEY 4           /* Money format                     */
#define DTIF_K_NUMSTD_COMMA 5           /* Comma format                     */
#define DTIF_K_NUMSTD_PERCENT 6         /* Percent format                   */
#define DTIF_K_NUMSTD_PHONE 7           /* Phone format                     */
#define DTIF_K_NUMSTD_BAR 8             /* Bar format                       */
#define DTIF_K_NUMSTD_TEXT 9            /* Text format                      */
#define DTIF_K_NUMSTD_PERCENT_NOSCALE 10 /* Percent, no scale               */
/* Values of DTIF_FMI_NUM_RNDTRUNC.					DTIF conforming */
#define DTIF_K_NUM_ROUND 0              /* Round                            */
#define DTIF_K_NUM_TRUNCATE 1           /* Truncate                         */
/* Values of DTIF_FMI_TXT_C.                                                */
#define DTIF_K_TXT_STANDARD 0           /* Text standard format		DTIF_FMI_TXTSTD_TYPE */
#define DTIF_K_TXT_EDITSTR 1            /* Text edit string		DTIF_FMI_TXTEDS_EDITSTR */
#define DTIF_K_TXT_EDITSTR_ID 2         /* Text edit string index	DTIF_FMI_TXTEID_EDITSTR_ID */
/* Values of DTIF_FMI_TXTSTD_TYPE.					DTIF conforming */
#define DTIF_K_TXTSTD_PHONE 0           /* Telephone                        */
#define DTIF_K_TXTSTD_TEXT 1            /* Text                             */
#define DTIF_K_TXTSTD_REPEAT 2          /* Repeat                           */
/* Values of DTIF_FMI_DAT_C.                                                */
#define DTIF_K_DAT_STANDARD 0           /* Date standard format		DTIF_FMI_DATSTD_TYPE to DTIF_FMI_DATSTD_ORDER */
#define DTIF_K_DAT_EDITSTR 1            /* Date edit string		DTIF_FMI_DATEDS_EDITSTR */
#define DTIF_K_DAT_EDITSTR_ID 2         /* Date edit string index	DTIF_FMI_DATEID_EDITSTR_ID */
/* Values of DTIF_FMI_DATSTD_TYPE.					DTIF conforming */
#define DTIF_K_DATSTD_DATEONLY 0        /* Date only                        */
#define DTIF_K_DATSTD_TIMEONLY 1        /* Time only                        */
#define DTIF_K_DATSTD_DATEANDTIME 2     /* Date and time                    */
#define DTIF_K_DATSTD_RELYEARMONTH 3    /* Relative, year and month         */
#define DTIF_K_DATSTD_RELDAYTIME 4      /* Relative, day and time           */
#define DTIF_K_DATSTD_RELFULLDATE 5     /* Relative, full date              */
/* Values of DTIF_FMI_DATSTD_ORDER.					DTIF conforming */
#define DTIF_K_DATSTD_MDY 0             /* Month day year                   */
#define DTIF_K_DATSTD_DMY 1             /* Day month year                   */
/* Bit definitions for DTIF_FMI_FLAGS.					DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_fmi_readonly 0x80000000
#else
#define dtif_m_fmi_readonly 1
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_noreadonly 0x40000000
#else
#define dtif_m_fmi_noreadonly 2
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_bold 0x20000000
#else
#define dtif_m_fmi_bold 4
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_nobold 0x10000000
#else
#define dtif_m_fmi_nobold 8
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_italic 0x8000000
#else
#define dtif_m_fmi_italic 16
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_noitalic 0x4000000
#else
#define dtif_m_fmi_noitalic 32
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_underline 0x2000000
#else
#define dtif_m_fmi_underline 64
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_nounderline 0x1000000
#else
#define dtif_m_fmi_nounderline 128
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_valuehidden 0x800000
#else
#define dtif_m_fmi_valuehidden 256
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_novaluehidden 0x400000
#else
#define dtif_m_fmi_novaluehidden 512
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_formulahidden 0x200000
#else
#define dtif_m_fmi_formulahidden 1024
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_noformulahidden 0x100000
#else
#define dtif_m_fmi_noformulahidden 2048
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_running 0x80000
#else
#define dtif_m_fmi_running 4096
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_norunning 0x40000
#else
#define dtif_m_fmi_norunning 8192
#endif
struct fmi_flags {
    unsigned dtif_v_fmi_readonly : 1;
    unsigned dtif_v_fmi_noreadonly : 1;
    unsigned dtif_v_fmi_bold : 1;
    unsigned dtif_v_fmi_nobold : 1;
    unsigned dtif_v_fmi_italic : 1;
    unsigned dtif_v_fmi_noitalic : 1;
    unsigned dtif_v_fmi_underline : 1;
    unsigned dtif_v_fmi_nounderline : 1;
    unsigned dtif_v_fmi_valuehidden : 1;
    unsigned dtif_v_fmi_novaluehidden : 1;
    unsigned dtif_v_fmi_formulahidden : 1;
    unsigned dtif_v_fmi_noformulahidden : 1;
    unsigned dtif_v_fmi_running : 1;
    unsigned dtif_v_fmi_norunning : 1;
    unsigned dtif_v_fmi_fill_00 : 2;
    unsigned dtif_v_fmi_fill_2 : 16;
    } ;
/* Values of DTIF_FMI_DIRECTION.					DTIF conforming */
#define DTIF_K_DIR_OPPOSITE 0           /* Opposite direction               */
/* Values of DTIF_FMI_ALIGNMENT.					DTIF conforming */
#define DTIF_K_ALIGN_LEFT 0             /* Left alignment                   */
#define DTIF_K_ALIGN_CENTER 1           /* Center alignment                 */
#define DTIF_K_ALIGN_RIGHT 2            /* Right alignment                  */
/* Bit definitions for DTIF_FMI_BORDER.				DTIF conforming */
#ifdef CDAbig_endian
#define dtif_m_fmi_border_left 0x80000000
#else
#define dtif_m_fmi_border_left 1
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_noleft 0x40000000
#else
#define dtif_m_fmi_border_noleft 2
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_top 0x20000000
#else
#define dtif_m_fmi_border_top 4
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_notop 0x10000000
#else
#define dtif_m_fmi_border_notop 8
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_right 0x8000000
#else
#define dtif_m_fmi_border_right 16
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_noright 0x4000000
#else
#define dtif_m_fmi_border_noright 32
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_bottom 0x2000000
#else
#define dtif_m_fmi_border_bottom 64
#endif
#ifdef CDAbig_endian
#define dtif_m_fmi_border_nobottom 0x1000000
#else
#define dtif_m_fmi_border_nobottom 128
#endif
struct fmi_border {
    unsigned dtif_v_fmi_border_left : 1;
    unsigned dtif_v_fmi_border_noleft : 1;
    unsigned dtif_v_fmi_border_top : 1;
    unsigned dtif_v_fmi_border_notop : 1;
    unsigned dtif_v_fmi_border_right : 1;
    unsigned dtif_v_fmi_border_noright : 1;
    unsigned dtif_v_fmi_border_bottom : 1;
    unsigned dtif_v_fmi_border_nobottom : 1;
    unsigned dtif_v_fmi_fill_000 : 8;
    unsigned dtif_v_fmi_fill_3 : 16;
    } ;
/* Item codes for Cell Coordinates aggregate.                               */
#define DTIF_CCD_ROW 135937             /* Row number			Integer */
#define DTIF_CCD_COLUMN 135938          /* Column number		Integer */
#define DTIF_CCD_FLAGS 135939           /* Flags			Enumeration */
#define DTIF_CCD_MAX 135940             /* Maximum code plus 1              */
/* Values of DTIF_CCD_FLAGS.						DTIF conforming */
#define DTIF_K_RELROW_RELCOL 0          /* Relative row, relative column    */
#define DTIF_K_RELROW_ABSCOL 1          /* Relative row, absolute column    */
#define DTIF_K_ABSROW_RELCOL 2          /* Absolute row, relative column    */
#define DTIF_K_ABSROW_ABSCOL 3          /* Absolute row, absolute column    */
/* Item codes for Range Definition aggregate.                               */
#define DTIF_RNG_NAME 136193            /* Name				Array of character string */
#define DTIF_RNG_TYPE 136194            /* Type				Enumeration */
#define DTIF_RNG_REGION 136195          /* Region			Sequence of DTIF_CLR, DTIF_RWR, DTIF_COR, DTIF_NMR, */
/*				            DTIF_ECR, DTIF_ENR              */
#define DTIF_RNG_SORT_KEYNUM 136196     /* Sort key number		Integer */
#define DTIF_RNG_DESCRIPTION 136197     /* Description			Array of character string */
#define DTIF_RNG_SORT_DIRECTION 136198  /* Sort direction		Enumeration */
#define DTIF_RNG_SORT_ORDER 136199      /* Sort order			Enumeration */
#define DTIF_RNG_MAX 136200             /* Maximum code plus 1              */
/* Values of DTIF_RNG_TYPE.						DTIF conforming */
#define DTIF_K_RT_NAMED_RANGE 0         /* Named area                       */
#define DTIF_K_RT_VIEW_RANGE 1          /* View definition                  */
#define DTIF_K_RT_COL_TITLE 2           /* Column title section             */
#define DTIF_K_RT_ROW_TITLE 3           /* Row title section                */
#define DTIF_K_RT_DISPLAY_DATA 4        /* Displayed window range           */
#define DTIF_K_RT_DATA_RANGE 5          /* Maximum window range             */
#define DTIF_K_RT_SORT_RANGE 6          /* Sort range                       */
#define DTIF_K_RT_SORT_KEY 7            /* Sort key                         */
/* Values of DTIF_RNG_SORT_DIRECTION.					DTIF conforming */
#define DTIF_K_ASCENDING 0              /* Sort ascending                   */
#define DTIF_K_DESCENDING 1             /* Sort descending                  */
/* Values of DTIF_RNG_SORT_ORDER.					DTIF conforming */
#define DTIF_K_ROW_MAJOR 0              /* Row major                        */
#define DTIF_K_COL_MAJOR 1              /* Column major                     */
/* Item codes for Cell Range aggregate.                                     */
#define DTIF_CLR_RANGE_BEGIN 136449     /* Beginning cell coordinates	DTIF_CCD */
#define DTIF_CLR_RANGE_END 136450       /* Ending cell coordinates	DTIF_CCD */
#define DTIF_CLR_MAX 136451             /* Maximum code plus 1              */
/* Item codes for Row Range aggregate.                                      */
#define DTIF_RWR_ROW_BEGIN 136705       /* Beginning row number		Integer */
#define DTIF_RWR_ROW_END 136706         /* Ending row number		Integer */
#define DTIF_RWR_MAX 136707             /* Maximum code plus 1              */
/* Item codes for Column Range aggregate.                                   */
#define DTIF_COR_COL_BEGIN 136961       /* Beginning column number	Integer */
#define DTIF_COR_COL_END 136962         /* Ending column number		Integer */
#define DTIF_COR_MAX 136963             /* Maximum code plus 1              */
/* Item codes for Named Range aggregate.                                    */
#define DTIF_NMR_NAMEDRANGE 137217      /* Named range			Array of character string */
#define DTIF_NMR_MAX 137218             /* Maximum code plus 1              */
/* Item codes for External aggregate.                                       */
#define DTIF_EXT_DIRECT_REFERENCE 137473 /* Direct reference		Object identifier */
#define DTIF_EXT_INDIRECT_REFERENCE 137474 /* Indirect reference		Integer */
#define DTIF_EXT_DATA_VALUE_DESCRIPTOR 137475 /* Data value descriptor	String */
#define DTIF_EXT_ENCODING_C 137476      /* Encoding			Enumeration */
#define DTIF_EXT_ENCODING 137477        /* 				Variable */
#define DTIF_EXT_ENCODING_L 137478      /*     Length (on input)	Integer */
#define DTIF_EXT_MAX 137479             /* Maximum code plus 1              */
/* Values of DTIF_EXT_ENCODING_C.                                           */
#define DTIF_K_DOCUMENT_ENCODING 0      /* Nested document		Document root aggregate */
#define DTIF_K_DDIS_ENCODING 1          /* Nested document		DDIS encoding */
#define DTIF_K_OCTET_ENCODING 2         /* Octet aligned		String */
#define DTIF_K_ARBITRARY_ENCODING 3     /* Arbitrary		 	Bit string */
/* Item codes for Repeat Sequence aggregate.                                */
#define DTIF_RSQ_SEQUENCE 137729        /* Sequence repetitions	   	Integer */
#define DTIF_RSQ_EACH_ELEM 137730       /* Element repetitions		Integer */
#define DTIF_RSQ_ELEM_LIST_C 137731     /* Element list			Enumeration */
#define DTIF_RSQ_NESTED 137732          /* Nested sequence		DTIF_RSQ */
#define DTIF_RSQ_VALUES_COUNT 137733    /* Values count			Integer */
#define DTIF_RSQ_VALUES_LIST_C 137734   /* Values list			Array of enumeration */
#define DTIF_RSQ_VALUES_LIST 137735     /*				Array of variable */
#define DTIF_RSQ_SERIES_START_C 137736  /* Series start value		Enumeration */
#define DTIF_RSQ_SERIES_START 137737    /*				Variable */
#define DTIF_RSQ_SERIES_INCR_C 137738   /* Series increment value	Enumeration */
#define DTIF_RSQ_SERIES_INCR 137739     /* 			    	Variable */
#define DTIF_RSQ_SERIES_STOP_C 137740   /* Series stop			Enumeration */
#define DTIF_RSQ_SERIES_END_C 137741    /* Series end value		Enumeration */
#define DTIF_RSQ_SERIES_END 137742      /*				Variable */
#define DTIF_RSQ_SERIES_COUNT 137743    /* Series count			Integer */
#define DTIF_RSQ_MAX 137744
/* Value of DTIF_RSQ_ELEM_LIST_C.                                           */
#define DTIF_K_NESTED 0                 /* Nested sequence.		DTIF_RSQ_NESTED */
#define DTIF_K_VALUES 1                 /* Count			DTIF_RSQ_VALUES_COUNT to DTIF_RSQ_VALUES_LIST */
#define DTIF_K_SERIES 2                 /* Series			DTIF_RSQ_SERIES_START_C to DTIF_RSQ_SERIES_COUNT */
/* Value of DTIF_RSQ_VALUES_LIST_C.                                         */
#define DTIF_K_EXPRESSION 0             /* Expression			CFE_EXP */
#define DTIF_K_NULL_EXPRESSION 1        /* None				None */
/* Value of DTIF_RSQ_SERIES_START_C, DTIF_RSQ_SERIES_INCR_C, AND DTIF_RSQ_SERIES_END_C.	  DTIF conforming */
#define DTIF_K_SR_INTEGER 0
#define DTIF_K_SR_FLOATING_POINT 1
#define DTIF_K_SR_SCALED_INTEGER 2
/* Value of DTIF_RSQ_SERIES_STOP_C.                                         */
#define DTIF_K_END_VALUE 0              /* Series ending value              */
#define DTIF_K_COUNT 1                  /* Series ending count              */
/* Item codes for Format Condition aggregate.                               */
#define DTIF_FMC_CONDITION_C 137985     /* Condition choice		Enumeration */
#define DTIF_FMC_REL_OPR 137986         /* Relation operator		Enumeration */
#define DTIF_FMC_REL_VALUE_C 137987     /* Relation value		Enumeration */
#define DTIF_FMC_REL_VALUE 137988       /* 				Variable */
#define DTIF_FMC_CELL_STATE 137989      /* Cell state			Enumeration */
#define DTIF_FMC_OTHER_EXPRESSION 137990 /* Expression			CFE_EXP */
#define DTIF_FMC_MAX 137991
/* Values of DTIF_FMC_CONDITION_C.                                          */
#define DTIF_K_RELATION 0               /* Relation			DTIF_FMC_REL_OPR to DTIF_FMC_VALUE */
#define DTIF_K_STATE 1                  /* Cell state			DTIF_FMC_CELL_STATE */
#define DTIF_K_OTHER_EXPRESSION 2       /* Other expression		DTIF_FMC_OTHER_EXPRESSION */
/* Values of DTIF_FMC_REL_OPR.						DTIF conforming */
#define DTIF_K_IS_GREATER 0
#define DTIF_K_IS_GREATER_OR_EQUAL 1
#define DTIF_K_IS_LESS 2
#define DTIF_K_IS_LESS_OR_EQUAL 3
#define DTIF_K_IS_EQUAL 4
#define DTIF_K_IS_NOT_EQUAL 5
/* Item codes for Relative Time aggregate.                                  */
#define DTIF_RLT_YEAR_MONTH 138241      /* Year and month		Integer */
#define DTIF_RLT_DAY_TIME 138242        /* Day and time			Integer */
#define DTIF_RLT_MAX 138243
/* Item codes for External Cell Coordinates aggregate.                      */
#define DTIF_ECC_TABLE_REF 138497       /* Table reference		Integer */
#define DTIF_ECC_TABLE_ID 138498        /* Table ID			Integer */
#define DTIF_ECC_ROW_C 138499           /* Row				Enumeration */
#define DTIF_ECC_ROW 138500             /*				Variable */
#define DTIF_ECC_COL_C 138501           /* Column			Enumeration */
#define DTIF_ECC_COL 138502             /*				Variable */
#define DTIF_ECC_MAX 138503
/* Values of DTIF_ECC_ROW_C and DTIF_ECC_COL_C.				DTIF defined */
#define DTIF_K_ABSOLUTE 0               /* Absolute                         */
#define DTIF_K_RELATIVE 1               /* Relative                         */
#define DTIF_K_OFFSET 2                 /* Offset                           */
/* Item codes for External Cell Range aggregate.                            */
#define DTIF_ECR_RANGE_BEGIN 138753     /* Range begin			DTIF_ECC */
#define DTIF_ECR_RANGE_END 138754       /* Range end			DTIF_ECC */
#define DTIF_ECR_MAX 138755
/* Item codes for External Named Range aggregate.                           */
#define DTIF_ENR_TABLE_REF 139009       /* Table reference		Integer */
#define DTIF_ENR_TABLE_ID 139010        /* Table ID			Integer */
#define DTIF_ENR_RANGE_NAME 139011      /* Range name			Array of character string */
#define DTIF_ENR_MAX 139012
/* Item codes for Reference aggregate.                                      */
#define DTIF_REF_TARGET 139265          /* Reference target		String */
#define DTIF_REF_INDEX 139266           /* Reference index		Integer */
#define DTIF_REF_MAX 139267
/* Aggregate type codes for ESF (Edit String Format).                       */
#define ESF_EDS 769                     /* Edit string                      */
#define ESF_RPT 770                     /* Repeat                           */
#define ESF_TXS 771                     /* Text string                      */
#define ESF_NVL 772                     /* Named value                      */
#define ESF_DAT 773                     /* Date and time                    */
#define ESF_EXT 774                     /* External                         */
#define ESF_MAX 775                     /* Maximum code plus 1              */
/* Item codes for all aggregates.  ESF_AGGREGATE_TYPE is read-only.         */
#define ESF_USER_CONTEXT 1              /* User context			Longword */
#define ESF_AGGREGATE_TYPE 2            /* Aggregate type code		Word */
#define ESF_ALL_MAX 3                   /* Maximum code plus 1              */
/* Item codes for Edit String aggregate.                                    */
#define ESF_EDS_MAJOR_VERSION 196865    /* Major version		Integer */
#define ESF_EDS_MINOR_VERSION 196866    /* Minor version		Integer */
#define ESF_EDS_EDIT_STRING_C 196867    /* Edit string			Array of enumeration */
#define ESF_EDS_EDIT_STRING 196868      /*				Array of variable */
#define ESF_EDS_MAX 196869              /* Maximum code plus 1              */
/* Current values for major and minor encoding version.  Should be omitted when the edit string is embedded in a DTIF document. */
#define ESF_K_MAJOR_VERSION 1
#define ESF_K_MINOR_VERSION 4
/* Values of ESF_EDS_EDIT_STRING_C and ESF_RPT_SEQ_C.                       */
#define ESF_K_EDS_ALPHABETIC 0          /* Alphabetic			None */
#define ESF_K_EDS_AM_PM 1               /* AM PM			None */
#define ESF_K_EDS_ANY_CHAR 2            /* Any character		None */
#define ESF_K_EDS_ANY_CASE 3            /* Any case			None */
#define ESF_K_EDS_BINARY_DIGIT 4        /* Binary digit			None */
#define ESF_K_EDS_DIGIT_SEP 5           /* Digit separator		None */
#define ESF_K_EDS_DAY_NUMBER 6          /* Day number			None */
#define ESF_K_EDS_DECIMAL_DIGIT 7       /* Decimal digit		None */
#define ESF_K_EDS_RADIX_POINT 8         /* Radix point			None */
#define ESF_K_EDS_ENCODED_MINUS 9       /* Encoded minus		None */
#define ESF_K_EDS_ENCODED_PLUS 10       /* Encoded plus			None */
#define ESF_K_EDS_ENCODED_SIGN 11       /* Encoded sign			None */
#define ESF_K_EDS_EXPONENT 12           /* Exponent			None */
#define ESF_K_EDS_ZERO_REPLACE 13       /* Zero replace			ESF_TXS */
#define ESF_K_EDS_CURRENCY 14           /* Currency			None */
#define ESF_K_EDS_MINUS 15              /* Minus			None */
#define ESF_K_EDS_PLUS 16               /* Plus				None */
#define ESF_K_EDS_SIGN 17               /* Sign				None */
#define ESF_K_EDS_FLOAT_BLANK_SUPR 18   /* Float blank suppress		None */
#define ESF_K_EDS_FRACTION_SECOND 19    /* Fraction second		None */
#define ESF_K_EDS_HEX_DIGIT 20          /* Hex digit			None */
#define ESF_K_EDS_HOUR_12 21            /* Hour (12 hour system)	None */
#define ESF_K_EDS_HOUR_24 22            /* Hour (24 hour system)	None */
#define ESF_K_EDS_JULIAN_DIGIT 23       /* Julian digit			None */
#define ESF_K_EDS_LOGICAL_CHAR 24       /* Logical character		None */
#define ESF_K_EDS_LONG_TEXT 25          /* Long text			None */
#define ESF_K_EDS_LOWERCASE 26          /* Lowercase			None */
#define ESF_K_EDS_MINUS_LITERAL 27      /* Minus literal begin		ESF_TXS */
#define ESF_K_EDS_MINUS_LIT_END 28      /* Minus literal end		ESF_TXS */
#define ESF_K_EDS_MINUTE 29             /* Minute			None */
#define ESF_K_EDS_MONTH_NAME 30         /* Month name			None */
#define ESF_K_EDS_MONTH_NUMBER 31       /* Month number			None */
#define ESF_K_EDS_OCTAL_DIGIT 32        /* Octal digit			None */
#define ESF_K_EDS_PLUS_LITERAL 33       /* Plus literal			ESF_TXS */
#define ESF_K_EDS_REVERSE 34            /* Reverse			None */
#define ESF_K_EDS_SECOND 35             /* Second			None */
#define ESF_K_EDS_STR_LITERAL 36        /* String literal		ESF_TXS */
#define ESF_K_EDS_MISSING_SEP 37        /* Missing separator		None */
#define ESF_K_EDS_UPPERCASE 38          /* Uppercase			None */
#define ESF_K_EDS_WEEKDAYNAME 39        /* Weekday name			None */
#define ESF_K_EDS_YEAR 40               /* Year				None */
#define ESF_K_EDS_APPL_PRIVATE 41       /* Application private		Sequence of ESF_NVL */
#define ESF_K_EDS_DIGIT_SEP_LIT 42      /* Digit separator literal	ESF_TXS */
#define ESF_K_EDS_RADIX_POINT_LIT 43    /* Radix point literal		ESF_TXS */
#define ESF_K_EDS_CURRENCY_LIT 44       /* Currency sign literal	ESF_TXS */
#define ESF_K_EDS_REPEAT 45             /* Repeat			ESF_RPT (not for ESF_RPT_SEQ_C) */
#define ESF_K_EDS_DAY_ABBREV_NAME 46    /* Day abbreviated name		None */
#define ESF_K_EDS_MONTH_ABBREV_NAME 47  /* Month abbreviated name	None */
#define ESF_K_EDS_YEAR_SEP 48           /* Year separator		None */
#define ESF_K_EDS_MONTH_SEP 49          /* Month separator		None */
#define ESF_K_EDS_DAY_SEP 50            /* Day separator		None */
#define ESF_K_EDS_HOUR_SEP 51           /* Hour separator		None */
#define ESF_K_EDS_MINUTE_SEP 52         /* Minute separator		None */
#define ESF_K_EDS_SECOND_SEP 53         /* Second separator		None */
#define ESF_K_EDS_FRACTION_SECOND_SEP 54 /* Fractional sec. separator	None */
/* Item codes for Repeat aggregate.                                         */
#define ESF_RPT_COUNT 197121            /* Repeat count			Integer */
#define ESF_RPT_SEQ_C 197122            /* Repeat sequence		Enumeration */
#define ESF_RPT_SEQ 197123              /*				Variable */
#define ESF_RPT_MAX 197124              /* Maximum code plus 1              */
/* Item codes for Text String aggregate.                                    */
#define ESF_TXS_TEXT_STRING 197377      /* Text string			Array of character string */
#define ESF_TXS_MAX 197378              /* Maximum code plus 1              */
/* Item codes for Named Value aggregate.                                    */
#define ESF_NVL_NAME 197633             /* Value name			String */
#define ESF_NVL_VALUE_C 197634          /* Value data			Enumeration */
#define ESF_NVL_VALUE 197635            /* 				Variable */
#define ESF_NVL_REFERENCE_ERF_INDEX 197636 /*				Integer */
#define ESF_NVL_MAX 197637              /* Maximum code plus 1              */
/* Values of ESF_NVL_VALUE_C.                                               */
#define ESF_K_VALUE_BOOLEAN 0           /*				Boolean */
#define ESF_K_VALUE_INTEGER 1           /*				Integer */
#define ESF_K_VALUE_TEXT 2              /*				Array of character string */
#define ESF_K_VALUE_GENERAL 3           /*				String */
#define ESF_K_VALUE_LIST 4              /*				Sequence of ESF_NVL */
#define ESF_K_VALUE_EXTERNAL 5          /*				ESF_EXT */
#define ESF_K_VALUE_FLOAT 6             /*				General floating point */
#define ESF_K_VALUE_DATE 7              /*				ESF_DAT */
#define ESF_K_VALUE_EXPR 8              /*				CFE_EXP */
#define ESF_K_VALUE_RELTIME 9           /*				DTIF_RLT */
#define ESF_K_VALUE_DDIF_DOC 10         /*				DDIF_DDF */
#define ESF_K_VALUE_DTIF_DOC 11         /*				DTIF_DTF */
#define ESF_K_VALUE_REFERENCE 12        /*				String (& ESF_NVL_REFERENCE_ERF_INDEX used) */
/* Item codes for Date and Time aggregate.                                  */
#define ESF_DAT_DATETIME 197889         /* Date and time		String */
#define ESF_DAT_TIME_DIFF_C 197890      /* Time difference		Enumeration */
#define ESF_DAT_TIME_DIFF 197891        /*				Variable */
#define ESF_DAT_MAX 197892              /* Maximum code plus 1              */
/* Values of ESF_DAT_TIME_DIFF_C.                                           */
#define ESF_K_UTC_TIME 0                /* UTC time			None */
#define ESF_K_PLUS_DIFF 1               /* Positive difference		String */
#define ESF_K_NEG_DIFF 2                /* Negative difference		String */
/* Item codes for External aggregate.                                       */
#define ESF_EXT_DIRECT_REFERENCE 198145 /* Direct reference		Object identifier */
#define ESF_EXT_INDIRECT_REFERENCE 198146 /* Indirect reference		Integer */
#define ESF_EXT_DATA_VALUE_DESCRIPTOR 198147 /* Data value descriptor	String */
#define ESF_EXT_ENCODING_C 198148       /* Encoding			Enumeration */
#define ESF_EXT_ENCODING 198149         /* 				Variable */
#define ESF_EXT_ENCODING_L 198150       /*     Length (on input)	Integer */
#define ESF_EXT_MAX 198151              /* Maximum code plus 1              */
/* Values of ESF_EXT_ENCODING_C.                                            */
#define ESF_K_DOCUMENT_ENCODING 0       /* Nested document		Document root aggregate */
#define ESF_K_DDIS_ENCODING 1           /* Nested document		DDIS encoding */
#define ESF_K_OCTET_ENCODING 2          /* Octet aligned		String */
#define ESF_K_ARBITRARY_ENCODING 3      /* Arbitrary			Bit string */
/* Aggregate type codes for CFE (Canonical Format Expressions).             */
#define CFE_EXP 1025                    /* Expression                       */
#define CFE_EXL 1026                    /* Expression list                  */
#define CFE_SLL 1027                    /* Selector list                    */
#define CFE_CFT 1028                    /* Complex float                    */
#define CFE_DAT 1029                    /* Date and time                    */
#define CFE_TXC 1030                    /* Text choice                      */
#define CFE_VTX 1031                    /* Varying text                     */
#define CFE_FRF 1032                    /* Field reference                  */
#define CFE_PEX 1033                    /* Parenthesized expression         */
#define CFE_PFE 1034                    /* Private function expression      */
#define CFE_STF 1035                    /* String format                    */
#define CFE_STP 1036                    /* String pretty                    */
#define CFE_NPM 1037                    /* Named parameter                  */
#define CFE_CCD 1038                    /* Cell coordinates                 */
#define CFE_CLR 1039                    /* Cell range                       */
#define CFE_RWR 1040                    /* Row range                        */
#define CFE_COR 1041                    /* Column range                     */
#define CFE_MAX 1042                    /* Maximum code plus one            */
/* Item codes for all aggregates.  CFE_AGGREGATE_TYPE is read-only.         */
#define CFE_USER_CONTEXT 1              /* User context			Longword */
#define CFE_AGGREGATE_TYPE 2            /* Aggregate type code		Word */
#define CFE_ALL_MAX 3                   /* Maximum code plus 1              */
/* Item codes for Expression aggregate.                                     */
#define CFE_EXP_MAJOR_VERSION 262401    /* Major version		Integer */
#define CFE_EXP_MINOR_VERSION 262402    /* Minor version		Integer */
#define CFE_EXP_LIST 262403             /* Expression list		Sequence of CFE_EXL */
#define CFE_EXP_MAX 262404              /* Maximum code plus 1              */
/* Current values for major and minor encoding version.  Should be omitted when the expression is embedded in a DTIF document. */
#define CFE_K_MAJOR_VERSION 1
#define CFE_K_MINOR_VERSION 4
/* Item codes for Expression List aggregate.                                */
#define CFE_EXL_EXPR_C 262657           /* Expression choice		Enumeration */
#define CFE_EXL_EXPR 262658             /*				Variable */
#define CFE_EXL_MAX 262659              /* Maximum code plus 1              */
/* Values of CFE_EXL_EXPR_C.                                                */
#define CFE_K_LIT_INTEGER 0             /* Literal integer		Integer */
#define CFE_K_LIT_FLOAT 1               /* Literal float		General floating point */
#define CFE_K_LIT_TEXT 2                /* Literal text			CFE_TXC */
#define CFE_K_LIT_DATE 3                /* Literal date			CFE_DAT */
#define CFE_K_LIT_SCALED_INTEGER 4      /* Literal scaled integer	Scaled integer */
#define CFE_K_LIT_COMPLEX_FLOAT 5       /* Literal complex float	CFE_CFT */
#define CFE_K_LIT_VTEXT 6               /* Literal varying text		CFE_VTX */
#define CFE_K_PARENTHESIZED 7           /* Parenthesized expression	CFE_PEX */
#define CFE_K_CELL_COORD 8              /* Cell coordinates		CFE_CCD */
#define CFE_K_CELL_RANGE 9              /* Cell range			CFE_CLR */
#define CFE_K_ROW_RANGE 10              /* Row range			CFE_RWR */
#define CFE_K_COL_RANGE 11              /* Column range			CFE_COR */
#define CFE_K_NAMED_RANGE 12            /* Named range			Array of character string */
#define CFE_K_COL_NUM 13                /* Column number		Integer */
#define CFE_K_ROW_NUM 14                /* Row number			Integer */
#define CFE_K_COL_NAME 15               /* Column name			String */
#define CFE_K_NEGATE 16                 /* Negate			Sequence of CFE_EXL */
#define CFE_K_ADD 17                    /* Add				Sequence of CFE_EXL */
#define CFE_K_SUBTRACT 18               /* Subtract			Sequence of CFE_EXL */
#define CFE_K_DIVIDE 19                 /* Divide			Sequence of CFE_EXL */
#define CFE_K_MULTIPLY 20               /* Multiply			Sequence of CFE_EXL */
#define CFE_K_POWER 21                  /* Raise to a power		Sequence of CFE_EXL */
#define CFE_K_EXPONENT 22               /* Exponent			Sequence of CFE_EXL */
#define CFE_K_IF_THEN_ELSE 23           /* If-then-else			Sequence of CFE_EXL */
#define CFE_K_NOT 24                    /* Logical not			Sequence of CFE_EXL */
#define CFE_K_AND 25                    /* Logical and 			Sequence of CFE_EXL */
#define CFE_K_OR 26                     /* Logical or			Sequence of CFE_EXL */
#define CFE_K_EQL 27                    /* Equal			Sequence of CFE_EXL */
#define CFE_K_GTR 28                    /* Greater than			Sequence of CFE_EXL */
#define CFE_K_GEQ 29                    /* Greater than or equal	Sequence of CFE_EXL */
#define CFE_K_LSS 30                    /* Less than			Sequence of CFE_EXL */
#define CFE_K_LEQ 31                    /* Less than or equal		Sequence of CFE_EXL */
#define CFE_K_NEQ 32                    /* Not equal			Sequence of CFE_EXL */
#define CFE_K_BETWEEN 33                /* Between			Sequence of CFE_EXL */
#define CFE_K_ABS_VALUE 34              /* Absolute value		Sequence of CFE_EXL */
#define CFE_K_MODULO 35                 /* Modulus			Sequence of CFE_EXL */
#define CFE_K_SQRT 36                   /* Square root			Sequence of CFE_EXL */
#define CFE_K_SUM 37                    /* Summation			CFE_SLL */
#define CFE_K_AVG 38                    /* Average			CFE_SLL */
#define CFE_K_COUNT 39                  /* Count			CFE_SLL */
#define CFE_K_MIN 40                    /* Minimum			CFE_SLL */
#define CFE_K_MAX 41                    /* Maximum			CFE_SLL */
#define CFE_K_STDEV 42                  /* Standard deviation		CFE_SLL */
#define CFE_K_VAR 43                    /* Variance			CFE_SLL */
#define CFE_K_CVT_TO_VALUE 44           /* Convert to value		Sequence of CFE_EXL */
#define CFE_K_ROUND 45                  /* Round			Sequence of CFE_EXL */
#define CFE_K_TRUNCATE 46               /* Truncate			Sequence of CFE_EXL */
#define CFE_K_INT 47                    /* Integerize			Sequence of CFE_EXL */
#define CFE_K_ISERROR 48                /* Is error			Sequence of CFE_EXL */
#define CFE_K_ISBLANK 49                /* Is blank			Sequence of CFE_EXL */
#define CFE_K_ISNULL 50                 /* Is null			Sequence of CFE_EXL */
#define CFE_K_ISDATE 51                 /* Is date			Sequence of CFE_EXL */
#define CFE_K_ISNUMBER 52               /* Is number			Sequence of CFE_EXL */
#define CFE_K_ISSTRING 53               /* Is string			Sequence of CFE_EXL */
#define CFE_K_ISREF 54                  /* Is referenced		Sequence of CFE_EXL */
#define CFE_K_STR_CHAR 55               /* String character		Sequence of CFE_EXL */
#define CFE_K_STR_CODE 56               /* String character code	Sequence of CFE_EXL */
#define CFE_K_STR_CONCAT 57             /* String concatenate		Sequence of CFE_EXL */
#define CFE_K_STR_EXTRACT 58            /* String extract		Sequence of CFE_EXL */
#define CFE_K_STR_FIND 59               /* String find substring	Sequence of CFE_EXL */
#define CFE_K_STR_FIXED 60              /* String fixed			Sequence of CFE_EXL */
#define CFE_K_STR_FORMAT 61             /* String edit			CFE_STF */
#define CFE_K_STR_LEFT 62               /* Extract substring left	Sequence of CFE_EXL */
#define CFE_K_STR_LENGTH 63             /* String length		Sequence of CFE_EXL */
#define CFE_K_STR_LOWER 64              /* String lowercase		Sequence of CFE_EXL */
#define CFE_K_STR_PRETTY 65             /* String pretty		CFE_STP */
#define CFE_K_STR_PROPER 66             /* String proper		Sequence of CFE_EXL */
#define CFE_K_STR_REPEAT 67             /* String repeat		Sequence of CFE_EXL */
#define CFE_K_STR_REPLACE 68            /* String replace		Sequence of CFE_EXL */
#define CFE_K_STR_REVERSE 69            /* String reverse		Sequence of CFE_EXL */
#define CFE_K_STR_RIGHT 70              /* Extract substring right	Sequence of CFE_EXL */
#define CFE_K_STR_TRIM 71               /* String trim			Sequence of CFE_EXL */
#define CFE_K_STR_UPPER 72              /* String uppercase		Sequence of CFE_EXL */
#define CFE_K_CHOOSE 73                 /* Choose			Sequence of CFE_EXL */
#define CFE_K_INDEX 74                  /* Index			Sequence of CFE_EXL */
#define CFE_K_VLOOKUP 75                /* Vertical lookup		Sequence of CFE_EXL */
#define CFE_K_HLOOKUP 76                /* Horizontal lookup		Sequence of CFE_EXL */
#define CFE_K_TABLE 77                  /* Table			Sequence of CFE_EXL */
#define CFE_K_NAME_DAY 78               /* Date day of the week		Sequence of CFE_EXL */
#define CFE_K_NAME_MONTH 79             /* Date month name		Sequence of CFE_EXL */
#define CFE_K_NAME_DAYNUM 80            /* Day of the week		Sequence of CFE_EXL */
#define CFE_K_NAME_MONTHNUM 81          /* Month name			Sequence of CFE_EXL */
#define CFE_K_NOW 82                    /* Now				None */
#define CFE_K_TODAY 83                  /* Today			None */
#define CFE_K_TOMORROW 84               /* Tomorrow			None */
#define CFE_K_YESTERDAY 85              /* Yesterday			None */
#define CFE_K_EXT_DAY 86                /* Extract day			Sequence of CFE_EXL */
#define CFE_K_EXT_MONTH 87              /* Extract month		Sequence of CFE_EXL */
#define CFE_K_EXT_YEAR 88               /* Extract year			Sequence of CFE_EXL */
#define CFE_K_EXT_HOUR 89               /* Extract hour			Sequence of CFE_EXL */
#define CFE_K_EXT_MINUTE 90             /* Extract minute		Sequence of CFE_EXL */
#define CFE_K_EXT_SECOND 91             /* Extract second		Sequence of CFE_EXL */
#define CFE_K_DIFF_DAY 92               /* Difference day		Sequence of CFE_EXL */
#define CFE_K_DIFF_WEEK 93              /* Difference week		Sequence of CFE_EXL */
#define CFE_K_DIFF_MONTH 94             /* Difference month		Sequence of CFE_EXL */
#define CFE_K_DIFF_YEAR 95              /* Difference year		Sequence of CFE_EXL */
#define CFE_K_DIFF_HOUR 96              /* Difference hour		Sequence of CFE_EXL */
#define CFE_K_DIFF_MIN 97               /* Difference minute		Sequence of CFE_EXL */
#define CFE_K_DIFF_SEC 98               /* Difference second		Sequence of CFE_EXL */
#define CFE_K_CVT_TO_DATE 99            /* String to date		Sequence of CFE_EXL */
#define CFE_K_CVT_TO_TIME 100           /* String to time		Sequence of CFE_EXL */
#define CFE_K_PLUS_DAYS 101             /* Plus days			Sequence of CFE_EXL */
#define CFE_K_PLUS_WEEKS 102            /* Plus weeks			Sequence of CFE_EXL */
#define CFE_K_PLUS_MONTHS 103           /* Plus months			Sequence of CFE_EXL */
#define CFE_K_PLUS_YEARS 104            /* Plus years			Sequence of CFE_EXL */
#define CFE_K_PLUS_HOURS 105            /* Plus hours			Sequence of CFE_EXL */
#define CFE_K_PLUS_MINS 106             /* Plus minutes			Sequence of CFE_EXL */
#define CFE_K_PLUS_SECS 107             /* Plus seconds			Sequence of CFE_EXL */
#define CFE_K_ERROR 108                 /* Error			None */
#define CFE_K_NULL 109                  /* Null				None */
#define CFE_K_CUR_ROW 110               /* Current row			None */
#define CFE_K_CUR_COL 111               /* Current column		None */
#define CFE_K_CUR_CELL 112              /* Current cell			None */
#define CFE_K_CELL_ROW 113              /* Row portion of cell name	Sequence of CFE_EXL */
#define CFE_K_CELL_COL 114              /* Column portion of cell name	Sequence of CFE_EXL */
#define CFE_K_CELL_NAME 115             /* Constructed cell reference	Sequence of CFE_EXL */
#define CFE_K_COUNT_ROWS 116            /* Count rows			Sequence of CFE_EXL */
#define CFE_K_COUNT_COLS 117            /* Count columns		Sequence of CFE_EXL */
#define CFE_K_CELL_EXTRACT 118          /* Cell extract			Sequence of CFE_EXL */
#define CFE_K_APPREC 119                /* Appreciation			Sequence of CFE_EXL */
#define CFE_K_DEP_CROSS 120             /* Depreciation declining balance crossover	Sequence of CFE_EXL */
#define CFE_K_DEP_DB 121                /* Depreciation declining balance	Sequence of CFE_EXL */
#define CFE_K_DEP_DDB 122               /* Depreciation double declining balance	Sequence of CFE_EXL */
#define CFE_K_DEP_SLINE 123             /* Depreciation straight line	Sequence of CFE_EXL */
#define CFE_K_DEP_SOYD 124              /* Depreciation sum of years	Sequence of CFE_EXL */
#define CFE_K_DISCOUNT 125              /* Discount			Sequence of CFE_EXL */
#define CFE_K_FV 126                    /* Future value			Sequence of CFE_EXL */
#define CFE_K_FVA 127                   /* Future value of annuity	Sequence of CFE_EXL */
#define CFE_K_FVPV 128                  /* Future value of single payment	Sequence of CFE_EXL */
#define CFE_K_INTEREST 129              /* Interest payments		Sequence of CFE_EXL */
#define CFE_K_IRR 130                   /* Internal rate of return	Sequence of CFE_EXL */
#define CFE_K_MIRR 131                  /* Modified internal rate of return	Sequence of CFE_EXL */
#define CFE_K_NPV 132                   /* Net present value		Sequence of CFE_EXL */
#define CFE_K_PAYBACK 133               /* Payback			Sequence of CFE_EXL */
#define CFE_K_PERPMT 134                /* Number periods to achieve future value	Sequence of CFE_EXL */
#define CFE_K_PERPV 135                 /* Number periods given present value		Sequence of CFE_EXL */
#define CFE_K_PMTPV 136                 /* Payment per period given present value	Sequence of CFE_EXL */
#define CFE_K_PMTFV 137                 /* Payment per period to achieve future value	Sequence of CFE_EXL */
#define CFE_K_PRINCIPAL 138             /* Principal			Sequence of CFE_EXL */
#define CFE_K_PVA 139                   /* Present value of annuity	Sequence of CFE_EXL */
#define CFE_K_PVFV 140                  /* Present value to achieve future value	Sequence of CFE_EXL */
#define CFE_K_RATE 141                  /* Interest rate		Sequence of CFE_EXL */
#define CFE_K_LOGEST 142                /* LogEst			Sequence of CFE_EXL */
#define CFE_K_LSQR 143                  /* Least squares		Sequence of CFE_EXL */
#define CFE_K_INTEGRATE 144             /* Integrate			Sequence of CFE_EXL */
#define CFE_K_SIGMA 145                 /* Sigma			Sequence of CFE_EXL */
#define CFE_K_TREND 146                 /* Trend			Sequence of CFE_EXL */
#define CFE_K_LIT_TRUE 147              /* Literal true			None */
#define CFE_K_LIT_FALSE 148             /* Literal false		None */
#define CFE_K_LIT_PI 149                /* Literal pi			None */
#define CFE_K_RANDOM_U 150              /* Random number, uniformly distributed		None */
#define CFE_K_DECIMAL_STRING 151        /* Decimal string		String */
#define CFE_K_IN_TABLE 152              /* Field in table		Sequence of CFE_EXL */
#define CFE_K_SIN 153                   /* Sine				Sequence of CFE_EXL */
#define CFE_K_COS 154                   /* Cosine			Sequence of CFE_EXL */
#define CFE_K_TAN 155                   /* Tangent			Sequence of CFE_EXL */
#define CFE_K_ASIN 156                  /* Arc sine			Sequence of CFE_EXL */
#define CFE_K_ACOS 157                  /* Arc cosine			Sequence of CFE_EXL */
#define CFE_K_ATAN 158                  /* Arc tangent			Sequence of CFE_EXL */
#define CFE_K_ATAN2 159                 /* Arc tangent 2		Sequence of CFE_EXL */
#define CFE_K_LOG10 160                 /* Common logarithm		Sequence of CFE_EXL */
#define CFE_K_LOGN 161                  /* Natural logarithm		Sequence of CFE_EXL */
#define CFE_K_ALOG 162                  /* Antilogarithm		Sequence of CFE_EXL */
#define CFE_K_FACTORIAL 163             /* Factorial			Sequence of CFE_EXL */
#define CFE_K_ASL 164                   /* Arithmetic shift left	Sequence of CFE_EXL */
#define CFE_K_ASR 165                   /* Arithmetic shift right	Sequence of CFE_EXL */
#define CFE_K_ONES_CMP 166              /* Ones complement		Sequence of CFE_EXL */
#define CFE_K_SIGN 167                  /* Sign				Sequence of CFE_EXL */
#define CFE_K_CONTAINS 168              /* Contains substring		Sequence of CFE_EXL */
#define CFE_K_MATCHES 169               /* Matches			Sequence of CFE_EXL */
#define CFE_K_STARTS 170                /* String starts with		Sequence of CFE_EXL */
#define CFE_K_UNARY_PLUS 171            /* Unary plus			Sequence of CFE_EXL */
#define CFE_K_PERCENT 172               /* Percent			Sequence of CFE_EXL */
#define CFE_K_ISNOT_AVAIL 173           /* Is not available		Sequence of CFE_EXL */
#define CFE_K_ISNOT_CALC 174            /* Is not calculatable		Sequence of CFE_EXL */
#define CFE_K_NOT_AVAIL 175             /* Not available		None */
#define CFE_K_NOT_CALC 176              /* Not calculatable		None */
#define CFE_K_CELL_INDIRECT 177         /* Cell indirection		Sequence of CFE_EXL */
#define CFE_K_PERFV 178                 /* Periods to achieve future value	Sequence of CFE_EXL */
#define CFE_K_CURRENT_VALUE 179         /* Current value		None */
#define CFE_K_IDENTIFIER 180            /* Identifier			CFE_TXC */
#define CFE_K_PRIVATE_FUNCTION 181      /* Private function		CFE_PFE */
#define CFE_K_FIELD_REFERENCE 182       /* Field reference		CFE_FRF */
#define CFE_K_STDEVP 183                /* Standard deviation		CFE_SLL */
#define CFE_K_VARP 184                  /* Biased variance		CFE_SLL */
#define CFE_K_SQL_SELECT 185            /* SQL Select			Sequence of CFE_EXL */
#define CFE_K_EXT_CELL_COORD 186        /* External cell coordinates	DTIF_ECC */
#define CFE_K_EXT_CELL_RANGE 187        /* External cell range		DTIF_ECR */
#define CFE_K_EXT_NAMED_RANGE 188       /* External named range		DTIF_ENR */
#define CFE_K_EXT_REFERENCE 189         /* External reference		DTIF_REF */
#define CFE_K_LIT_RELTIME 190           /* Literal relative time	DTIF_RLT */
/* Item codes for Selector List aggregate.                                  */
#define CFE_SLL_CRITERIA 262913         /* Criteria			Sequence of CFE_EXL */
#define CFE_SLL_SELECTION 262914        /* Selection			Sequence of CFE_EXL */
#define CFE_SLL_MAX 262915              /* Maximum code plus 1              */
/* Item codes for Complex Float aggregate.                                  */
#define CFE_CFT_REAL_PART 263169        /* Real part			General floating point */
#define CFE_CFT_IMAGINARY_PART 263170   /* Imaginary part		General floating point */
#define CFE_CFT_MAX 263171              /* Maximum code plus 1              */
/* Item codes for Date and Time aggregate.                                  */
#define CFE_DAT_DATETIME 263425         /* Date and time		String */
#define CFE_DAT_TIME_DIFF_C 263426      /* Time difference		Enumeration */
#define CFE_DAT_TIME_DIFF 263427        /*				Variable */
#define CFE_DAT_MAX 263428              /* Maximum code plus 1              */
/* Values of CFE_DAT_TIME_DIFF_C.                                           */
#define CFE_K_UTC_TIME 0                /* UTC time			None */
#define CFE_K_PLUS_DIFF 1               /* Positive difference		String */
#define CFE_K_NEG_DIFF 2                /* Negative difference		String */
/* Item codes for Text Choice aggregate.                                    */
#define CFE_TXC_TEXT_C 263681           /* Text choice			Enumeration */
#define CFE_TXC_TEXT 263682             /*				Variable */
#define CFE_TXC_MAX 263683              /* Maximum code plus 1              */
/* Values of CFE_TXC_TEXT_C.                                                */
#define CFE_K_LATIN1_TEXT 0             /* Latin-1 text			String */
#define CFE_K_SIMPLE_TEXT 1             /* Simple text			Character string */
#define CFE_K_COMPLEX_TEXT 2            /* Complex text			Array of character string */
/* Item codes for Varying Text Aggregate.                                   */
#define CFE_VTX_VTEXT_LEN 263937        /* Varying Text Length		Integer */
#define CFE_VTX_VTEXT_STR 263938        /* Varying Text String		Character-String */
#define CFE_VTX_MAX 263939              /* Maximum code plus 1              */
/* Item codes for Field Reference aggregate.                                */
#define CFE_FRF_FIELD_CONTEXT 264193    /* Field context		String */
#define CFE_FRF_PATH 264194             /* Path				Array of string */
#define CFE_FRF_MAX 264195              /* Maximum code plus 1              */
/* Item codes for Parenthesized Expression aggregate.                       */
#define CFE_PEX_BEGIN_EXPR 264449       /* Begin expression 		Array of character string */
#define CFE_PEX_VALUE_EXPR 264450       /* Value expression		Sequence of CFE_EXL */
#define CFE_PEX_END_EXPR 264451         /* End expression		Array of character string */
#define CFE_PEX_MAX 264452              /* Maximum code plus 1              */
/* Item codes for Private Function Expression aggregate.                    */
#define CFE_PFE_FACILITY 264705         /* Facility			String */
#define CFE_PFE_NAME 264706             /* Function name		String */
#define CFE_PFE_REF_LABEL 264707        /* Reference label		String */
#define CFE_PFE_REF_LABEL_TYPE 264708   /* Reference label type		String with add-info */
#define CFE_PFE_RETURN_TYPE 264709      /* Return type			Longword */
#define CFE_PFE_PARAMS 264710           /* Parameters			Sequence of CFE_NPM */
#define CFE_PFE_MAX 264711              /* Maximum code plus 1              */
/* Values of the add-info parameter for CFE_PFE_REF_LABEL_TYPE.             */
#define CFE_K_PRIVATE_LABEL_TYPE 0      /* Private label type               */
#define CFE_K_RMS_LABEL_TYPE 1          /* RMS file specification ("$RMS")  */
#define CFE_K_UTX_LABEL_TYPE 2          /* ULTRIX file specification ("$UTX") */
#define CFE_K_MDS_LABEL_TYPE 3          /* MS-DOS or OS/2 file specification ("$MDS") */
/* Bit definitions for CFE_PFE_RET_TYPE.                                    */
#ifdef CDAbig_endian
#define cfe_m_pfe_fncret_numeric 0x80000000
#else
#define cfe_m_pfe_fncret_numeric 1
#endif
#ifdef CDAbig_endian
#define cfe_m_pfe_fncret_boolean 0x40000000
#else
#define cfe_m_pfe_fncret_boolean 2
#endif
#ifdef CDAbig_endian
#define cfe_m_pfe_fncret_date 0x20000000
#else
#define cfe_m_pfe_fncret_date 4
#endif
#ifdef CDAbig_endian
#define cfe_m_pfe_fncret_text 0x10000000
#else
#define cfe_m_pfe_fncret_text 8
#endif
struct pfe_type {
    unsigned cfe_v_pfe_fncret_numeric : 1;
    unsigned cfe_v_pfe_fncret_boolean : 1;
    unsigned cfe_v_pfe_fncret_date : 1;
    unsigned cfe_v_pfe_fncret_text : 1;
    unsigned cfe_v_pfe_fill_0 : 12;
    unsigned cfe_v_pfe_fill : 16;
    } ;
/* Item codes for String Format aggregate.                                  */
#define CFE_STF_SOURCE 264961           /* Source			Sequence of CFE_EXL */
#define CFE_STF_EDIT_STRING 264962      /* Edit string			ESF_EDS */
#define CFE_STF_MAX 264963              /* Maximum code plus 1              */
/* Item codes for String Pretty aggregate.                                  */
#define CFE_STP_STRING_EXPR 265217      /* String expression		Sequence of CFE_EXL */
#define CFE_STP_PRETTY_FLAGS 265218     /* Flags			Longword */
#define CFE_STP_MAX 265219              /* Maximum code plus 1              */
/* Bit definitions for CFE_STP_PRETTY_FLAGS.                                */
#ifdef CDAbig_endian
#define cfe_m_pretty_collapse 0x80000000
#else
#define cfe_m_pretty_collapse 1
#endif
#ifdef CDAbig_endian
#define cfe_m_pretty_compress 0x40000000
#else
#define cfe_m_pretty_compress 2
#endif
#ifdef CDAbig_endian
#define cfe_m_pretty_lowercase 0x20000000
#else
#define cfe_m_pretty_lowercase 4
#endif
#ifdef CDAbig_endian
#define cfe_m_pretty_trim 0x10000000
#else
#define cfe_m_pretty_trim 8
#endif
#ifdef CDAbig_endian
#define cfe_m_pretty_uncomment 0x8000000
#else
#define cfe_m_pretty_uncomment 16
#endif
#ifdef CDAbig_endian
#define cfe_m_pretty_upcase 0x4000000
#else
#define cfe_m_pretty_upcase 32
#endif
struct stp_pretty_flags {
    unsigned cfe_v_pretty_collapse : 1;
    unsigned cfe_v_pretty_compress : 1;
    unsigned cfe_v_pretty_lowercase : 1;
    unsigned cfe_v_pretty_trim : 1;
    unsigned cfe_v_pretty_uncomment : 1;
    unsigned cfe_v_pretty_upcase : 1;
    unsigned cfe_v_pretty_fill_0 : 10;
    unsigned cfe_v_pretty_fill_1 : 16;
    } ;
/* Item codes for Named Parameter aggregate.                                */
#define CFE_NPM_NAME 265473             /* Parameter name		String */
#define CFE_NPM_VALUE 265474            /* Parameter value		Sequence of CFE_EXL */
#define CFE_NPM_MAX 265475              /* Maximum code plus 1              */
/* Item codes for Cell Coordinates aggregate.                               */
#define CFE_CCD_ROW 265729              /* Row number			Integer */
#define CFE_CCD_COLUMN 265730           /* Column number		Integer */
#define CFE_CCD_FLAGS 265731            /* Flags			Enumeration */
#define CFE_CCD_MAX 265732              /* Maximum code plus 1              */
/* Values of CFE_CCD_FLAGS.						DTIF defined */
#define CFE_K_RELROW_RELCOL 0           /* Relative row, relative column    */
#define CFE_K_RELROW_ABSCOL 1           /* Relative row, absolute column    */
#define CFE_K_ABSROW_RELCOL 2           /* Absolute row, relative column    */
#define CFE_K_ABSROW_ABSCOL 3           /* Absolute row, absolute column    */
/* Item codes for Cell Range aggregate.                                     */
#define CFE_CLR_RANGE_BEGIN 265985      /* Beginning cell coordinates	CFE_CCD */
#define CFE_CLR_RANGE_END 265986        /* Ending cell coordinates	CFE_CCD */
#define CFE_CLR_MAX 265987              /* Maximum code plus 1              */
/* Item codes for Row Range aggregate.                                      */
#define CFE_RWR_ROW_BEGIN 266241        /* Beginning row number		Integer */
#define CFE_RWR_ROW_END 266242          /* Ending row number		Integer */
#define CFE_RWR_MAX 266243              /* Maximum code plus 1              */
/* Item codes for Column Range aggregate.                                   */
#define CFE_COR_COL_BEGIN 266497        /* Beginning column number	Integer */
#define CFE_COR_COL_END 266498          /* Ending column number		Integer */
#define CFE_COR_MAX 266499              /* Maximum code plus 1              */
#endif
#ifndef __DTK$ROUTINES_LOADED
#define __DTK$ROUTINES_LOADED	1

/*** MODULE dtk$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    DTK$ANSWER_PHONE                                                      */
/*                                                                          */
/*    Wait for Phone to Ring and Answer                                     */
/*                                                                          */
/*    The Wait for Phone to Ring and Answer routine                         */
/*    waits for the phone connected to the DECtalk device to ring           */
/*    and then answers it.                                                  */
/*                                                                          */
unsigned long int dtk$answer_phone() ;
/*    DTK$CHECK_HDWR_STATUS                                                 */
/*                                                                          */
/*    Check Hardware Status                                                 */
/*                                                                          */
/*    The Check Hardware Status routine checks the DECtalk hardware for hardware */
/*    malfunctions.                                                         */
/*                                                                          */
unsigned long int dtk$check_hdwr_status() ;
/*    DTK$DIAL_PHONE                                                        */
/*                                                                          */
/*    Dial the Telephone                                                    */
/*                                                                          */
/*    The Dial the Telephone routine dials the specified number on the telephone. */
/*                                                                          */
unsigned long int dtk$dial_phone() ;
/*    DTK$HANGUP_PHONE                                                      */
/*                                                                          */
/*    Hang Up the Phone                                                     */
/*                                                                          */
/*    The Hang Up the Phone routine speaks an optional message and          */
/*    then hangs up the phone.                                              */
/*                                                                          */
unsigned long int dtk$hangup_phone() ;
/*    DTK$INITIALIZE                                                        */
/*                                                                          */
/*    Initialize DECtalk                                                    */
/*                                                                          */
/*    The Initialize DECtalk routine initializes a DECtalk device and returns the device's assigned */
/*    voice identifier.                                                     */
/*                                                                          */
unsigned long int dtk$initialize() ;
/*    DTK$LOAD_DICTIONARY                                                   */
/*                                                                          */
/*    Load a Word into the DECtalk Dictionary                               */
/*                                                                          */
/*    The Load a Word into the DECtalk Dictionary routine                   */
/*    loads a phonemic definition of a word into the DECtalk                */
/*    dictionary.                                                           */
/*                                                                          */
unsigned long int dtk$load_dictionary() ;
/*    DTK$READ_KEYSTROKE                                                    */
/*                                                                          */
/*    Read a Key Entered on the Keypad                                      */
/*                                                                          */
/*    The Read a Key Entered on the Keypad routine                          */
/*    reads a key entered on the phone keypad.                              */
/*                                                                          */
unsigned long int dtk$read_keystroke() ;
/*    DTK$READ_STRING                                                       */
/*                                                                          */
/*    Read a Series of Keys Entered on the Keypad                           */
/*                                                                          */
/*    The Read a Series of Keys Entered on the Keypad routine reads a       */
/*    series of keys entered on the phone keypad.                           */
/*                                                                          */
unsigned long int dtk$read_string() ;
/*    DTK$RETURN_LAST_INDEX                                                 */
/*                                                                          */
/*    Return Last Index Spoken                                              */
/*                                                                          */
/*    The Return Last Index Spoken routine returns the last index spoken.   */
/*                                                                          */
unsigned long int dtk$return_last_index() ;
/*    DTK$SPELL_TEXT                                                        */
/*                                                                          */
/*    Spell Text                                                            */
/*                                                                          */
/*    The Spell Text routine causes DECtalk to pronounce each letter of     */
/*    the specified text.                                                   */
/*                                                                          */
unsigned long int dtk$spell_text() ;
/*    DTK$SPEAK_FILE                                                        */
/*                                                                          */
/*    Speak the Text in a Specified File                                    */
/*                                                                          */
/*    The Speak the Text in a Specified File routine                        */
/*    speaks the text contained in the specified file.                      */
/*                                                                          */
unsigned long int dtk$speak_file() ;
/*    DTK$SPEAK_PHONEMIC_TEXT                                               */
/*                                                                          */
/*    Speak the Specified Phonemic Text                                     */
/*                                                                          */
/*    The Speak the Specified Phonemic Text routine                         */
/*    sends the specified phonemic text to the DECtalk device               */
/*    to be spoken.                                                         */
/*                                                                          */
unsigned long int dtk$speak_phonemic_text() ;
/*    DTK$SPEAK_TEXT                                                        */
/*                                                                          */
/*    Speak the Specified Text                                              */
/*                                                                          */
/*    The Speak the Specified Text routine                                  */
/*    sends the specified text to the DECtalk device                        */
/*    to be spoken.                                                         */
/*                                                                          */
unsigned long int dtk$speak_text() ;
/*    DTK$SET_INDEX                                                         */
/*                                                                          */
/*    Insert an Index at the Current Position                               */
/*                                                                          */
/*    The Insert an Index at the Current Position routine                   */
/*    inserts an index into the current output stream.                      */
/*                                                                          */
unsigned long int dtk$set_index() ;
/*    DTK$SET_KEYPAD_MODE                                                   */
/*                                                                          */
/*    Turn the Phone Keypad On and Off                                      */
/*                                                                          */
/*    The Turn the Phone Keypad On and Off routine turns recognition        */
/*    of the telephone keypad on or off.                                    */
/*                                                                          */
unsigned long int dtk$set_keypad_mode() ;
/*    DTK$SET_LOGGING_MODE                                                  */
/*                                                                          */
/*    Set the Logging Mode for the Video Terminal Connected to the DECtalk Device */
/*                                                                          */
/*    The Set the Logging Mode for the Video Terminal                       */
/*    Connected to the DECtalk Device routine                               */
/*    controls the information that is displayed on the video               */
/*    terminal while the DECtalk device is functioning.                     */
/*                                                                          */
unsigned long int dtk$set_logging_mode() ;
/*    DTK$SET_MODE                                                          */
/*                                                                          */
/*    Set the Mode for the DECtalk Terminal                                 */
/*                                                                          */
/*    The Set the Mode for the DECtalk Terminal routine                     */
/*    sets or resets the mode settings of the DECtalk terminal.             */
/*                                                                          */
unsigned long int dtk$set_mode() ;
/*    DTK$SET_SPEECH_MODE                                                   */
/*                                                                          */
/*    Turn Speech Mode On and Off                                           */
/*                                                                          */
/*    The Turn Speech Mode On and Off routine                               */
/*    either starts or stops the DECtalk device's speech.                   */
/*                                                                          */
unsigned long int dtk$set_speech_mode() ;
/*    DTK$SET_TERMINAL_MODE                                                 */
/*                                                                          */
/*    Set the Mode for the Video Terminal Connected to the DECtalk Device   */
/*                                                                          */
/*    The Set the Mode for the Video Terminal                               */
/*    Connected to the DECtalk Device routine                               */
/*    controls the attributes of the video terminal connected               */
/*    to the DECtalk device.                                                */
/*                                                                          */
unsigned long int dtk$set_terminal_mode() ;
/*    DTK$SET_VOICE                                                         */
/*                                                                          */
/*    Set Voice Characteristics                                             */
/*                                                                          */
/*    The Set Voice Characteristics routine                                 */
/*    changes the DECtalk voice characteristics to match those              */
/*    specified.                                                            */
/*                                                                          */
unsigned long int dtk$set_voice() ;
/*    DTK$TERMINATE                                                         */
/*                                                                          */
/*    Terminate DECtalk                                                     */
/*                                                                          */
/*    The Terminate DECtalk routine terminates the use of an initialized DECtalk */
/*    device.                                                               */
/*                                                                          */
unsigned long int dtk$terminate() ;

#endif					/* __DTK$ROUTINES_LOADED */
#ifndef __DTKDEF_LOADED
#define __DTKDEF_LOADED	1

/*** MODULE $dtkdef ***/
/* Definitions for RTL DECtalk Management                                   */
/*                                                                          */
/*	Phone keypad keys.                                                  */
/*                                                                          */
#define DTK$K_TRM_ZERO 48
#define DTK$K_TRM_ONE 49
#define DTK$K_TRM_TWO 50
#define DTK$K_TRM_THREE 51
#define DTK$K_TRM_FOUR 52
#define DTK$K_TRM_FIVE 53
#define DTK$K_TRM_SIX 54
#define DTK$K_TRM_SEVEN 55
#define DTK$K_TRM_EIGHT 56
#define DTK$K_TRM_NINE 57
#define DTK$K_TRM_A 65
#define DTK$K_TRM_B 66
#define DTK$K_TRM_C 67
#define DTK$K_TRM_D 68
#define DTK$K_TRM_NUMBER_SIGN 35
#define DTK$K_TRM_ASTERISK 42
/* Conditions                                                               */
#define DTK$K_TRM_CANCELLED 508         /* I/O cancelled                    */
#define DTK$K_TRM_TIMEOUT 509           /* Timeout period expired           */
#define DTK$K_TRM_BUFFER_FULL 510       /* Buffer is full                   */
#define DTK$K_TRM_UNKNOWN 511           /* Unknown terminator               */
/*                                                                          */
/*	Self-test constants.                                                */
/*                                                                          */
#define DTK$K_TEST_POWER 1
#define DTK$K_TEST_HDATA 2
#define DTK$K_TEST_HCONTROL 3
#define DTK$K_TEST_DATA 4
#define DTK$K_TEST_SPEAK 5
/*                                                                          */
/*	Phone dialing constants.                                            */
/*                                                                          */
#define DTK$K_DIAL_TONE 0
#define DTK$K_DIAL_PULSE 1
/*                                                                          */
/*	DECtalk types.                                                      */
/*                                                                          */
#define DTK$K_DTC_UNKNOWN 0
#define DTK$K_DTC_01 1
#define DTK$K_DTC_03 2
/*                                                                          */
/*	Keypad modes.                                                       */
/*                                                                          */
#define DTK$K_KEYPAD_OFF 0
#define DTK$K_KEYPAD_ON 1
#define DTK$K_KEYPAD_AUTO 2
/*                                                                          */
/*	Voices.                                                             */
/*                                                                          */
#define DTK$K_VOICE_MALE 0
#define DTK$K_VOICE_FEMALE 1
#define DTK$K_VOICE_CHILD 2
#define DTK$K_VOICE_DEEP_MALE 3
#define DTK$K_VOICE_DEEP_FEMALE 4
#define DTK$K_VOICE_OLDER_MALE 5
#define DTK$K_VOICE_LIGHT_FEMALE 6
/*                                                                          */
/*	Speaking modes.                                                     */
/*                                                                          */
#define DTK$K_SPEAK 0
#define DTK$K_STOP 1
#define DTK$K_HALT 2
/*                                                                          */
/*	Return modes.                                                       */
/*                                                                          */
#define DTK$K_IMMED 0                   /* Return immedately after sending text. */
#define DTK$K_WAIT 1                    /* Wait until text is completely spoken be returning. */
#define DTK$K_STATUS 2                  /* Wait for text to be spoken and return phone status. */
/*                                                                          */
/*        DEFINE BIT MASKS AND VALUES FOR MODE ATTRIBUTES                   */
/*                                                                          */
#define DTK$M_SQUARE 1
#define DTK$M_ASCII 2
#define DTK$M_MINUS 4
#define DTK$M_EUROPE 8
#define DTK$M_SPELL 16
#define DTK$M_NORMAL 0                  /* no bits set                      */
#define DTK$K_SQUARE 0                  /* Mode square bitvector index      */
#define DTK$K_ASCII 1                   /* asky mode                        */
#define DTK$K_MINUS 2                   /* Say dash as minus bitvector index */
#define DTK$K_EUROPE 3                  /* European type numbers            */
#define DTK$K_SPELL 4                   /* Spell all words                  */
#define DTK$M_HOST 1
#define DTK$M_SPEAK_ALL 2
#define DTK$M_EDITED 4
#define DTK$M_HARD 8
#define DTK$M_SETUP 16
#define DTK$M_FILTER 32
#define DTK$K_HOST 0                    /* Send all chars typed to host.    */
#define DTK$K_SPEAK_ALL 1               /* Speak all chars typed.           */
#define DTK$K_EDITED 2                  /* Line edit all chars typed.       */
#define DTK$K_HARD 3                    /* Do local echo in hardcopy format. */
#define DTK$K_SETUP 4                   /* Speak all chars displayed in setup mode. */
#define DTK$K_FILTER 5                  /* Don't send DECtalk specific sequences. */
#define DTK$M_TEXT 1
#define DTK$M_PHONEME 2
#define DTK$M_RAWHOST 4
#define DTK$M_INHOST 8
#define DTK$M_OUTHOST 16
#define DTK$M_ERROR 32
#define DTK$M_TRACE 64
#define DTK$M_DEBUG 128
#define DTK$K_TEXT 0                    /* Log ASCII text.                  */
#define DTK$K_PHONEME 1                 /* Log phonemic text.               */
#define DTK$K_RAWHOST 2                 /* Log all chars without inspection. */
#define DTK$K_INHOST 3                  /* Log text read from host.         */
#define DTK$K_OUTHOST 4                 /* Log text sent to host.           */
#define DTK$K_ERROR 5                   /* Log error messages.              */
#define DTK$K_TRACE 6                   /* Log sequences symbolically       */
#define DTK$K_DEBUG 7                   /* Reserved                         */
#pragma nostandard
union dtkdef {
/*                                                                          */
/*	DEFINE BITS, MASKS, AND FIELDS FOR THE CONTROL MODES.               */
/*                                                                          */
    variant_struct  {
        unsigned dtk$v_square : 1;      /* Set mode square on               */
        unsigned dtk$v_ascii : 1;       /* asky mode                        */
        unsigned dtk$v_minus : 1;       /* Say dash as minus                */
        unsigned dtk$v_europe : 1;      /* Europe                           */
        unsigned dtk$v_spell : 1;       /* Spell all words                  */
        unsigned dtk$v_fill_0 : 3;
        } dtk$r_dtkmode_bits;
    variant_struct  {
        unsigned dtk$v_host : 1;        /* Send all chars typed to host.    */
        unsigned dtk$v_speak_all : 1;   /* Speak all chars typed.           */
        unsigned dtk$v_edited : 1;      /* Line edit all chars typed.       */
        unsigned dtk$v_hard : 1;        /* Do local echo in hardcopy format. */
        unsigned dtk$v_setup : 1;       /* Speak all chars displayed in setup mode. */
        unsigned dtk$v_filter : 1;      /* Don't send DECtalk specific sequences. */
        unsigned dtk$v_fill_1 : 2;
        } dtk$r_dtkterm_bits;
    variant_struct  {
        unsigned dtk$v_text : 1;        /* Log ASCII text.                  */
        unsigned dtk$v_phoneme : 1;     /* Log phonemic text.               */
        unsigned dtk$v_rawhost : 1;     /* Log all chars without inspection. */
        unsigned dtk$v_inhost : 1;      /* Log text read from host.         */
        unsigned dtk$v_outhost : 1;     /* Log text sent to host.           */
        unsigned dtk$v_error : 1;       /* Log error messages.              */
        unsigned dtk$v_trace : 1;       /* Log sequences symbolically       */
        unsigned dtk$v_debug : 1;       /* Reserved                         */
        } dtk$r_dtklog_bits;
    } ;
#pragma standard

#endif					/* __DTKDEF_LOADED */
#ifndef __DTKMSG_LOADED
#define __DTKMSG_LOADED	1

/*** MODULE $dtkmsg ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:50.24 */
/*                                                                          */
/* FILE: DTKMSG.MSG  EDIT: TS1004                                           */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984, 1985, 1986, 1987 BY		    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 1-004 ADD DSR STATUS MESSAGES.  TS 29-AUG-1986                           */
/* 1-003 ADD /MACRO=$DTKMSG FOR STARLETSD.  TS 30-JUL-1986                  */
/* 1-002 ADD DTK$_TLKINUSE.  TS 10-APR-1986                                 */
/* 1-001 ORIGINAL.  TS 6-AUG-1985                                           */
/*-                                                                         */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	DTK$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$DTKDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS AS EXTERNAL;                 */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*                                                                          */
/*-                                                                         */
/* TEMPLATE FOR DOCUMENTING MESSAGES.                                       */
/* EACH EXPLANATION FOLLOWS THE MESSAGE IT APPLIES TO AND                   */
/* IS FOLLOWED BY A BLANK LINE.                                             */
/* BE SURE NOT TO USE THE SEQUENCE "++" AFTER A "!" IN REGULAR COMMENTS     */
/* AS THIS SEQUENCE BEGINS A DOCUMENTATION SEQUENCE AND CAN BE              */
/* SEARCHED FOR IF AND WHEN THE PROCESS OF EXTRACTING THE                   */
/* DOCUMENTATION BECOMES AUTOMATED.                                         */
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	X                                                           */
/* USER ACTION:	Y                                                           */
/*--                                                                        */
/*			; SET LH TO 419 (DECIMAL).                          */
#define DTK$_FACILITY 419
#define DTK$_NORMAL 27492353
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	NORMAL SUCCESSFUL COMPLETION.                               */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define DTK$_VOIALREXI 27492369
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A USER TRIED TO CREATE A NEW VOICE_ID FOR A DECTALK         */
/*		DEVICE, WHEN ONE ALREADY EXISTS.  THIS IS NORMAL IN         */
/*		A MODULAR ENVIRONMENT.  THE EXISTING VOICE ID               */
/*		IS RETURNED.                                                */
/* USER ACTION:	NONE. MAKE SURE YOU DON'T DELETE A VOICE_ID                 */
/*		THAT YOU ACTUALLY DIDN'T CREATE.                            */
/*--                                                                        */
#define DTK$_NOT_A_TRM 27492377
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		THE OUTPUT DEVICE IS NOT A TERMINAL.                        */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
/*+                                                                         */
/* NOTE::	DO NOT ADD ANY ADDITIONAL SUCCESS MESSAGES HERE.            */
/*		ADD THEM BELOW AFTER THE REMAINING .SUCCESS MESSAGES.       */
/*-                                                                         */
#define DTK$_BUSY 27492387
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE ROUTINE DTK$DIAL_PHONE WAS CALLED TO DIAL A PHONE       */
/*		NUMBER AND THE LINE WAS BUSY.                               */
/* USER ACTION:	TRY CALLING AGAIN.                                          */
/*--                                                                        */
#define DTK$_NOANSWER 27492395
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE ROUTINE DTK$DIAL_PHONE WAS CALLED TO DIAL A PHONE       */
/*		NUMBER AND NO ONE ANSWERED THE CALL.                        */
/* USER ACTION:	TRY CALLING AGAIN.                                          */
/*--                                                                        */
#define DTK$_NODIATONE 27492403
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE ROUTINE DTK$DIAL_PHONE WAS CALLED TO DIAL A PHONE       */
/*		NUMBER AND NO DIAL TONE WAS DETECTED ON THE                 */
/*		PHONE LINE.                                                 */
/* USER ACTION:	CORRECT THE TELEPHONE LINE PROBLEM AND CALL AGAIN.          */
/*--                                                                        */
#define DTK$_OFFHOOK 27492411
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		THE PHONE IS OFFHOOK (A CALL IS ACTIVE).                    */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define DTK$_ONHOOK 27492419
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		THE PHONE IS ONHOOK (NO CALL IS ACTIVE).                    */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define DTK$_TIMEOUT 27492427
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		THE OUTPUT DEVICE HAS TIMED OUT.                            */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define DTK$_WINK 27492435
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A WINK (POSSIBLE TIMEOUT) WAS DETECTED ON THE               */
/*		PHONE LINE.  THE CALLER MAY HAVE HUNG UP THE PHONE.         */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define DTK$_COMFAIL 27492443
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A COMMUNICATIONS MALFUNCTION HAS OCCURRED SINCE THE         */
/*		DECTALK UNIT WAS TURNED ON.                                 */
/* USER ACTION:	CHECK THE DECTALK HARDWARE.                                 */
/*--                                                                        */
#define DTK$_INPBUFOVR 27492451
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	AN INPUT BUFFER OVERFLOW MALFUNCTION HAS OCCURRED SINCE     */
/*		THE DECTALK UNIT WAS TURNED ON.                             */
/* USER ACTION:	CHECK THE DECTALK HARDWARE.                                 */
/*--                                                                        */
#define DTK$_NVROPRFAI 27492459
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A NVR OPERATION FAILURE HAS OCCURRED SINCE                  */
/*		THE DECTALK UNIT WAS TURNED ON.                             */
/* USER ACTION:	CHECK THE DECTALK HARDWARE.                                 */
/*--                                                                        */
#define DTK$_ERRPHOTRA 27492467
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A PHONEMIC TRANSCRIPTION MALFUNCTION HAS OCCURRED SINCE     */
/*		THE DECTALK UNIT WAS TURNED ON.                             */
/* USER ACTION:	CHECK THE DECTALK HARDWARE.                                 */
/*--                                                                        */
#define DTK$_CONSEQERR 27492475
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A DECTALK PRIVATE CONTROL SEQUENCE MALFUNCTION HAS          */
/*		OCCURRED SINCE THE DECTALK UNIT WAS TURNED ON.              */
/* USER ACTION:	CHECK THE DECTALK HARDWARE.                                 */
/*--                                                                        */
#define DTK$_DECTSTFAI 27492483
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A LOCAL SELF-TEST MALFUNCTION HAS OCCURRED SINCE            */
/*		THE DECTALK UNIT WAS TURNED ON.                             */
/* USER ACTION:	CHECK THE DECTALK HARDWARE.                                 */
/*--                                                                        */
#define DTK$_FATERRLIB 27492868
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	AN INTERNAL ERROR HAS OCCURED WITHIN DTK.                   */
/* USER ACTION:	SUBMIT AN SPR DESCRIBING THE PROBLEM.                       */
/*--                                                                        */
#define DTK$_FILTOOLON 27492876
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE LENGTH OF THE SPECIFIED STRING                          */
/*		WAS TOO LONG.                                               */
/* USER ACTION:	CORRECT YOUR PROGRAM SO THAT IT REQUESTS A FILE             */
/*		NAME OF 255 CHARACTERS OR LESS.                             */
/*--                                                                        */
#define DTK$_INVARG 27492884
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE VALUE OF SOME ARGUMENT IS NOT IN THE CORRECT RANGE.     */
/* USER ACTION:	EXAMINE EACH ARGUMENT. DETERMINE WHICH ONE IS               */
/*		OUT OF RANGE AND CORRECT YOUR PROGRAM.                      */
/*--                                                                        */
#define DTK$_INVMODE 27492892
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE VALUE OF THE MODE ARGUMENT IS NOT IN THE                */
/*		CORRECT RANGE.                                              */
/* USER ACTION:	EXAMINE THE ARGUMENT. DETERMINE WHAT IS                     */
/*		OUT OF RANGE AND CORRECT YOUR PROGRAM.                      */
/*--                                                                        */
#define DTK$_INVVOI_ID 27492900
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	AN INVALID VOICE-ID WAS SPECIFIED.                          */
/* USER ACTION:	CHECK THAT YOU ARE PASSING THE VOICE ID BY REFERENCE        */
/*		NOT BY VALUE. ENSURE THAT THE VOICE ID WAS                  */
/*		PREVIOUSLY SET UP BY A CALL TO DTK$INITIALIZE.              */
/*--                                                                        */
#define DTK$_NOROOM 27492908
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THERE IS NO ROOM LEFT IN THE DICTIONARY FOR THIS            */
/*		DEFINITION.                                                 */
/* USER ACTION:	CORRECT YOUR PROGRAM SO THAT IT REQUESTS FEWER              */
/*		DICTIONARY ENTRIES OR SO THAT EACH ENTRY IS SMALLER.        */
/*--                                                                        */
#define DTK$_NOTIMP 27492916
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	YOU TRIED TO USE A FEATURE THAT IS NOT IMPLEMENTED          */
/*		IN THIS VERSION OF DTK$.                                    */
/* USER ACTION:	GET THE APPROPRIATE VERSION OF DTK$.                        */
/*--                                                                        */
#define DTK$_PROTOOLON 27492924
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE LENGTH OF A PROMPT STRING EXCEEDED 512 CHARACTERS.      */
/* USER ACTION:	SHORTEN THE PROMPT TO 512 CHARACTERS OR LESS.               */
/*--                                                                        */
#define DTK$_STRTERESC 27492932
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:  AN DTK OUTPUT ROUTINE WAS PASSED AN ESCAPE SEQUENCE        */
/*		EMBEDDED IN THE OUTPUT STRING.                              */
/* USER ACTION:	CHECK YOUR OUTPUT STRING TO DETERMINE WHAT ESCAPE           */
/*		SEQUENCE WAS BEING PASSED.  IF YOU NEED THE ACTION          */
/*		PROVIDED BY THIS ESCAPE SEQUENCE, THERE IS MOST             */
/*		LIKELY A DTK ROUTINE THAT PROVIDES THAT FUNCTIONALITY.      */
/*--                                                                        */
#define DTK$_TOOLONG 27492940
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THE LENGTH OF THE SPECIFIED STRING WAS TOO LONG.            */
/* USER ACTION:	CORRECT YOUR PROGRAM SO THAT IT REQUESTS A PHONE NUMBER     */
/*		OR DICTIONARY SUBSTITUTION OF 255 CHARACTERS OR LESS.       */
/*--                                                                        */
#define DTK$_UNKESCSEQ 27492948
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:  A DTK INPUT ROUTINE WAS PASSED AN ESCAPE SEQUENCE          */
/*		THAT IT WAS UNABLE TO UNDERSTAND.                           */
/* USER ACTION:	????                                                        */
/*--                                                                        */
#define DTK$_UNKREPLY 27492956
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:  A DTK INPUT ROUTINE WAS PASSED AN ESCAPE SEQUENCE          */
/*		THAT IT COULD NOT PARSE CORRECTLY.                          */
/* USER ACTION:	????                                                        */
/*--                                                                        */
#define DTK$_WRONUMARG 27492964
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A DTK ROUTINE WAS CALLED WITH TOO FEW ARGUMENTS             */
/*		(LESS THAN THE NUMBER OF REQUIRED ARGUMENTS)                */
/*		OR TOO MANY ARGUMENTS.                                      */
/* USER ACTION:	CORRECT THE CODE TO CALL THE ROUTINE WITH                   */
/*		THE PROPER NUMBER OF ARGUMENTS.                             */
/*--                                                                        */
#define DTK$_TLKINUSE 27492972
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	A DTK ROUTINE WAS CALLED FROM AN AST ROUTINE                */
/*		THAT INTERRUPTED A DTK ROUTINE WITH THE SAME                */
/*		VOICE_ID.                                                   */
/* USER ACTION:	CORRECT THE CODE TO CALL THE ROUTINE WITH                   */
/*		THE PROPER SYNCHRONIZATION.                                 */
/*--                                                                        */
#define DTK$_NOMALFUN1 27494401
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		NO MALFUNCTIONS HAVE OCCURRED SINCE THE DECTALK             */
/*		UNIT WAS TURNED ON.  THIS IS THE FIRST REPLY.               */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define DTK$_NOMALFUN2 27494409
/*++                                                                        */
/* FACILITY:	DTK                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		NO MALFUNCTIONS HAVE OCCURRED SINCE THE DECTALK             */
/*		UNIT WAS TURNED ON.  THIS IS THE SECOND OR LATER REPLY.     */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */

#endif					/* __DTKMSG_LOADED */
#ifndef __DVIDEF_LOADED
#define __DVIDEF_LOADED	1

/*** MODULE $dvidef ***/
/*+                                                                         */
/*                                                                          */
/* Get Device and Volume Information Data Identifier Definitions            */
/*                                                                          */
/* **** NOTE ****                                                           */
/*                                                                          */
/*        New items must always be added at the END of the list so that     */
/*        users will not have to rebuild.                                   */
/*                                                                          */
/*-                                                                         */
#define DVI$_DEVCHAR 2                  /* Device characteristics - VALUE - 4 bytes  */
#define DVI$_DEVCLASS 4                 /* Device class - VALUE - 1 byte    */
#define DVI$_DEVTYPE 6                  /* Device type - VALUE - 1 byte     */
#define DVI$_DEVBUFSIZ 8                /* Device buffer size - VALUE - 2 bytes  */
#define DVI$_DEVDEPEND 10               /* Device dependent information - VALUE - 4 bytes  */
#define DVI$_UNIT 12                    /* Unit number - VALUE - 2 bytes    */
#define DVI$_PID 14                     /* Process identification of device owner - VALUE - 4 bytes  */
#define DVI$_OWNUIC 16                  /* UIC of device owner - VALUE - 4 bytes  */
#define DVI$_VPROT 18                   /* Volume protection mask - VALUE - 2 bytes  */
#define DVI$_ERRCNT 20                  /* Error count - VALUE - 2 bytes    */
#define DVI$_OPCNT 22                   /* Operation count - VALUE - 4 bytes  */
#define DVI$_RECSIZ 24                  /* Blocked record size - VALUE - 2 bytes  */
#define DVI$_MAXBLOCK 26                /* Number of logical blocks on the volume (disk) - VALUE - 4 bytes  */
#define DVI$_DEVDEPEND2 28              /* Additional device dependent data - VALUE - 4 bytes  */
#define DVI$_REFCNT 30                  /* Reference count of processes - VALUE - 2 bytes  */
#define DVI$_DEVNAM 32                  /* Device name - STRING - 64 bytes  */
#define DVI$_VOLNAM 34                  /* Volume name - STRING - 12 bytes  */
#define DVI$_SECTORS 36                 /* Number of sectors per track (disk) - VALUE - 1 byte  */
#define DVI$_TRACKS 38                  /* Number of tracks per cylinder (disk) - VALUE - 1 byte  */
#define DVI$_CYLINDERS 40               /* Number of cylinders on the volume (disk) - VALUE - 2 bytes  */
#define DVI$_FREEBLOCKS 42              /* Number of free blocks on the volume (disk) - VALUE - 4 bytes  */
#define DVI$_LOGVOLNAM 44               /* Logical volume name - STRING - 64 bytes  */
#define DVI$_VOLNUMBER 46               /* Number of this volume in volume set (disk) - VALUE - 4 byte  */
#define DVI$_VOLCOUNT 48                /* Count of volumes in volume set (disk) - VALUE - 4 byte  */
#define DVI$_ROOTDEVNAM 50              /* Device name of root volume in volume set (disk) - STRING - 64 bytes  */
#define DVI$_NEXTDEVNAM 52              /* Device name of next volume in volume set (disk) - STRING - 64 bytes  */
#define DVI$_TRANSCNT 54                /* Volume Transaction Count - VALUE - 2 bytes  */
#define DVI$_MOUNTCNT 56                /* Mount count - VALUE - 2 bytes    */
#define DVI$_CLUSTER 58                 /* Volume Cluster Size (disk) - VALUE - 2 bytes  */
#define DVI$_MAXFILES 60                /* Maximum Files on Volume (disk) - VALUE - 4 bytes  */
#define DVI$_SERIALNUM 62               /* Volume Serial Number (disk) - VALUE - 4 bytes  */
#define DVI$_ACPPID 64                  /* ACP Process ID - VALUE - 4 bytes  */
#define DVI$_ACPTYPE 66                 /* ACP type code - VALUE - 1 byte   */
#define DVI$_CONCEALED 68               /* Device is a concealed device - BOOLEAN - 1 byte */
/*                                                                          */
/** THE FOLLOWING CODES ARE THE INDIVIDUAL BITS OF THE DEVCHAR LONGWORD     */
/*                                                                          */
#define DVI$_REC 70                     /* DEVICE RECORD ORIENTED           */
#define DVI$_CCL 72                     /* CARRIAGE CONTROL DEVICE          */
#define DVI$_TRM 74                     /* DEVICE IS A TERMINAL             */
#define DVI$_DIR 76                     /* DEVICE IS DIRECTORY STRUCTURED   */
#define DVI$_SDI 78                     /* DEVICE IS SINGLE DIRECTORY STRUCTURED  */
#define DVI$_SQD 80                     /* SEQUENTIAL BLOCK-ORIENTED DEVICE (I.E., MAGTAPE)  */
#define DVI$_SPL 82                     /* DEVICE BEING SPOOLED             */
#define DVI$_OPR 84                     /* DEVICE IS AN OPERATOR            */
#define DVI$_RCT 86                     /* DISK CONTAINS RCT (DEC STANDARD 166 DISK)  */
#define DVI$_NET 88                     /* NETWORK DEVICE                   */
#define DVI$_FOD 90                     /* FILES-ORIENTED DEVICE (I.E., DISK AND MT)  */
#define DVI$_DUA 92                     /* DEVICE IS DUAL PORTED            */
#define DVI$_SHR 94                     /* DEVICE SHAREABLE                 */
#define DVI$_GEN 96                     /* DEVICE IS A GENERIC DEVICE       */
#define DVI$_AVL 98                     /* DEVICE AVAILABLE FOR USE         */
#define DVI$_MNT 100                    /* DEVICE IS MOUNTED                */
#define DVI$_MBX 102                    /* DEVICE IS A MAILBOX              */
#define DVI$_DMT 104                    /* DEVICE MARKED FOR DISMOUNT       */
#define DVI$_ELG 106                    /* DEVICE HAS ERROR LOGGING ENABLED  */
#define DVI$_ALL 108                    /* DEVICE IS ALLOCATED              */
#define DVI$_FOR 110                    /* DEVICE IS MOUNTED FOREIGN (I.E., NON-FILE STRUCTURED)  */
#define DVI$_SWL 112                    /* DEVICE IS SOFTWARE WRITE LOCKED  */
#define DVI$_IDV 114                    /* DEVICE CAPABLE OF PROVIDING INPUT  */
#define DVI$_ODV 116                    /* DEVICE CAPABLE OF PROVIDING OUTPUT  */
#define DVI$_RND 118                    /* DEVICE ALLOWS RANDOM ACCESS      */
#define DVI$_RTM 120                    /* DEVICE IS REALTIME IN NATURE     */
#define DVI$_RCK 122                    /* DEVICE HAS READ CHECKING ENABLED  */
#define DVI$_WCK 124                    /* DEVICE HAS WRITE CHECKING ENABLED  */
/*                                                                          */
/**  THE FOLLOWING CODES ARE THE INDIVIDUAL BITS OF THE DEVDEPEND LONGWORD  */
/**  (AS DEFINED FOR TERMINALS: TTDEF IN STARDEFQZ.SDL)                     */
/*                                                                          */
#define DVI$_TT_PASSALL 126
#define DVI$_TT_NOECHO 128
#define DVI$_TT_NOTYPEAHD 130
#define DVI$_TT_ESCAPE 132
#define DVI$_TT_HOSTSYNC 134
#define DVI$_TT_TTSYNC 136
#define DVI$_TT_SCRIPT 138
#define DVI$_TT_LOWER 140
#define DVI$_TT_MECHTAB 142
#define DVI$_TT_WRAP 144
#define DVI$_TT_CRFILL 146
#define DVI$_TT_LFFILL 148
#define DVI$_TT_SCOPE 150
#define DVI$_TT_REMOTE 152
#define DVI$_TT_EIGHTBIT 154
#define DVI$_TT_MBXDSABL 156
#define DVI$_TT_NOBRDCST 158
#define DVI$_TT_READSYNC 160
#define DVI$_TT_MECHFORM 162
#define DVI$_TT_HALFDUP 164
#define DVI$_TT_MODEM 166
#define DVI$_TT_OPER 168
#define DVI$_TT_PAGE 170
/*                                                                          */
/**  THE FOLLOWING CODES ARE THE INDIVIDUAL BITS OF THE DEVDEPEND2 LONGWORD */
/**  (AS DEFINED FOR TERMINALS: TT2DEF IN STARDEFQZ.SDL)                    */
/*                                                                          */
#define DVI$_TT_LOCALECHO 172
#define DVI$_TT_AUTOBAUD 174
#define DVI$_TT_HANGUP 176
#define DVI$_TT_MODHANGUP 178
#define DVI$_TT_BRDCSTMBX 180
#define DVI$_TT_DMA 182
#define DVI$_TT_ALTYPEAHD 184
#define DVI$_TT_SETSPEED 186
#define DVI$_TT_DCL_MAILBX 188          /* TEMP DEFINITIONS FOR DCL SPAWN   */
#define DVI$_TT_EDITING 190
#define DVI$_TT_INSERT 192
#define DVI$_TT_FALLBACK 194
#define DVI$_TT_DIALUP 196
#define DVI$_TT_SECURE 198
#define DVI$_TT_DISCONNECT 200
#define DVI$_TT_PASTHRU 202
#define DVI$_TT_SIXEL 204
#define DVI$_TT_DRCS 206
#define DVI$_TT_PRINTER 208
#define DVI$_TT_APP_KEYPAD 210
#define DVI$_TT_SYSPWD 212
#define DVI$_TT_ANSICRT 214
#define DVI$_TT_REGIS 216
#define DVI$_TT_BLOCK 218
#define DVI$_TT_AVO 220
#define DVI$_TT_EDIT 222
#define DVI$_TT_DECCRT 224
/*                                                                          */
/**  THE FOLLOWING CODES ARE REGULAR ITEMS                                  */
/*                                                                          */
#define DVI$_STS 226                    /* STATUS LONGWORD                  */
#define DVI$_DEVSTS 228                 /* DEVICE STATUS WORD               */
#define DVI$_DEVCHAR2 230               /* Second device characteristics longword - VALUE - 4 bytes  */
#define DVI$_FULLDEVNAM 232             /* Fully qualified device name      */
#define DVI$_LOCKID 234                 /* Device lock id - VALUE - 4 bytes */
#define DVI$_ALLDEVNAM 236              /* Allocation class + device name   */
#define DVI$_VOLSETMEM 238              /* Volume set member                */
#define DVI$_DEVLOCKNAM 240             /* Device lock name                 */
/*                                                                          */
/** THE FOLLOWING CODES SUPPORT FEATURES OF DUAL-PATH AND SHADOW-SET DEVICES */
/*                                                                          */
#define DVI$_ALLOCLASS 242              /* Allocation class of host(s)      */
#define DVI$_ALT_HOST_AVAIL 244         /* Alternate host is active         */
#define DVI$_ALT_HOST_NAME 246          /* Name of host serving alternate path */
#define DVI$_ALT_HOST_TYPE 248          /* Type of alternate host           */
#define DVI$_HOST_AVAIL 250             /* Primary host is active           */
#define DVI$_HOST_COUNT 252             /* Number of paths to the device    */
#define DVI$_HOST_NAME 254              /* Name of host serving the primary path */
#define DVI$_HOST_TYPE 256              /* Type of primary host (today one of "V785", "V780", "V750" or "HS50") */
#define DVI$_REMOTE_DEVICE 258          /* Device is not connected to local node */
#define DVI$_SERVED_DEVICE 260          /* Device is served to the cluster  */
#define DVI$_SHDW_CATCHUP_COPYING 262   /* Catch-up copy is in progress     */
#define DVI$_SHDW_MASTER 264            /* Device is "virtual" master device for shadow set */
#define DVI$_SHDW_MASTER_NAME 266       /* Name of the "virtual" master device for a shadow set */
#define DVI$_SHDW_MEMBER 268            /* Device is one of the volumes making a shadow set */
#define DVI$_SHDW_MERGE_COPYING 270     /* Merge copy is in progress        */
#define DVI$_SHDW_NEXT_MBR_NAME 272     /* Name of the next device in shadow set */
/*                                                                          */
/**  THE FOLLOWING CODES ARE REGULAR ITEMS                                  */
/*                                                                          */
#define DVI$_TT_PHYDEVNAM 274           /* Terminal physical device name - STRING - 64 bytes */
#define DVI$_TT_DECCRT2 276             /* DEC_CRT level 2 part of devdepend2 longword for  */
/* terminals.                                                               */
#define DVI$_MEDIA_NAME 278             /* Decoded media name from UCB$L_MEDIA_ID field (ie. RK07 ) */
#define DVI$_MEDIA_TYPE 280             /* Decoded media type from UCB$L_MEDIA_ID field (ie. DM ) */
#define DVI$_MEDIA_ID 282               /* NONdecoded media id from UCB$L_MEDIA_ID */
/*                                                                          */
#define DVI$_SHDW_FAILED_MEMBER 284     /* Member unit has been failed out from shadow set */
#define DVI$_MSCP_UNIT_NUMBER 286       /* MSCP unit number of device (internal hash */
/*  value, not useful for customers or applications)                        */
#define DVI$_DISPLAY_DEVNAM 288         /* A displayable device name, useful for user */
/*  displays but not for $ASSIGN                                            */
#define DVI$_TT_ACCPORNAM 290           /* Name of local port on remote system.  Counted */
/* string in remote native format, ie: LAT, X.29                            */
#define DVI$_DEVDEPEND3 292             /* Device dependent longword 3      */
#define DVI$_TT_MULTISESSION 294        /* Multi-session terminal           */
#define DVI$_TT_DECCRT3 296             /* VT3xx series terminal            */
/*                                                                          */
/****	ADD NEW ITEM-CODES IMMEDIATELY BEFORE THIS COMMENT *****            */
/*                                                                          */
/*                                                                          */
/* Define flag bits in the item code.                                       */
/*                                                                          */
#define DVI$M_SECONDARY 1
#define DVI$M_NOREDIRECT 32768
struct dvidef {
    unsigned dvi$v_secondary : 1;       /* Use secondary device characteristics */
    unsigned dvi$v_item_code : 14;      /* Space for item code              */
/* Define additional flags here, subtracting the space out of the           */
/* above item code. (The item code must contain all the unused bits         */
/* for proper validation in the service.)                                   */
    unsigned dvi$v_noredirect : 1;      /* Don't redirect to virtual terminal */
    } ;
/*                                                                          */
/* Constant form of name for past compatibility.                            */
/*                                                                          */
#define DVI$C_SECONDARY 1
/*                                                                          */
/* The following ACP type codes are formally defined in $AQBDEF             */
/* These synonyms are available to user programs and they are               */
/* guaranteed to be consistent by ASSUME's in SYSGETDEV.  Additions         */
/* to the ACP type codes in $AQBDEF should be reflected here and            */
/* in the ASSUMES in SYSGETDEV.                                             */
/*                                                                          */
#define DVI$C_ACP_F11V1 1               /* FILES-11 STRUCTURE LEVEL 1       */
#define DVI$C_ACP_F11V2 2               /* FILES-11 STRUCTURE LEVEL 2       */
#define DVI$C_ACP_MTA 3                 /* MAGTAPE                          */
#define DVI$C_ACP_NET 4                 /* NETWORKS                         */
#define DVI$C_ACP_REM 5                 /* REMOTE I/O                       */
 

#endif					/* __DVIDEF_LOADED */
#define _dvr$cdef_

/*
**++
**  COPYRIGHT (c) 1988,1989 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**--
**/


/*
**++
**  MODULE NAME:
**	dvr$cc_def.h
**
**  FACILITY:
**      DDIF Viewer V2.0
**
**  ABSTRACT:
**  	this file will include all the public
**  	entry points for appications calling the
**  	DDIF character cell viewer.
**
**  AUTHORS:
**      Barbara Bazemore, Peter Derr
**
**  RELEASER:
**
**  CREATION DATE:     22-Feb-1988
**
**  MODIFICATION HISTORY:
**
**	8-Mar-88   Bb	Added character cell viewer structures and defines,
**			remove dvr$include.h
**
**	3-jun-88   dam  moved in dvr$constants.h because dvr$status only contains
**			statuses now; and dvr$constants contains DVRFailure, etc.
**
**	22-jun-88  dam	moved dvr$constants out- directly into dvr$cc_viewer.c
**
**	22-Nov-88 through
**	 3-Jan-89  PBD	Major revisions for V2
**	27-jul-89  dam	remove VAX bindings; not yet supported externally
**--
**/

/**
 ** Character cell viewer constants and structure defs
 **/
/*
 * Selectoptions flags, all are boolean
 */
#define DVR$M_SoftDirectives   (1L<<0)	/* obey soft directives		*/
#define DVR$M_Auto_Wrap	       (1L<<1)	/* do word-wrap formatting of text */
#define DVR$M_Outfile	       (1L<<2)	/* output to file		*/
#define DVR$M_Paging	       (1L<<3)	/* pause at end of page		*/
#define DVR$M_Text	       (1L<<4)	/* output text			*/
#define DVR$M_Images	       (1L<<5)	/* text placeholder for images	*/
#define DVR$M_Graphics	       (1L<<6)	/* text placeholder for graphics*/
#define DVR$M_ReportErrors     (1L<<7)	/* write errors to stderr   */
#define DVR$M_Layout	       (1L<<8)	/* Do layout		    */
#define DVR$M_SpecificLayout   (1L<<9)	/* Do specific layout	    */
#define DVR$M_Text_Backend     (1L<<10)	/* Act like a text backend*/
#define DVR$M_DefaultOptions					    \
      DVR$M_SoftDirectives | DVR$M_Auto_Wrap | DVR$M_Outfile \
    | DVR$M_Text | DVR$M_Images | DVR$M_Graphics	       \
    | DVR$M_Layout | DVR$M_SpecificLayout

/* Item codes for CDA$CONVERT, CDA$OPEN_CONVERTER, domain$READ_format, and  */
/* domain$WRITE_format.  The DVR$ prefix has been substituted for the CDA$  */
/* prefix.								    */
#define DVR$_PROCESSING_OPTION 1        /* Processing option                */
#define DVR$_INPUT_FORMAT 2             /* Input document format-name       */
#define DVR$_INPUT_FRONT_END_PROCEDURE 3 /* Input document front-end procedure */
#define DVR$_INPUT_FILE 4               /* Input file specification         */
#define DVR$_INPUT_DEFAULT 5            /* Input default file specification */
#define DVR$_INPUT_PROCEDURE 6          /* Input get data procedure         */
#define DVR$_INPUT_POSITION_PROCEDURE 7 /* Input get position procedure     */
#define DVR$_INPUT_PROCEDURE_PARM 8     /* Input procedure parameter        */
#define DVR$_INPUT_ROOT_AGGREGATE 9     /* Input root aggregate             */
#define DVR$_OUTPUT_FORMAT 10           /* Output document format-name      */
#define DVR$_OUTPUT_BACK_END_PROCEDURE 11 /* Output document back-end procedure */
#define DVR$_OUTPUT_FILE 12             /* Output file specification        */
#define DVR$_OUTPUT_DEFAULT 13          /* Output default file specification */
#define DVR$_OUTPUT_PROCEDURE 14        /* Output procedure                 */
#define DVR$_OUTPUT_PROCEDURE_PARM 15   /* Output procedure parameter       */
#define DVR$_OUTPUT_PROCEDURE_BUFFER 16 /* Output procedure initial buffer  */
#define DVR$_OUTPUT_ROOT_AGGREGATE 17   /* Output root aggregate            */
#define DVR$_OPTIONS_FILE 18            /* Options file specification       */

/*
**  This following item codes area unique to the CC viewer.  They are intended
**  for use in the private item list argument to the DvrCCInitialize routine.
*/
#define DVR$_FRONT_END_HANDLE 	256	/* front end input procedure handle */
#define DVR$_PAGE_HEIGHT	257	/* formatted page height in chars   */
#define DVR$_PAGE_WIDTH		258	/* formatted page width in chars    */

/*
**++
**  COPYRIGHT (c) 1987, 1991 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**  	this file will include all the public
**  	definitions for appications calling the
**  	windowing CDA Viewer interface. Note, public function
**	prototypes are in dvr$decw_ptp.h on vms; dvr_decw_ptp.h on
**	ultrix; dvr$wptp.h os/2.
**
**--
**/
/*
 * Translate __ predefined symbols to pre ANSI C style when not
 * compiling with an ANSI C conformant compiler.
 */
#include <cdatrans.h>

#ifdef __vms__
#define CDA_DECWINDOWS

#ifndef _cdatyp_
#include <cdatyp.h>
#endif

#endif

#ifdef __unix__

#define CDA_DECWINDOWS

#ifndef _cdatyp_
#include <cda_typ.h>
#endif

#endif

#ifndef CDA_DECWINDOWS
#ifndef _cdatyp_
#include <cda$typ.h>
#endif
#endif

/*
 * typedef for DVR callback structure
 */

typedef struct
  {
    int		    reason;

#ifdef CDA_DECWINDOWS
    XEvent	    *event;
#endif

    CDAstatus 	    status;
    CDAenvirontext  CDA_FAR *string_ptr;
  } DvrCallbackStruct;

#define DvrCRactivate	 		0
#define DvrCRendDocument  		1
#define DvrCRhelpRequested		2
#define DvrCRcdaError			3
#define DvrCRpsOK			4
#define DvrCRexpose			5
#define DvrCRmouseMotion		6
#define DvrCRbuttonEvent		7
#define DvrCRscrollBarEvent		8

/*
 * SELECT options flags (Make sure don't conflict w/ CC Viewer flag position
 * when adding more.)  These flags must match the correponding CC Viewer values.
 */
#define DvrSoftDirectives 		(1<<0)
#define DvrWordWrap			(1<<1)
#define DvrText				(1<<4)	/* output text		    */
#define DvrImages			(1<<5)	/* output images	    */
#define DvrGraphics			(1<<6)	/* output graphics	    */
#define DvrLayout			(1<<8)	/* Do layout		    */
#define DvrSpecificLayout		(1<<9)	/* Do specific layout	    */

/* Values for item list codes used in Converter Selection Widget. */

#define DvrOptionFlags			201
#define DvrFileSelectionOverride	202
#define DvrFormatSelectionList		203
#define DvrInitialFormatSelection	204
#define DvrOptionalLabelButton		205
#define DvrOptionalIconButton		206
#define DvrDirectoryMask		207
#define DvrWindowX			208
#define DvrWindowY			209
#define DvrWindowCaption		210
#define DvrServerNode			211
#define DvrUsername			212
#define DvrPassword			213
#define DvrUserParameter		214

/* Mask values for option flags in Converter Selection Widget. */

#define DvrMinputFile		  	  1
#define DvrMoutputFile		  	  2
#define DvrMlistDDIFformats		  4
#define DvrMlistDTIFformats		  8
#define DvrMlistCDAformats		 16
#define DvrMlistAllFormats		252
#define DvrMnoMaskModification		256
#define DvrMomitOptionsFile		512
#define DvrMomitOptionsButton		512
#define DvrMomitNetworkButton	       1024


#ifdef CDA_DECWINDOWS

/* literals to be used for CDA X viewer (specific to Xwindows) */

#define DvrViewerClassStr 		"DVRviewer"

#define DvrNscrollHorizontal 		"DVRscrollHorizontal"
#define DvrNscrollVertical 		"DVRscrollVertical"
#define DvrNprocessingOptions		"DVRprocessingOptions"
#define DvrNpaperWidth			"DVRpaperWidth"
#define DvrNpaperHeight			"DVRpaperHeight"

#define DvrNbuttonBox			"DVRbuttonBox"
#define DvrNpageNumber			"DVRpageNumber"

#define DvrNuseComments			"DVRuseComments"
#define DvrNuseBitmaps			"DVRuseBitmaps"
#define DvrNuseTrays			"DVRuseTrays"
#define DvrNwatchProgress		"DVRwatchProgress"
#define DvrNorientation			"DVRorientation"
#define DvrNscaleValue			"DVRscaleValue"
#define DvrNheaderRequired		"DVRheaderRequired"

#define DvrNscrollBarCallback		"DVRscrollBarCallback"
#define DvrNbuttonsCallback		"DVRbuttonsCallback"
#define DvrNmouseMotionCallback		"DVRmouseMotionCallback"


/*
 * typedef for DVR scroll callback structure
 * (so far, only applies to XWindows)
 */

typedef struct
  {
    int		    reason;   		 /* scroll bar callback reason */
    XEvent	    *event;              /* X event structure */
    int		    Xtop;                /* current X top position within page */
    int		    Ytop;                /* current Y top position within page */
    int		    page_width;		 /* page width */
    int		    page_height;	 /* page height*/
    int		    win_width;		 /* window width */
    int		    win_height;		 /* window height */
  } DvrScrollBarEvent;

#else

/*  item codes for low level viewer create DvrViewerCreate() when
 *  not on DECwindows (OS/2,...)
 */

#define DVR$_SCROLL_HORIZONTAL		101
#define DVR$_SCROLL_VERTICAL		102
#define DVR$_PROCESSING_OPTIONS		103
#define DVR$_PAPER_WIDTH		104
#define DVR$_PAPER_HEIGHT		105
#define DVR$_BUTTON_BOX			106
#define DVR$_PAGE_NUMBER		107
#define DVR$_CALLBACK 			108
#define DVR$_HELP_CALLBACK		109
#define DVR$_X				110
#define DVR$_Y				111
#define DVR$_WIDTH			112
#define DVR$_HEIGHT			113

/* Constants related to import/export help callbacks */

/* The following constants are used for help callbacks in the import/export */
/* dialog box. When the message is WM_USER, the specific help requested is  */
/* indicated by the value of wParam, as indicated below.                    */

#define DvrConvHelpImport		  1  /* lParam */
#define DvrConvHelpNetwork		  2  /* lParam */
#define DvrConvHelpOptions		  3  /* lParam */

/* Type definitions */

typedef struct {
    CDAuserparam   user_param;
    CDAenvirontext CDA_FAR *server;
    CDAenvirontext CDA_FAR *username;
    CDAenvirontext CDA_FAR *password;
    CDAenvirontext CDA_FAR *dir_mask;
    CDAenvirontext CDA_FAR *file_spec;
    CDAenvirontext CDA_FAR *file_format;
    CDAsize        num_options;
    CDAenvirontext CDA_FAR * CDA_FAR * options;
} DvrConvCallbackData;


#endif
/*
**++
**
**  COPYRIGHT (c) 1991 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**	This file contains function prototype definitions for the
**	windowing CDA Viewer Routines.
**--
**/

/*
 * Translate __ predefined symbols to pre ANSI C style when not
 * compiling with an ANSI C conformant compiler.
 */
#include <cdatrans.h>

/*
 * Include CDA defined types.
 */
#ifdef __vms__
#define CDA_DECWINDOWS

#ifndef _cdatyp_
#include <cda$typ.h>
#endif

#endif

#ifdef __unix__
#define CDA_DECWINDOWS

#ifndef _cdatyp_
#include <cda_typ.h>
#endif

#endif

#ifndef CDA_DECWINDOWS
#ifndef _cdatyp_
#include <cda$typ.h>
#endif
#endif

#ifdef CDA_DECWINDOWS
#define DVR_BOOLEAN	Boolean 	/* Boolean is defined by X */
#else
#ifndef HAB
#define HAB HANDLE
#endif
#define DVR_BOOLEAN 	BOOL            /* BOOL is defined by PM */
#endif

#ifndef DVR_VIEW_TYPES

#define DVR_VIEW_TYPES
typedef struct dvrviewerwidget  CDA_FAR * DvrViewerWidget;
#endif

/* external documented entry points */

#ifdef CDA_DECWINDOWS  /*** DECWINDOWS specific definitions ***/

PROTO( DvrViewerWidget DvrViewer,
		(Widget,
		 CDAenvirontext *,
		 Position,
		 Position,
		 Dimension,
		 Dimension,
		 Boolean,
		 Boolean,
		 CDAflags,
		 XtCallbackList,
		 XtCallbackList) );

PROTO( DvrViewerWidget DvrViewerCreate,
		(Widget,
		 CDAenvirontext *,
		 ArgList,
		 CDAcardinal) );

/* converter selection widget create routines */
PROTO( CDAstatus DvrConverterFileSelection,
		(Widget	*,
		 Widget	*,
		 CDAflags,
		 Position,
		 Position,
		 CDAenvirontext	*,
		 Boolean,
		 XtCallbackList) );

PROTO( CDAstatus DvrConvFileSelectionCreate,
		 (Widget *,
		  Widget *,
	   	  CDAitemlist *,
		  XtCallbackList) );

#else  /* OS/2 and/or MS-Windows */

PROTO( DvrViewerWidget CDA_APIENTRY DvrViewer,
		(HAB,
		 HWND,
		 HWND CDA_FAR *,
                 CDAcardinal,
		 CDAcardinal,
		 CDAcardinal,
		 CDAcardinal,
		 DVR_BOOLEAN,
		 DVR_BOOLEAN,
		 CDAflags,
		 void (CDA_CALLBACK *) (HWND, DvrCallbackStruct CDA_FAR *),
                 void (CDA_CALLBACK *) (HWND, DvrCallbackStruct CDA_FAR *) ));

PROTO( DvrViewerWidget CDA_APIENTRY DvrViewerCreate,
		(HAB,
		 HWND,
		 HWND CDA_FAR *,
		 CDAitemlist CDA_FAR *) );

PROTO(CDAstatus CDA_APIENTRY DvrSetValues,
		(DvrViewerWidget,
		 CDAitemlist CDA_FAR *) );

PROTO(CDAstatus CDA_APIENTRY DvrGetValues,
		(DvrViewerWidget,
		 CDAitemlist CDA_FAR *) );

PROTO(CDAstatus CDA_APIENTRY DvrLoadFile,
		(DvrViewerWidget,
		 CDAenvirontext CDA_FAR *,
		 CDAenvirontext CDA_FAR *,
		 CDAenvirontext CDA_FAR *,
		 CDAstatus (CDA_CALLBACK *) (CDAuserparam, CDAsize CDA_FAR *, 
					     CDAbufaddr CDA_FAR *),
		 CDAuserparam) );

PROTO(CDAstatus CDA_APIENTRY DvrDisplayFirstPage,
                (DvrViewerWidget) );

PROTO (HWND CDA_APIENTRY DvrConverterFileSelection, 
            (HWND,
	     CDAconstant,
	     int,
	     int,
   	     CDAenvirontext CDA_FAR *,
	     CDAboolean, 
             BOOL (CDA_CALLBACK *)(HWND, WORD, WORD, LONG)));

PROTO (HWND CDA_APIENTRY DvrConvFileSelectionCreate,
            (HWND, 
             DVR_BOOLEAN (CDA_CALLBACK *)(HWND, WORD, WORD, LONG), 
             CDAitemlist CDA_FAR *));

#endif

PROTO(CDAstatus CDA_APIENTRY DvrViewerFile,
		(DvrViewerWidget,
		 CDAenvirontext CDA_FAR *,
		 CDAenvirontext CDA_FAR *,
		 CDAenvirontext CDA_FAR *,
		 CDAstatus (CDA_CALLBACK *) (CDAuserparam, CDAsize CDA_FAR *, 
					     CDAbufaddr CDA_FAR *),
		 CDAuserparam) );

PROTO(CDAstatus CDA_APIENTRY DvrRegisterClass,
		() );

PROTO(CDAstatus CDA_APIENTRY DvrCloseFile,
		(DvrViewerWidget) );

PROTO(CDAstatus CDA_APIENTRY DvrDocumentInfo,
		(DvrViewerWidget,
		 CDAenvirontext CDA_FAR * CDA_FAR *) );

PROTO(CDAstatus CDA_APIENTRY DvrTopDocument,
		(DvrViewerWidget) );

PROTO(CDAstatus CDA_APIENTRY DvrBottomDocument,
		(DvrViewerWidget) );

PROTO(CDAstatus CDA_APIENTRY DvrNextPage,
		(DvrViewerWidget) );

PROTO(CDAstatus CDA_APIENTRY DvrPreviousPage,
		(DvrViewerWidget) );

PROTO(CDAstatus CDA_APIENTRY DvrGotoPage,
		(DvrViewerWidget,
		 CDAconstant) );

/**/
/******************************************************************************/
/**                                                                          **/
/**  Copyright (c) 1991                                                      **/
/**  by DIGITAL Equipment Corporation, Maynard, Mass.                        **/
/**                                                                          **/
/**  This software is furnished under a license and may be used and  copied  **/
/**  only  in  accordance  with  the  terms  of  such  license and with the  **/
/**  inclusion of the above copyright notice.  This software or  any  other  **/
/**  copies  thereof may not be provided or otherwise made available to any  **/
/**  other person.  No title to and ownership of  the  software  is  hereby  **/
/**  transferred.                                                            **/
/**                                                                          **/
/**  The information in this software is subject to change  without  notice  **/
/**  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  **/
/**  Corporation.                                                            **/
/**                                                                          **/
/**  DIGITAL assumes no responsibility for the use or  reliability  of  its  **/
/**  software on equipment which is not supplied by DIGITAL.                 **/
/**                                                                          **/
/******************************************************************************/
/********************************************************************************************************************************/
/* Created  3-AUG-1991 18:09:41 by VAX SDL V3.2-12     Source:  3-AUG-1991 18:09:36 DDIF$DEVELOP_ROOT:[DDIFBUILD.DVR.SRC]DVR$MSG. */
/********************************************************************************************************************************/
 
/*** MODULE $DVRDEF ***/
#define DVR$_FACILITY 859
#define DVR$_NORMAL 56328201
#define DVR$_FILENOTFOUND 56328211
#define DVR$_NOFONT 56328219
#define DVR$_TOPOFDOC 56328227
#define DVR$_INVALREQ 56328235
#define DVR$_EOD 56328243
#define DVR$_EOC 56328251
#define DVR$_SCRFULL 56328259
#define DVR$_DEFAULTFONT 56328267
#define DVR$_ALREADYWIDGET 56328275
#define DVR$_NODISPCONT 56328283
#define DVR$_FILENOTOPEN 56328291
#define DVR$_OPENFAIL 56328300
#define DVR$_INVADDR 56328308
#define DVR$_INVTEXTUNIT 56328316
#define DVR$_INVFILETYPE 56328324
#define DVR$_NOCONVERTER 56328332
#define DVR$_MEMALLOFAIL 56328340
#define DVR$_MEMDEALLOFAIL 56328348
#define DVR$_INTERNALERROR 56328356
#define DVR$_BADFRAMETYPE 56328364
#define DVR$_DDIFERR 56328372
#define DVR$_DDIFDELERR 56328380
#define DVR$_NOTDDIFDOC 56328388
#define DVR$_BADINFILENAME 56328396
#define DVR$_BADOUTFILENAME 56328404
#define DVR$_OUTFILEOPEN 56328412
#define DVR$_OUTFILECLOSE 56328420
#define DVR$_OUTFILEWRITE 56328428
#define DVR$_FATALERROR 56328436
#define DVR$_DRMREGISTERFAIL 56328444
#define DVR$_DRMHIERARCHYFAIL 56328452
#define DVR$_DRMMAINFETCHFAIL 56328460
#define DVR$_DRMSTRINGFETCHFAIL 56328468
#define DVR$_DRMPOPUPFETCHFAIL 56328476
#define DVR$_NOTBITONAL 56328483
#define DVR$_IMAGEFAIL 56328491
#define DVR$_GRAPHICFAIL 56328499
#define DVR$_UNKOBJTYPE 56328507
#define DVR$_PAGENOTFOUND 56328515
#define DVR$_FORMATINFO 56328523
#define DVR$_TEXTFAIL 56328531
#define DVR$_FORMATWARN 56328536
#define DVR$_UNKSTRTYPE 56328548
#define DVR$_BADPARAM 56328556
#define DVR$_FORMATERROR 56328564
#define DVR$_NOPSHEAD 56328572
#define DVR$_NODPSEXT 56328580
#define DVR$_NOPAGE 56328588
#define DVR$_OBSOLETE 56328594
#define DVR$_BADCOMMENTS 56328600
#define DVR$_LOADINPROGRESS 56328610
#define _dvr_cdef_

/*
**++
**  COPYRIGHT (c) 1988, 1992 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**  	this file will include all the public
**  	entry points for appications calling the
**  	CDA character cell viewer.
**
** Modified by:
**
**	V01-003		RJD000		Ronan Duke		28-Mar-1994
**		Merged in code from DEC Asia - to handle Asian characters
**
**	V01-002		SJM0000		Stephen Munyan		18-May-1992
**		Merged in code from DEC Japan as a result of their code
**		merge.
**
**	V01-001		ECR0000		Elizabeth C. Rust	30-Mar-1992
**		merge in audio code
**
**--
**/

/**
 ** Character cell viewer constants and structure defs
 **/
/*
 * Selectoptions flags, all are boolean
 */
#define DVR_M_SoftDirectives   (1L<<0)	/* obey soft directives		*/
#define DVR_M_Auto_Wrap	       (1L<<1)	/* do word-wrap formatting of text */
#define DVR_M_Outfile	       (1L<<2)	/* output to file		*/
#define DVR_M_Paging	       (1L<<3)	/* pause at end of page		*/
#define DVR_M_Text	       (1L<<4)	/* output text			*/
#define DVR_M_Images	       (1L<<5)	/* text placeholder for images	*/
#define DVR_M_Graphics	       (1L<<6)	/* text placeholder for graphics*/
#define DVR_M_ReportErrors     (1L<<7)	/* write errors to stderr   */
#define DVR_M_Layout	       (1L<<8)	/* Do layout		    */
#define DVR_M_SpecificLayout   (1L<<9)	/* Do specific layout	    */
#define DVR_M_Text_Backend     (1L<<10)	/* Act like a text backend*/
/* BEGIN AUDIO STUFF */
#ifdef CDA_AUDIO_SUPPORT
#define DVR_M_Audio	       (1L<<11)	/* text placeholder for audio	*/
#endif
/* END AUDIO STUFF */
#ifdef I18N_MULTIBYTE
#define DVR_M_Ascii_Fallback   (1L<<12)	/* Do Ascii Fallback            */
#endif

/* BEGIN AUDIO */
#ifdef CDA_AUDIO_SUPPORT
#define DVR_M_DefaultOptions					    \
      DVR_M_SoftDirectives | DVR_M_Auto_Wrap | DVR_M_Outfile \
    | DVR_M_Text | DVR_M_Images | DVR_M_Graphics | DVR_M_Audio \
    | DVR_M_Layout | DVR_M_SpecificLayout
#else
#define DVR_M_DefaultOptions					    \
      DVR_M_SoftDirectives | DVR_M_Auto_Wrap | DVR_M_Outfile \
    | DVR_M_Text | DVR_M_Images | DVR_M_Graphics	     \
    | DVR_M_Layout | DVR_M_SpecificLayout
#endif
/* Item codes for CDA_CONVERT, CDA_OPEN_CONVERTER, domain$READ_format, and  */
/* domain$WRITE_format.  The DVR_ prefix has been substituted for the CDA_  */
/* prefix.								    */
#define DVR_PROCESSING_OPTION 1        /* Processing option                */
#define DVR_INPUT_FORMAT 2             /* Input document format-name       */
#define DVR_INPUT_FRONT_END_PROCEDURE 3 /* Input document front-end procedure */
#define DVR_INPUT_FILE 4               /* Input file specification         */
#define DVR_INPUT_DEFAULT 5            /* Input default file specification */
#define DVR_INPUT_PROCEDURE 6          /* Input get data procedure         */
#define DVR_INPUT_POSITION_PROCEDURE 7 /* Input get position procedure     */
#define DVR_INPUT_PROCEDURE_PARM 8     /* Input procedure parameter        */
#define DVR_INPUT_ROOT_AGGREGATE 9     /* Input root aggregate             */
#define DVR_OUTPUT_FORMAT 10           /* Output document format-name      */
#define DVR_OUTPUT_BACK_END_PROCEDURE 11 /* Output document back-end procedure */
#define DVR_OUTPUT_FILE 12             /* Output file specification        */
#define DVR_OUTPUT_DEFAULT 13          /* Output default file specification */
#define DVR_OUTPUT_PROCEDURE 14        /* Output procedure                 */
#define DVR_OUTPUT_PROCEDURE_PARM 15   /* Output procedure parameter       */
#define DVR_OUTPUT_PROCEDURE_BUFFER 16 /* Output procedure initial buffer  */
#define DVR_OUTPUT_ROOT_AGGREGATE 17   /* Output root aggregate            */
#define DVR_OPTIONS_FILE 18            /* Options file specification       */

/*
**  This following item codes area unique to the CC viewer.  They are intended
**  for use in the private item list argument to the DvrCCInitialize routine.
*/
#define DVR_FRONT_END_HANDLE 	256	/* front end input procedure handle */
#define DVR_PAGE_HEIGHT	257	/* formatted page height in chars   */
#define DVR_PAGE_WIDTH		258	/* formatted page width in chars    */
#ifdef I18N_MULTIBYTE
#define DVR_TEXT_ENCODING 	259 /* text encoding name               */
#endif
#ifndef _dvr_cint_
#define _dvr_cint_

/*
**++
**   COPYRIGHT (c) 1989, 1992 BY
**   DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**   ALL RIGHTS RESERVED.
**
**   THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**   ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**   INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**   COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**   OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
**   TRANSFERRED.
**
**   THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**   AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
**   CORPORATION.
**
**    DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**    SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
** FACILITY:
**
**	Compound Document Architecture (CDA)
**	Compound Document Viewers
**	DIGITAL Document Interchange Format (DDIF)
**
** ABSTRACT:
**
**	Internal definitions.
**
** AUTHORS:
**
**      Peter Derr, Barbara Bazemore
**
** MODIFIED BY:
**
**	V02-019		RJD000		Ronan Duke		28-Mar-1994
**		Merge in changes from DEC Hong Kong for handling 
**		Asian characters
**
**	V02-018		DAM000		Dennis McEvoy		18-Jun-1992
**		match up context fields with engine types
**
**	V02-017		DAM000		Dennis McEvoy		03-Jun-1992
**		use CDAuserparam for generic routine params
**
**	V02-016		DAM000		Dennis McEvoy		29-May-1992
**		cleanup typedefs for alpha/osf1
**
**	V02-015		ECR000		Elizabeth C. Rust	30-Mar-1992
**		Merge in audio code.
**
**	V02-014		SJM000		Stephen Munyan		 9-Jan-1992
**		Merge in changes from DEC Japan
**
**	V02-013		DAM000		Dennis McEvoy		05-aug-1991
**		rename, remove dollar signs
**
**	V02-012		SJM000		Stephen Munyan		17-Jul-1991
**		DEC C Cleanups for Alpha
**
**	V02-011		DAM002		Ralph A. Mak		03-Apr-1991
**		cleanup typedefs
**
**	V02-010		RAM002		Ralph A. Mak		01-Apr-1991
**		Use CDAenvirontext *, CDAsize on CbrSet/CheckCCRendBit routine
**		protos.
**
**	V02-009		PBD002		Peter Derr		 1-Mar-1991
**		Revise to use new CDA type defs.
**
**      V02-008         RAM001          Ralph A. Mack           06-Dec-1990
**              Add support for MS-DOS/MS-Windows. Rename CDA_APIENTRY to
**              CDA_APIENTRY.
**
**	V02-007		SJM000		Stephen Munyan		 5-Nov-1990
**		Add in PROTO statements for CBR routines
**
**	V02-006		SJM000		Stephen Munyan		 8-Oct-1990
**		Merge in CBR changes from Charlie Chan
**
**	V02-005		PBD001		Peter Derr		19-Jul-90
**		Don't redefine WARNING macro.
**
**	V02-004		JJT002		Jeff Tancill		12-Jun-1990
**              Use struct cda_converter instead of explicit struct converter in
**              context structure.
**
**	V02-003		JJT001		Jeff Tancill		12-Apr-1990
**		Switch over to new typedef names utilizing prepended CDA_
**		to avoid name space collisions with application code.
**
**	V02-002		SJM001		Stephen Munyan	       14-Dec-1989
**		Changed static definitions to be read only and sharable.
**
**	V02-001		BB0001		Barbara Bazemore	3-May-1989
**		Initial creation from DVS_INT.H
**--
*/


/*
**
**  MACRO DEFINITIONS
**
*/

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif


/*
 * Error message stuff
 */
#ifdef __vms__
#define WARNING_STATE	STS$K_WARNING
#define SUCCESS_STATE	STS$K_SUCCESS
#define ERROR_STATE	STS$K_ERROR
#define INFO_STATE	STS$K_INFO
#define SEVERE_STATE	STS$K_SEVERE
#define M_SEVERITY	STS$M_SEVERITY
#endif

#if defined(OS2) || defined(msdos)
#define WARNING_STATE	0
#define SUCCESS_STATE	1
#define ERROR_STATE   	2
#define INFO_STATE	3
#define SEVERE_STATE	4
#define M_SEVERITY	0x00000007
#endif

#ifdef __unix__
#define WARNING_STATE	0
#define SUCCESS_STATE	1
#define ERROR_STATE   	2
#define INFO_STATE	3
#define SEVERE_STATE	4
#define M_SEVERITY	0x00000007
#endif

/* Define status checking macro, check that lowest bit is set */
#ifdef __vms__
#define DVRSuccess(status)	((status & STS$M_SUCCESS)!=0)
#define DVRFailure(status)	((status & STS$M_SUCCESS) ==0)

#else
#define DVRSuccess(status) (((status) & 1) != 0)
#define DVRFailure(status) (((status) & 1) == 0)

#endif

/*
 * Memory allocation and deallocation macros
 */

#define DVR_GET_MEMORY(size, address, id) 				\
	dvr_get_memory(size, (CDAaddress *)address, (short)id)

#define DVR_FREE_MEMORY(address)				\
	(CdaFree(*(address)) != 0 ? DVR_MEMDEALLOFAIL : DVR_NORMAL)


/*
 * Item list definition macro
 */
#define MAKE_ITEM(item, i, code, length, address)			  \
{(item)[i].item_code   = (unsigned short) (code);			  \
 (item)[i].item_length = (unsigned short) (length);			  \
 (item)[i].CDAitemparam.item_address = (char *)(address);}

/*
 * Macro to find an item code in an item list. Item lists must be terminated
 * with an item_code of 0.
 */
#define FIND_ITEM(item_list, code, i)					    \
   while ((item_list[i].item_code != (code)) && (item_list[i].item_code != 0)) \
	i++;			    					    \



/*
**
**  CONSTANTS
**
*/


/* messages to be posted if graphic or image not displayed */

#ifdef __vms__
#pragma nostandard
#endif

static READ_ONLY CDAenvirontext DVR_GRAPHIC_MESSAGE[] = "<< Graphics content appears here >>";
static READ_ONLY CDAenvirontext DVR_SHORT_GRAPHIC_MESSAGE[] = "<< Graphics >>";

static READ_ONLY CDAenvirontext DVR_IMAGE_MESSAGE[] = "<< Image content appears here >>";
static READ_ONLY CDAenvirontext DVR_SHORT_IMAGE_MESSAGE[] = "<< Image >>";

/* BEGIN AUDIO STUFF */
#ifdef CDA_AUDIO_SUPPORT
static READ_ONLY CDAenvirontext DVR_AUDIO_MESSAGE[] = "<< Audio content appears here >>";
static READ_ONLY CDAenvirontext DVR_SHORT_AUDIO_MESSAGE[] = "<< Audio >>";
#endif
/* END AUDIO STUFF */

#ifdef __vms__
#pragma standard
#endif


#define DVR_GR_MSG_SIZE 36			/* including null terminator */
#define DVR_SHORT_GR_MSG_SIZE 15		/* including null terminator */
#define DVR_IMG_MSG_SIZE 33			/* including null terminator */
#define DVR_SHORT_IMG_MSG_SIZE 12		/* including null terminator */
/* BEGIN AUDIO STUFF */
#ifdef CDA_AUDIO_SUPPORT
#define DVR_AUD_MSG_SIZE 33			/* including null terminator */
#define DVR_SHORT_AUD_MSG_SIZE 12		/* including null terminator */
#endif
/* END AUDIO STUFF */

#define FONT_SUBSTITUTE_NAME_12PT					      \
		"-ADOBE-Courier-Medium-R-Normal--12-120-75-75-M-70-ISO8859-1"
#define FONT_SUBSTITUTE_NAME_10PT					      \
		"-ADOBE-Courier-Medium-R-Normal--10-100-75-75-M-60-ISO8859-1"
#define FONT_SUBSTITUTE_NAME_8PT					      \
		"-ADOBE-Courier-Medium-R-Normal--8-80-75-75-M-50-ISO8859-1"
#define FONT_SUBSTITUTE_NAME_LENGTH	59 /* max length of font name strings */

#define MAX_FILENAME_SIZE      255
#define DEFAULT_WIDTH	       132 /* max chars per line, if not otherwise specified */
#define INIT_BUFFER_LINES	20 /* initial number of lines in internal   */
				   /* text buffer when page height not	    */
				   /* specified				    */

#define CPNTS_PER_CHAR_VERT ( (viewer_context->point_size == 8) ? 800 :	    \
    ( (viewer_context->point_size == 10)  ? 1000 : 1200 ) )
#define CPNTS_PER_CHAR_HORIZ ( (viewer_context->point_size == 8) ? 480:	    \
    ( (viewer_context->point_size == 10)  ? 600 : 720) )

/* cbr stuff */

/*
 * Note that the following constants are used for the character cell
 * Viewer such that we can determine which line the reference is on.
 *
 * The CBR_MAX_HIGHLIGHT_LINES constant indicates the maximum number
 * of lines on a page that we can process.  Any references on lines
 * past this point will not be flagged.
 */

#define CBR_MAX_HIGHLIGHT_LINES	(128)
#define CBR_HIGHLIGHT_BIT_SIZE	(CBR_MAX_HIGHLIGHT_LINES/8)

/* end cbr stuff */




/*
 * Type declarations
 */

/*
 * Define structure to hold information on pages returned to the caller.
 */
typedef	struct	page_structure
	    {
		struct page_structure *next;
		struct page_structure *previous;
		CDAsize		page_number;
		CDAsize		number_of_lines;
		CDAenvirontext 	**line_array;
		CDAsize		*line_size_array;
/* cbr stuff */

		CDAenvirontext	cbr_line_bit[CBR_HIGHLIGHT_BIT_SIZE];
		CDAuint32	pag_cbr_marked;

/* end cbr stuff */

	    }	PAGE_STRUCTURE;


/*
** Context structure used in DVR_CC_VIEWER, and DVR_CC_GET_PAGE modules.
*/

typedef	struct	cc_viewer_context_struct
	    {
		ENG		dvs_context_pointer;
		PAG		dvs_page_structure_ptr;
		CDAmeasurement	page_width;	/* characters */
		CDAmeasurement	page_height;	/* characters */
		CDAmeasurement	doc_page_width;	/* centipoints */
		CDAmeasurement	doc_page_height;/* centipoints */
		CDAsize		point_size;	/* points */
		PAGE_STRUCTURE  *page_list;
		CDAenvirontext	*work_buffer;
		CDAsize		lines_in_buffer;
		CDAsize		last_line_filled;
		CDAsize		last_line_output;
		CDAstatus	status;
		CDAconverterhandle converter_context;
		struct	flags
		{
		    unsigned int text_backend : 1;
		    unsigned int graphics : 1;
		    unsigned int images	 : 1;
/* BEGIN AUDIO STUFF */
#ifdef CDA_AUDIO_SUPPORT
		    unsigned int audio	 : 1;
#endif
/* END AUDIO STUFF */
		    unsigned int text	 : 1;
		    unsigned int outfile_specified : 1;
		    unsigned int paging	 : 1;
		    unsigned int soft_directives : 1;
		    unsigned int auto_wrap : 1;
		    unsigned int layout	: 1;
		    unsigned int specific_layout : 1;
		    unsigned int report_errors : 1;
		    unsigned int buffer_flushed : 1;
		    unsigned int eod_reached : 1;
#ifdef I18N_MULTIBYTE
		    unsigned int ascii_fallback : 1;
#endif
		}	flags;

/* cbr stuff */

		CDAuint32 	cbr_mode;
		CDAuint32 	pag_cbr_marked;
		unsigned char 	*cbr_line_bit;
		CDAenvirontext 	cbr_frg_bit[CBR_HIGHLIGHT_BIT_SIZE];

/* end cbr stuff */

/* i18n changes  */
#ifdef I18N_MULTIBYTE
		CDAoctet	*work_buffer_csid;         /* csid mapping */
		CDAenvirontext	*work_output_buffer;       /* output buffer */
		CDAsize		work_output_buffer_length; /* buffer length */
		CDAindex	text_encoding_ix;  /* text encoding index */
		CDAuserparam	put_cstring_context; /* put_cstring context */
#endif

	    }	CC_VIEWER_CONTEXT_STRUCT;

#define CC_VIEW_TYPES 1

#ifdef I18N_MULTIBYTE

typedef struct {
     char *name;
     PROTO(CDAstatus (CDA_CALLBACK *init_put_cstring),
	   (CDAuserparam *));
     PROTO(CDAstatus (CDA_CALLBACK *put_cstring),
	   (CDAuserparam, CDAenvirontext *, CDAsize, CDAconstant, CDAbufaddr *, CDAsize *));
     PROTO(CDAstatus (CDA_CALLBACK *close_put_cstring),
	   (CDAuserparam));
} TextEnc;

#endif

/*
**
**  CC internal function prototypes
**
*/
PROTO(CDAstatus CDA_APIENTRY Dvr_CC_Viewer_Backend, (CDAconstant *, CDAitemlist *,
	    CC_VIEWER_CONTEXT_STRUCT **, CDAfrontendhandle  *, CDAuserparam *));
PROTO(CDAstatus CDA_APIENTRY dvr_get_memory, (CDAsize *, CDAaddress *, CDAcardinal));
PROTO(CDAstatus CDA_APIENTRY reallocate_text_buff, (CDAenvirontext * *, CDAsize *,
						    CDAsize));

#ifdef I18N_MULTIBYTE
PROTO(CDAstatus CDA_APIENTRY reallocate_text_buff_csid, (CDAoctet * *, CDAsize *,
							 CDAsize));
#endif
/* cbr stuff */

PROTO(void CDA_APIENTRY DvrCbrSetCCRendBit, (CDAenvirontext *, CDAsize));
PROTO(CDAstatus CDA_APIENTRY DvrCbrCheckCCRendBit, (CDAenvirontext *, CDAsize));
PROTO(void CDA_APIENTRY DvrCbrSetHndl, (CC_VIEWER_CONTEXT_STRUCT *, 
CDAstatus (*)(), CDAuserparam, CDAuint32));
PROTO(void CDA_APIENTRY DvrCbrClearHndl, (CC_VIEWER_CONTEXT_STRUCT *));

/* end cbr stuff */

#endif
#ifndef _dvr_cc_ptp_
#define _dvr_cc_ptp_
/*
**++
**
**  COPYRIGHT (c) 1989, 1991 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**	This file contains function prototype definitions for the DVR 
**	character cell viewer callable routines.
**
**--
**/

#ifndef _cdatyp_
#include <cdatyp.h>
#endif

#ifndef CC_VIEW_TYPES
typedef struct cc_viewer_context_struct {int opaque;} CC_VIEWER_CONTEXT_STRUCT;
#endif

PROTO(  CDAstatus CDA_APIENTRY DvrCCGetPage, (CC_VIEWER_CONTEXT_STRUCT * *,
				    CDAsize *, CDAenvirontext ***, CDAsize **));
PROTO(  CDAstatus CDA_APIENTRY DvrCCDeletePage, (CC_VIEWER_CONTEXT_STRUCT * *,
						 CDAenvirontext ***));
PROTO(  CDAstatus CDA_APIENTRY DvrCCEnd, (CC_VIEWER_CONTEXT_STRUCT **));
PROTO(  CDAstatus CDA_APIENTRY DvrCCInitialize, (CDAflags, CDAitemlist *, CDAitemlist *,
	CDAsize, CDAsize, CC_VIEWER_CONTEXT_STRUCT **));
#endif
/**/
/******************************************************************************/
/**                                                                          **/
/**  Copyright (c) 1994                                                      **/
/**  by DIGITAL Equipment Corporation, Maynard, Mass.                        **/
/**                                                                          **/
/**  This software is furnished under a license and may be used and  copied  **/
/**  only  in  accordance  with  the  terms  of  such  license and with the  **/
/**  inclusion of the above copyright notice.  This software or  any  other  **/
/**  copies  thereof may not be provided or otherwise made available to any  **/
/**  other person.  No title to and ownership of  the  software  is  hereby  **/
/**  transferred.                                                            **/
/**                                                                          **/
/**  The information in this software is subject to change  without  notice  **/
/**  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  **/
/**  Corporation.                                                            **/
/**                                                                          **/
/**  DIGITAL assumes no responsibility for the use or  reliability  of  its  **/
/**  software on equipment which is not supplied by DIGITAL.                 **/
/**                                                                          **/
/******************************************************************************/
/********************************************************************************************************************************/
/* Created  6-DEC-1994 08:35:27 by VAX SDL V3.2-10     Source:  6-DEC-1994 08:35:18 DECW$APPSRESD:[CDAVIEW.OBJ]DVRMSG.SDL;2 */
/********************************************************************************************************************************/
 
/*** MODULE $DVRDEF ***/
#define DVR_FACILITY 859
#define DVR_NORMAL 56328201
#define DVR_FILENOTFOUND 56328211
#define DVR_NOFONT 56328219
#define DVR_TOPOFDOC 56328227
#define DVR_INVALREQ 56328235
#define DVR_EOD 56328243
#define DVR_EOC 56328251
#define DVR_SCRFULL 56328259
#define DVR_DEFAULTFONT 56328267
#define DVR_ALREADYWIDGET 56328275
#define DVR_NODISPCONT 56328283
#define DVR_FILENOTOPEN 56328291
#define DVR_OPENFAIL 56328300
#define DVR_INVADDR 56328308
#define DVR_INVTEXTUNIT 56328316
#define DVR_INVFILETYPE 56328324
#define DVR_NOCONVERTER 56328332
#define DVR_MEMALLOFAIL 56328340
#define DVR_MEMDEALLOFAIL 56328348
#define DVR_INTERNALERROR 56328356
#define DVR_BADFRAMETYPE 56328364
#define DVR_DDIFERR 56328372
#define DVR_DDIFDELERR 56328380
#define DVR_NOTDDIFDOC 56328388
#define DVR_BADINFILENAME 56328396
#define DVR_BADOUTFILENAME 56328404
#define DVR_OUTFILEOPEN 56328412
#define DVR_OUTFILECLOSE 56328420
#define DVR_OUTFILEWRITE 56328428
#define DVR_FATALERROR 56328436
#define DVR_DRMREGISTERFAIL 56328444
#define DVR_DRMHIERARCHYFAIL 56328452
#define DVR_DRMMAINFETCHFAIL 56328460
#define DVR_DRMSTRINGFETCHFAIL 56328468
#define DVR_DRMPOPUPFETCHFAIL 56328476
#define DVR_NOTBITONAL 56328483
#define DVR_IMAGEFAIL 56328491
#define DVR_GRAPHICFAIL 56328499
#define DVR_UNKOBJTYPE 56328507
#define DVR_PAGENOTFOUND 56328515
#define DVR_FORMATINFO 56328523
#define DVR_TEXTFAIL 56328531
#define DVR_FORMATWARN 56328536
#define DVR_UNKSTRTYPE 56328548
#define DVR_BADPARAM 56328556
#define DVR_FORMATERROR 56328564
#define DVR_NOPSHEAD 56328572
#define DVR_NODPSEXT 56328580
#define DVR_NOPAGE 56328588
#define DVR_OBSOLETE 56328594
#define DVR_BADCOMMENTS 56328600
#define DVR_LOADINPROGRESS 56328610
#define DVR_ARRNOTSUP 56328619
#define DVR_DWVNOTFND 56328628
#define DVR_CCVNOTFND 56328636
#define DVR_DWVBADVER 56328644
#define DVR_CCVBADVER 56328652
#define DVR_AUDIOFAIL 56328658
#define DVR_AUDBUTTONFETCHFAIL 56328666
#define DVR_AUDDIALFAIL 56328674
#define DVR_AUDCONNECTFAIL 56328682
#define DVR_AUDLOADFAIL 56328690
#define DVR_AUDSERVFAIL 56328698
#define DVR_DRMCTXFAIL 56328706
#define DVR_DRMDPYFAIL 56328716
#define DVR_PRINTERROR 56328722
#define DVR_CDAABORT 56328728
#ifndef _dvrwdef_
#define _dvrwdef_
/*
**++
**  COPYRIGHT (c) 1987, 1992 BY
**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**  ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
**  ABSTRACT:
**  	this file will include all the public
**  	definitions for appications calling the
**  	windowing CDA Viewer interface. Note, public function
**	prototypes are in dvrwptp.h
**
**--
**/

/*
 * Translate __ predefined symbols to pre ANSI C style when not
 * compiling with an ANSI C conformant compiler.
 */
#include <cdatrans.h>


#ifdef __vms__
#define CDA_DECWINDOWS
#endif

#ifdef __unix__
#define CDA_DECWINDOWS
#endif

#ifndef _cdatyp_
#include <cdatyp.h>
#endif

/*
 * typedef for DVR callback structure
 */

typedef struct
  {
    int		    reason;

#ifdef CDA_DECWINDOWS
    XEvent	    *event;
#endif

    CDAstatus 	    status;
    CDAenvirontext  CDA_FAR *string_ptr;
  } DvrCallbackStruct;

#define DvrCRactivate	 		0
#define DvrCRendDocument  		1
#define DvrCRhelpRequested		2
#define DvrCRcdaError			3
#define DvrCRpsOK			4
#define DvrCRexpose			5
#define DvrCRmouseMotion		6
#define DvrCRbuttonEvent		7
#define DvrCRscrollBarEvent		8
#define DvrCRprintPageCounter		9

/*
 * SELECT options flags (Make sure don't conflict w/ CC Viewer flag position
 * when adding more.)  These flags must match the correponding CC Viewer values.
 */
#define DvrSoftDirectives 		(1<<0)
#define DvrWordWrap			(1<<1)
#define DvrText				(1<<4)	/* output text		    */
#define DvrImages			(1<<5)	/* output images	    */
#define DvrGraphics			(1<<6)	/* output graphics	    */
#define DvrLayout			(1<<8)	/* Do layout		    */
#define DvrSpecificLayout		(1<<9)	/* Do specific layout	    */

/* Values for item list codes used in Converter Selection Widget. */

#define DvrOptionFlags			201
#define DvrFileSelectionOverride	202
#define DvrFormatSelectionList		203
#define DvrInitialFormatSelection	204
#define DvrOptionalLabelButton		205
#define DvrOptionalIconButton		206
#define DvrDirectoryMask		207
#define DvrWindowX			208
#define DvrWindowY			209
#define DvrWindowCaption		210
#define DvrServerNode			211
#define DvrUsername			212
#define DvrPassword			213
#define DvrUserParameter		214

/* Mask values for option flags in Converter Selection Widget. */

#define DvrMinputFile		  	  1
#define DvrMoutputFile		  	  2
#define DvrMlistDDIFformats		  4
#define DvrMlistDTIFformats		  8
#define DvrMlistCDAformats		 16
#define DvrMlistAllFormats		252
#define DvrMnoMaskModification		256
#define DvrMomitOptionsFile		512
#define DvrMomitOptionsButton		512
#define DvrMomitNetworkButton	       1024


#ifdef CDA_DECWINDOWS

/* literals to be used for CDA X viewer (specific to Xwindows) */

#define DvrViewerClassStr 		"DVRviewer"

#define DvrNscrollHorizontal 		"DVRscrollHorizontal"
#define DvrNscrollVertical 		"DVRscrollVertical"
#define DvrNprocessingOptions		"DVRprocessingOptions"
#define DvrNpaperWidth			"DVRpaperWidth"
#define DvrNpaperHeight			"DVRpaperHeight"

#define DvrNbuttonBox			"DVRbuttonBox"
#define DvrNpageNumber			"DVRpageNumber"

#define DvrNuseComments			"DVRuseComments"
#define DvrNuseBitmaps			"DVRuseBitmaps"
#define DvrNuseTrays			"DVRuseTrays"
#define DvrNwatchProgress		"DVRwatchProgress"
#define DvrNorientation			"DVRorientation"
#define DvrNscaleValue			"DVRscaleValue"
#define DvrNheaderRequired		"DVRheaderRequired"

#define DvrNscrollBarCallback		"DVRscrollBarCallback"
#define DvrNbuttonsCallback		"DVRbuttonsCallback"
#define DvrNmouseMotionCallback		"DVRmouseMotionCallback"


/*
 * typedef for DVR scroll callback structure
 * (so far, only applies to XWindows)
 */

typedef struct
  {
    int		    reason;   		 /* scroll bar callback reason */
    XEvent	    *event;              /* X event structure */
    int		    Xtop;                /* current X top position within page */
    int		    Ytop;                /* current Y top position within page */
    int		    page_width;		 /* page width */
    int		    page_height;	 /* page height*/
    int		    win_width;		 /* window width */
    int		    win_height;		 /* window height */
  } DvrScrollBarEvent;

#else

/* define viewer custom control string */
#define DVR_CONTROL_STR	"CDAViewer"

/* define styles for viewer custom control */
#define DVR_DEF_STYLE			  0
#define DVR_WINONLY_STYLE		  1
#define DVR_HBAR_STYLE			  2
#define DVR_VBAR_STYLE		  	  4
#define DVR_BBOX_STYLE			  8

/*  item codes for low level viewer create DvrViewerCreate() when
 *  not on DECwindows (OS/2,...)
 */

#define DVR_SCROLL_HORIZONTAL		101
#define DVR_SCROLL_VERTICAL		102
#define DVR_PROCESSING_OPTIONS		103
#define DVR_PAPER_WIDTH		104
#define DVR_PAPER_HEIGHT		105
#define DVR_BUTTON_BOX			106
#define DVR_PAGE_NUMBER		107
#define DVR_CALLBACK 			108
#define DVR_HELP_CALLBACK		109
#define DVR_X				110
#define DVR_Y				111
#define DVR_WIDTH			112
#define DVR_HEIGHT			113

/* Constants related to import/export help callbacks */

/* The following constants are used for help callbacks in the import/export */
/* dialog box. When the message is WM_USER, the specific help requested is  */
/* indicated by the value of wParam, as indicated below.                    */

#define DvrConvHelpImport		  1  /* lParam */
#define DvrConvHelpNetwork		  2  /* lParam */
#define DvrConvHelpOptions		  3  /* lParam */

/* Type definitions */

typedef struct {
    CDAuserparam   user_param;
    CDAenvirontext CDA_FAR *server;
    CDAenvirontext CDA_FAR *username;
    CDAenvirontext CDA_FAR *password;
    CDAenvirontext CDA_FAR *dir_mask;
    CDAenvirontext CDA_FAR *file_spec;
    CDAenvirontext CDA_FAR *file_format;
    CDAsize        num_options;
    CDAenvirontext CDA_FAR * CDA_FAR * options;
} DvrConvCallbackData;

typedef PROTO (BOOL (CDA_CALLBACK *DvrAbortProcPtr), (HDC, short));

typedef struct {
    void CDA_FAR    *print_info; 	/* FAR pointer to a PRINTDLG */
    DvrAbortProcPtr abort_proc_ptr;     /* ptr to Abort Procedure */
    int		    escape_return_code;	/* return code from Escape() */
} DvrPrintStruct;


#endif

#endif

#ifndef __ENVDEF_LOADED
#define __ENVDEF_LOADED	1

/*** MODULE $envdef ***/
/*                                                                          */
/* ENV - Define/reference an environment                                    */
/*                                                                          */
#define ENV$M_DEF 1
#define ENV$M_NESTED 2
#pragma nostandard
struct envdef {
    unsigned char env$b_gsdtyp;         /*Type field                        */
    variant_union  {
        unsigned short int env$w_flags; /*Environment flags                 */
        variant_struct  {
            unsigned env$v_def : 1;     /*Definition of environment         */
            unsigned env$v_nested : 1;  /*Nested environment if set         */
            unsigned env$v_fill_20 : 6;
            } env$r_flags_bits;
        } env$r_flags_overlay;
    unsigned short int env$w_envindx;   /*Index of parent environment       */
    unsigned char env$b_namlng;         /*Length of environment name        */
    char env$t_name [31];               /*Environment name                  */
    } ;
#pragma standard

#endif					/* __ENVDEF_LOADED */
#ifndef __EOMDEF_LOADED
#define __EOMDEF_LOADED	1

/*** MODULE $eomdef ***/
/*                                                                          */
/* End of module record (EOM)                                               */
/*                                                                          */
#define EOM$C_SUCCESS 0                 /*Successful (no errors)            */
#define EOM$C_WARNING 1                 /*Warnings issued                   */
#define EOM$C_ERROR 2                   /*Errors detected                   */
#define EOM$C_ABORT 3                   /*Abort the link                    */
#define EOM$K_EOMMIN 2                  /*Min length of EOM record          */
#define EOM$C_EOMMIN 2                  /*Min length of EOM record          */
#define EOM$K_EOMMX1 7                  /*Length of EOM record w/o transfer flags  */
#define EOM$C_EOMMX1 7                  /*Length of EOM record w/o transfer flags  */
#define EOM$K_EOMMAX 8                  /*Maximum length of EOM record      */
#define EOM$C_EOMMAX 8                  /*Maximum length of EOM record      */
#define EOM$M_WKTFR 1
#pragma nostandard
struct eomdef {
    unsigned char eom$b_rectyp;         /*Record type (OBJ$C_EOM)           */
    unsigned char eom$b_comcod;         /*Compiler completion code          */
/*Values                                                                    */
    unsigned char eom$b_psindx;         /*P-sect of transfer address        */
    unsigned long int eom$l_tfradr;     /*Transfer address                  */
    variant_union  {
        unsigned char eom$b_tfrflg;     /*Transfer address flags            */
        variant_struct  {
            unsigned eom$v_wktfr : 1;   /*Transfer address is weak          */
            unsigned eom$v_fill_12 : 7;
            } eom$r_tfrflg_bits;
        } eom$r_tfrflg_overlay;
    } ;
#pragma standard

#endif					/* __EOMDEF_LOADED */
#ifndef __EOMWDEF_LOADED
#define __EOMWDEF_LOADED	1

/*** MODULE $eomwdef ***/
/*                                                                          */
/* End of module record with word of psect (EOMW)                           */
/*                                                                          */
#define EOMW$K_EOMMIN 2                 /*Min length of EOM record          */
#define EOMW$C_EOMMIN 2                 /*Min length of EOM record          */
#define EOMW$K_EOMMX1 8                 /*Length of EOMW record w/o transfer flags  */
#define EOMW$C_EOMMX1 8                 /*Length of EOMW record w/o transfer flags  */
#define EOMW$K_EOMMAX 9                 /*Maximum length of EOMW record     */
#define EOMW$C_EOMMAX 9                 /*Maximum length of EOMW record     */
#define EOMW$M_WKTFR 1
#pragma nostandard
struct eomwdef {
    unsigned char eomw$b_rectyp;        /*Record type (OBJ$C_EOM)           */
    unsigned char eomw$b_comcod;        /*Compiler completion code          */
    unsigned short int eomw$w_psindx;   /*P-sect of transfer address        */
    unsigned long int eomw$l_tfradr;    /*Transfer address                  */
    variant_union  {
        unsigned char eomw$b_tfrflg;    /*Transfer address flags            */
        variant_struct  {
            unsigned eomw$v_wktfr : 1;  /*Transfer address is weak          */
            unsigned eomw$v_fill_13 : 7;
            } eomw$r_tfrflg_bits;
        } eomw$r_tfrflg_overlay;
    } ;
#pragma standard

#endif					/* __EOMWDEF_LOADED */
#ifndef __EPMDEF_LOADED
#define __EPMDEF_LOADED	1

/*** MODULE $epmdef ***/
/*                                                                          */
/* GSD entry - Entry point definition, normal symbols                       */
/*                                                                          */
#define EPM$K_NAME 12
#define EPM$C_NAME 12
#pragma nostandard
struct epmdef {
    variant_union  {
        unsigned char epm$b_gsdtyp;     /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char epm$t_start [];
            char epmdef$$_fill_1;
            } epm$r_gsdtyp_fields;
        } epm$r_gsdtyp_overlay;
    unsigned char epm$b_datyp;          /*Maps over GSY$B_DATYP             */
    unsigned short int epm$w_flags;     /*Maps over GSY$W_FLAGS             */
    unsigned char epm$b_psindx;         /*Maps over SDF$B_PSINDX            */
    unsigned long int epm$l_addrs;      /*Entry point address, maps over SDF$L_VALUE  */
    unsigned short int epm$w_mask;      /*Entry point mask                  */
    unsigned char epm$b_namlng;         /*Length of name                    */
    char epm$t_name [31];               /*Symbol name                       */
    } ;
#pragma standard

#endif					/* __EPMDEF_LOADED */
#ifndef __EPMMDEF_LOADED
#define __EPMMDEF_LOADED	1

/*** MODULE $epmmdef ***/
/*                                                                          */
/* GSD entry - Entry point definition, version mask symbols                 */
/*                                                                          */
#define EPMM$K_NAME 16
#define EPMM$C_NAME 16
#pragma nostandard
struct epmmdef {
    variant_union  {
        unsigned char epmm$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char epmm$t_start [];
            char epmmdef$$_fill_1;
            } epmm$r_gsdtyp_fields;
        } epmm$r_gsdtyp_overlay;
    unsigned char epmm$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int epmm$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned char epmm$b_psindx;        /*Maps over SDF$B_PSINDX            */
    unsigned long int epmm$l_addrs;     /*Entry point address, maps over SDF$L_VALUE  */
    unsigned long int epmm$l_version_mask; /*Mask value for symbol          */
    unsigned short int epmm$w_mask;     /*Entry point mask                  */
    unsigned char epmm$b_namlng;        /*Length of name                    */
    char epmm$t_name [31];              /*Symbol name                       */
    } ;
#pragma standard

#endif					/* __EPMMDEF_LOADED */
#ifndef __EPMVDEF_LOADED
#define __EPMVDEF_LOADED	1

/*** MODULE $epmvdef ***/
/*                                                                          */
/* GSD entry - Entry point definition, vectored symbols                     */
/*                                                                          */
#define EPMV$K_NAME 16
#define EPMV$C_NAME 16
#pragma nostandard
struct epmvdef {
    variant_union  {
        unsigned char epmv$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char epmv$t_start [];
            char epmvdef$$_fill_1;
            } epmv$r_gsdtyp_fields;
        } epmv$r_gsdtyp_overlay;
    unsigned char epmv$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int epmv$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned char epmv$b_psindx;        /*Maps over SDF$B_PSINDX            */
    unsigned long int epmv$l_addrs;     /*Entry point address, maps over SDF$L_VALUE  */
    unsigned long int epmv$l_vector;    /*Vectored entry point address      */
    unsigned short int epmv$w_mask;     /*Entry point mask                  */
    unsigned char epmv$b_namlng;        /*Length of name                    */
    char epmv$t_name [31];              /*Symbol name                       */
    } ;
#pragma standard

#endif					/* __EPMVDEF_LOADED */
#ifndef __EPMWDEF_LOADED
#define __EPMWDEF_LOADED	1

/*** MODULE $epmwdef ***/
/*                                                                          */
/* GSD entry - Entry point definition with word of psect value              */
/*                                                                          */
#define EPMW$K_NAME 13
#define EPMW$C_NAME 13
#pragma nostandard
struct epmwdef {
    variant_union  {
        unsigned char epmw$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char epmw$t_start [];
            char epmwdef$$_fill_1;
            } epmw$r_gsdtyp_fields;
        } epmw$r_gsdtyp_overlay;
    unsigned char epmw$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int epmw$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned short int epmw$w_psindx;   /*Maps over SDFW$W_PSINDX           */
    unsigned long int epmw$l_addrs;     /*Entry point address, maps over SDFW$L_VALUE  */
    unsigned short int epmw$w_mask;     /*Entry point mask                  */
    unsigned char epmw$b_namlng;        /*Length of name                    */
    char epmw$t_name [31];              /*Symbol name                       */
    } ;
#pragma standard

#endif					/* __EPMWDEF_LOADED */
#ifndef __ERADEF_LOADED
#define __ERADEF_LOADED	1

/*** MODULE $eradef ***/
/*                                                                          */
/*                                                                          */
/* Define erase type codes.  The codes LODUMMY and HIDUMMY are              */
/* used as placeholders, to make the definition of the upper and            */
/* lower bound erase type symbols automatic.  New erase type codes          */
/* should be added at the end of the list, but before HIDUMMY.              */
/*                                                                          */
/*                                                                          */
#define ERA$K_LODUMMY 0                 /*                                  */
#define ERA$K_MEMORY 1                  /* Erase main memory                */
#define ERA$K_DISK 2                    /* Erase disk mass storage          */
#define ERA$K_TAPE 3                    /* Erase magnetic tape mass storage */
#define ERA$K_HIDUMMY 4                 /*                                  */
#define ERA$K_MINTYPE 1                 /* Lower bound of erase type codes  */
#define ERA$K_MAXTYPE 3                 /* Upper bound of erase type codes  */

#endif					/* __ERADEF_LOADED */
#ifndef __ERRNO_LOADED
#define __ERRNO_LOADED	1

/*	ERRNO - V3.0 - UNIX-style Error Code Definitions	*/

#define	EPERM	1		/* not owner */
#define	ENOENT	2		/* no such file or directory */
#define	ESRCH	3		/* no such process */
#define	EINTR	4		/* interrupted system call */
#define	EIO	5		/* i/o error */
#define	ENXIO	6		/* no such device or address */
#define	E2BIG	7		/* arg list too long */
#define	ENOEXEC	8		/* exec format error */
#define	EBADF	9		/* bad file number */
#define	ECHILD	10		/* no children */
#define	EAGAIN	11		/* no more processes */
#define	ENOMEM	12		/* not enough core */
#define	EACCES	13		/* permission denied */
#define	EFAULT	14		/* bad address */
#define	ENOTBLK	15		/* block device required */
#define	EBUSY	16		/* mount device busy */
#define	EEXIST	17		/* file exists */
#define	EXDEV	18		/* cross-device link */
#define	ENODEV	19		/* no such device */
#define	ENOTDIR	20		/* not a directory */
#define	EISDIR	21		/* is a directory */
#define	EINVAL	22		/* invalid argument */
#define	ENFILE	23		/* file table overflow */
#define	EMFILE	24		/* too many open files */
#define	ENOTTY	25		/* not a typewriter */
#define	ETXTBSY	26		/* text file busy */
#define	EFBIG	27		/* file too large */
#define	ENOSPC	28		/* no space left on device */
#define	ESPIPE	29		/* illegal seek */
#define	EROFS	30		/* read-only file system */
#define	EMLINK	31		/* too many links */
#define	EPIPE	32		/* broken pipe */
#define	EDOM	33		/* math argument */
#define	ERANGE	34		/* result too large */
#define EWOULDBLOCK	 35	/* I/O operation would block channel */

#define EINPROGRESS      36	/* Operation now in progress  */
#define EALREADY         37	/* Operation already in progress  */
#define ENOTSOCK         38      /* Socket operation on non-socket */

#define EDESTADDRREQ     39  /* Destination address required  */
#define EMSGSIZE         40  /* Message too long  */
#define EPROTOTYPE       41  /* Protocol wrong type for socket */
#define ENOPROTOOPT      42  /* Protocol not available */
#define EPROTONOSUPPORT  43  /* Protocol not supported */

#define  ESOCKTNOSUPPORT 44  /* Socket type not supported */

#define EOPNOTSUPP       45   /* Operation not supported on socket */

#define EPFNOSUPPORT     46  	/* Protocol family not supported */ 

#define EAFNOSUPPORT     47  	/* Address family not supported  */
		  				
#define EADDRINUSE	 48  	/* Address already in use  */
#define EADDRNOTAVAIL	 49  	/* Can't assign requested address */
#define ENETDOWN	 50 	/* Network is down */
#define ENETUNREACH	 51 	/* Network is unreachable */
#define ENETRESET	 52	/* Network dropped connection on reset */
#define ECONNABORTED     53 	/* Software caused connection abort */
#define ECONNRESET	 54 	/* Connection reset by peer  */

#define ENOBUFS		 55 		/* No buffer space available */
#define EISCONN		 56 		/* Socket is already connected */
#define ENOTCONN	 57 	/* Socket is not connected  */

#define	ESHUTDOWN	 58 	/* Can't send after socket shutdown  */
#define ETOOMANYREFS	 59 	/* Too many references: can't splice */ 
#define ETIMEDOUT	 60 	/* Connection timed out */
#define ECONNREFUSED	 61	/* Connection refused  */

#define	ELOOP		62 	/* Too many levels of symbolic links */
#define	ENAMETOOLONG	63 	/* File name too long  */

#define EHOSTDOWN	64 	/* Host is down */

#define EHOSTUNREACH	65 	/* No route to host */

#define EVMSERR 65535		/* VMS-specific error code for non-translatable errors from VMS to C */

#pragma nostandard
#ifdef CC$VAXCSHR
int *vaxc$get_errno_addr(void);	/* UNIX style error code */
#define errno (*vaxc$get_errno_addr())
int *vaxc$get_vms_errno_addr(void);	/* VMS error code when errno = EVMSERR */
#define vaxc$errno (*vaxc$get_vms_errno_addr())
#else
extern volatile int noshare errno;	/* UNIX style error code */
extern volatile int noshare vaxc$errno;	/* VMS error code when errno = EVMSERR */
#endif
#pragma standard

#endif					/* __ERRNO_LOADED */
#ifndef __ERRNODEF_LOADED
#define __ERRNODEF_LOADED	1

/*	ERRNODEF - V3.0 - VMS Status Code Equivalents for UNIX-style Error Codes	*/
#pragma nostandard
globalvalue C$_EPERM;		/* not owner */
globalvalue C$_ENOENT;		/* no such file or directory */
globalvalue C$_ESRCH;		/* no such process */
globalvalue C$_EINTR;		/* interrupted system call */
globalvalue C$_EIO;		/* i/o error */
globalvalue C$_ENXIO;		/* no such device or address */
globalvalue C$_E2BIG;		/* arg list too long */
globalvalue C$_ENOEXEC;		/* exec format error */
globalvalue C$_EBADF;		/* bad file number */
globalvalue C$_ECHILD;		/* no children */
globalvalue C$_EAGAIN;		/* no more processes */
globalvalue C$_ENOMEM;		/* not enough core */
globalvalue C$_EACCES;		/* permission denied */
globalvalue C$_EFAULT;		/* bad address */
globalvalue C$_ENOTBLK;		/* block device required */
globalvalue C$_EBUSY;		/* mount device busy */
globalvalue C$_EEXIST;		/* file exists */
globalvalue C$_EXDEV;		/* cross-device link */
globalvalue C$_ENODEV;		/* no such device */
globalvalue C$_ENOTDIR;		/* not a directory */
globalvalue C$_EISDIR;		/* is a directory */
globalvalue C$_EINVAL;		/* invalid argument */
globalvalue C$_ENFILE;		/* file table overflow */
globalvalue C$_EMFILE;		/* too many open files */
globalvalue C$_ENOTTY;		/* not a typewriter */
globalvalue C$_ETXTBSY;		/* text file busy */
globalvalue C$_EFBIG;		/* file too large */
globalvalue C$_ENOSPC;		/* no space left on device */
globalvalue C$_ESPIPE;		/* illegal seek */
globalvalue C$_EROFS;		/* read-only file system */
globalvalue C$_EMLINK;		/* too many links */
globalvalue C$_EPIPE;		/* broken pipe */
globalvalue C$_EDOM;		/* math argument */
globalvalue C$_ERANGE;		/* result too large */
globalvalue C$_EWOULDBLOCK;	/* I/O operation would block channel */

/*	VMS-specific error codes	*/

globalvalue C$_ERROR;		/* C error condition */
globalvalue C$_INV_FRAME;	/* invalid frame while in fork state */
globalvalue C$_KILL;		/* process killed, unimplemented signal specified */
globalvalue C$_LONGJMP;		/* longjump requested */
globalvalue C$_LONGJMP_FAILED;	/* attempted longjmp failed */
#pragma standard

#endif					/* __ERRNODEF_LOADED */
/*
 *	%W%	(DEC OSF/1)	%G%
 */
/*
 *  Copyright (c) 1989, 1992 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	DECthreads exception services
 *
 *  FILENAME:
 *
 * 	EXC_HANDLING.H
 *
 *  ABSTRACT:
 *
 *	Header file for exception handling in C
 *
 *  AUTHORS:
 *
 *	Eric Roberts
 *	Bob Conti
 *	Dave Butenhof
 *
 *  CREATION DATE:
 *
 *	15 March 1989
 *
 *  MODIFIED BY:
 *
 *	Dave Butenhof
 *	Bob Conti
 *	Paul Curtin
 *	Webb Scales
 */


#ifndef EXC_HANDLING
# define EXC_HANDLING	1

/*
 *  INCLUDE FILES
 */

#define _EXC__CC	1
#define _EXC__VAXC	2
#define _EXC__DECC	3
#define _EXC__CFRONT	4
#define _EXC__GCC	5
#define _EXC__DECCPLUS	6
#define _EXC__GCPLUS	7

/*
 * Test for C++ compilers before C compilers because Glockenspiel C++ also
 * defines symbols for the VAX C compiler and this could be the case for
 * other C++/C compiler combinations
 */
#ifndef _EXC_COMPILER_
# if defined(__cplusplus)		/* test for other C++ compilers first */
#  if defined(__DECCXX)
#   define _EXC_COMPILER_	_EXC__DECCPLUS
#  else
#   define _EXC_COMPILER_	_EXC__CFRONT
#  endif
# elif defined(vaxc) || defined(VAXC) || defined(__vaxc) || defined(__VAXC)
#  define _EXC_COMPILER_	_EXC__VAXC
# elif defined(__decc) || defined(__DECC)
#  define _EXC_COMPILER_	_EXC__DECC
# elif defined(__GNUC__)
#  define _EXC_COMPILER_	_EXC__GCC
# else
#  define _EXC_COMPILER_	_EXC__CC
# endif
#endif

/*
 * Name of the hardware platform
 */
#define	_EXC__MIPS	1
#define	_EXC__VAX	2
#define _EXC__M68K	3
#define _EXC__HPPA	4
#define _EXC__IBMR2     5
#define _EXC__ALPHA	6

#ifndef	_EXC_HARDWARE_
# if defined(vax) || defined (VAX) || defined(__vax) || defined(__VAX)
#  define	_EXC_HARDWARE_	_EXC__VAX
# endif
# if defined(mips) || defined(MIPS) || defined(__mips) || defined(__MIPS)
#  define	_EXC_HARDWARE_	_EXC__MIPS
# endif
# if defined(m68k) || defined(m68000) || defined(_ISP__M68K) || defined(M68000) || defined(mc68000) 
#  define	_EXC_HARDWARE_	_EXC__M68K
# endif
# if defined(hp9000s300) || defined(__hp9000s300)
#  define	_EXC_HARDWARE_	_EXC__M68K
# endif
# if defined(__hppa)
#  define	_EXC_HARDWARE_	_EXC__HPPA
# endif
# if defined(_IBMR2)
#  define	_EXC_HARDWARE_	_EXC__IBMR2
# endif
# if defined(__ALPHA)
#  define	_EXC_HARDWARE_	_EXC__ALPHA
# endif
# ifndef _EXC_HARDWARE_
   !!!Error: _EXC_HARDWARE_ not set
# endif
#endif

#define _EXC__UNIX	1
#define _EXC__VMS	2

#ifndef	_EXC_OS_
# if defined(unix) || defined(__unix) || defined(_AIX) || defined(__OSF__) || defined(__osf__)
#  define	_EXC_OS_	_EXC__UNIX
# endif
# if defined(vms) || defined(__vms) || defined(VMS) || defined(__VMS) || defined(__vms__)
#  define	_EXC_OS_	_EXC__VMS
# endif
# ifndef _EXC_OS_
   !!!Error: _EXC_OS_ not set
# endif
#endif

/*
 * Combined platform (OS + hardware)
 */
#define	_EXC__MIPS_UNIX		1
#define	_EXC__VAX_VMS		2
#define _EXC__VAX_UNIX		3
#define _EXC__M68K_UNIX		4
#define _EXC__HPPA_UNIX		5
#define _EXC__IBMR2_UNIX	6
#define _EXC__ALPHA_UNIX        7
#define _EXC__ALPHA_VMS         8

#ifndef	_EXC_PLATFORM_
# if _EXC_OS_ == _EXC__UNIX
#  if _EXC_HARDWARE_ == _EXC__MIPS
#   define _EXC_PLATFORM_	_EXC__MIPS_UNIX
#  endif
#  if _EXC_HARDWARE_ == _EXC__VAX
#   define _EXC_PLATFORM_	_EXC__VAX_UNIX
#  endif
#  if _EXC_HARDWARE_ == _EXC__M68K
#   define _EXC_PLATFORM_	_EXC__M68K_UNIX
#  endif
#  if _EXC_HARDWARE_ == _EXC__HPPA
#   define _EXC_PLATFORM_	_EXC__HPPA_UNIX
#  endif
#  if _EXC_HARDWARE_ == _EXC__IBMR2
#   define _EXC_PLATFORM_	_EXC__IBMR2_UNIX
#  endif
#  if _EXC_HARDWARE_ == _EXC__ALPHA_UNIX
#   define _EXC_PLATFORM_	_EXC__ALPHA_UNIX
#  endif
# endif
# if _EXC_OS_ == _EXC__VMS
#  if _EXC_HARDWARE_ == _EXC__VAX
#   define _EXC_PLATFORM_	_EXC__VAX_VMS
#  endif
#  if _EXC_HARDWARE_ == _EXC__ALPHA
#   define _EXC_PLATFORM_	_EXC__ALPHA_VMS
#  endif
# endif
# ifndef _EXC_PLATFORM_
   !!!Error: _EXC_PLATFORM_ not set
# endif
#endif

/*
 * Name of the software vendor (alphabetical order :-) )
 */
#define _EXC__APOLLO	1
#define _EXC__DIGITAL	2
#define _EXC__HP        3
#define _EXC__IBM       4
#define _EXC__OSF	5
#define _EXC__SUN       6

#ifndef _EXC_VENDOR_
# ifdef apollo
#  define	_EXC_VENDOR_	_EXC__APOLLO
# endif
# if _EXC_OS_ == _EXC__VMS
#  define	_EXC_VENDOR_	_EXC__DIGITAL
# endif
# if defined(ultrix) || defined(__ULTRIX) || defined (__ultrix)
#  define	_EXC_VENDOR_	_EXC__DIGITAL
# endif
# if defined(__osf__) && !defined(__OSF__) && (_EXC_HARDWARE_ == _EXC__MIPS)
#  define	_EXC_VENDOR_	_EXC__DIGITAL
# endif
# if defined(__osf__) && !defined(__OSF__) && (_EXC_HARDWARE_ == _EXC__ALPHA)
#  define	_EXC_VENDOR_	_EXC__DIGITAL
# endif
# if defined(hpux) || defined(__hpux)
#  define	_EXC_VENDOR_	_EXC__HP
# endif
# ifdef _IBMR2
#  define 	_EXC_VENDOR_	_EXC__IBM
# endif
# ifdef sun
#  define	_EXC_VENDOR_	_EXC__SUN
# endif
# if defined (__OSF__) && !defined (_EXC_VENDOR_)
#  define	_EXC_VENDOR_	_EXC__OSF
# endif
# ifndef _EXC_VENDOR_
   !!!Error: _EXC_VENDOR_ not set
# endif
#endif

/*
 * This controls whether ANSI C function prototypes are used for EXC
 * interfaces.
 */
#ifndef	_EXC_PROTO_
# ifdef __STDC__
#  define _EXC_PROTO_		1
# endif
# if _EXC_COMPILER_ == _EXC__DECC
#  define _EXC_PROTO_		1
# endif
# if _EXC_COMPILER_ == _EXC__GCC
#  define _EXC_PROTO_		1
# endif
# if _EXC_COMPILER_ == _EXC__CFRONT
#  define _EXC_PROTO_		1
# endif
# if _EXC_COMPILER_ == _EXC__DECCPLUS
#  define _EXC_PROTO_		1
# endif
# if _EXC_COMPILER_ == _EXC__GCPLUS
#  define _EXC_PROTO_		1
# endif
# if _EXC_COMPILER_ == _EXC__VAXC
#  define _EXC_PROTO_		1
# endif
# if (_EXC_VENDOR_ == _EXC__DIGITAL) && (_EXC_HARDWARE_ == _EXC__MIPS)
#  define _EXC_PROTO_		1
# endif
# if _EXC_VENDOR_ == _EXC__APOLLO
#  define _EXC_PROTO_		1
# endif
# if (_EXC_VENDOR_ == _EXC__HP) && (_EXC_HARDWARE_ == _EXC__HPPA)
#  define _EXC_PROTO_		1
# endif
# if _EXC_HARDWARE_ == _EXC__IBMR2
#  define _EXC_PROTO_		1
# endif
/* Otherwise, _EXC_PROTO_ is undefined, which means do not use prototypes. */
#endif

/*
 * MIPS C on DEC OSF/1 sets __osf__ but not __OSF__; but gcc on "raw" OSF/1
 * sets __OSF__ but not __osf__. This little ditty provides a bridge.
 */
#if defined (__OSF__) && !defined (__osf__)
# define __osf__
#endif

#define _EXC__OS_AIX	1
#define _EXC__OS_OSF	2
#define _EXC__OS_BSD	3
#define _EXC__OS_SYSV	4
#define _EXC__OS_VMS	5

#ifndef _EXC_OSIMPL_
# if _EXC_OS_ == _EXC__VMS
#  define _EXC_OSIMPL_          _EXC__OS_VMS
# else
#  if defined (__osf__)
#   define _EXC_OSIMPL_         _EXC__OS_OSF
#  else
#   if _EXC_VENDOR_ == _EXC__IBM
#    define _EXC_OSIMPL_        _EXC__OS_AIX
#   else
#    if _EXC_VENDOR_ == _EXC__SUN
#     define _EXC_OSIMPL_       _EXC__OS_SYSV
#    else
#     define _EXC_OSIMPL_       _EXC__OS_BSD
#    endif
#   endif
#  endif
# endif
#endif

#ifndef	_EXC_VOLATILE_
# if _EXC_PLATFORM_ == _EXC__VAX_UNIX
#  if _EXC_COMPILER_ == _EXC__CC
#   define _EXC_VOLATILE_
#   define _EXC_VOLATILE_FLAG_		0
#  endif
# endif
# if _EXC_VENDOR_ == _EXC__SUN
#  define _EXC_VOLATILE_
#  define _EXC_VOLATILE_FLAG_		0
# endif
# if _EXC_COMPILER_ == _EXC__CFRONT
#  define _EXC_VOLATILE_
#  define _EXC_VOLATILE_FLAG_		0
# endif
#ifndef	_EXC_VOLATILE_
#  define _EXC_VOLATILE_  		volatile
#  define _EXC_VOLATILE_FLAG_		1
# endif
#endif

#ifndef _EXC_IMPORT_
# if (_EXC_OS_ == _EXC__VMS) && (_EXC_HARDWARE_ == _EXC__VAX)
#  define _EXC_IMPORT_ globalref
# else
#  define _EXC_IMPORT_ extern
# endif
#endif

#ifdef _EXC_PROTO_
#define _EXC_PROTOTYPE_(arg)	arg
#else
#define _EXC_PROTOTYPE_(arg)	()
#endif

/*
 * NOTE: on U*IX systems, these status codes must be kept unique from
 * "Enums".  We do this arbitrarily by setting some high order bits which
 * happen to be the same as we use on VMS. Apollo systems use different
 * error numbering scheme, and override this.
 */
#if _EXC_VENDOR_ == _EXC__APOLLO
# define exc_facility_c	0x03c0000
# define _EXC_STATUS_(val, sev) ((exc_int_t)(exc_facility_c + (val)))
#endif
#if _EXC_OS_ == _EXC__VMS
# define exc_facility_c	00020100000
# define _EXC_STATUS_(val, sev) \
	((exc_int_t)(exc_facility_c | ((val) << 3) | (sev)))
#endif
#ifndef _EXC_STATUS_
# define _EXC_DCE_PREFIX_	0x177db000
# define exc_facility_c		_EXC_DCE_PREFIX_
# define _EXC_STATUS_(val, sev) \
	((exc_int_t)(_EXC_DCE_PREFIX_ | (val)))
#endif

#include <setjmp.h>

/*
 * Define a symbol that specifies whether exception handling should use the
 * standard setjmp() and longjmp() functions, or the alternate _setjmp() and
 * _longjmp().  The latter are faster, as they don't save/restore the signal
 * mask (and therefore require no kernel calls).  However, _setjmp() and
 * _longjmp() are not standard, and therefore may not be available
 * everywhere. Also, there may be some platforms where failing to save signal
 * state could break exception handling. For both reasons, we enable use of
 * the optimized functions only where we know for sure they are both
 * available and appropriate.
 */
#ifndef _EXC_BAR_JMP_
# if (_EXC_VENDOR_ == _EXC__APOLLO) || ((_EXC_VENDOR_ == _EXC__DIGITAL) && (_EXC_OS_ == _EXC__UNIX))
#  define _EXC_BAR_JMP_	1
# endif
# ifndef _EXC_BAR_JMP_
#  define _EXC_BAR_JMP_	0
# endif
#endif

#if _EXC_OS_ == _EXC__VMS
# if _EXC_HARDWARE_ == _EXC__VAX
   typedef int cma__t_jmp_buf[14];
   extern int cma$$save_exc_context (_EXC_VOLATILE_ int *);
# else
#  include <ints.h>
   typedef uint64 cma__t_jmp_buf[(14+8+3)];
   extern int cma$$save_exc_context (_EXC_VOLATILE_ uint64 *);
# endif
# define exc_setjmp(__env)	cma$$save_exc_context((__env))
#else
  typedef jmp_buf cma__t_jmp_buf;
# if _EXC_BAR_JMP_
#  if _EXC_OSIMPL_ == _EXC__OS_OSF
    /*
     * OSF/1 already provides prototypes for _setjmp and _longjmp in
     * /usr/include/setjmp.h; the prototypes here should be compatible, so
     * we'll just cast the volatile jump buffer inside the exc_setjmp macro
     * instead of defining an appropriate prototype as we do elsewhere.
     */
    extern int _setjmp _EXC_PROTOTYPE_ ((jmp_buf));
    extern void _longjmp _EXC_PROTOTYPE_ ((jmp_buf, int));
#   define exc_setjmp(__env)		_setjmp ((int *)(__env))
#   define exc_longjmp(__env,__val)	_longjmp((int *)(__env),(__val))
#  else
    extern int _setjmp _EXC_PROTOTYPE_ ((_EXC_VOLATILE_ int *));
    extern void _longjmp _EXC_PROTOTYPE_ ((_EXC_VOLATILE_ int *, int));
#   define exc_setjmp(__env)		_setjmp ((__env))
#   define exc_longjmp(__env,__val)	_longjmp((__env),(__val))
#  endif
# else
#  define exc_setjmp(__env)		setjmp ((__env))
#  define exc_longjmp(__env,__val)	longjmp((__env),(__val))
# endif
#endif

typedef char *exc_address_t;

/*
 * Use the most efficient code available to determine the address of the
 * current procedure frame on VAX VMS systems (which we need to integrate
 * well with native VAX VMS condition handling).
 *
 * - VAX C under VAX VMS supports instruction "builtins" to access general
 * registers. Since it requires a "#pragma", which some old cpp versions
 * can't parse, it's hidden in a separate file.
 *
 * - GCC supports an "asm" statement that generates inline assembly code.
 *
 * - Otherwise, declare an extern function (part of DECthreads' assembly
 * code) that will return the value.
 */
#if _EXC_OS_ == _EXC__VMS
# if _EXC_HARDWARE_ == _EXC__VAX
#  if _EXC_COMPILER_ == _EXC__VAXC
#   include <exc_handling_vms.h>
#  elif _EXC_COMPILER_ == _EXC__GCC
#   define cma$exc_fetch_fp() \
    ({ int frameptr; \
    asm volatile ("movl fp, %0" : "=g" (frameptr)); \
    frameptr; })
#  else
   extern exc_address_t cma$exc_fetch_fp (void);
#  endif
# else
   extern exc_address_t cma$exc_fetch_fp (void);
# endif
#endif

/*
 * Define all of the status codes used by DECthreads.
 *
 * For VMS, these must remain in synch with the CMA_MESSAGE.GNM message file.
 *
 * These values cannot be altered after they have shipped in some DECthreads
 * release.
 */

/*
 * EXC facility messages
 */
#define exc_s_exception         _EXC_STATUS_(1, 4)
#define exc_s_exccop            _EXC_STATUS_(2, 4)
#define exc_s_uninitexc         _EXC_STATUS_(3, 4)
#define exc_s_unkstatus		_EXC_STATUS_(128, 4)
#define exc_s_exccoplos		_EXC_STATUS_(129, 4)

/*
 * These should be set to match with underlying system exception codes on
 * platforms where that is appropriate (e.g., ss$_ codes on VMS).
 */
#if _EXC_OS_ == _EXC__VMS
/*
 * A few of these codes are somewhat imaginary, since VMS doesn't support
 * condition codes that very closely approximate the sense of some UNIX
 * signals.  SIGTRAP, SIGIOT, and SIGEMT have no clear parallels, and the
 * values chosen are fairly arbitrary.  For two others, we chose what seemed
 * close equivalents: SIGPIPE becomes "no mailbox", and SIGXFSZ becomes "disk
 * quota exceeded".
 */
# define exc_s_illaddr		12	/* ss$_accvio */
# define exc_s_exquota		28	/* ss$_exquota */
# define exc_s_insfmem		292	/* ss$_insfmem */
# define exc_s_nopriv		36	/* ss$_nopriv */
# define exc_s_normal		1	/* ss$_normal */
# define exc_s_illinstr		1084	/* ss$_opcdec */
# define exc_s_resaddr		1100	/* ss$_radrmod */
# define exc_s_privinst		1084	/* ss$_opcdec */
# define exc_s_resoper		1108	/* ss$_roprand */
# define exc_s_SIGTRAP		1044	/* ss$_break */
# define exc_s_SIGIOT		44	/* ss$_abort */
# define exc_s_SIGEMT		1068	/* ss$_compat */
# define exc_s_aritherr		1164	/* ss$_fltovf */
# define exc_s_SIGSYS		20	/* ss$_badparam */
# define exc_s_SIGPIPE		628	/* ss$_nombx */
# define exc_s_excpu		8364	/* ss$_excputim */
# define exc_s_exfilsiz		1004	/* ss$_exdiskquota */
# define exc_s_intovf		1148	/* ss$_intovf */
# define exc_s_intdiv		1156	/* ss$_intdiv */
# define exc_s_fltovf		1164	/* ss$_fltovf */
# define exc_s_fltdiv		1172	/* ss$_fltdiv */
# define exc_s_fltund		1180	/* ss$_fltund */
# define exc_s_decovf		1188	/* ss$_decovf */
# define exc_s_subrng		1196	/* ss$_subrng */
#else
# define exc_s_illaddr		_EXC_STATUS_(5, 4)
# define exc_s_exquota		_EXC_STATUS_(6, 4)
# define exc_s_insfmem		_EXC_STATUS_(7, 4)
# define exc_s_nopriv		_EXC_STATUS_(8, 4)
# define exc_s_normal		_EXC_STATUS_(9, 1)
# define exc_s_illinstr		_EXC_STATUS_(10, 4)
# define exc_s_resaddr		_EXC_STATUS_(11, 4)
# define exc_s_privinst		_EXC_STATUS_(12, 4)
# define exc_s_resoper		_EXC_STATUS_(13, 4)
# define exc_s_SIGTRAP		_EXC_STATUS_(14, 4)
# define exc_s_SIGIOT		_EXC_STATUS_(15, 4)
# define exc_s_SIGEMT		_EXC_STATUS_(16, 4)
# define exc_s_aritherr		_EXC_STATUS_(17, 4)
# define exc_s_SIGSYS		_EXC_STATUS_(18, 4)
# define exc_s_SIGPIPE		_EXC_STATUS_(19, 4)
# define exc_s_excpu		_EXC_STATUS_(20, 4)
# define exc_s_exfilsiz		_EXC_STATUS_(21, 4)
# define exc_s_intovf		_EXC_STATUS_(22, 4)
# define exc_s_intdiv		_EXC_STATUS_(23, 4)
# define exc_s_fltovf		_EXC_STATUS_(24, 4)
# define exc_s_fltdiv		_EXC_STATUS_(25, 4)
# define exc_s_fltund		_EXC_STATUS_(26, 4)
# define exc_s_decovf		_EXC_STATUS_(27, 4)
# define exc_s_subrng		_EXC_STATUS_(28, 4)
#endif

/*
 * Define alias names
 */
#define exc_s_accvio		exc_s_illaddr
#define exc_s_SIGILL		exc_s_illinstr
#define exc_s_SIGFPE		exc_s_aritherr
#define exc_s_SIGBUS		exc_s_illaddr
#define exc_s_SIGSEGV		exc_s_illaddr
#define exc_s_SIGXCPU		exc_s_excpu
#define exc_s_SIGXFSZ		exc_s_exfilsiz

/*
 * DECthreads facility (CMA) messages
 */
#define cma_s_alerted           _EXC_STATUS_(48, 4)
#define cma_s_assertion         _EXC_STATUS_(49, 4)
#define cma_s_badparam          _EXC_STATUS_(50, 4)
#define cma_s_bugcheck          _EXC_STATUS_(51, 4)
#define cma_s_exit_thread       _EXC_STATUS_(52, 4)
#define cma_s_existence         _EXC_STATUS_(53, 4)
#define cma_s_in_use            _EXC_STATUS_(54, 4)
#define cma_s_use_error         _EXC_STATUS_(55, 4)
#define cma_s_wrongmutex	_EXC_STATUS_(56, 4)
#define cma_s_stackovf          _EXC_STATUS_(57, 4)
#define cma_s_nostackmem        _EXC_STATUS_(58, 4)
#define cma_s_notcmastack       _EXC_STATUS_(59, 4)
#define cma_s_timed_out         _EXC_STATUS_(60, 4)
#define cma_s_unimp             _EXC_STATUS_(61, 4)
#define cma_s_inialrpro         _EXC_STATUS_(62, 4)
#define cma_s_defer_q_full      _EXC_STATUS_(63, 4)
#define cma_s_signal_q_full	_EXC_STATUS_(64, 4)
#define cma_s_alert_nesting	_EXC_STATUS_(65, 4)

/*
 * Synonyms for convenience
 */
#define cma_s_normal		exc_s_normal

/*
 * TYPEDEFS
 */

/*
 * Constants for the kind of an exception object.
 *
 * There are *currently* only two kinds.  In the address-kind, the identity
 * of an exception object is its address; in the value-kind, the
 * identity of an exception object is an integer, typically, 
 * a system-defined-status-value. These coded kinds also
 * serve as sentinels to help detect uninitialized exceptions.
 */
typedef enum EXC_KIND_T {
    exc_kind_address_c	= 0x02130455,  
    exc_kind_status_c	= 0x02130456
    }			exc_kind_t;

/*
 * Internal contents of an exception object.
 */
typedef long int exc_int_t;

typedef struct EXC_EXT_T {
    exc_int_t		sentinel;
    exc_int_t		version;
    exc_address_t	extend;
    unsigned int	*args;
    } exc_ext_t;

typedef struct EXC_KIND_V1ADDR_T {
    exc_kind_t		kind;
    exc_address_t	address;
    exc_int_t		filler[6];
    } exc_kind_v1addr_t;

typedef struct EXC_KIND_V1STATUS_T {
    exc_kind_t		kind;
    exc_int_t		status;
    exc_int_t		filler[6];
    } exc_kind_v1status_t;

typedef struct EXC_KIND_ADDRESS_T {
    exc_kind_t		kind;
    exc_address_t	address;
    exc_ext_t		ext;
    } exc_kind_address_t;

typedef struct EXC_KIND_STATUS_T {
    exc_kind_t		kind;
    exc_int_t		status;
    exc_ext_t		ext;
    } exc_kind_status_t;

typedef union EXC_EXCEPTION_T	{
    exc_kind_t		kind;
    exc_kind_v1status_t	v1status;
    exc_kind_v1addr_t	v1address;
    exc_kind_status_t	status;
    exc_kind_address_t	address;
    } EXCEPTION;

/*
 * Constants for the state of handling in the current TRY clause.
 * 
 * The state is "none" when no exception has been raised, "active" when
 * one has been raised but has not yet been caught by a CATCH clause, and
 * "handled" after the exception has been caught by some CATCH clause.
 */
typedef enum EXC_STATE_T {
    exc_active_c	= 0, /* This must be the 0 state, see pop_ctx */
    exc_none_c		= 1,
    exc_handled_c	= 2,
    exc_popped_c	= 3
    }			exc_state_t;

/*
 * Structure of a context block.
 *
 * A context block is allocated in the current stack frame for each
 * TRY clause.  These context blocks are linked to form a stack of
 * all current TRY blocks in the current thread.  Each context block
 * contains a jump buffer for use by setjmp and longjmp.  
 *
 */
#define exc_excargs_c	40

typedef struct EXC_CONTEXT_T {
    cma__t_jmp_buf	jmp;		/* Jump buffer */
    _EXC_VOLATILE_ struct EXC_CONTEXT_T
			*link;		/* Link to context block stack */
    EXCEPTION		cur_exception;	/* Copy of the current exception */
    exc_state_t		exc_state;	/* State of handling for this TRY */
#if _EXC_OS_ == _EXC__VMS
    exc_address_t	current_frame;	/* Address of current stack frame */
# if _EXC_PLATFORM_ == _EXC__VAX_VMS
    exc_address_t	old_handler;	/* Address of previous handler */
# endif
#endif
    exc_int_t		sentinel;	/* Identify as "new" ctx block */
    exc_int_t		version;	/* Client context version */
    unsigned int	exc_args[exc_excargs_c];
    } exc_context_t;

/*
 *  GLOBAL DATA
 */

#if _EXC_OS_ == _EXC__VMS
/*
 * On VMS, use the VMS calling standard ("$") interface, to avoid pulling in
 * the open interface image (cma$open_rtl) unless the client code uses it.
 */
extern void cma$exc_push_ctx _EXC_PROTOTYPE_ ((	/* Push a context block */
	_EXC_VOLATILE_	exc_context_t *cb));
extern void cma$exc_pop_ctx _EXC_PROTOTYPE_ ((	/* Pop a context block */
	_EXC_VOLATILE_	exc_context_t *cb));
extern void cma$exc_raise _EXC_PROTOTYPE_ ((	/* Raise an exception */
	EXCEPTION *exc));
extern void cma$exc_raise_status _EXC_PROTOTYPE_ ((	/* Raise a status as exception*/
	exc_int_t	status));
extern void cma$exc_report _EXC_PROTOTYPE_ ((	/* Report an exception */
	EXCEPTION *exc));
# define exc_push_ctx		cma$exc_push_ctx
# define exc_pop_ctx		cma$exc_pop_ctx
# define exc_raise		cma$exc_raise
# define exc_raise_status	cma$exc_raise_status
# define exc_report		cma$exc_report
#else
extern void exc_push_ctx _EXC_PROTOTYPE_ ((	/* Push a context block */
	_EXC_VOLATILE_	exc_context_t *cb));
extern void exc_pop_ctx _EXC_PROTOTYPE_ ((	/* Pop a context block */
	_EXC_VOLATILE_	exc_context_t *cb));
extern void exc_raise _EXC_PROTOTYPE_ ((	/* Raise an exception */
	EXCEPTION *exc));
extern void exc_raise_status _EXC_PROTOTYPE_ ((	/* Raise a status as exception*/
	exc_int_t	status));
extern void exc_report _EXC_PROTOTYPE_ ((	/* Report an exception */
	EXCEPTION *exc));
#endif

#if _EXC_OS_ == _EXC__VMS
extern int  cma$exc_handler (/* sargs, margs*/);	/* System condition handler */
#endif

/*
 * Define the exception values that go with the above status codes
 *
 * NOTE: it does not make sense to turn all of the above into 
 * exceptions as some are never raised as exceptions.  Those are:
 *	cma_s_normal	-- never signalled
 *	cma_s_exception	-- internal to the implementation of exceptions
 * 	cma_s_exccop	-- internal to the implementation of exceptions
 *	cma_s_timed_out -- returned as status value from timed condition wait
 */

#ifndef _EXC_NO_EXCEPTIONS_
_EXC_IMPORT_ EXCEPTION
    exc_e_uninitexc,
    exc_e_illaddr,
    exc_e_exquota,
    exc_e_insfmem,
    exc_e_nopriv,
    exc_e_illinstr,
    exc_e_resaddr,
    exc_e_privinst,
    exc_e_resoper,
    exc_e_SIGTRAP,
    exc_e_SIGIOT,
    exc_e_SIGEMT,
    exc_e_aritherr,
    exc_e_SIGSYS,
    exc_e_SIGPIPE,
    exc_e_excpu,
    exc_e_exfilsiz,
    exc_e_intovf,
    exc_e_intdiv,
    exc_e_fltovf,
    exc_e_fltdiv,
    exc_e_fltund,
    exc_e_decovf,
    exc_e_subrng,
    cma_e_alerted,
    cma_e_assertion,
    cma_e_badparam,
    cma_e_bugcheck,
    cma_e_exit_thread,
    cma_e_existence,
    cma_e_in_use,
    cma_e_use_error,
    cma_e_wrongmutex,
    cma_e_stackovf,
    cma_e_nostackmem,
    cma_e_notcmastack,
    cma_e_unimp,
    cma_e_inialrpro,
    cma_e_defer_q_full,
    cma_e_signal_q_full,
    cma_e_alert_nesting;

/*
 * Define aliased exceptions
 */
# define exc_e_accvio		exc_e_illaddr
# define exc_e_SIGILL		exc_e_illinstr
# define exc_e_SIGFPE		exc_e_aritherr
# define exc_e_SIGBUS		exc_e_illaddr
# define exc_e_SIGSEGV		exc_e_illaddr
# define exc_e_SIGXCPU		exc_e_excpu
# define exc_e_SIGXFSZ		exc_e_exfilsiz

/*
 * The following are pthread exception names.
 */

# define exc_uninitexc_e	exc_e_uninitexc
# define exc_illaddr_e		exc_e_illaddr
# define exc_exquota_e		exc_e_exquota
# define exc_insfmem_e		exc_e_insfmem
# define exc_nopriv_e		exc_e_nopriv
# define exc_illinstr_e		exc_e_illinstr
# define exc_resaddr_e		exc_e_resaddr
# define exc_privinst_e		exc_e_privinst
# define exc_resoper_e		exc_e_resoper
# define exc_SIGTRAP_e		exc_e_SIGTRAP
# define exc_SIGIOT_e		exc_e_SIGIOT
# define exc_SIGEMT_e		exc_e_SIGEMT
# define exc_aritherr_e		exc_e_aritherr
# define exc_SIGSYS_e		exc_e_SIGSYS
# define exc_SIGPIPE_e		exc_e_SIGPIPE
# define exc_excpu_e		exc_e_excpu
# define exc_exfilsiz_e		exc_e_exfilsiz
# define exc_intovf_e		exc_e_intovf
# define exc_intdiv_e		exc_e_intdiv
# define exc_fltovf_e		exc_e_fltovf
# define exc_fltdiv_e		exc_e_fltdiv
# define exc_fltund_e		exc_e_fltund
# define exc_decovf_e		exc_e_decovf
# define exc_subrng_e		exc_e_subrng

# define pthread_cancel_e	cma_e_alerted
# define pthread_assertion_e	cma_e_assertion
# define pthread_badparam_e	cma_e_badparam
# define pthread_bugcheck_e	cma_e_bugcheck
# define pthread_exit_thread_e	cma_e_exit_thread
# define pthread_existence_e	cma_e_existence
# define pthread_in_use_e	cma_e_in_use
# define pthread_use_error_e	cma_e_use_error
# define pthread_wrongmutex_e	cma_e_wrongmutex
# define pthread_stackovf_e	cma_e_stackovf
# define pthread_nostackmem_e	cma_e_nostackmem
# define pthread_notstack_e	cma_e_notcmastack
# define pthread_unimp_e	cma_e_unimp
# define pthread_inialrpro_e	cma_e_inialrpro
# define pthread_defer_q_full_e	cma_e_defer_q_full
# define pthread_signal_q_full_e cma_e_signal_q_full

# define exc_accvio_e		exc_e_accvio
# define exc_SIGILL_e		exc_e_SIGILL
# define exc_SIGFPE_e		exc_e_SIGFPE
# define exc_SIGBUS_e		exc_e_SIGBUS
# define exc_SIGSEGV_e		exc_e_SIGSEGV
# define exc_SIGXCPU_e		exc_e_SIGXCPU
# define exc_SIGXFSZ_e		exc_e_SIGXFSZ
#endif

/*
 * CONSTANTS AND MACROS
 */

/*
 * This constant helps to identify a context block or exception created with
 * DECthreads BL9 or later; the new structures include a version field to
 * better manage future changes.
 */
#define exc_newexc_c	0x45586732	/* Identify ctx block with version */

/*
 * Define a version constant to be put into exception structures.
 */
#define exc_v2exc_c	2

/*
 * Define "keyword" to initialize an exception. Note: all exceptions *must*
 * be initialized using this macro.
 */
#define EXCEPTION_INIT(e)   (	\
    (e).address.address = (exc_address_t)&(e),	\
    (e).address.kind = exc_kind_address_c, \
    (e).address.ext.sentinel = exc_newexc_c, \
    (e).address.ext.version = exc_v2exc_c, \
    (e).address.ext.extend = (exc_address_t)0, \
    (e).address.ext.args = (unsigned int *)0)

/*
 * Define "routine" to equivalence an exception to an integer
 * (typically a system-defined status value).
 */
#define exc_set_status(e,s) ( \
    (e)->status.status = (s), \
    (e)->status.kind = exc_kind_status_c)

/*
 * Define "routine" to return the status of an exception. Returns 0 if status
 * kind (and value of status in *s), or -1 if not status kind.
 */
#define exc_get_status(e,s) ( \
    (e)->kind == exc_kind_status_c ? \
	(*(s) = (e)->status.status, 0) : \
	-1)

/*
 * Define "routine" to determine if two exceptions match.
 */
#define exc_matches(e1,e2) \
    ((e1)->kind == (e2)->kind \
    && (e1)->address.address == (e2)->address.address)

/*
 * Define "statement" for clients to use to raise an exception.
 */
#define RAISE(e) exc_raise(&(e))

#if _EXC_PLATFORM_ == _EXC__VAX_VMS
/*
 * For VAX VMS, try to integrate peacefully with native VMS condition
 * handling. Save the previous handler for the frame, and restore it on
 * ENDTRY. The DECthreads condition handler will call the saved handler
 * before resignalling a condition that we don't want to handle, unless
 * it is the DECthreads condition handler (to avoid infinite recursion).
 */
# define exc_establish(_exc_ctx_) ( \
        (_exc_ctx_)->current_frame = ((exc_address_t)cma$exc_fetch_fp()), \
	(_exc_ctx_)->old_handler = \
		*((exc_address_t *)(_exc_ctx_)->current_frame), \
        *(exc_address_t *)(_exc_ctx_)->current_frame = \
		((exc_address_t)cma$exc_handler))

# define exc_unestablish(_exc_ctx_) \
	*(exc_address_t *)(_exc_ctx_)->current_frame = (_exc_ctx_)->old_handler;
#else
# if _EXC_PLATFORM_ == _EXC__ALPHA_VMS
    /*
     * Workaround: early Alpha DEC C baselevels require including the header
     * file vaxcshr.h to direct C RTL calls to the proper DEC C entry points.
     * This header erroneously defines "vaxc$establish" to "decc$establish",
     * which doesn't exist and isn't properly translated into defining a
     * condition handler in the procedure descriptor. So defeat the #define
     * manually.
     */
#  ifdef vaxc$establish
#   undef vaxc$establish
#  endif
#  define exc_establish(_exc_ctx_) \
	(_exc_ctx_)->current_frame = ((exc_address_t)cma$exc_fetch_fp()); \
	lib$establish (cma$exc_handler);
#  define exc_unestablish(_exc_ctx_)
# else
#  define exc_establish(_exc_ctx_)
#  define exc_unestablish(_exc_ctx_)
# endif
#endif

/*
 * Constants to define versions of the context block:
 */
#define exc_v2ctx_c	2

/* 
 * Start a new TRY block, which may contain exception handlers
 * 
 *   Allocate a context block on the stack to remember the current
 *   exception. Push it on the context block stack.  Initialize
 *   this context block to indicate that no exception is active. Do a SETJMP
 *   to snapshot this environment (or return to it).  Then, start
 *   a block of statements to be guarded by the TRY clause.
 *   This block will be ended by one of the following: a CATCH, CATCH_ALL,
 *   or the ENDTRY macros.
 */
#define TRY \
    { \
	_EXC_VOLATILE_ exc_context_t exc_ctx; \
	exc_ctx.sentinel = exc_newexc_c; \
	exc_ctx.version = exc_v2ctx_c; \
	exc_ctx.exc_args[0] = 0; \
	exc_push_ctx (&exc_ctx);\
	exc_establish (&exc_ctx);\
        if (!exc_setjmp (exc_ctx.jmp)) {
/*		{ user's block of code goes here } 	*/

/* 
 * Define an CATCH(e) clause (or exception handler).
 *
 *   First, end the prior block.  Then, check if the current exception
 *   matches what the user is trying to catch with the CATCH clause.
 *   If there is a match, a variable is declared to support lexical
 *   nesting of RERAISE statements, and the state of the current
 *   exception is changed to "handled".
 */
#define CATCH(e) \
            } \
            else if (exc_matches(&exc_ctx.cur_exception, &(e))) { \
		EXCEPTION *THIS_CATCH = (EXCEPTION *)&exc_ctx.cur_exception;\
		exc_ctx.exc_state = exc_handled_c;
/*		{ user's block of code goes here } 	*/

/* 
 * Define an CATCH_ALL clause (or "catchall" handler).
 *
 *   First, end the prior block.  Then, unconditionally,
 *   let execution enter into the catchall code.  As with a normal
 *   catch, a variable is declared to support lexical
 *   nesting of RERAISE statements, and the state of the current
 *   exception is changed to "handled".
 */
#define CATCH_ALL \
            } \
            else { \
		EXCEPTION *THIS_CATCH = (EXCEPTION *)&exc_ctx.cur_exception;\
		exc_ctx.exc_state = exc_handled_c;
/*		{ user's block of code goes here } 	*/

/* 
 * Define a RERAISE statement.
 * 
 *   This "statement" is valid only if lexically nested in
 *   a CATCH or CATCH_ALL clause. Reraise the current lexically visible 
 *   exception.
 */
#define RERAISE exc_raise(THIS_CATCH)

/* 
 * Define a FINALLY clause
 *
 *   This "keyword" starts a FINALLY clause.  It must appear before
 *   an ENDTRY.  A FINALLY clause will be entered after normal exit
 *   of the TRY block, or if an unhandled exception tries to propagate
 *   out of the TRY block.  
 *
 *   Unlike Modula 3's TRY clause, we do not expend overhead trying to
 *   enforce that FINALLY be mutually exclusive with CATCH clauses.  Currently, 
 *   if they are used together, then control will drop into a FINALLY clause 
 *   under the following conditions:
 *	o normal exit from TRY, 
 *	o an exception is raised and no CATCH is present (recommended usage) 
 *	o CATCH's are present but none matches the exception.
 *	o CATCH's are present and one matches the exception, but it
 *	  does not raise any exception.  
 *   That is, FINALLY is always entered after TRY unless a CATCH clause raises 
 *   (or re-raises) an exception.
 *
 *			** WARNING **
 *   You should *avoid* using FINALLY with CATCH clauses, that is, use it 
 *   only as TRY {} FINALLY {} ENDTRY.  Source code that combines CATCHes
 *   with FINALLY in the same TRY clause is considered "unsupported"
 *   -- that is, such code may be broken by a future version of this
 *   package.  
 *
 *   There are several reasons this restriction is necessary:
 *	o FINALLY may be added to C++ and its combination with CATCH
 *	  clauses may have different semantics than implemented by these macros.
 *	o The restriction is consistant with the same restriction in Modula 3
 *	o It allows the use of the 2-phase or "debugging" implementation 
 *	  technique of the SRC exception package for these same macros.
 */
#define FINALLY   } \
	if (exc_ctx.exc_state == exc_none_c) \
	    exc_pop_ctx (&exc_ctx);\
	{
/*		{ user's block of code goes here } 	*/

/* 
 * End the whole TRY clause
 */
#define ENDTRY \
	} \
    exc_unestablish (&exc_ctx); \
    if (exc_ctx.exc_state == exc_none_c \
	    || exc_ctx.exc_state == exc_active_c) { \
	exc_pop_ctx (&exc_ctx); \
	} \
    }

#endif
/*
 *  Copyright (c) 1990, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	CMA services
 *
 *  ABSTRACT:
 *
 *	Header file for VAX/VMS exception package host-specific functions
 *
 *  AUTHORS:
 *
 *	Dave Butenhof
 *
 *  CREATION DATE:
 *
 *	19 April 1990
 *
 *  MODIFICATION HISTORY:
 * 
 *	001	Dave Butenhof	25 March 1991
 *		Change name to exc_fetch_fp()
 *	002	Dave Butenhof, Webb Scales	30 July 1991
 *		Change type of exc_fetch_fp() to exc_t_address
 *	003	Dave Butenhof	29 October 1991
 *		Change FP fetcher to cma$exc_fetch_fp() to be compatible with
 *		direct use of cma$rtl entry rather than cma$open_rtl entry.
 *	004	Dave Butenhof	12 December 1991
 *		Change type.
 */


/*
 *  INCLUDE FILES
 */

/*
 * CONSTANTS AND MACROS
 */

#pragma builtins

/*
 * Return the present value of the frame pointer for the current thread
 *
 * _READ_GPR reads the value of a general processor register
 *  (register 13 is FP)
 */
#define cma$exc_fetch_fp() ((exc_address_t)_READ_GPR (13))

/*
 *  GLOBAL DATA
 */

/*
 * INTERNAL INTERFACES
 */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_EXCEPTION_VMS.H */
/*  *1    12-DEC-1990 21:24:47 BUTENHOF "VMS specific exception defs" */
/*  DEC/CMS REPLACEMENT HISTORY, Element CMA_EXCEPTION_VMS.H */
/*  DEC/CMS REPLACEMENT HISTORY, Element EXC_HANDLING_VMS.H */
/*  *4    13-DEC-1991 09:52:34 BUTENHOF "Change type" */
/*  *3    31-OCT-1991 12:37:02 BUTENHOF "Change name of fetch_fp reference" */
/*  *2    31-JUL-1991 18:39:34 BUTENHOF "Change type of exc_fetch_fp()" */
/*  *1     1-APR-1991 18:52:51 BUTENHOF "VMS specific exception defs" */
/*  DEC/CMS REPLACEMENT HISTORY, Element EXC_HANDLING_VMS.H */
#ifndef __FAB_LOADED
#define __FAB_LOADED	1
#pragma nostandard

/*** MODULE $fabdef ***/
/*+++++*****                                                                */
/*   the fields thru ctx must not be modified due to                        */
/*   commonality between fab/rab/xab                                        */
#define FAB$C_BID 3                     /* code for fab                     */
#define FAB$M_PPF_RAT 16320
#define FAB$M_PPF_IND 16384
#define FAB$M_ASY 1
#define FAB$M_MXV 2
#define FAB$M_SUP 4
#define FAB$M_TMP 8
#define FAB$M_TMD 16
#define FAB$M_DFW 32
#define FAB$M_SQO 64
#define FAB$M_RWO 128
#define FAB$M_POS 256
#define FAB$M_WCK 512
#define FAB$M_NEF 1024
#define FAB$M_RWC 2048
#define FAB$M_DMO 4096
#define FAB$M_SPL 8192
#define FAB$M_SCF 16384
#define FAB$M_DLT 32768
#define FAB$M_NFS 65536
#define FAB$M_UFO 131072
#define FAB$M_PPF 262144
#define FAB$M_INP 524288
#define FAB$M_CTG 1048576
#define FAB$M_CBT 2097152
#define FAB$M_SYNCSTS 4194304
#define FAB$M_RCK 8388608
#define FAB$M_NAM 16777216
#define FAB$M_CIF 33554432
#define FAB$M_ESC 134217728
#define FAB$M_TEF 268435456
#define FAB$M_OFP 536870912
#define FAB$M_KFO 1073741824
#define FAB$M_PUT 1
#define FAB$M_GET 2
#define FAB$M_DEL 4
#define FAB$M_UPD 8
#define FAB$M_TRN 16
#define FAB$M_BIO 32
#define FAB$M_BRO 64
#define FAB$M_EXE 128
#define FAB$M_SHRPUT 1
#define FAB$M_SHRGET 2
#define FAB$M_SHRDEL 4
#define FAB$M_SHRUPD 8
#define FAB$M_MSE 16
#define FAB$M_NIL 32
#define FAB$M_UPI 64
#define FAB$M_ORG 240
#define FAB$C_SEQ 0                     /* sequential                       */
#define FAB$C_REL 16                    /* relative                         */
#define FAB$C_IDX 32                    /* indexed                          */
#define FAB$C_HSH 48                    /* hashed                           */
#define FAB$M_FTN 1
#define FAB$M_CR 2
#define FAB$M_PRN 4
#define FAB$M_BLK 8
#define FAB$C_RFM_DFLT 2                /* var len is default               */
#define FAB$C_UDF 0                     /* undefined (also stream binary)   */
#define FAB$C_FIX 1                     /* fixed length records             */
#define FAB$C_VAR 2                     /* variable length records          */
#define FAB$C_VFC 3                     /* variable fixed control           */
#define FAB$C_STM 4                     /* RMS-11 stream (valid only for sequential org)  */
#define FAB$C_STMLF 5                   /* LF stream (valid only for sequential org)  */
#define FAB$C_STMCR 6                   /* CR stream (valid only for sequential org)  */
#define FAB$C_MAXRFM 6                  /* maximum rfm supported            */
#define FAB$M_ONLY_RU 1
#define FAB$M_RU 2
#define FAB$M_BI 4
#define FAB$M_AI 8
#define FAB$M_AT 16
#define FAB$M_NEVER_RU 32
#define FAB$M_JOURNAL_FILE 64
#define FAB$M_RCF_RU 1
#define FAB$M_RCF_AI 2
#define FAB$M_RCF_BI 4
#define FAB$K_BLN 80                    /* length of fab                    */
#define FAB$C_BLN 80                    /* length of fab                    */
struct FAB {
    unsigned char fab$b_bid;            /* block id                         */
    unsigned char fab$b_bln;            /* block len                        */
    variant_union  {
        unsigned short int fab$w_ifi;   /* internal file index              */
        variant_struct  {
            unsigned fabdef$$_fill_1 : 6; /* move to bit 6                  */
            unsigned fab$v_ppf_rat : 8; /* rat value for process-permanent files  */
            unsigned fab$v_ppf_ind : 1; /* indirect access to process-permanent file  */
/* (i.e., restricted operations)                                            */
            unsigned fab$v_fill_0 : 1;
            } fab$r_ifi_bits;
        } fab$r_ifi_overlay;
    variant_union  {
        unsigned long int fab$l_fop;    /* file options                     */
        variant_struct  {
            unsigned fab$v_asy : 1;     /* asynchronous operations          */
            unsigned fab$v_mxv : 1;     /* maximize version number          */
            unsigned fab$v_sup : 1;     /* supersede existing file          */
            unsigned fab$v_tmp : 1;     /* create temporary file            */
            unsigned fab$v_tmd : 1;     /* create temp file marked for delete  */
            unsigned fab$v_dfw : 1;     /* deferred write (rel and idx)     */
            unsigned fab$v_sqo : 1;     /* sequential access only           */
            unsigned fab$v_rwo : 1;     /* rewind mt on open                */
            unsigned fab$v_pos : 1;     /* use next magtape position        */
            unsigned fab$v_wck : 1;     /* write checking                   */
            unsigned fab$v_nef : 1;     /* inhibit end of file positioning  */
            unsigned fab$v_rwc : 1;     /* rewind mt on close               */
            unsigned fab$v_dmo : 1;     /* dismount mt on close (not implemented)  */
            unsigned fab$v_spl : 1;     /* spool file on close              */
            unsigned fab$v_scf : 1;     /* submit command file on close     */
            unsigned fab$v_dlt : 1;     /* delete sub-option                */
            unsigned fab$v_nfs : 1;     /* non-file structured operation    */
            unsigned fab$v_ufo : 1;     /* user file open - no rms operations  */
            unsigned fab$v_ppf : 1;     /* process permanent file (pio segment)  */
            unsigned fab$v_inp : 1;     /* process-permanent file is 'input'  */
            unsigned fab$v_ctg : 1;     /* contiguous extension             */
            unsigned fab$v_cbt : 1;     /* contiguous best try              */
            unsigned fab$v_syncsts : 1; /* Synchronous status notification for asynchronous routines. */
            unsigned fab$v_rck : 1;     /* read checking                    */
            unsigned fab$v_nam : 1;     /* use name block dvi, did, and/or fid fields for open  */
            unsigned fab$v_cif : 1;     /* create if non-existent           */
            unsigned fabdef$$_fill_3 : 1; /* reserved (was UFM bitfield)    */
            unsigned fab$v_esc : 1;     /* 'escape' to non-standard function ($modify)  */
            unsigned fab$v_tef : 1;     /* truncate at eof on close (write-accessed seq. disk file only)  */
            unsigned fab$v_ofp : 1;     /* output file parse (only name type sticky)  */
            unsigned fab$v_kfo : 1;     /* known file open (image activator only release 1)  */
            unsigned fabdef$$_fill_4 : 1; /* reserved (not implemented)     */
            } fab$r_fop_bits;
        } fab$r_fop_overlay;
    unsigned long int fab$l_sts;        /* status                           */
    unsigned long int fab$l_stv;        /* status value                     */
    unsigned long int fab$l_alq;        /* allocation quantity              */
    unsigned short int fab$w_deq;       /* default allocation quantity      */
    variant_union  {
        unsigned char fab$b_fac;        /* file access                      */
        variant_struct  {
            unsigned fab$v_put : 1;     /* put access                       */
            unsigned fab$v_get : 1;     /* get access                       */
            unsigned fab$v_del : 1;     /* delete access                    */
            unsigned fab$v_upd : 1;     /* update access                    */
            unsigned fab$v_trn : 1;     /* truncate access                  */
            unsigned fab$v_bio : 1;     /* block i/o access                 */
            unsigned fab$v_bro : 1;     /* block and record i/o access      */
            unsigned fab$v_exe : 1;     /* execute access (caller must be exec or kernel mode,  */
/*  ufo must also be set)                                                   */
            } fab$r_fac_bits;
        } fab$r_fac_overlay;
    variant_union  {
        unsigned char fab$b_shr;        /* file sharing                     */
        variant_struct  {
            unsigned fab$v_shrput : 1;  /* put access                       */
            unsigned fab$v_shrget : 1;  /* get access                       */
            unsigned fab$v_shrdel : 1;  /* delete access                    */
            unsigned fab$v_shrupd : 1;  /* update access                    */
            unsigned fab$v_mse : 1;     /* multi-stream connects enabled    */
            unsigned fab$v_nil : 1;     /* no sharing                       */
            unsigned fab$v_upi : 1;     /* user provided interlocking (allows multiple  */
/*  writers to seq. files)                                                  */
            unsigned fab$v_fill_1 : 1;
            } fab$r_shr_bits;
        } fab$r_shr_overlay;
    unsigned long int fab$l_ctx;        /* user context                     */
/*-----*****                                                                */
    char fab$b_rtv;                     /* retrieval window size            */
    variant_union  {
        unsigned char fab$b_org;        /* file organization                */
        variant_struct  {
            unsigned fabdef$$_fill_5 : 4;
            unsigned fab$v_org : 4;
            } fab$r_org_bits;
        } fab$r_org_overlay;
    variant_union  {
        unsigned char fab$b_rat;        /* record format                    */
        variant_struct  {
            unsigned fab$v_ftn : 1;     /* fortran carriage-ctl             */
            unsigned fab$v_cr : 1;      /* lf-record-cr carriage ctl        */
            unsigned fab$v_prn : 1;     /* print-file carriage ctl          */
            unsigned fab$v_blk : 1;     /* records don't cross block boundaries  */
            unsigned fab$v_fill_2 : 4;
            } fab$r_rat_bits;
        } fab$r_rat_overlay;
    unsigned char fab$b_rfm;            /* record format                    */
    variant_union  {
	unsigned int fab$l_jnl;		/* lcb address */
	variant_struct {
	    variant_union  {
		unsigned char fab$b_journal;    /* journaling options (from FH2$B_JOURNAL) */
		variant_struct  {               /* note: only one of RU, ONLY_RU, NEVER_RU */
/* may be set at a time                                                     */
		    unsigned fab$v_only_ru : 1; /* file is accessible only in recovery unit  */
	            unsigned fab$v_ru : 1;      /* enable recovery unit journal     */
	            unsigned fab$v_bi : 1;      /* enable before image journal      */
	            unsigned fab$v_ai : 1;      /* enable after image journal       */
	            unsigned fab$v_at : 1;      /* enable audit trail journal       */
	            unsigned fab$v_never_ru : 1; /* file is never accessible in recovery unit */
	            unsigned fab$v_journal_file : 1; /* this is a journal file      */
	            unsigned fab$v_fill_3 : 1;
	            } fab$r_journal_bits;
	        } fab$r_journal_overlay;
	    unsigned char fab$b_ru_facility;    /* recoverable facility id number   */
	    short int fabdef$$_fill_7;          /* (spare)                          */
	    } fab$l_jnl_real_stuff;
	} fab$l_jnl_overlay;
    char *fab$l_xab;		        /* xab address                      */
    struct NAM *fab$l_nam;      	/* nam block address                */
    char *fab$l_fna;			/* file name string address         */
    char *fab$l_dna;			/* default file name string addr    */
    unsigned char fab$b_fns;            /* file name string size            */
    unsigned char fab$b_dns;            /* default name string size         */
    unsigned short int fab$w_mrs;       /* maximum record size              */
    unsigned long int fab$l_mrn;        /* maximum record number            */
    unsigned short int fab$w_bls;       /* blocksize for tape               */
    unsigned char fab$b_bks;            /* bucket size                      */
    unsigned char fab$b_fsz;            /* fixed header size                */
    unsigned long int fab$l_dev;        /* device characteristics           */
    unsigned long int fab$l_sdc;        /* spooling device characteristics  */
    unsigned short int fab$w_gbc;       /* Global buffer count              */
    variant_union  {
        unsigned char fab$b_acmodes;    /* agent access modes               */
        variant_struct  {
            unsigned fab$v_lnm_mode : 2; /* ACMODE for log nams             */
            unsigned fab$v_chan_mode : 2; /* ACMODE for channel             */
            unsigned fab$v_file_mode : 2; /* ACMODE to use for determining file accessibility */
            unsigned fab$v_callers_mode : 2; /* ACMODE for user structure probing; */
/* maximized with actual mode of caller                                     */
            } fab$r_acmodes_bits;
        } fab$r_acmodes_overlay;
    variant_union  {                    /* recovery control flags           */
        unsigned char fab$b_rcf;        /* (only for use by RMS Recovery)   */
        variant_struct  {
            unsigned fab$v_rcf_ru : 1;  /* recovery unit recovery           */
            unsigned fab$v_rcf_ai : 1;  /* after image recovery             */
            unsigned fab$v_rcf_bi : 1;  /* before image recovery            */
            unsigned fab$v_fill_4 : 5;
            } fab$r_rcf_bits;
        } fab$r_rcf_overlay;
    long int fabdef$$_fill_9;           /* (spare)                          */
    } ;
 
/* These are tradtional macros that should be hand-maintained for compatibility */
#define FAB$V_PPF_RAT	6		/* rat value for process-permanent files */
#define FAB$S_PPF_RAT	8
#define FAB$V_PPF_IND	14		/* indirect access to process-permanent file */
#define FAB$V_MXV	1		/* maximize version number */
#define FAB$V_SUP	2		/* supersede existing file */
#define FAB$V_TMP	3		/* create temporary file */
#define FAB$V_TMD	4		/* temporary file marked for delete */
#define FAB$V_DFW	5		/* deferred write (rel and idx) */
#define FAB$V_SQO	6		/* sequential access only */
#define FAB$V_RWO	7		/* rewind magnetic tape on open */
#define FAB$V_POS	8		/* use next magnetic tape position */
#define FAB$V_WCK	9		/* write checking */
#define FAB$V_NEF	10		/* not end of file, inihibit eof positioning */
#define FAB$V_RWC	11		/* rewind magnetic tape on close */
#define FAB$V_DMO	12		/* dismount mt on close (not implemented) */
#define FAB$V_SPL	13		/* spool file on close */
#define FAB$V_SCF	14		/* submit command file on close */
#define FAB$V_DLT	15		/* delete file */
#define FAB$V_NFS	16		/* non-file-structured operation */
#define FAB$V_UFO	17		/* user file open - no rms operation */
#define FAB$V_PPF	18		/* process permanent file (pio segment) */
#define FAB$V_INP	19		/* process permanent file is 'input' */
#define FAB$V_CTG	20		/* contiguous extension */
#define FAB$V_CBT	21		/* contiguous best try */
#define FAB$V_JNL	22		/* explicit logging (not implemented) */
#define FAB$M_JNL	(1 << FAB$V_JNL)
#define FAB$V_RCK	23		/* read checking */
#define FAB$V_NAM	24		/* use NAM block device, file and/or directory id */
#define FAB$V_CIF	25		/* create if non-existent */
#define FAB$V_UFM	26		/* user file open mode (user if 1, super if 0) enable only if esc and (ufo or nfs) are also on */
#define FAB$M_UFM	(1 << FAB$V_UFM)
#define FAB$V_ESC	27		/* 'escape' to non-standard functions ($modify) */
#define FAB$V_TEF	28		/* truncate at end-of-file on close (write-accessed seq. disk file only) */
#define FAB$V_OFP	29		/* output file parse (only name type sticky) */
#define FAB$V_KFO	30		/* known file open (image activator only release 1) */
#define FAB$V_PUT	0		/* put access */
#define FAB$V_GET	1		/* get access */
#define FAB$V_DEL	2		/* delete access */
#define FAB$V_UPD	3		/* update access */
#define FAB$V_TRN	4		/* truncate access */
#define FAB$V_BIO	5		/* block i/o access */
#define FAB$V_BRO	6		/* block and record i/o access */
#define FAB$V_EXE	7		/* execute access (caller must be exec or kernel mode, ufo must also be set) */
#define FAB$V_SHRPUT	0		/* put access */
#define FAB$V_SHRGET	1		/* get access */
#define FAB$V_SHRDEL	2		/* delete access */
#define FAB$V_SHRUPD	3		/* update access */
#define FAB$V_MSE	4		/* multi-stream connects enabled */
#define FAB$V_NIL	5		/* no sharing */
#define FAB$V_UPI	6		/* user provided interlocking (allows multiple */
#define FAB$V_ORG	4		/* file organization */
#define FAB$S_ORG	4
#define FAB$V_FTN	0		/* FORTRAN carriage control character */
#define FAB$V_CR	1		/* line feed - record -carriage return */
#define FAB$V_PRN	2		/* print-file carriage control */
#define FAB$V_BLK	3		/* records don't cross block boundaries */
#define fab$b_dsbmsk	fab$b_acmodes	/* saved for backwards compatibility */
#define FAB$S_LNM_MODE	2		/* logical names */
#define FAB$V_LNM_MODE	0
#define FAB$S_CHAN_MODE	2		/* channel */
#define FAB$V_CHAN_MODE	2
#define FAB$S_FILE_MODE	2		/* files accessability */
#define FAB$V_FILE_MODE	4
/* The following defines were scrambled before VAX C V3.1 */
#define FAB$V_RU	1		/* (was 0) recovery unit recovery */
#define FAB$V_BI	2		/* (was 2) before image recovery */
#define FAB$V_AI	3		/* (was 1) after image recovery */

globalref struct FAB cc$rms_fab;	/* Declare initialized prototype data structure */

#pragma standard
#endif					/* __FAB_LOADED */
#ifndef __FALDEF_LOADED
#define __FALDEF_LOADED	1

/*** MODULE $faldef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:14.79 */
/*                                                                          */
/*                                                                          */
/* VERSION:	'X-3'                                                       */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/* FACILITY:                                                                */
/*                                                                          */
/*	MESSAGES ARE FOR THE FAL (DECNET FILE ACCESS LISTENER) FACILITY, BUT */
/*	ARE GENERATED ON BEHALF OF FAL BY RMS.                              */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS MODULE DEFINES FAL STATUS CODE SYMBOLS AND CORRESPONDING MESSAGE */
/*	TEXT. NOTE THAT THIS MESSAGE FILE IS MAINTAINED BY THE RMS FACILITY, */
/*	NOT THE FAL FACILITY, BECAUSE RMS DOES THE TRANSLATION OF DAP STATUS */
/*	INTO FAL STATUS CODES WHICH ARE REPORTED AS SECONDARY STATUS INFORMATION */
/*	TO THE RMS$_NETFAIL AND RMS$_SUPPORT COMPLETION CODES ON BEHALF OF FAL. */
/*                                                                          */
/* ENVIRONMENT: VAX/VMS                                                     */
/*                                                                          */
/* AUTHOR: JAMES A. KRYCKA,	CREATION DATE:	15-JAN-1982                 */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	X-3	SAD009		STUART A. DAVIDSON	06-OCT-1986         */
/*		ADD STATUS CODES FOR SNADTF.                                */
/*                                                                          */
/*	X-2	DAS		DAVID A. SOLOMON	01-AUG-1986         */
/*		REMOVE /MACRO= ON .FACILITY SO THE PROPER MACROS WILL       */
/*		BE GENERATED IN THE SDL FILE.                               */
/*                                                                          */
/*	V03-001	JAK0147		J A KRYCKA	09-JUL-1984                 */
/*		ADD ERROR CODES THAT CORRESPOND TO DAP MICCODES 416 TO 470  */
/*		(OCTAL) FOR MACCODES 4 THROUGH 7 DEFINED IN THE DAP V7.0    */
/*		SPECIFICATION.                                              */
/*                                                                          */
/*--                                                                        */
/*++                                                                        */
/* DEFINE FAL STATUS CODES FOR USE BY RMS AS SECONDARY STATUS CODES.        */
/*                                                                          */
/* LAYOUT OF MESSAGE SPACE:                                                 */
/*                                                                          */
/*	MSG NUMBERS	MSG NUMBERS	MSG CODES	DESCRIPTION         */
/*	(DECIMAL)	(HEXADECIMAL)	(HEXADECIMAL)                       */
/*                                                                          */
/*	   0 - 1023	0000 - 03FF	8000 - 9FFF	UNUSED              */
/*	1024 - 2047	0400 - 07FF	A000 - BFFF	FOR RMS$_NETFAIL    */
/*	2048 - 4095	0800 - 0FFF	C000 - FFFF	FOR RMS$_SUPPORT    */
/*--                                                                        */
#define FAL$_FACILITY 503
/*+                                                                         */
/* DEFINE FAL STATUS CODES THAT ARE ASSOCIATED WITH THE RMS$_NETFAIL COMPLETION */
/* CODE AND RETURNED IN THE STV FIELD OF THE FAB OR RAB.                    */
/*                                                                          */
/* USE THE FOLLOWING FORMULA TO MAP A DAP STATUS CODE (STSCODE FIELD WITH   */
/* MACCODE = 4 THRU 7) INTO A CORRESPONDING FAL MESSAGE CODE (LOWER 16 BITS): */
/*                                                                          */
/*	MESSAGE-CODE = (2**15 + ((MICCODE + 1024) * 8) + SEVERITY-LEVEL)    */
/*                                                                          */
/* NOTE:	THE FIRST THREE CHARACTERS OF THE MESSAGE IDENTIFICATION MNEMONIC */
/*	FOR EACH MESSAGE CODE IN THIS SET INDICATES ITS ORIGIN AS FOLLOWS:  */
/*                                                                          */
/*	RMS ---	THE CODE IS DEFINED FOR RMS-11 OR RMS-20, BUT NOT FOR RMS-32. */
/*		(RMS-32 COMPLETION CODES ARE DEFINED IN RMSDEF.MDL.)        */
/*	FCS --- THE CODE IS DEFINED FOR THE FCS-11 ENVIRONMENT.             */
/*	TEN --- THE CODE IS DEFINED FOR THE TOPS-10 ENVIRONMENT.            */
/*	DAP --- ORIGIN IN THE DAP SPECIFICATION IS UNKNOWN.                 */
/*-                                                                         */
#define FAL$_OFFSET_A 1024
/* MICCODE = 0000 (OCTAL)                                                   */
#define FAL$_DAPFAIL 33005572
#define FAL$_RMSABO 33005580
/* MICCODE = 0011 (OCTAL)                                                   */
#define FAL$_RMSAST 33005644
#define FAL$_RMSBPA 33005652
#define FAL$_RMSBPS 33005660
/* MICCODE = 0026 (OCTAL)                                                   */
#define FAL$_RMSCLS 33005748
/* MICCODE = 0056 (OCTAL)                                                   */
#define FAL$_RMSFID 33005940
/* MICCODE = 0071 (OCTAL)                                                   */
#define FAL$_RMSINI 33006028
/* MICCODE = 0102 (OCTAL)                                                   */
#define FAL$_RMSLBL 33006100
#define FAL$_RMSLBY 33006108
#define FAL$_RMSLCH 33006116
/* MICCODE = 0106 (OCTAL)                                                   */
#define FAL$_RMSLOC 33006132
#define FAL$_RMSMAP 33006140
/* MICCODE = 0115 (OCTAL)                                                   */
#define FAL$_RMSNID 33006188
/* MICCODE = 0117 (OCTAL)                                                   */
#define FAL$_RMSOPN 33006204
/* MICCIDE = 0124 (OCTAL)                                                   */
#define FAL$_RMSPRM 33006244
/* MICCODE = 0153 (OCTAL)                                                   */
#define FAL$_RMSSTK 33006428
/* MICCODE = 0162 (OCTAL)                                                   */
#define FAL$_RMSVOL 33006484
/* MICCODE = 0170 (OCTAL)                                                   */
#define FAL$_RMSCAA 33006532
/* MICCODE = 0231 (OCTAL)                                                   */
#define FAL$_RMSBLK 33006796
#define FAL$_RMSBSZ 33006804
#define FAL$_RMSCDR 33006812
#define FAL$_RMSCGJ 33006820
#define FAL$_RMSCOF 33006828
#define FAL$_RMSJFN 33006836
#define FAL$_RMSPEF 33006844
#define FAL$_RMSTRU 33006852
#define FAL$_RMSUDF 33006860
#define FAL$_RMSXCL 33006868
#define FAL$_DAPDIRFUL 33006876
#define FAL$_FCSHWR 33006884
#define FAL$_FCSFHE 33006892
#define FAL$_DAPWRTEOF 33006900
#define FAL$_FCSONP 33006908
#define FAL$_FCSDNA 33006916
#define FAL$_FCSDAA 33006924
#define FAL$_FCSDUN 33006932
#define FAL$_FCSRSU 33006940
#define FAL$_FCSOVR 33006948
#define FAL$_FCSBCC 33006956
#define FAL$_FCSNOD 33006964
#define FAL$_FCSIFU 33006972
#define FAL$_FCSHFU 33006980
#define FAL$_FCSWAC 33006988
#define FAL$_FCSCKS 33006996
#define FAL$_FCSWAT 33007004
#define FAL$_FCSALN 33007012
#define FAL$_FCSBTF 33007020
#define FAL$_FCSILL 33007028
#define FAL$_FCS2DV 33007036
#define FAL$_FCSFEX 33007044
#define FAL$_FCSRNM 33007052
#define FAL$_FCSFOP 33007060
#define FAL$_FCSVER 33007068
#define FAL$_FCSEOV 33007076
#define FAL$_FCSDAO 33007084
#define FAL$_FCSBBE 33007092
#define FAL$_FCSEOT 33007100
#define FAL$_FCSNBF 33007108
#define FAL$_FCSNBK 33007116
#define FAL$_FCSNST 33007124
#define FAL$_FCSULK 33007132
#define FAL$_FCSNLN 33007140
#define FAL$_FCSSRE 33007148
/* MICCODE = 0311 (OCTAL)                                                   */
#define FAL$_DAPQUOEXC 33007180
/* MICCODE = 0346 (OCTAL)                                                   */
#define FAL$_DAPDIRCAF 33007412
#define FAL$_DAPDIRCRA 33007420
#define FAL$_DAPDIRPRO 33007428
#define FAL$_DAPDIRPRA 33007436
#define FAL$_DAPDIRNFA 33007444
#define FAL$_DAPDIRCON 33007452
/* MICCODE = 0416 (OCTAL)                                                   */
#define FAL$_TENFILMOD 33007732
#define FAL$_TENDEVNA 33007740
#define FAL$_TENDEVNF 33007748
#define FAL$_TENPARALL 33007756
#define FAL$_TENBNFREE 33007764
#define FAL$_TENCSDF 33007772
#define FAL$_TENCDDF 33007780
#define FAL$_TENSFDNF 33007788
#define FAL$_TENSLE 33007796
#define FAL$_TENSFDCNT 33007804
#define FAL$_TENNCESL 33007812
#define FAL$_TENCUPFIL 33007820
#define FAL$_TENNETCAP 33007828
#define FAL$_TENTSKNA 33007836
#define FAL$_TENNODNF 33007844
#define FAL$_TENSFDREN 33007852
#define FAL$_TENCDFNDR 33007860
#define FAL$_TENJCREAD 33007868
#define FAL$_TENRENSFD 33007876
#define FAL$_TENDEVDWN 33007884
#define FAL$_TENDEVRES 33007892
#define FAL$_TENDEVMDA 33007900
#define FAL$_TENDEVALL 33007908
#define FAL$_TENILLDM 33007916
#define FAL$_TENLPTPAG 33007924
#define FAL$_TENLPTVFU 33007932
#define FAL$_TENLPTCHR 33007940
#define FAL$_TENLPTRAM 33007948
#define FAL$_TENFILSPC 33007956
/* MICCODE = 0453 (OCTAL)                                                   */
#define FAL$_TENNSNOD 33007964
#define FAL$_TENANODI 33007972
#define FAL$_TENSNODI 33007980
#define FAL$_TENNSDEV 33007988
#define FAL$_TENADEVI 33007996
#define FAL$_TENSDEVI 33008004
#define FAL$_TENNSDIR 33008012
#define FAL$_TENADIRI 33008020
#define FAL$_TENSDIRI 33008028
#define FAL$_TENNSFIL 33008036
#define FAL$_TENAFILI 33008044
#define FAL$_TENSFILI 33008052
#define FAL$_TENAFILR 33008060
#define FAL$_TENSFILR 33008068
/* MICCODE = 475 (OCTAL)                                                    */
#define FAL$_DTFFALSHT 33008108
#define FAL$_DTFNOFIL 33008116
#define FAL$_DTFNOREC 33008124
#define FAL$_DTFNOTREG 33008132
#define FAL$_DTFOPRABO 33008140
/* MICCODE = 504 (OCTAL)                                                    */
#define FAL$_DTFRDCKP 33008164
/*+                                                                         */
/* DEFINE FAL STATUS CODES THAT ARE ASSOCIATED WITH THE RMS$_SUPPORT COMPLETION */
/* CODE AND RETURNED IN THE STV FIELD OF THE FAB OR RAB.                    */
/*                                                                          */
/* USE THE FOLLOWING FORMULA TO MAP A DAP STATUS CODE (STSCODE FIELD WITH   */
/* MACCODE = 2) INTO A CORRESPONDING FAL MESSAGE CODE (LOWER 16 BITS):      */
/*                                                                          */
/*	MESSAGE-CODE = (2**15 + ((MICCODE + 2048) * 8) + SEVERITY-LEVEL)    */
/*                                                                          */
/* NOTE:	THE INTENT IN THIS SECTION IS TO DEFINE FAL STATUS CODES ONLY FOR DAP */
/*	FIELDS THAT CORRESPOND DIRECTLY TO RMS CONTROL BLOCK FIELDS USED FOR */
/*	INPUT. FOR OTHER DAP FIELDS THAT MAY BE REJECTED BY THE REMOTE FAL AS */
/*	BEING UNSUPPORTED, THE RMS$_SUP COMPLETION CODE IS RETURNED IN THE STS */
/*	FIELD OF THE FAB OR RAB WITH AN ASSOCIATED DAP CODE IN THE STV FIELD. */
/*-                                                                         */
#define FAL$_OFFSET_B 2048
/* MICCODE = 0222 (OCTAL)                                                   */
#define FAL$_ORG 33014932
#define FAL$_RFM 33014940
#define FAL$_RAT 33014948
#define FAL$_BLS 33014956
#define FAL$_MRS 33014964
#define FAL$_ALQ1 33014972
#define FAL$_BKS 33014980
#define FAL$_FSZ 33014988
#define FAL$_MRN 33014996
/* MICCODE = 0234 (OCTAL)                                                   */
#define FAL$_DEQ1 33015012
#define FAL$_FOP1 33015020
/* MICCODE = 0241 (OCTAL)                                                   */
#define FAL$_LRL 33015052
/* MICCODE = 0320 (OCTAL)                                                   */
#define FAL$_ACCFUNC 33015428
/* MICCODE = 0323 (OCTAL)                                                   */
#define FAL$_FAC 33015452
#define FAL$_SHR 33015460
/* MICCODE = 0420 (OCTAL)                                                   */
#define FAL$_CTLFUNC 33015940
/* MICCODE = 0422 (OCTAL)                                                   */
#define FAL$_RAC 33015956
#define FAL$_KEY 33015964
#define FAL$_KRF 33015972
#define FAL$_ROP 33015980
/* MICCODE = 0520 (OCTAL)                                                   */
#define FAL$_CONFUNC 33016452
/* MICCODE = 0720 (OCTAL)                                                   */
#define FAL$_CMPFUNC 33017476
#define FAL$_FOP2 33017484
/* MICCODE = 1221 (OCTAL)                                                   */
#define FAL$_FLG 33019020
#define FAL$_DFL 33019028
#define FAL$_IFL 33019036
/* MICCODE = 1225 (OCTAL)                                                   */
#define FAL$_POS 33019052
#define FAL$_SIZ 33019060
#define FAL$_REF 33019068
#define FAL$_KNM 33019076
#define FAL$_NUL 33019084
#define FAL$_IAN 33019092
#define FAL$_LAN 33019100
#define FAL$_DAN 33019108
#define FAL$_DTP 33019116
/* MICCODE = 1321 (OCTAL)                                                   */
#define FAL$_VOL 33019532
#define FAL$_ALN 33019540
#define FAL$_AOP 33019548
#define FAL$_LOC 33019556
/* MICCODE = 1326 (OCTAL)                                                   */
#define FAL$_ALQ2 33019572
#define FAL$_AID 33019580
#define FAL$_BKZ 33019588
#define FAL$_DEQ2 33019596
/* MICCODE = 1521 (OCTAL)                                                   */
#define FAL$_CDT 33020556
#define FAL$_RDT 33020564
#define FAL$_EDT 33020572
#define FAL$_RVN 33020580
/* MICCODE = 1621 (OCTAL)                                                   */
#define FAL$_OWNER 33021068
#define FAL$_PROTSYS 33021076
#define FAL$_PROTOWN 33021084
#define FAL$_PROTGRP 33021092
#define FAL$_PROTWLD 33021100

#endif					/* __FALDEF_LOADED */
#ifndef __FCHDEF_LOADED
#define __FCHDEF_LOADED	1

/*	FCHDEF - V3.0	*/
/*
 * File Characteristics Bit Positions and Mask Definitions
 *	Provided as part of DEC/Shell V1.0
 */
#define FCH$V_ACL	0x00B			/* position of acl bit */
#define FCH$M_ACL	(1 << FCH$V_ACL) 	/* acl bit mask */
#define FCH$V_BADBLOCK	0x00E			/* position of badblk bit */
#define FCH$M_BADBLOCK	(1 << FCH$V_BADBLOCK)	/* badblock bit mask */
#define FCH$V_CONTIG	0x007			/* position of contig bit */
#define FCH$M_CONTIG	(1 << FCH$V_CONTIG)	/* contig bit mask */
#define FCH$V_CONTIGB	0x005			/* pos of cont best try bit */
#define FCH$M_CONTIGB	(1 << FCH$V_CONTIGB)	/* contig best try bit mask */
#define FCH$V_DIRECTORY	0x00D			/* position of directory bit */
#define FCH$M_DIRECTORY (1 << FCH$V_DIRECTORY)	/* directory bit mask */
#define FCH$V_ERASE	0x011			/* position of erase bit */
#define FCH$M_ERASE	(1 << FCH$V_ERASE)	/* erase bit mask */
#define FCH$V_LOCKED	0x006			/* position of locked bit */
#define FCH$M_LOCKED	(1 << FCH$V_LOCKED)	/* locked bit mask */
#define FCH$V_MARKDEL	0x00F			/* pos of mark for del bit */
#define FCH$M_MARKDEL	(1 << FCH$V_MARKDEL)	/* mark for delete bit mask */
#define FCH$V_NOBACKUP	0x001			/* pos of nobackup bit */
#define FCH$M_NOBACKUP	(1 << FCH$V_NOBACKUP)	/* nobackup bit mask */
#define FCH$V_NOCHARGE	0x010			/* pos of nocharge bit */
#define FCH$M_NOCHARGE	(1 << FCH$V_NOCHARGE)	/* nocharge bit mask */
#define FCH$V_READCHECK	0x003			/* pos of readcheck bit */
#define FCH$M_READCHECK	(1 << FCH$V_READCHECK)	/* readcheck bit mask */
#define FCH$V_SPOOL	0x00C			/* pos of spool bit */
#define FCH$M_SPOOL	(1 << FCH$V_SPOOL)	/* spool bit mask */
#define FCH$V_WRITCHECK	0x004			/* pos of writecheck bit */
#define FCH$M_WRITCHECK	(1 << FCH$V_WRITCHECK)	/* writecheck bit mask */
#define FCH$V_WRITEBACK	0x002			/* pos of writeback bit */
#define FCH$M_WRITEBACK	(1 << FCH$V_WRITEBACK)	/* writeback bit mask */

#endif					/* __FCHDEF_LOADED */
#ifndef __FDLDEF_LOADED
#define __FDLDEF_LOADED	1

/*** MODULE $fdldef ***/
/*+                                                                         */
/* FDL CALL INTERFACE CONTROL FLAGS                                         */
/*-                                                                         */
#define FDL$M_SIGNAL 1
#define FDL$M_FDL_STRING 2
#define FDL$M_DEFAULT_STRING 4
#define FDL$M_FULL_OUTPUT 8
#define FDL$M_$CALLBACK 16
#pragma nostandard
union fdldef {
    variant_struct  {
        unsigned fdl$v_signal : 1;      /* SIGNAL ERRORS, DON'T RETURN      */
        unsigned fdl$v_fdl_string : 1;  /* MAIN FDL SPEC IS A CHAR STRING   */
        unsigned fdl$v_default_string : 1; /* DEFAULT FDL SPEC IS A CHAR STRING */
        unsigned fdl$v_full_output : 1; /* PRODUCE A 'COMPLETE' FDL SPEC    */
        unsigned fdl$v_$callback : 1;   /* USED BY EDF ON INPUT (DEC ONLY)  */
        unsigned fdl$v_fill_0 : 3;
        } fdl$r_fdldef_bits;
    } ;
#pragma standard

#endif					/* __FDLDEF_LOADED */
#ifndef __FIBDEF_LOADED
#define __FIBDEF_LOADED	1

/*** MODULE $fibdef ***/
/*----                                                                      */
/*                                                                          */
/* LAYOUT OF THE FILE IDENTIFICATION BLOCK (FIB)                            */
/*                                                                          */
/*****                                                                      */
/*                                                                          */
/*        NOTE:        If the size of the FIB is changed the following must be changed */
/*                to reflect the change:                                    */
/*                                                                          */
/*                In Module:        [RMS.SRC]RMSFWADEF.SDL                  */
/*                                                                          */
/*                Field:                FWA$T_FIBBUF                        */
/*                                                                          */
/*                Constant:        FWA$C_FIBLEN                             */
/*                                                                          */
/*                Both the field and constant must be GEQ to the size of    */
/*                the FIB, i.e. FIB$C_LENGTH. FIB length is currently 64.   */
/*                                                                          */
/*****                                                                      */
/*                                                                          */
#define FIB$M_NOWRITE 1
#define FIB$M_DLOCK 2
#define FIB$M_BLK_LOCK 4
#define FIB$M_SPOOL 16
#define FIB$M_WRITECK 32
#define FIB$M_SEQONLY 64
#define FIB$M_WRITE 256
#define FIB$M_READCK 512
#define FIB$M_NOREAD 1024
#define FIB$M_NOTRUNC 2048
#define FIB$M_CONTROL 4096
#define FIB$M_EXECUTE 65536
#define FIB$M_PRSRV_ATR 131072
#define FIB$M_RMSLOCK 262144
#define FIB$M_WRITETHRU 524288
#define FIB$M_NOLOCK 1048576
#define FIB$M_NORECORD 2097152
#define FIB$M_REWIND 8
#define FIB$M_CURPOS 16
#define FIB$M_UPDATE 64
#define FIB$K_ACCDATA 10                /* ABOVE DATA NECESSARY FOR ACCESS  */
#define FIB$C_ACCDATA 10                /* ABOVE DATA NECESSARY FOR ACCESS  */
#define FIB$K_DIRDATA 22                /* ABOVE DATA NECESSARY FOR DIRECTORY OPS  */
#define FIB$C_DIRDATA 22                /* ABOVE DATA NECESSARY FOR DIRECTORY OPS  */
#define FIB$M_ALLVER 8
#define FIB$M_ALLTYP 16
#define FIB$M_ALLNAM 32
#define FIB$M_WILD 256
#define FIB$M_NEWVER 512
#define FIB$M_SUPERSEDE 1024
#define FIB$M_FINDFID 2048
#define FIB$M_LOWVER 16384
#define FIB$M_HIGHVER 32768
#define FIB$M_ALCON 1
#define FIB$M_ALCONB 2
#define FIB$M_FILCON 4
#define FIB$M_ALDEF 8
#define FIB$M_ALLOCATR 16
#define FIB$M_EXTEND 128
#define FIB$M_TRUNC 256
#define FIB$M_NOHDREXT 512
#define FIB$M_MARKBAD 1024
#define FIB$M_NOCHARGE 32768
#define FIB$K_EXTDATA 32                /* ABOVE NECESSARY FOR BASIC FILE EXTENSION  */
#define FIB$C_EXTDATA 32                /* ABOVE NECESSARY FOR BASIC FILE EXTENSION  */
#define FIB$M_EXACT 1
#define FIB$M_ONCYL 2
#define FIB$C_CYL 1                     /* CYLINDER ADDRESS SPECIFIED       */
#define FIB$C_LBN 2                     /* LBN SPECIFIED                    */
#define FIB$C_VBN 3                     /* PROXIMATE VBN SPECIFIED          */
#define FIB$C_RFI 4                     /* RELATED FILE ID SPECIFIED        */
#define FIB$K_ALCDATA 44                /* ABOVE DATA NECESSARY FOR PLACEMENT  */
#define FIB$C_ALCDATA 44                /* ABOVE DATA NECESSARY FOR PLACEMENT  */
#define FIB$M_ALT_REQ 1
#define FIB$M_ALT_GRANTED 2
#define FIB$M_DIRACL 4
#define FIB$M_PROPAGATE 8
#define FIB$K_LENGTH 64
#define FIB$C_LENGTH 64
struct fibdef {
    union  {
        unsigned long int fib$l_acctl;  /* ACCESS CONTROL BITS              */
        struct  {
            unsigned fib$v_nowrite : 1; /* NO OTHER WRITERS                 */
            unsigned fib$v_dlock : 1;   /* ENABLE DEACCESS LOCK             */
            unsigned fib$v_blk_lock : 1; /* ENABLE RMS-11 BLOCK LOCKING     */
            unsigned fibdef$$_fill_1 : 1; /* UNUSED                         */
            unsigned fib$v_spool : 1;   /* SPOOL FILE ON CLOSE              */
            unsigned fib$v_writeck : 1; /* ENABLE WRITE CHECK               */
            unsigned fib$v_seqonly : 1; /* SEQUENTIAL ONLY ACCESS           */
            unsigned fibdef$$_fill_2 : 1; /* SPARE                          */
            unsigned fib$v_write : 1;   /* WRITE ACCESS                     */
            unsigned fib$v_readck : 1;  /* ENABLE READ CHECK                */
            unsigned fib$v_noread : 1;  /* NO OTHER READERS                 */
            unsigned fib$v_notrunc : 1; /* FILE MAY NOT BE TRUNCATED        */
            unsigned fib$v_control : 1; /* CONTROL ACCESS TO FILE           */
            unsigned fibdef$$_fill_3 : 3; /* SPARE                          */
/* THE HIGH 8 BITS CANNOT BE COPIED                                         */
/* INTO THE ACCESS MODE WORD IN THE WINDOW                                  */
            unsigned fib$v_execute : 1; /* ACCESS FOR EXECUTE (USE EXECUTE PROTECTION)  */
            unsigned fib$v_prsrv_atr : 1; /* PRESERVE ORIGINAL ATTRIBUTES OF FILE  */
            unsigned fib$v_rmslock : 1; /* OPEN WITH RMS RECORD LOCKING     */
            unsigned fib$v_writethru : 1; /* FORCE CACHE WRITE-THROUGH ON OPERATION  */
            unsigned fib$v_nolock : 1;  /* OVERRIDE ACCESS INTERLOCKS       */
            unsigned fib$v_norecord : 1; /* DO NOT RECORD FILE ACCESS       */
            unsigned fibdef$$_fill_4 : 2; /* SPARE                          */
            } fib$r_acctl_bits0;
        struct  {
            unsigned fibdef$$_fill_5 : 3;
            unsigned fib$v_rewind : 1;  /* REWIND TAPE                      */
            unsigned fib$v_curpos : 1;  /* CREATE AT CURRENT TAPE POSITION  */
            unsigned fibdef$$_fill_6 : 1;
            unsigned fib$v_update : 1;  /* UPDATE MODE (POSITION TO START OF FILE)  */
            unsigned fib$v_fill_1 : 1;
            } fib$r_acctl_bits1;
        struct  {
            char fibdef$$_fill_13 [3];
            char fib$b_wsize;           /* WINDOW SIZE                      */
            } fib$r_acctl_fields2;
        } fib$r_acctl_overlay;
    union  {
        unsigned short int fib$w_fid [3]; /* FILE ID                        */
        struct  {
            unsigned short int fib$w_fid_num; /* FILE NUMBER                */
            unsigned short int fib$w_fid_seq; /* FILE SEQUENCE NUMBER       */
            union  {
                unsigned short int fib$w_fid_rvn; /* RELATIVE VOLUME NUMBER  */
                struct  {
                    unsigned char fib$b_fid_rvn; /* SHORT FORM RVN          */
                    unsigned char fib$b_fid_nmx; /* EXTENDED FILE NUMBER    */
                    } fib$r_fid_rvn_fields;
                } fib$r_fid_rvn_overlay;
            } fib$r_fid_fields;
        } fib$r_fid_overlay;
    union  {
        unsigned short int fib$w_did [3]; /* DIRECTORY ID                   */
        struct  {
            unsigned short int fib$w_did_num; /* FILE NUMBER                */
            unsigned short int fib$w_did_seq; /* FILE SEQUENCE NUMBER       */
            union  {
                unsigned short int fib$w_did_rvn; /* RELATIVE VOLUME NUMBER  */
                struct  {
                    unsigned char fib$b_did_rvn; /* SHORT FORM RVN          */
                    unsigned char fib$b_did_nmx; /* EXTENDED FILE NUMBER    */
                    } fib$r_did_rvn_fields;
                } fib$r_did_rvn_overlay;
            } fib$r_did_fields;
        } fib$r_did_overlay;
    unsigned long int fib$l_wcc;        /* WILD CARD CONTEXT                */
    union  {
        unsigned short int fib$w_nmctl; /* NAME CONTROL BITS                */
        struct  {
            unsigned fibdef$$_fill_7 : 3;
            unsigned fib$v_allver : 1;  /* MATCH ALL VERSIONS               */
            unsigned fib$v_alltyp : 1;  /* MATCH ALL TYPES                  */
            unsigned fib$v_allnam : 1;  /* MATCH ALL NAMES                  */
            unsigned fibdef$$_fill_8 : 2;
            unsigned fib$v_wild : 1;    /* WILD CARDS IN FILE NAME          */
            unsigned fib$v_newver : 1;  /* MAXIMIZE VERSION NUMBER          */
            unsigned fib$v_supersede : 1; /* SUPERSEDE EXISTING FILE        */
            unsigned fib$v_findfid : 1; /* SEARCH FOR FILE ID               */
            unsigned fibdef$$_fill_9 : 2;
            unsigned fib$v_lowver : 1;  /* LOWER VERSION OF FILE EXISTS     */
            unsigned fib$v_highver : 1; /* HIGHER VERSION OF FILE EXISTS    */
            } fib$r_nmctl_bits;
        } fib$r_nmctl_overlay;
    union  {
        unsigned short int fib$w_exctl; /* EXTEND CONTROL                   */
        struct  {
            unsigned fib$v_alcon : 1;   /* ALLOCATE CONTIGUOUS              */
            unsigned fib$v_alconb : 1;  /* CONTIGUOUS BEST EFFORT           */
            unsigned fib$v_filcon : 1;  /* MARK FILE CONTIGUOUS             */
            unsigned fib$v_aldef : 1;   /* ALLOCATE DEFAULT AMOUNT          */
            unsigned fib$v_allocatr : 1; /* PLACEMENT DATA PRESENT IN ATTRIBUTE LIST  */
            unsigned fibdef$$_fill_10 : 2;
            unsigned fib$v_extend : 1;  /* ENABLE EXTENSION                 */
            unsigned fib$v_trunc : 1;   /* ENABLE TRUNCATION                */
            unsigned fib$v_nohdrext : 1; /* INHIBIT EXTENSION HEADERS       */
            unsigned fib$v_markbad : 1; /* MARK BLOCKS BAD                  */
            unsigned fibdef$$_fill_11 : 4;
            unsigned fib$v_nocharge : 1; /* DON'T CHARGE DISKQUOTA          */
            } fib$r_exctl_bits;
        } fib$r_exctl_overlay;
    unsigned long int fib$l_exsz;       /* EXTEND SIZE                      */
    unsigned long int fib$l_exvbn;      /* EXTENSION VBN                    */
    union  {
        unsigned char fib$b_alopts;     /* ALLOCATION OPTIONS               */
        struct  {
            unsigned fib$v_exact : 1;   /* EXACT PLACEMENT REQUIRED         */
            unsigned fib$v_oncyl : 1;   /* PUT ALLOCATION ON ONE CYLINDER   */
            unsigned fib$v_fill_2 : 6;
            } fib$r_alopts_bits;
        } fib$r_alopts_overlay;
    unsigned char fib$b_alalign;        /* ALLOCATION ALIGNMENT             */
    union  {
        unsigned short int fib$w_alloc [5]; /* ALLOCATION LOCATION          */
        struct  {
            union  {
                unsigned short int fib$w_loc_fid [3]; /* RELATED FILE ID    */
                struct  {
                    unsigned short int fib$w_loc_num; /* RELATED FILE NUMBER  */
                    unsigned short int fib$w_loc_seq; /* FILE SEQUENCE NUMBER  */
                    union  {
                        unsigned short int fib$w_loc_rvn; /* RELATED RVN    */
                        struct  {
                            unsigned char fib$b_loc_rvn; /* SHORT FORM RVN  */
                            unsigned char fib$b_loc_nmx; /* EXTENDED FILE NUMBER  */
                            } fib$r_loc_rvn_fields;
                        } fib$r_loc_rvn_overlay;
                    } fib$r_loc_fid_fields;
                } fib$r_loc_fid_overlay;
            unsigned long int fib$l_loc_addr; /* LOCATION ADDRESS (VBN, LBN, CYL)  */
            } fib$r_alloc_fields;
        } fib$r_alloc_overlay;
    unsigned short int fib$w_verlimit;  /* DIRECTORY ENTRY VERSION LIMIT    */
    unsigned char fib$b_agent_mode;     /* AGENTS ACCESS MODE               */
    unsigned char fib$b_ru_facility;    /* RECOVERABLE-FACILITY CODE        */
    unsigned long int fib$l_aclctx;     /* ACL CONTEXT FOR READ             */
    unsigned long int fib$l_acl_status; /* RETURN STATUS FROM ACL OPERATION */
    union  {
        unsigned long int fib$l_status; /* GENERAL STATUS LONGWORD          */
        struct  {
            unsigned fib$v_alt_req : 1; /* ALTERNATE ACCESS REQUIRED        */
            unsigned fib$v_alt_granted : 1; /* ALTERNATE ACCESS GRANTED     */
            unsigned fib$v_diracl : 1;  /* DO DIRECTORY ACL PROPAGATION     */
            unsigned fib$v_propagate : 1; /* DO PROPAGATION ON ENTER        */
            unsigned fib$v_fill_3 : 4;
            } fib$r_status_bits;
        } fib$r_status_overlay;
    unsigned long int fib$l_alt_access; /* ALTERNATE ACCESS MASK            */
    } ;
#define FIB$C_REWINDVOL 1               /* REWIND VOLUME SET                */
#define FIB$C_POSEND 2                  /* POSITION TO END OF VOLUME SET    */
#define FIB$C_NEXTVOL 3                 /* FORCE NEXT VOLUME                */
#define FIB$C_SPACE 4                   /* SPACE MAGNETIC TAPE              */
#define FIB$C_ILLEGAL 5                 /*                                  */
#define FIB$C_REWINDFIL 6               /* REWIND FILE                      */
#define FIB$C_LOCK_VOL 7                /* LOCK VOLUME AGAINST ALLOCATION   */
#define FIB$C_UNLK_VOL 8                /* UNLOCK VOLUME                    */
/* QUOTA FILE OPERATIONS                                                    */
#define FIB$C_ENA_QUOTA 9               /* ENABLE QUOTA FILE                */
#define FIB$C_DSA_QUOTA 10              /* DISABLE QUOTA FILE               */
#define FIB$C_ADD_QUOTA 11              /* ADD QUOTA FILE ENTRY             */
#define FIB$C_EXA_QUOTA 12              /* EXAMINE QUOTA FILE ENTRY         */
#define FIB$C_MOD_QUOTA 13              /* MODIFY QUOTA FILE ENTRY          */
#define FIB$C_REM_QUOTA 14              /* REMOVE QUOTA FILE ENTRY          */
#define FIB$C_USEREOT 15                /* ENABLE USER END OF TAPE HANDLING  */
#define FIB$C_REMAP 16                  /* REMAP FILE WINDOW                */
#define FIB$C_CLSEREXCP 17              /* ALLOW THE USER TO CLEAR A SERIOUS EXCP FROM A TAPE DRIVE */
#define FIB$C_FLUSH_CACHE 18            /* FLUSH SELECTED CACHE             */
#define FIB$C_FORCE_MV 19               /* FORCE MOUNT VERIFICATION TO OCCUR */
#define FIB$K_MTALEN 28                 /* LENGTH OF MTAACP DATA            */
#define FIB$C_MTALEN 28                 /* LENGTH OF MTAACP DATA            */
/*                                                                          */
#define FIB$C_FID_CACHE 1
#define FIB$C_EXTENT_CACHE 2
#define FIB$C_QUOTA_CACHE 3
/*                                                                          */
#define FIB$M_ALL_MEM 1
#define FIB$M_ALL_GRP 2
#define FIB$M_MOD_USE 4
#define FIB$M_MOD_PERM 8
#define FIB$M_MOD_OVER 16
struct fibdef1 {
    char fibdef$$_fill_14 [22];
    unsigned short int fib$w_cntrlfunc; /* ACP CONTROL FUNCTION             */
/* DEFINE ACP CONTROL FUNCTION CODES                                        */
/*                                                                          */
    union  {
        unsigned long int fib$l_cntrlval; /* ACP CONTROL FUNCTION VALUE PARAMETER  */
/* CACHE IDENTIFIER CODES FOR FLUSH_CACHE                                   */
/*                                                                          */
/* CONTROL BITS FOR QUOTA FILE OPERATIONS                                   */
/*                                                                          */
        struct  {
            unsigned fib$v_all_mem : 1; /* MATCH ALL MEMBER NUMBERS         */
            unsigned fib$v_all_grp : 1; /* MATCH ALL GROUP NUMBERS          */
            unsigned fib$v_mod_use : 1; /* MODIFY USAGE DATA                */
            unsigned fib$v_mod_perm : 1; /* MODIFY PERMANENT QUOTA          */
            unsigned fib$v_mod_over : 1; /* MODIFY OVERDRAFT LIMIT          */
            unsigned fib$v_fill_4 : 3;
            } fib$r_cntrlval_bits;
        } fib$r_cntrlval_overlay;
    } ;
 

#endif					/* __FIBDEF_LOADED */
#ifndef __FIDDEF_LOADED
#define __FIDDEF_LOADED	1

/*** MODULE $fiddef ***/
/*                                                                          */
/* STRUCTURE OF A FILE ID (FID)                                             */
/*                                                                          */
#define FID$K_LENGTH 6
#define FID$C_LENGTH 6
#define FID$C_INDEXF 1                  /* INDEX FILE                       */
#define FID$C_BITMAP 2                  /* STORAGE MAP FILE                 */
#define FID$C_BADBLK 3                  /* BAD BLOCK FILE                   */
#define FID$C_MFD 4                     /* MASTER FILE DIRECTORY            */
#define FID$C_CORIMG 5                  /* CORE IMAGE FILE                  */
#define FID$C_VOLSET 6                  /* VOLUME SET LIST FILE             */
#define FID$C_CONTIN 7                  /* STANRARD CONTINUATION FILE       */
#define FID$C_BACKUP 8                  /* BACKUP LOG FILE                  */
#define FID$C_BADLOG 9                  /* BAD BLOCK LOG FILE               */
#define FID$C_FREFIL 10                 /* FREE SPACE FILE                  */
#pragma nostandard
struct fiddef {
    unsigned short int fid$w_num;       /* FILE NUMBER                      */
    unsigned short int fid$w_seq;       /* FILE SEQUENCE NUMBER             */
    variant_union  {
        unsigned short int fid$w_rvn;   /* RELATIVE VOLUME NUMBER           */
        variant_struct  {
            unsigned char fid$b_rvn;    /* BYTE FORM OF RVN                 */
            unsigned char fid$b_nmx;    /* FILE NUMBER EXTENSION            */
/* FILE ID'S OF THE RESERVED FILES                                          */
            } fid$r_rvn_fields;
        } fid$r_rvn_overlay;
    } ;
#pragma standard

#endif					/* __FIDDEF_LOADED */
#ifndef __FILE_LOADED
#define __FILE_LOADED	1

/*	FILE - V3.0	*/

/*
	Manifest constants used by BSD 4.2 OPEN function
 */

# define O_RDONLY	000
# define O_WRONLY	001
# define O_RDWR		002
# define O_NDELAY	004
# define O_NOWAIT	004
# define O_APPEND	010
# define O_CREAT	01000
# define O_TRUNC	02000
# define O_EXCL		04000

#endif					/* __FILE_LOADED */
#ifndef __FLOAT_LOADED
#define __FLOAT_LOADED	1

/*	FLOAT - V3.0 - Definitions from ANSI 2.2.4.2	*/


/* Rounding mode for floating point addition.
 */
#define	FLT_ROUNDS	1		/* To nearest value */


/* Radix of exponent representation.
 */
#define	FLT_RADIX	2


/* Number of FLT_RADIX digits in the mantissa including the hidden bit.
 */
#define	FLT_MANT_DIG	24

/* 
 * CC$gfloat's definition was modified so that it's defined when
 * g_float is in effect, and undefined otherwise.  The syntax below is used
 * to allow VAX C to still be able to compile the header files correctly. 
*/
#ifndef CC$gfloat
#define CC$gfloat 0
#endif

#if CC$gfloat
#define	DBL_MANT_DIG	53		/* Under /G_FLOAT */
#define	LDBL_MANT_DIG	53
#else
#define	DBL_MANT_DIG	56		/* Under /NOG_FLOAT */
#define	LDBL_MANT_DIG	56
#endif

/* Number of decimal digits of precision.
 */
#define	FLT_DIG		6
#if CC$gfloat
#define	DBL_DIG		15		/* Under /G_FLOAT */
#define	LDBL_DIG	15
#else
#define	DBL_DIG		16		/* Under /NOG_FLOAT */
#define	LDBL_DIG	16
#endif

/* Minimum negative number such that FLT_RADIX raised to that (power minus
 * one) is a normalized floating-point number.
 */
#define	FLT_MIN_EXP	(-127)
#if CC$gfloat
#define	DBL_MIN_EXP	(-1023)		/* Under /G_FLOAT */
#define	LDBL_MIN_EXP	(-1023)
#else
#define	DBL_MIN_EXP	(-127)		/* Under /NOG_FLOAT */
#define	LDBL_MIN_EXP	(-127)
#endif


/* Minimum negative integer such that 10 raised to that power is in the
 * range of normalized floating-point numbers.
 */
#define	FLT_MIN_10_EXP  (-38)
#if CC$gfloat
#define	DBL_MIN_10_EXP	(-308)		/* Under /G_FLOAT */
#define	LDBL_MIN_10_EXP	(-308)
#else
#define	DBL_MIN_10_EXP	(-38)		/* Under /NOG_FLOAT */
#define	LDBL_MIN_10_EXP	(-38)
#endif

/* Maximum integer such that FLT_RADIX raised to that (power minus one)
 * is a representable finite floating point number.
 */
#define	FLT_MAX_EXP	127
#if CC$gfloat
#define	DBL_MAX_EXP	1023		/* Under /G_FLOAT */
#define	LDBL_MAX_EXP	1023
#else
#define	DBL_MAX_EXP	127		/* Under /NOG_FLOAT */
#define	LDBL_MAX_EXP	127
#endif


/* Maximum integer such that 10 raised to that power is in the range of
 * representable finite floating-point numbers.
 */
#define	FLT_MAX_10_EXP	38
#if CC$gfloat
#define	DBL_MAX_10_EXP	307		/* Under /G_FLOAT */
#define	LDBL_MAX_10_EXP	307
#else
#define	DBL_MAX_10_EXP	38		/* Under /NOG_FLOAT */
#define	LDBL_MAX_10_EXP	38
#endif

/* Maximum representable finite floating-point number. */
#define	FLT_MAX		((float) 1.7014117e+38)
#if CC$gfloat
#define	DBL_MAX		8.98846567431157854e+307	/* Under /G_FLOAT */
#define	LDBL_MAX	8.98846567431157854e+307
#else
#define	DBL_MAX		1.70141183460469229e+38		/* Under /NOG_FLOAT */
#define	LDBL_MAX	1.70141183460469229e+38
#endif

/* Minimum positive floating-point number epsilon such that 
 *	1.0 + epsilon  != 1.0
 */
#define	FLT_EPSILON	((float) (1.0 / 16777216))
#if CC$gfloat
#define	DBL_EPSILON	(1.0 / 1048576 / 1048576 / 8192)  /* Under /G_FLOAT */
#define	LDBL_EPSILON	(1.0 / 1048576 / 1048576 / 8192)
#else
#define	DBL_EPSILON	(1.0 / 1048576 / 1048576 / 65536) /* Under /NOG_FLOAT */
#define	LDBL_EPSILON	(1.0 / 1048576 / 1048576 / 65536)
#endif

/* Minimum normalized positive floating-point number */
#define	FLT_MIN		((float) 2.93873587705571877e-39)
#if CC$gfloat
#define	DBL_MIN		5.56268464626800346e-309	/* Under /G_FLOAT */
#define	LDBL_MIN	5.56268464626800346e-309
#else
#define	DBL_MIN		2.93873587705571877e-39		/* Under /NOG_FLOAT */
#define	LDBL_MIN	2.93873587705571877e-39
#endif

#endif					/* __FLOAT_LOADED */
#ifndef __FMLDEF_LOADED
#define __FMLDEF_LOADED	1

/*** MODULE $fmldef ***/
/*                                                                          */
/* Appended to a procedure definition are the formal arguments:             */
/*        FML$ - The fixed part of the formal arguments description         */
/*                                                                          */
#define FML$K_SIZE 2
#define FML$C_SIZE 2
struct fmldef {
    unsigned char fml$b_minargs;        /*Minimum number of arguments       */
    unsigned char fml$b_maxargs;        /*Maximum which include function if procedure is one  */
    } ;
 

#endif					/* __FMLDEF_LOADED */
#ifndef __FORDEF_LOADED
#define __FORDEF_LOADED	1

/*** MODULE $fordef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:28.99 */
/*                                                                          */
/* FILE: FORMSG.MSG  EDIT: CHH2009                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984, 1986 BY			    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 1-014 - ADD ERRORS 17-19 FOR NAMELIST.  SBL 10-NOV-1980                  */
/* 1-015 - CORRECT TYPO IN TOOMANVAL.  SBL 15-DEC-1980                      */
/* 1-016 - RESTORE CLOSING BRACKET ON OPEDEFREQ, MYSTERIOUSLY DROPPED IN 1-015. */
/*	  SBL 6-JAN-1981                                                    */
/* 2-001 - CONVERT TO MESSAGE UTILITY SOURCE FORMAT.  ADAPTED FROM FORMSG.MDL */
/*	  VERSION 1-016.  SBL 22-APR-1981                                   */
/* 2-002 - ADD UNFIO_FMT, FMTIO_UNF, DIRIO_KEY, SEQIO_DIR, KEYIO_DIR,       */
/*	  IO_NONFOR, INVTXTREC, FLOUNDEXC.  JAW 23-AUG-1981                 */
/* 2-003 - CHANGE INVTXTREC TO INVTEXREC.  JAW 24-AUG-1981                  */
/* 2-004 - ADD INVTEX WHICH DOES NOT REQUIRE A RECORD NUMBER.  THIS IS FOR INDEXED */
/*	  AND INTERNAL FILES THAT DO NOT HAVE A VALID RECORD NUMBER.  DGP 21-DEC-1981 */
/* 2-005 - ADD .TITLE.  SBL 28-AUG-1982                                     */
/* 2-006 - ADD OPEREQDIS AND OPEREQSEQ.  SBL 2-JUN-1983                     */
/* 2-007 - ADD ULTRIX SPECIFIC ERRORS AND WARNINGS.                         */
/* 2-008 - ADD INVMATKEY.  DJM 14-SEP-1987.                                 */
/* 2-009 - ADD FORRTL2 MESSAGES.  CHH 22-SEP-1987                           */
/*--                                                                        */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	FOR$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$FORDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE STS$V_MSG_ID IS THE FORTRAN ERROR NUMBER (1:94).                     */
/* THESE SYMBOLS ARE DECLARED EXTERNAL BY THE RUN-TIME LIBRARY,             */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*-                                                                         */
/*			; MAKE ALL ERRORS BE SEVERE (EXCEPT AS NOTED)       */
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
/*			; SET LH TO 24 (DECIMAL).                           */
#define FOR$_FACILITY 24
#define FOR$_NOTFORSPE 1605644
/*		; NEVER SIGNALED. USED ONLY AS A FORTRAN ERROR              */
/*		; NUMBER FOR ERRSNS TO MEAN SOME OTHER FACILITY             */
/*		; THAN FOR$ OR MTH$ DETECTED THE ERROR.                     */
#define FOR$_NOTIMP 1605652
#define FOR$_IGNORED 1605656
#define FOR$_IGNNOTDEL 1605664
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
/*			; SET LH TO 24 (DECIMAL).                           */
#define FOR$_SYNERRNAM 1605772
#define FOR$_TOOMANVAL 1605780
#define FOR$_INVREFVAR 1605788
#define FOR$_REWERR 1605796
#define FOR$_DUPFILSPE 1605804
#define FOR$_INPRECTOO 1605812
#define FOR$_BACERR 1605820
#define FOR$_ENDDURREA 1605828
#define FOR$_RECNUMOUT 1605836
#define FOR$_OPEDEFREQ 1605844
#define FOR$_TOOMANREC 1605852
#define FOR$_CLOERR 1605860
#define FOR$_FILNOTFOU 1605868
#define FOR$_OPEFAI 1605876
#define FOR$_MIXFILACC 1605884
#define FOR$_INVLOGUNI 1605892
#define FOR$_ENDFILERR 1605900
#define FOR$_UNIALROPE 1605908
#define FOR$_SEGRECFOR 1605916
#define FOR$_ATTACCNON 1605924
#define FOR$_INCRECLEN 1605932
#define FOR$_ERRDURWRI 1605940
#define FOR$_ERRDURREA 1605948
#define FOR$_RECIO_OPE 1605956
#define FOR$_INSVIRMEM 1605964
#define FOR$_NO_SUCDEV 1605972
#define FOR$_FILNAMSPE 1605980
#define FOR$_INCRECTYP 1605988
#define FOR$_KEYVALERR 1605996
#define FOR$_INCOPECLO 1606004
#define FOR$_WRIREAFIL 1606012
#define FOR$_INVARGFOR 1606020
#define FOR$_INVKEYSPE 1606028
#define FOR$_INCKEYCHG 1606036
#define FOR$_INCFILORG 1606044
#define FOR$_SPERECLOC 1606052
#define FOR$_NO_CURREC 1606060
#define FOR$_REWRITERR 1606068
#define FOR$_DELERR 1606076
#define FOR$_UNLERR 1606084
#define FOR$_FINERR 1606092
#define FOR$_MORONEREC 1605852
#define FOR$_ATTREANON 1605924
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
#define FOR$_LISIO_SYN 1606108
#define FOR$_INFFORLOO 1606116
#define FOR$_FORVARMIS 1606124
#define FOR$_SYNERRFOR 1606132
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE ERROR (NOT SEVERE) */
#define FOR$_OUTCONERR 1606138
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
#define FOR$_INPCONERR 1606148
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
#define FOR$_OUTSTAOVE 1606164
#define FOR$_INPSTAREQ 1606172
#define FOR$_VFEVALERR 1606180
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
#define FOR$_ADJARRDIM 1606380
#define FOR$_INVMATKEY 1606388
/* **********                                                               */
/* THE FOLLOWING MESSAGES ARE SECONDARY MESSAGES, OR ARE USED ONLY IN       */
/* EXIT HANDLERS, AND THEREFORE DO NOT NEED TO BE (AND SHOULD NOT BE)       */
/* CONTIGUOUS WITH THE MESSAGES ABOVE.                                      */
/* THE NEXT SIX MESSAGES ARE SECONDARY MESSAGES FOR USE WITH MIXFILACC IN   */
/* FOR$$IO_BEG AND FOR$$CB.                                                 */
#define FOR$_UNFIO_FMT 1607684
#define FOR$_FMTIO_UNF 1607692
#define FOR$_DIRIO_KEY 1607700
#define FOR$_SEQIO_DIR 1607708
#define FOR$_KEYIO_DIR 1607716
#define FOR$_IO_NONFOR 1607724
/* THE NEXT TWO MESSAGES ARE SECONDARY MESSAGES FOR USE WITH INPCONERR IN   */
/* FOR$$UDF_WF AND FOR$$UDF_WL.                                             */
#define FOR$_INVTEXREC 1607732
#define FOR$_INVTEX 1607740
/* ADDITIONAL SECONDARY MESSAGES                                            */
#define FOR$_OPEREQDIS 1607748
#define FOR$_OPEREQSEQ 1607756
/* THE NEXT MESSAGE IS A PRIMARY MESSAGE USED IN THE EXIT HANDLER WHICH     */
/* IS DECLARED BY FOR$HANDLER.                                              */
#define FOR$_FLOUNDEXC 1608035
/* END OF SPECIAL MESSAGES                                                  */
/* **********                                                               */
/* **********                                                               */
/* THE FOLLOWING MESSAGES ARE MESSAGES ISSUED FROM FORRTL2, THE             */
/* VAX FORTRAN V5.0 PARALLEL PROCESSING RTL SUPPORT.                        */
/*                                                                          */
#define FOR$_FATINTERR 1609732
#define FOR$_SUBPRCDIED 1609740
#define FOR$_NOTIMPRET 1609748
#define FOR$_FAIOWNERID 1609756
#define FOR$_FAIPRCID 1609764
#define FOR$_FAIPRCNAME 1609772
#define FOR$_FAIACTCPU 1609780
#define FOR$_FAIIDPRC 1609788
#define FOR$_FAIIMAGNAME 1609796
#define FOR$_FAIDCLEXIT 1609804
#define FOR$_FAISUBPRC 1609812
#define FOR$_INVNUMPRC 1609820
#define FOR$_MEMSHRERR 1609828
#define FOR$_LOCALSHRERR 1609836
#define FOR$_LOCALACCESS 1609844
#define FOR$_INVLCLADR 1609852
#define FOR$_COMSHRERR 1609860
#define FOR$_INVCOMADR 1609868
#define FOR$_PARINITERR 1609876
#define FOR$_STACKSHRERR 1609884
#define FOR$_FAISHRSTACK 1609892
#define FOR$_INVUNWIND 1609900
#define FOR$_STKBUFOVR 1609908
#define FOR$_INVLOGNAM 1611778
#define FOR$_TOOMANPRC 1611786
#define FOR$_INVDSTRSIZE 1611794
#define FOR$_DEFVALUSED 1615875
#define FOR$_UNIPROCESS 1615883
#define FOR$_NOPARINIT 1615891
#define FOR$_NOTRUNINPP 1615899
#define FOR$_NESTPPLOOP 1615907         /* END OF FORRTL2 MESSAGES          */
/* **********                                                               */

#endif					/* __FORDEF_LOADED */
/*** MODULE FORMS$C_DEFINITIONS.H ***/
/*** IDENT V1.0-000 ***/
/*                                                                          */
/************************************************************************** */
/*                    Copyright  1988, 1989, 1991 by                     * */
/*              DIGITAL Equipment Corporation, Maynard, Mass.             * */
/*                                                                        * */
/* This software is furnished under a license and may be used and  copied * */
/* only  in  accordance  with  the  terms  of  such  license and with the * */
/* inclusion of the above copyright notice.  This software or  any  other * */
/* copies  thereof may not be provided or otherwise made available to any * */
/* other person.  No title to or  ownership of  the  software  is  hereby * */
/* transferred.                                                           * */
/*                                                                        * */
/* The information in this software is subject to change  without  notice * */
/* and  should  not  be  construed  as  a commitment by DIGITAL Equipment * */
/* Corporation.                                                           * */
/*                                                                        * */
/* DIGITAL assumes no responsibility for the use or  reliability  of  its * */
/* software on equipment which is not supplied by DIGITAL.                * */
/*                                                                        * */
/************************************************************************** */
/*                                                                          */
/*                                                                          */
/* FACILITY:	    DECforms V1.4.                                          */
/*                                                                          */
/* ABSTRACT:	    Definitions file for DECforms applications written in C.*/
/*                                                                          */
/*                                                                          */

/*                                                                          */
/* FORMS$AR_FORM_TABLE declaration.                                         */
/*                                                                          */
globalref long int forms$ar_form_table ;

/*                                                                          */
/* Item codes for REQUEST_OPTIONS item lists.                               */
/*                                                                          */

#define FORMS$K_LANGUAGE 1
#define FORMS$K_IMAGE 2
#define FORMS$K_TRACEFILE 3
#define FORMS$K_TRACE 4
#define FORMS$K_PRINTFILE 5
#define FORMS$K_EFN 6
#define FORMS$K_RSB 7
#define FORMS$K_ASTADR 8
#define FORMS$K_ASTPRM 9
#define FORMS$K_ERROR_ROUTINE 10
#define FORMS$K_ERROR_PARAMETER 11
#define FORMS$K_NO_TERM_IO 12
#define FORMS$K_SELECTION_LABEL 13

/*                                                                          */
/* DECforms routines.                                                       */
/*                                                                          */
long int forms$enable() ;
long int forms$send() ;
long int forms$receive() ;
long int forms$transceive() ;
long int forms$disable() ;
long int forms$cancel() ;
#ifndef _FORMS_DEFINED
#define _FORMS_DEFINED

/*
** ++
**   FACILITY:
**
**       DECforms
**
**   ABSTRACT:
**
**       Include file for the DECforms API.
**
** --
*/

/* Possible values for the default terminal type option  */
typedef enum {
		forms_c_dev_vt100       = 0,
		forms_c_dev_vt100_noavo = 1,
		forms_c_dev_vt200       = 2,
		forms_c_dev_vt300       = 3,
		forms_c_dev_vt400       = 4 
             } Forms_Default_Term_Type;

/* Possible values for the default color type option */
typedef enum {
		forms_c_color_mono        = 0,
                forms_c_color_regis       = 4,
                forms_c_color_ansi        = 8
             } Forms_Default_Color_Type;

#ifdef vms
#define Forms_Form_Object globalref void*  /* type definition for global symbol created by forms extract object utility */
#else
#define Forms_Form_Object extern void*
#endif

typedef long int Forms_Status;             /* type definition for status of a request call   */

typedef char Forms_Session_Id[16];         /* type definition for session id                 */
typedef char Forms_Control_Text_Item[5];   /* type definition for one control text item      */
typedef char Forms_Control_Text[5][5];     /* type definition for a control text array       */
typedef char Forms_Request_Id[24];         /* type definition for parent request id          */

/***********************************************************************************************/
/*                                                                                             */
/* Structure for passing send and receive record data and shadow record data                   */
/*                                                                                             */
/***********************************************************************************************/

typedef struct {
     long int  data_length;    /* length of the actual record data area  */
     void *data_record;        /* pointer to the actual record data area */
     long int  shadow_length;  /* length of the shadow record data area  */
     void *shadow_record;      /* pointer to the shadow record data area */
} Forms_Record_Data;


/***********************************************************************************************/
/*                                                                                             */
/* Structure for building a field in a record message which maps to a record field             */
/* of IFDL data type TM.  ANSI C doesn't say how long the tm data type is, only that           */
/* it contains certain fields.  The DECforms TM data type is an implementation of the          */
/* ANSI C data type, but your C compiler may have a different (but still standard-conforming)  */
/* implementation.  Hence this structure can be used to load and unload the record message     */
/* even if your C compiler's implementation of tm changes.                                     */
/***********************************************************************************************/

typedef struct 
   {
	int	tm_sec, tm_min, tm_hour;
	int	tm_mday, tm_mon, tm_year;
	int	tm_wday, tm_yday, tm_isdst;
   } Forms_Tm;

/***********************************************************************************************/
/*                                                                                             */
/* Option names for Forms_Request_Options                                                      */
/*                                                                                             */
/***********************************************************************************************/

typedef enum {  
	        forms_c_opt_selection_label = -10,      /* selection label value               */	
	        forms_c_opt_default_color = -9,             /* default color type                  */	
	        forms_c_opt_default_term = -8,              /* default terminal type               */	
		forms_c_opt_no_term_io = -7,		/* suppresses terminal I/O	       */
		forms_c_opt_form = -6,		        /* DECforms form Object                */
                forms_c_opt_trace  = -5,		/* name of the trace file and options  */
                forms_c_opt_print = -4, 		/* name of printfile to use            */
                forms_c_opt_language = -3,		/* name of language to match           */
                forms_c_opt_completion_status = -2,	/* location to store completion status */
                forms_c_opt_completion_routine = -1,	/* completion routine and parameter    */
                forms_c_opt_end = 0,			/* indicates end of request options    */
                forms_c_opt_parent_request = 1,		/* specifies parent request id         */
                forms_c_opt_receive_record = 2,     	/* number of records being passed      */
		forms_c_opt_send_record = 3,		/* number of records being passed      */
		forms_c_opt_receive_control = 4,	/* receive control text info           */
		forms_c_opt_send_control = 5,		/* send control text info              */
                forms_c_opt_timeout = 6			/* describes timeout period            */
             } Forms_Request_Options_Type;


/***********************************************************************************************/
/*                                                                                             */
/* Forms_Request_Options for API request calls                                                 */
/*                                                                                             */
/***********************************************************************************************/


typedef union {

 /* Discriminate Tag */

 Forms_Request_Options_Type option;

 struct {                                  /* forms_c_opt_selection_label */
    Forms_Request_Options_Type option;
    char *name;
    long int name_length;
 } selection_label;

 struct {                                  /* forms_c_opt_default_color */
    Forms_Request_Options_Type option;
    Forms_Default_Color_Type type;
 } default_color;

 struct {                                  /* forms_c_opt_default_term */
    Forms_Request_Options_Type option;
    Forms_Default_Term_Type type;
 } default_term;

 struct {                                  /* forms_c_opt_no_term_io */
    Forms_Request_Options_Type option;
    long int flag;
 } no_term_io;

 struct {                                  /* forms_c_opt_form */
    Forms_Request_Options_Type option;
    void *object;                           
 } form;

 struct {                                  /* forms_c_opt_trace */
    Forms_Request_Options_Type option;
    char *file_name;
    long int file_name_length;
    long int flag;
 } trace;

 struct {                                  /* forms_c_opt_print */
    Forms_Request_Options_Type option;
    char *file_name;
    long int file_name_length;
 } print;

 struct {                                  /* forms_c_opt_language */
    Forms_Request_Options_Type option;
    char *name;
    long int name_length;
 } language;

 struct {                                  /* forms_c_opt_completion_status */
    Forms_Request_Options_Type option;
    Forms_Status *address;
 } completion_status;

 struct {                                  /* forms_c_opt_completion_routine */
    Forms_Request_Options_Type option;
    void (*address) ();
    void *parameter;
 } completion_routine;

 struct {                                  /* forms_c_opt_end */
    Forms_Request_Options_Type option;
 } end;

 struct {                                  /* forms_c_opt_parent_request */
    Forms_Request_Options_Type option;
    Forms_Request_Id *id;
 } parent_request;

 struct {                                  /* forms_c_opt_receive_record */
    Forms_Request_Options_Type option;
    long int count;
 } receive_record;

 struct {                                  /* forms_c_opt_send_record */
    Forms_Request_Options_Type option;
    long int count;
 } send_record;

 struct {                                  /* forms_c_opt_receive_control */
    Forms_Request_Options_Type option;
    long int *text_count;                  /* Number of control text returned by DECforms - write only */
    Forms_Control_Text *text;              /* receive control text must be an array of 25 bytes */
 } receive_control;

 struct {                                  /* forms_c_opt_send_control */
    Forms_Request_Options_Type option;
    long int text_count;                   /* Number of control text being sent to DECforms - read only */
    Forms_Control_Text *text;              /* send control text could be up to 25 bytes */
 } send_control;

 struct {                                  /* forms_c_opt_timeout */
    Forms_Request_Options_Type option;     
    long int period;                       /* timeout value is limited to the range between 0 to 32767 seconds on VMS. */
 } timeout;

 struct {                                 
    Forms_Request_Options_Type option;     /* This structure is placed here to ensure extensibilities. */
    char forms_reserved_bytes[28];         /* Please do not use this structure.                        */
 } forms_reserved_struct;

} Forms_Request_Options;


/*                                                                                                 */
/* FIMS specified status value                                                                     */
/*                                                                                                 */
/* Note: S000 and ESnnn are corresponding FIMS control texts.                                      */
/*                                                                                                 */
/*       Severity of each status is indicated by:                                                  */
/*                                                                                                 */
/*       (E) - Fatal error(s) occurred during request. Must be fixed before continuing.            */
/*       (W) - Warning error(s) occurred during request. Should fix before continuing.             */
/*       (I) - Informational event(s) occurred during request.                                     */
/*       (S) - Request processed successfully.                                                     */
/*                                                                                                 */

typedef enum {
    forms_s_normal		=  0,  /*  S000: (S) Request calls completed successfully */
    forms_s_timeout             =  1,  /* ES001: (E) Input did not complete in the time specified */
    forms_s_formerror		=  2,  /* ES002: (E) Encountered problem when using form file  */
    forms_s_nolayout		=  3,  /* ES003: (E) No layout fit terminal type, language and display size */
    forms_s_invdevice		=  4,  /* ES004: (E) Invalid device specified in ENABLE */
    forms_s_hangup		=  5,  /* ES005: (E) Data set hangup; session disabled */
    forms_s_norecord		=  7,  /* ES007: (E) Specified record identifier not in form */
    forms_s_badreclen		=  8,  /* ES008: (E) Record length argument not match length of record in form */
    forms_s_inuse		= 10,  /* ES010: (E) Attempted to disable a form still in use */
    forms_s_nosession		= 11,  /* ES011: (E) Session id in argument not match existing session */
    forms_s_return_immed	= 12,  /* ES012: (S) Request completed due to REQUEST IMMEDIATE */
    forms_s_nodecpt		= 14,  /* ES014: (E) Decimal or comma decimal point positioned incorrectly in record field */
    forms_s_bad_rshdwreclen	= 15,  /* ES015: (E) Receive shadow record length not match length specified in form */
    forms_s_bad_sshdwreclen	= 16,  /* ES016: (E) Send-shadow-record-length is something other than 1 */
    forms_s_cancelled		= 17,  /* ES017: (E) Request interrupted by arrival of CANCEL */
    forms_s_noactreq		= 19,  /* ES019: (E) No active requests to CANCEL */
    forms_s_invlobound		= 24,  /* ES024: (E) Subscript reference less than base */
    forms_s_invhibound		= 25,  /* ES025: (E) Subscript reference greater than array dimension defined */

/*                                                                                                 */
/* DECforms specific status values                                                                 */
/*                                                                                                 */
/* Note: EInnn are corresponding DECforms control texts. Any status relating to parameter checking */ 
/*       of DECforms request calls or license checking of DECforms will have not a corresponding   */
/*       control text.                                                                             */
/*                                                                                                 */
/*       Severity of each status is indicated by:                                                  */
/*                                                                                                 */
/*       (E) - Fatal error(s) occurred during request. Must be fixed before continuing.            */
/*       (W) - Warning error(s) occurred during request. Should fix before continuing.             */
/*       (I) - Informational event(s) occurred during request.                                     */
/*       (S) - Request processed successfully.                                                     */
/*                                                                                                 */
                                                                     
    forms_s_illdtcvt            =  -1,    /* EI001: (W) Illegal DATE, TIME, ADT conversion */
    forms_s_badreccnt		=  -2,    /* EI002: (E) number of records not match number specified in record list */
    forms_s_converr		=  -3,    /* EI003: (I) Error while converting from one data type to another */
    forms_s_aborted		=  -4,    /* EI004: (E) Session aborted due to severe error in another request */
    forms_s_badarg		=  -5,    /*      : (E) Bad argument or incorrect format */
    forms_s_baditmlstcode	=  -6,    /*      : (E) Invalid item code found in item list */
    forms_s_baditmlstcomb	=  -7,    /*      : (E) Invalid combination of item codes found in item list */
    forms_s_blocked_by_ast	=  -8,    /* EI008: (E) Cannot process request; block by application AST */
    forms_s_bad_devhlr		=  -9,    /* EI009: (E) Invalid device handler */
    forms_s_caninprog		= -10,    /* EI010: (E) A previous CANCEL is still in progress */
    forms_s_closetrace		= -11,    /* EI011: (W) Cannot close trace file */
    forms_s_deverr		= -12,    /* EI012: (E) Device I/O error  */
    forms_s_disinprog		= -13,    /* EI013: (E) A previous DISABLE is still in progress */
    forms_s_exprevalerr         = -14,    /* EI014: (E) Cannot convert operands into common data type */
    forms_s_fatinterr		= -15,    /* EI015: (E) Fatal Internal error */
    forms_s_illctltxtcnt	= -16,    /*      : (E) Illegal control text count argument */
    forms_s_illfldvaluectx      = -17,    /* EI017: (E) Illegal FIELDVALUE context */
    forms_s_illvpuse            = -18,    /* EI018: (E) Illegal use of print viewport */
    forms_s_intdatcor		= -19,    /* EI019: (E) Database consistency check failed */
    forms_s_invrange		= -20,    /* EI020: (E) Invalid subscript range */
    forms_s_invreccnt		= -21,    /* EI021: (E) Invalid record count value */
    forms_s_invrecdes		= -22,    /* EI022: (E) Invalid record message descriptor */
    forms_s_nohandler		= -23,    /* EI023: (E) No device handler for such device */
    forms_s_nolicense		= -24,    /*      : (E) No DECforms software license is active */
    forms_s_noparent		= -25,    /* EI025: (E) Specified parent request not exist */
    forms_s_no_read_access	= -26,    /*      : (E) No read access to user argument */
    forms_s_openout             = -27,    /* EI027: (E) The specified output file cannot be opened */
    forms_s_opentrace		= -28,    /* EI028: (W) Cannot open trace file for output */
    forms_s_paramovrflow	= -29,    /* EI029: (E) An escape routine parameter has overflowed */
    forms_s_procesc_not_found	= -30,    /* EI030: (E) Address of procedural escape not found */
    forms_s_proc_escape_error	= -31,    /* EI031: (E) Request terminated due to severe error in PEU */
    forms_s_recvrecitems	= -32,    /*      : (E) # of receive record items not match record count value */
    forms_s_reqdarg		= -33,    /*      : (E) Required argument missing */
    forms_s_sendrecitems	= -34,    /*      : (E) # of send record items not match record count value */
    forms_s_strtooshort		= -35,    /* EI035: (E) length of string is too small */
    forms_s_writetrace		= -36,    /* EI036: (W) Cannot write to trace file */
    forms_s_no_write_access	= -37,    /*      : (E) No write access to user argument */
    forms_s_bckgrndio           = -38,    /* EI038: (E) Attempted read or write I/O from background process */
    forms_s_timeract		= -39,    /* EI039: (E) Attempted timed field input while alarm active */
    forms_s_blkbyreq		= -40,    /* EI040: (E) Attempted synchronous request while another request active */
    forms_s_imgmismatch         = -41,    /*      : (E) Shareable image mismatch */
    forms_s_nyi                 = -42     /* EI042: (E) Requested operation is not yet implemented */

} Forms_Status_Values;

#if defined(__STDC__) || defined (vaxc)

Forms_Status forms_enable 
		(Forms_Session_Id      session_id, 
                 char                  *device_name,
                 char                  *form_file_name,
                 char                  *form_name,
                 Forms_Request_Options request_options[]);

Forms_Status forms_send 
		(Forms_Session_Id      session_id,
                 char                  *send_record_name,
                 Forms_Record_Data     send_record[],
                 Forms_Request_Options request_options[]);

Forms_Status forms_receive 
		(Forms_Session_Id      session_id,
                 char                  *receive_record_name,
                 Forms_Record_Data     receive_record[],
                 Forms_Request_Options request_options[]);

Forms_Status forms_transceive 
		(Forms_Session_Id      session_id,
                 char                  *send_record_name,
                 Forms_Record_Data     send_record[],
                 char                  *receive_record_name,
                 Forms_Record_Data     receive_record[],
                 Forms_Request_Options request_options[]);

Forms_Status forms_disable 
		(Forms_Session_Id      session_id,
                 Forms_Request_Options request_options[]);

Forms_Status forms_cancel 
		(Forms_Session_Id      session_id,
                 Forms_Request_Options request_options[]);

# else

Forms_Status forms_enable();
Forms_Status forms_send();
Forms_Status forms_receive();
Forms_Status forms_transceive();
Forms_Status forms_disable();
Forms_Status forms_cancel();

# endif

# endif
#ifndef __FSCNDEF_LOADED
#define __FSCNDEF_LOADED	1

/*** MODULE $fscndef ***/
/*++                                                                        */
/*                                                                          */
/*        Descriptor codes for SYS$FILESCAN                                 */
/*                                                                          */
/*                                                                          */
#define FSCN$M_NODE 1
#define FSCN$M_DEVICE 2
#define FSCN$M_ROOT 4
#define FSCN$M_DIRECTORY 8
#define FSCN$M_NAME 16
#define FSCN$M_TYPE 32
#define FSCN$M_VERSION 64
struct fldflags {
    unsigned fscn$v_node : 1;           /* Node name present                */
    unsigned fscn$v_device : 1;         /* Device name present              */
    unsigned fscn$v_root : 1;           /* Root directory present           */
    unsigned fscn$v_directory : 1;      /* Directory present                */
    unsigned fscn$v_name : 1;           /* File name present                */
    unsigned fscn$v_type : 1;           /* File type present                */
    unsigned fscn$v_version : 1;        /* File version present             */
    unsigned fscn$v_fill_23 : 1;
    } ;
#define FSCN$_FILESPEC 1                /* complete filespec                */
#define FSCN$_NODE 2                    /* node:: field                     */
#define FSCN$_DEVICE 3                  /* device: field                    */
#define FSCN$_ROOT 4                    /* [root.] field                    */
#define FSCN$_DIRECTORY 5               /* [directory] field                */
#define FSCN$_NAME 6                    /* name field                       */
#define FSCN$_TYPE 7                    /* .typ field                       */
#define FSCN$_VERSION 8                 /* ;version field                   */
#define FSCN$S_ITEM_LEN 8
struct fscndef {
    unsigned short int fscn$w_length;   /* return length word               */
    unsigned short int fscn$w_item_code; /* item code value                 */
    unsigned long int fscn$l_addr;      /* return length pointer            */
    } ;
 

#endif					/* __FSCNDEF_LOADED */
/********************************************************************************************************************************/
/* Created 31-JAN-1994 14:55:49 by VAX SDL V3.2-12     Source: 16-NOV-1993 11:28:47 PROJ:[FTSV.BUILD]FTSV$API_SYMBOLS.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $API_symbols IDENT V2.3 ***/
/*                                                                          */
/* FTSV Callable interface (API) constants                                  */
/*                                                                          */
/*+ constants used in FTSV$GETJBI callable routine                               */
#define FTSV$K_BLOCKS_COPIED 1
#define FTSV$K_BLOCKS_TOTAL 2
#define FTSV$K_COMMAND 3
#define FTSV$K_CURRENT 4
#define FTSV$K_FILES 5
#define FTSV$K_ELAPSED 6
#define FTSV$K_ESTTIME 7
#define FTSV$K_EXPIRES 8
#define FTSV$K_FREQUENCY 9
#define FTSV$K_INTERVAL 9
#define FTSV$K_LASTERROR 10
#define FTSV$K_MAXRETRIES 11
#define FTSV$K_RETRIES 12
#define FTSV$K_STARTTIME 13
#define FTSV$K_STATE 14
#define FTSV$K_TRANSFER 15
#define FTSV$K_USERNAME 16
#define FTSV$K_JOB_NAME 17
#define FTSV$K_JOB_UIC 18
/* possible values in buffer for item _transfer:                                 */
#define FTSV$K_BLOCK 1
#define FTSV$K_RECORD 2
/*-                                                                              */
/*+ possible values in buffer for item _state:                                 */
#define FTSV$K_QUEUED 0
#define FTSV$K_INITIALISING 1
#define FTSV$K_INIT_PAUSE 2
#define FTSV$K_COPY 3
#define FTSV$K_COPY_PAUSE 4
#define FTSV$K_COMPLETED 5
#define FTSV$K_LOST 6
#define FTSV$K_CANCELLING 7
#define FTSV$K_INIT_PRE 8
#define FTSV$K_COPY_PRE 9
#define FTSV$K_DECOMPRESSING 10
/* Used internally                                                          */
#define FTSV$K_STATUS_COUNT 11
/*-                                                                              */
/*+ Field constants used in FTSV$GETJID callable routine                                               */
#define ftsv$m_user 1
#define ftsv$m_all 2
struct getjid_flags {
    union  {
        unsigned short int ftsv$w_flags;
        struct  {
            unsigned ftsv$v_user : 1;
            unsigned ftsv$v_all : 1;
            unsigned ftsv$v_fill_0 : 6;
            } ftsv$r_choice;
        } ftsv$r_flags_word;
    } ;
/*-                                                                                                */
/*                                                                          */
/* Constants used for the FTSV Accounting file                              */
/*                                                                          */
/* The Record_Type is "J" for Job (ends at End_Brief), "F" for              */
/* File, or "S" for statistics record.                                      */
/*                                                                          */
#define FTSV$K_ACC_JOB "J"
#define FTSV$K_ACC_FILE "F"
#define FTSV$K_ACC_STATS "S"
/*                                                                          */
/* The Transfer_Mode is "R" for record mode, or "B" for                     */
/* block mode.                                                              */
/*                                                                          */
#define FTSV$K_ACCXFRMOD_RIO "R"
#define FTSV$K_ACCXFRMOD_BIO "B"
/*                                                                          */
/* FTSV Extended Accounting file field definitions                          */
/* for file compression statistics                                          */
/*                                                                          */
#define EACCO$K_End_Brief 77
#define EACCO$K_MAX_REC_SIZE 630
struct EACC$ {
    char EACCO$r_Job_ID [4];
    char EACCO$r_Username [12];
    char EACCO$r_Copy_Status [8];
    char EACCO$r_Copied [6];
    char EACCO$r_Retries [6];
    char EACCO$r_Time_Started [20];
    char EACCO$r_Time_Finished [20];
/* For EACC, Record_Type is "S"                                             */
/*                                                                          */
    char EACCO$r_Record_Type [1];
    char EACCO$r_Transfer_Mode [1];
    char EACCO$r_Input_File_Length [3];
    char EACCO$r_Output_File_Length [3];
    char EACCO$r_Input_File [255];
    char EACCO$r_Output_File [255];
/*                                                                          */
/* Compressed_Algo is the algorithm, or method, that was used to            */
/* compress the file. It can be "UNKNOWN", or any user-defined method.      */
/* If Compressed_Algo is "UNKNOWN", the file was either not compressed,     */
/* or compressed in an unknown format.                                      */
/*                                                                          */
    char EACCO$r_Compressed_Algo [20];
    char EACCO$r_Orig_File_Size [8];
    char EACCO$r_Comp_File_Size [8];
    } ;
/*                                                                          */
/* FTSV Accounting file field definitions                                   */
/*                                                                          */
#define ACCO$K_End_Brief 77
#define ACCO$K_End_Static 84
#define ACCO$K_Max_Rec_Size 630
struct ACC$ {
    char ACCO$r_Job_ID [4];
    char ACCO$r_Username [12];
    char ACCO$r_Copy_Status [8];
    char ACCO$r_Copied [6];
    char ACCO$r_Retries [6];
    char ACCO$r_Time_Started [20];
    char ACCO$r_Time_Finished [20];
/* For ACC, Record_Type is "J" or "F"                                       */
/*                                                                          */
    char ACCO$r_Record_Type [1];
    char ACCO$r_Transfer_Mode [1];
    char ACCO$r_Input_File_Length [3];
    char ACCO$r_Output_File_Length [3];
    char ACCO$r_Input_File [1];
    } ;
unsigned long int FTSV$FTSV() ;
unsigned long int FTSV$GETJBI() ;
unsigned long int FTSV$GETJID() ;
unsigned long int FTSV$GET_STATUS() ;
unsigned long int FTSV$SET_LOCK() ;
unsigned long int FTSV$INIT_READ_STATUS() ;
unsigned long int FTSV$READ_STATUS() ;
/*                                                                          */
/* The statistics structure                                                 */
/*                                                                          */
struct FTSVCOMP_STATS {
    unsigned long int toprocess;        /* Number of bytes to process       */
    unsigned long int total_incount;    /* Total number of input bytes processed */
    unsigned long int total_outcount;   /* Total number of output bytes processed */
    unsigned int elapsed [2];           /* Elapsed compression/decompression time */
    unsigned int cpu [2];               /* Cpu compression/decompression time */
    unsigned long int io_status;        /* IO status in case of io error    */
    unsigned long int io_stv;           /* RMS stv in case of io error      */
    unsigned long int cd_status;        /* compression decompression status in case of error */
    } ;
/********************************************************************************************************************************/
/* Created 31-JAN-1994 14:56:23 by VAX SDL V3.2-12     Source: 31-JAN-1994 14:56:20 PROJ:[FTSV.BUILD]FTSVMESS.SDL;5 */
/********************************************************************************************************************************/
 
/*** MODULE $FTSVDEF ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on 31-JAN-1994 14:56:20.46 */
/*                                                                          */
#define FTSV$_FACILITY 1025             /* HEX 401                          */
#define FTSV$_BROADERR 67207168
#define FTSV$_CLOSEDOWN 67207176
#define FTSV$_DUMMY_1 67207184          /* ERRCANCEL CHANGED TO ERROR SEVERITY */
#define FTSV$_ERRDURCOP 67207192
#define FTSV$_FDLNOTUSED 67207200
#define FTSV$_IGNOREF 67207208
#define FTSV$_IGNORER 67207216
#define FTSV$_IGNORET 67207224
#define FTSV$_MAILERR 67207232
#define FTSV$_MBXERR 67207240
#define FTSV$_NOQUEUE 67207248
#define FTSV$_NOTIFYERR 67207256
#define FTSV$_ERRCANCEL 67207264
#define FTSV$_NOHISREC 67207272
#define FTSV$_QUEINUSE 67207280
#define FTSV$_ERRTRNRDT 67207288
#define FTSV$_ERRCONQUE 67207296
#define FTSV$_NOBATJOB 67207304
#define FTSV$_VERBAD 67207312
#define FTSV$_INVINPREC 67207320
#define FTSV$_INVINPINP 67207328
#define FTSV$_INVINPOUT 67207336
#define FTSV$_INVTRANS 67207344
#define FTSV$_LOGICACCDENIED 67207352
#define FTSV$_PARTCOP 67207360
#define FTSV$_REQUEUENO 67207368
#define FTSV$_MARKCAN 67207376
#define FTSV$_SHOWKEY10 67207384
#define FTSV$_SHOWKEY20 67207392
#define FTSV$_SHOWKEY30 67207400
#define FTSV$_SHOWKEY40 67207408
#define FTSV$_SHOWKEY50 67207416
#define FTSV$_SHOWKEY60 67207424
#define FTSV$_SHOWKEY70 67207432
#define FTSV$_NOCOMSYM 67207440
#define FTSV$_ELMOVF 67207448
#define FTSV$_QF_TMO 67207456
#define FTSV$_NOTCMP 67207464
#define FTSV$_DCMPERR 67207472
#define FTSV$_DCMPFILERR 67207480
#define FTSV$_DCMPABORT 67207488
#define FTSV$_DCMPFAIL 67207496
#define FTSV$_COMPERR 67207504
#define FTSV$_COMPABORT 67207512
#define FTSV$_COMPFILERR 67207520
#define FTSV$_ALREADYCOMP 67207528
#define FTSV$_POORCMPR 67207536
#define FTSV$_BADCMPR 67207544
#define FTSV$_COMPFAIL 67207552
#define FTSV$_NODELCMP 67207560
#define FTSV$_ERRDELCMP 67207568
#define FTSV$_ERRDELUNCMP 67207576
#define FTSV$_ERRPARSORIG 67207584
#define FTSV$_NOAACCESS 67207592
#define FTSV$_ERRWRTACC 67207600
#define FTSV$_CMPMETHNF 67207608
#define FTSV$_NOCMPMETH 67207616
#define FTSV$_ERRGETCMP 67207624
#define FTSV$_ERRGETCMPTST 67207632
#define FTSV$_ERRGETDCMP 67207640
#define FTSV$_ERRGETSTATS 67207648
#define FTSV$_FATALCMP 67207656
#define FTSV$_FATALCMPTST 67207664
#define FTSV$_FATALDCMP 67207672
#define FTSV$_FATALSTATS 67207680
#define FTSV$_INVOFFHOURS 67207688
#define FTSV$_ETCSCR0 67207696
#define FTSV$_ETCSCR1 67207704
#define FTSV$_ETCSCR2 67207712
#define FTSV$_ETCET 67207720
#define FTSV$_ETCTCT 67207728
#define FTSV$_ETCETC1 67207736
#define FTSV$_ETCETC2 67207744
#define FTSV$_ETCETC3 67207752
/*                                                                          */
/*                                                                          */
/* COMPRESSION SUPPORT                                                      */
/*    SECOND STATUS ABORT CURRENT FILE RETURN VALUES                        */
/*	- CURRENT FILE COULD NOT BE PROCESSED,                              */
/*	  ACTION: CONTINUE WITH NEXT INPUT FILE.                            */
/*       - FIRST STATUS MUST BE SS$_ABORT                                   */
/*       - SECOND STATUS ONE OF THE FOLLOWING                               */
/*                                                                          */
#define FTSV$_COMP_INPUTERR 67207760
#define FTSV$_COMP_OUTPUTERR 67207768
#define FTSV$_COMP_UNSUP 67207776
#define FTSV$_COMP_COMPERR 67207784
#define FTSV$_COMP_INVHEAD 67207792
#define FTSV$_COMP_DECOMPERR 67207800
#define FTSV$_COMP_NOTCOMP 67207808
#define FTSV$_JOBVER 67209217
#define FTSV$_VEROK 67209225
#define FTSV$_QFOPENED 67209233
#define FTSV$_DCMPOK 67209241
#define FTSV$_COMPOK 67209249
/*                                                                          */
/* COMPRESSION SUPPORT                                                      */
/*	SECOND STATUS SUCCESS RETURN VALUES                                 */
/*                                                                          */
#define FTSV$_COMP_SUCCESS 67209257
#define FTSV$_BADFREQ 67211266
#define FTSV$_BADINPUT 67211274
#define FTSV$_BADJOBID 67211282
#define FTSV$_BADLOG 67211290
#define FTSV$_BADOUTPUT 67211298
#define FTSV$_BADRETRY 67211306
#define FTSV$_BADTIME 67211314
#define FTSV$_ERRPOSIN 67211322
#define FTSV$_ERRPOSOUT 67211330
#define FTSV$_ILLFMCOM 67211338
#define FTSV$_INVINPCON 67211346
#define FTSV$_NOCANCEL 67211354
#define FTSV$_NOOPER 67211362
#define FTSV$_NOSUCHJOB 67211370
#define FTSV$_JOBNOTFND 67211378
#define FTSV$_QUETOLONG 67211386
#define FTSV$_NOREQUEUE 67211394
#define FTSV$_DUMMY1 67211402
#define FTSV$_REQACTIVE 67211410
#define FTSV$_ERELEASE 67211418
#define FTSV$_NORELEASE 67211426
#define FTSV$_ERRFR 67211434
#define FTSV$_ECMDTOLNG 67211442
#define FTSV$_NAMTOLONG 67211450
#define FTSV$_NONOMAX 67211458
#define FTSV$_NOCONV 67211466
#define FTSV$_NOSYSPRV 67211474
#define FTSV$_BADPRIO 67211482
#define FTSV$_ERRACCIF 67211490
#define FTSV$_ERRPARSIF 67211498
#define FTSV$_INPLISNUL 67211506
#define FTSV$_USRNTOLNG 67211514
#define FTSV$_ERRCREUSR 67211522
#define FTSV$_ERRPARACC 67211530
#define FTSV$_QUEUEFULL 67211538
#define FTSV$_MAXDEFINC 67211546
#define FTSV$_NOPARENT 67211554
#define FTSV$_ERRATTACH 67211562
#define FTSV$_ERRSPAWN 67211570
#define FTSV$_NORECEIVR 67211578
#define FTSV$_LCKERRNOT 67211586
#define FTSV$_INVRESNAM 67211594
#define FTSV$_PARSEFAIL 67211602
#define FTSV$_OPENIN 67211610
#define FTSV$_ERROUTCOMP 67211618
#define FTSV$_ERROUTDCMP 67211626
#define FTSV$_ERRGETOUT 67211634
#define FTSV$_ERRGETIN 67211642
#define FTSV$_UERRESHODEF 67211650
#define FTSV$_UERRESHOMAX 67211658      /*                                  */
/* COMPRESSION SUPPORT                                                      */
/*    SECOND STATUS ABORT PROCESSING RETURN VALUES                          */
/*	- CONTINUED PROCESSING NOT POSSIBLE,                                */
/*	  ACTION: CLOSE FILES AND EXIT.                                     */
/*       - FIRST STATUS MUST BE SS$_ABORT                                   */
/*       - SECOND STATUS ONE OF THE FOLLOWING                               */
/*                                                                          */
#define FTSV$_COMP_ALLOC 67211666
#define FTSV$_COMP_INVPARAM 67211674
#define FTSV$_COMP_INVSTAT 67211682
#define FTSV$_FDLNOTFND 67213315
#define FTSV$_NORMAL 67213323
#define FTSV$_NOJOBS 67213331
#define FTSV$_BADINS 67213339
#define FTSV$_CANCELING 67213347
#define FTSV$_CONCATTO 67213355
#define FTSV$_OLDDELETE 67213363
#define FTSV$_QUEUEMADE 67213371
#define FTSV$_QUEFILCVT 67213379
#define FTSV$_SYMBOLERR 67213387
#define FTSV$_REQUEUED 67213395
#define FTSV$_RECOVER 67213403
#define FTSV$_RELEASED 67213411
#define FTSV$_JOBID 67213419
#define FTSV$_PREFUNC 67213427
#define FTSV$_POSTFUNC 67213435
#define FTSV$_PAUSEFUNC 67213443
#define FTSV$_CREHIS 67213451
#define FTSV$_RECOPY 67213459
#define FTSV$_SKIP_LIST 67213467
#define FTSV$_TRYOPENQF 67213475
#define FTSV$_PROCJOB 67213483
#define FTSV$_STACOMP 67213491
#define FTSV$_STADCMP 67213499
#define FTSV$_DELCMP 67213507
#define FTSV$_DELUNCMP 67213515
#define FTSV$_BADPARAM 67215364
#define FTSV$_EXCMAXRET 67215372
#define FTSV$_EXCMAXTIM 67215380
#define FTSV$_FATALEXIT 67215388
#define FTSV$_FTEXP 67215396
#define FTSV$_INSUFARGS 67215404
#define FTSV$_INSUFPRIV 67215412
#define FTSV$_INVPARAM 67215420
#define FTSV$_INVITMCOD 67215428
#define FTSV$_INVITMLST 67215436
#define FTSV$_JOBABORT 67215444
#define FTSV$_NOHEADER 67215452
#define FTSV$_NOMAKEQUE 67215460
#define FTSV$_NOPRIV 67215468
#define FTSV$_NOQACCESS 67215476
#define FTSV$_NORACCESS 67215484
#define FTSV$_NORACC1 67215492
#define FTSV$_NORACC2 67215500
#define FTSV$_NORACC3 67215508
#define FTSV$_OLDQUEUE 67215516
#define FTSV$_ERRVERLIM 67215524
#define FTSV$_NOLOADRQE 67215532
#define FTSV$_NOLOADSTV 67215540
#define FTSV$_NOLACCESS 67215548
#define FTSV$_QF_MISMATCH 67215556
#define FTSV$_JOBTOOOLD 67215564
#define FTSV$_NORACCLOC 67215572
#define FTSV$_CMDTOOLNG 67215580
#define FTSV$_FAILPARSORIG 67215588
#define FTSV$_UERRFJOB0 67215596
#define FTSV$_UERRFENQ 67215604
#define FTSV$_UERRFMAXT 67215612
#define FTSV$_UERRFDEFT 67215620
#define FTSV$_UERRFPWD 67215628
#define FTSV$_UERRFLNM 67215636
#define FTSV$_UERRFINVP1 67215644
#define FTSV$_UERRFINVP2 67215652
#define FTSV$_UERRFLNM2 67215660
#define FTSV$_UERRFQUI 67215668
#define FTSV$_UERRFTIM 67215676
#define FTSV$_UERRFREQSCR0 67215684
#define FTSV$_UERRFREQSCR1 67215692
#define FTSV$_UERRFREQSCR2 67215700
#define FTSV$_UERRFREQSRC 67215708
#define FTSV$_UERRFQFH 67215716
#define FTSV$_UERRFJH 67215724
#define FTSV$_UERRFJL 67215732
#define FTSV$_UERRFJF 67215740
#define FTSV$_UERRFCNVEX 67215748
#define FTSV$_UERRFCNVCW 67215756
#define FTSV$_UERRFVM 67215764
#define FTSV$_UERRFINP 67215772
#define FTSV$_UERRFNINP 67215780
#define FTSV$_UERRFOUTP 67215788
#define FTSV$_UERRFTIMSUB 67215796
#define FTSV$_UERRFEXH 67215804
#define FTSV$_UERRFGQUI1 67215812
#define FTSV$_UERRFGQUI2 67215820
#define FTSV$_UERRFQFCW1 67215828
#define FTSV$_UERRFTIMSUB2 67215836
#define FTSV$_UERRFTIMSUB3 67215844
#define FTSV$_UERRFTIMRES 67215852
#define FTSV$_UERRFQFEX 67215860
#define FTSV$_UERRFQFCW2 67215868
#define FTSV$_UERRFFRE 67215876
#define FTSV$_UERRFINVSET 67215884
#define FTSV$_UERRFSETFAIL 67215892
#define FTSV$_UERRFSETDEF 67215900
#define FTSV$_UERRFSETMAX 67215908
#define FTSV$_UERRFINVSHO 67215916
#define FTSV$_UERRFSHOFAIL 67215924
#ifndef __GPSDEF_LOADED
#define __GPSDEF_LOADED	1

/*** MODULE $gpsdef ***/
/*                                                                          */
/* GSD entry - P-section definition                                         */
/*                                                                          */
#define GPS$M_PIC 1
#define GPS$M_LIB 2
#define GPS$M_OVR 4
#define GPS$M_REL 8
#define GPS$M_GBL 16
#define GPS$M_SHR 32
#define GPS$M_EXE 64
#define GPS$M_RD 128
#define GPS$M_WRT 256
#define GPS$M_VEC 512
#define GPS$K_NAME 9
#define GPS$C_NAME 9
#pragma nostandard
struct gpsdef {
    variant_union  {
        unsigned char gps$b_gsdtyp;     /*Typ field                         */
        variant_struct  {
            char gps$t_start [];
            char gpsdef$$_fill_1;
            } gps$r_gsdtyp_fields;
        } gps$r_gsdtyp_overlay;
    unsigned char gps$b_align;          /*P-sect alignment                  */
    variant_union  {
        unsigned short int gps$w_flags; /*P-sect flags                      */
        variant_struct  {
            unsigned gps$v_pic : 1;     /*Position independent              */
            unsigned gps$v_lib : 1;     /*From a shareable image            */
            unsigned gps$v_ovr : 1;     /*Overlaid memory allocation        */
            unsigned gps$v_rel : 1;     /*Relocatable                       */
            unsigned gps$v_gbl : 1;     /*Global scope                      */
            unsigned gps$v_shr : 1;     /*Shareable                         */
            unsigned gps$v_exe : 1;     /*Executable                        */
            unsigned gps$v_rd : 1;      /*Readable                          */
            unsigned gps$v_wrt : 1;     /*Writeable                         */
            unsigned gps$v_vec : 1;     /*Vector psect                      */
            unsigned gps$v_fill_15 : 6;
            } gps$r_flags_bits;
        } gps$r_flags_overlay;
    unsigned long int gps$l_alloc;      /*Length of this contribution       */
    unsigned char gps$b_namlng;         /*Length of p-sect name             */
    char gps$t_name [31];               /*Name field                        */
    } ;
#pragma standard

#endif					/* __GPSDEF_LOADED */
#ifndef __GSDEF_LOADED
#define __GSDEF_LOADED	1

/*** MODULE $gsdef ***/
/*                                                                          */
/* Global symbol definition record (GSD)                                    */
/*                                                                          */
#define GSD$K_ENTRIES 1                 /*Offset to first entry in record   */
#define GSD$C_ENTRIES 1                 /*Offset to first entry in record   */
#define GSD$C_PSC 0                     /*Psect definition                  */
#define GSD$C_SYM 1                     /*Symbol specification              */
#define GSD$C_EPM 2                     /*Entry point and mask definition   */
#define GSD$C_PRO 3                     /*Procedure with formal arguments   */
#define GSD$C_SYMW 4                    /*Symbol specification with word psect  */
#define GSD$C_EPMW 5                    /*Entry point mask with word psect  */
#define GSD$C_PROW 6                    /*Procedure with word psect         */
#define GSD$C_IDC 7                     /*Random entity check               */
#define GSD$C_ENV 8                     /*Define environment                */
#define GSD$C_LSY 9                     /*Local symbol                      */
#define GSD$C_LEPM 10                   /*Local symbol entry point definition  */
#define GSD$C_LPRO 11                   /*Local symbol procedure definition  */
#define GSD$C_SPSC 12                   /*Shareable image psect definition  */
/*                                                                          */
#define GSD$C_VECTOR_TYPE_INCREMENT 12
#define GSD$C_SYMV 13                   /*Vectored (dual-valued) versions of SYM, */
#define GSD$C_EPMV 14                   /*	EPM,                        */
#define GSD$C_PROV 15                   /*	PRO                         */
/*                                                                          */
#define GSD$C_MASK_TYPE_INCREMENT 15
#define GSD$C_SYMM 16                   /*Masked versions of SYM,           */
#define GSD$C_EPMM 17                   /*      EPM,                        */
#define GSD$C_PROM 18                   /*      PRO                         */
#define GSD$C_MAXRECTYP 18              /*Maximum entry type defined        */
struct gsdef {
    unsigned char gsd$b_rectyp;         /*Record type (OBJ$C_GSD)           */
    unsigned char gsd$b_gsdtyp;         /*Type of entry (first byte of entry)  */
/* Vectored symbol types are (regular + 12).  For example, SYMV = SYM + 12. */
/*                                                                          */
/* Mask symbol types are (regular + 15).  For example, SYMM = SYM + 15.     */
/*                                                                          */
    } ;
 

#endif					/* __GSDEF_LOADED */
#ifndef __GSYDEF_LOADED
#define __GSYDEF_LOADED	1

/*** MODULE $gsydef ***/
/*                                                                          */
/* GSD entry - Symbol definition                                            */
/*                                                                          */
/* common to definitions, references, and entry                             */
/* point definitions.                                                       */
/*                                                                          */
#define GSY$M_WEAK 1
#define GSY$M_DEF 2
#define GSY$M_UNI 4
#define GSY$M_REL 8
#define GSY$M_COMM 16
#pragma nostandard
struct gsydef {
    variant_union  {
        unsigned char gsy$b_gsdtyp;     /*Type field                        */
        variant_struct  {
            char gsy$t_start [];
            char gsydef$$_fill_1;
            } gsy$r_gsdtyp_fields;
        } gsy$r_gsdtyp_overlay;
    unsigned char gsy$b_datyp;          /*Symbol data type                  */
    variant_union  {
        unsigned short int gsy$w_flags; /*Symbol flags                      */
        variant_struct  {
            unsigned gsy$v_weak : 1;    /*Weak symbol                       */
            unsigned gsy$v_def : 1;     /*Definition                        */
            unsigned gsy$v_uni : 1;     /*Universal                         */
            unsigned gsy$v_rel : 1;     /*Relocatable                       */
            unsigned gsy$v_comm : 1;    /*C common globaldef                */
            unsigned gsy$v_fill_17 : 3;
            } gsy$r_flags_bits;
        } gsy$r_flags_overlay;
    } ;
#pragma standard

#endif					/* __GSYDEF_LOADED */
#ifndef __HLPDEF_LOADED
#define __HLPDEF_LOADED	1

/*** MODULE $hlpdef ***/
/*                                                                          */
/* Data structures for help processing                                      */
/*                                                                          */
#define HLP$M_PROMPT 1
#define HLP$M_PROCESS 2
#define HLP$M_GROUP 4
#define HLP$M_SYSTEM 8
#define HLP$M_LIBLIST 16
#define HLP$M_HELP 32
#define HLP$M_SPARE1 64
#define HLP$M_SPARE2 128
#define HLP$M_PAGE 256
#define HLP$M_OUTPUT 512
#define HLP$M_LIBRARY 1024
#define HLP$M_ALL 2048
#define HLP$M_PAGEDEF 4096
#define HLP$M_PMPTDEF 8192
#define HLP$M_NOTTERM 16384
#pragma nostandard
union hlpdef {
    variant_struct  {
        unsigned hlp$v_prompt : 1;      /* Prompting enabled                */
        unsigned hlp$v_process : 1;     /* Process logical name table searches enabled  */
        unsigned hlp$v_group : 1;       /* Group logical name table searches enabled  */
        unsigned hlp$v_system : 1;      /* System logical name table searched enabled  */
        unsigned hlp$v_liblist : 1;     /* Output list of default libraries  */
        unsigned hlp$v_help : 1;        /* Display help on help before list of topics  */
        unsigned hlp$v_spare1 : 1;
        unsigned hlp$v_spare2 : 1;
        unsigned hlp$v_page : 1;        /* Page breaks enabled              */
        unsigned hlp$v_output : 1;      /* Output listing file enabled      */
        unsigned hlp$v_library : 1;     /* Main library specified by user   */
        unsigned hlp$v_all : 1;         /* Some logical name table searches enabled  */
        unsigned hlp$v_pagedef : 1;     /* Page flag defaulting disabled    */
        unsigned hlp$v_pmptdef : 1;     /* Prompt flag defaulting disabled  */
        unsigned hlp$v_notterm : 1;     /* Input device is not a terminal   */
        unsigned hlp$v_fill_2 : 1;
        } hlp$r_hlpdef_bits;
    } ;
#define HLP$M_NOHLPTXT 1
#define HLP$M_KEYNAMLIN 2
#define HLP$M_OTHERINFO 4
struct hlpdef1 {
    unsigned long int hlp$l_desc;       /* Address of string descriptor for line  */
    variant_union  {
        unsigned long int hlp$l_flags;  /* Flags                            */
        variant_struct  {
            unsigned hlp$v_nohlptxt : 1; /* Line is part of text due to no help found  */
            unsigned hlp$v_keynamlin : 1; /* Line contains keynames to be printed  */
            unsigned hlp$v_otherinfo : 1; /* Line is part of "other info available"  */
            unsigned hlp$v_fill_3 : 5;
            } hlp$r_flags_bits;
        } hlp$r_flags_overlay;
    unsigned long int hlp$l_data;       /* Address of user data passed to GET_HELP  */
    unsigned long int hlp$l_level;      /* Level of this help               */
    } ;
#pragma standard

#endif					/* __HLPDEF_LOADED */
#ifndef __IACDEF_LOADED
#define __IACDEF_LOADED	1

/*** MODULE $iacdef ***/
/*+                                                                         */
/* IMAGE ACTIVATION CONTROL FLAGS                                           */
/*-                                                                         */
#define IAC$M_NOACT 1
#define IAC$M_WRITABLE 2
#define IAC$M_SHAREABLE 4
#define IAC$M_PRIVILEGE 8
#define IAC$M_MERGE 16
#define IAC$M_EXPREG 32
#define IAC$M_P1MERGE 64
#define IAC$M_LASTCLU 256
#define IAC$M_LIM 512
#define IAC$M_RETRY 1024
#define IAC$M_NOCMKRNL 2048
#define IAC$M_SEQDEVLOD 4096
#define IAC$M_XLINKER 8192
#define IAC$M_KP_RESHDR 16384
#define IAC$M_IS_RESHDR 32768
#define IAC$M_NOTSHARED 65536
#define IAC$M_GBLCLUSTR 131072
#define IAC$M_SHMIDENT 262144
#define IAC$M_NOCOPY 524288
#define IAC$M_P1MERG_P0 1048576
#define IAC$M_SETVECTOR 2097152
#define IAC$C_LARGEST 6                 /*LARGEST FLAG CALLER MAY SPECIFY   */
union iacdef {
#pragma nostandard
    variant_struct  {
        unsigned iac$v_noact : 1;       /*DO NOT ACTIVATE THE IMAGE (FOR INSTALL)  */
        unsigned iac$v_writable : 1;    /*MAKE IMAGE FILE WRITABLE          */
        unsigned iac$v_shareable : 1;   /*ACT. SHAREABLE IMAGE FOR EXECUTABLE IMG  */
        unsigned iac$v_privilege : 1;   /*ACT. SHARE. IMG FOR PRIV EXECUTABLE IMG  */
        unsigned iac$v_merge : 1;       /*ACT 2ND EXECUTABLE IMG INTO ADR SPACE  */
        unsigned iac$v_expreg : 1;      /*MAP IMAGE INTO NEXT FREE VA SPACE  */
        unsigned iac$v_p1merge : 1;     /*P1 MERGED ACTIVATION (LEGAL INPUT FLAG)  */
        unsigned iacdef$$_fill_1 : 1;   /*SPARE                             */
        unsigned iac$v_lastclu : 1;     /*LAST CLUSTER FLAG                 */
        unsigned iac$v_lim : 1;         /*LINKABLE IMAGE                    */
        unsigned iac$v_retry : 1;       /*RETRY IMAGE ACTIVATION            */
        unsigned iac$v_nocmkrnl : 1;    /*SHUT OFF CMKRNL,CMEXEC-SYSVER DIFF  */
        unsigned iac$v_seqdevlod : 1;   /*LOADING FROM SEQUENTIAL DEVICE (NET)  */
        unsigned iac$v_xlinker : 1;     /*CROSS LINKER FORMAT               */
        unsigned iac$v_kp_reshdr : 1;   /*MAKE IMAGE HEADER RESIDENT        */
        unsigned iac$v_is_reshdr : 1;   /*IMAGE HEADER IS RESIDENT          */
        unsigned iac$v_notshared : 1;   /*DO NOT SET IS_SHARED IN KFI ENTRY  */
        unsigned iac$v_gblclustr : 1;   /*CURRENTLY PROCESSING GBL ISD CLUSTER  */
        unsigned iac$v_shmident : 1;    /*SHARED MEMORY IDENT USED FOR GBL SEC  */
        unsigned iac$v_nocopy : 1;      /*NO PRIVATE COPY OF SECTION IN EXEC IMG  */
        unsigned iac$v_p1merg_p0 : 1;   /*P1 MERGED ACTIVATION WITH P0 ADDRESS  */
/* RANGE (INTERNAL FLAG ONLY)                                               */
        unsigned iac$v_setvector : 1;   /*SIGNAL ATLERNATE ENTRY TO SET VECTORS  */
        unsigned iac$v_fill_5 : 2;
        } iac$r_iacdef_bits;
    } ;
 
#pragma standard

#endif					/* __IACDEF_LOADED */
#ifndef __IDCDEF_LOADED
#define __IDCDEF_LOADED	1

/*** MODULE $idcdef ***/
/*                                                                          */
/* IDC - Random entity ident consistency check                              */
/*                                                                          */
#define IDC$C_LEQ 0
#define IDC$C_EQUAL 1
struct idcdef {
    unsigned char idc$b_gsdtyp;         /*Type field                        */
#pragma nostandard
    variant_union  {
        unsigned short int idc$w_flags; /*Flags                             */
        variant_struct  {
            unsigned idc$v_binident : 1; /*Ident is binary longword rather than ASCIC  */
            unsigned idc$v_idmatch : 2; /*Field for ident match control if binary ident  */
            unsigned idc$v_errsev : 3;  /*Error severity (default is warning-0)  */
            unsigned idc$v_fill_19 : 2;
            } idc$r_flags_bits;
/*Match control values                                                      */
        } idc$r_flags_overlay;
    variant_union  {
        unsigned char idc$b_namlng;     /*Length of entity name             */
        variant_struct  {
            char idcdef$$_fill_1;
            char idc$t_name [];         /*                                  */
/* Followed by entity name                                                  */
/* Followed by                                                              */
/*        byte of ident length                                              */
/*                ident string (length = string length)                     */
/*                        or                                                */
/*                ident binary value (length = 4)                           */
/* Followed by byte of length of name of object                             */
/* Followed by the object name                                              */
            } idc$r_namlng_fields;
        } idc$r_namlng_overlay;
    } ;
 
#pragma standard

#endif					/* __IDCDEF_LOADED */
#ifndef __IN_LOADED
#define __IN_LOADED	1

/*
 * Copyright (c) 1982 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	in.h	6.5 (Berkeley) 6/8/85
 */

#ifndef __SOCKET_TYPEDEFS
typedef char * caddr_t;

typedef unsigned short u_short;

typedef unsigned long u_long;

typedef unsigned char u_char;

#define __SOCKET_TYPEDEFS
#endif

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981.
 */

/*
 * Protocols
 */
#define	IPPROTO_IP		0		/* dummy for IP */
#define	IPPROTO_ICMP		1		/* control message protocol */
#define	IPPROTO_GGP		2		/* gateway^2 (deprecated) */
#define	IPPROTO_TCP		6		/* tcp */
#define	IPPROTO_EGP		8		/* exterior gateway protocol */
#define	IPPROTO_PUP		12		/* pup */
#define	IPPROTO_UDP		17		/* user datagram protocol */

#define	IPPROTO_RAW		255		/* raw IP packet */
#define	IPPROTO_MAX		256


/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define	IPPORT_RESERVED		1024
#define IPPORT_USERRESERVED	5000

/*
 * Link numbers
 */
#define	IMPLINK_IP		155
#define	IMPLINK_LOWEXPER	156
#define	IMPLINK_HIGHEXPER	158

/*
 * Internet address (a structure for historical reasons)
 */
struct in_addr {
	union {
		struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { u_short s_w1,s_w2; } S_un_w;
		u_long S_addr;
	} S_un;
#define	s_addr	S_un.S_addr	/* can be used for most tcp & ip code */
#define	s_host	S_un.S_un_b.s_b2	/* host on imp */
#define	s_net	S_un.S_un_b.s_b1	/* network */
#define	s_imp	S_un.S_un_w.s_w2	/* imp */
#define	s_impno	S_un.S_un_b.s_b4	/* imp # */
#define	s_lh	S_un.S_un_b.s_b3	/* logical host */
};

/*
 * Definitions of bits in internet address integers.
 */
#define	IN_CLASSA(i)		((((long)(i))&0x80000000)==0)
#define	IN_CLASSA_NET		0xff000000
#define	IN_CLASSA_NSHIFT	24
#define	IN_CLASSA_HOST		0x00ffffff
#define	IN_CLASSA_MAX		128

#define	IN_CLASSB(i)		((((long)(i))&0xc0000000)==0x80000000)
#define	IN_CLASSB_NET		0xffff0000
#define	IN_CLASSB_NSHIFT	16
#define	IN_CLASSB_HOST		0x0000ffff
#define	IN_CLASSB_MAX		65536

#define	IN_CLASSC(i)		((((long)(i))&0xc0000000)==0xc0000000)
#define	IN_CLASSC_NET		0xffffff00
#define	IN_CLASSC_NSHIFT	8
#define	IN_CLASSC_HOST		0x000000ff

#define IN_CLASSD(i)            (((long)(i) & 0xf0000000) == 0xe0000000)
#define IN_MULTICAST(i)         IN_CLASSD(i)

#define IN_EXPERIMENTAL(i)      (((long)(i) & 0xe0000000) == 0xe0000000)
#define IN_BADCLASS(i)          (((long)(i) & 0xf0000000) == 0xf0000000)

#define	INADDR_ANY		0x00000000
#define	INADDR_BROADCAST	0xffffffff
#ifndef KERNEL
#define INADDR_NONE             0xffffffff              /* -1 return */
#endif

#define IN_LOOPBACKNET          127                     /* official! */


/*
 * Macros for subnetworks.  A subnet is distinguished by
 * 	(1) the network number is a `local' network number, and
 *	(2) the most significant bit of the host part is set.
 * Such addresses include one additional byte in the network number,
 * and use one less byte in the host part (i.e., a subnet of a Class A
 * network uses the rules for Class B net/host number extraction,
 * a Class B subnet is dealt with as if it were a Class C net).
 * Subnets of Class C nets are not supported.
 */
#define	SUBNETSHIFT		8  /* used to get main net number from subnet */

#define	IN_SUBNETA(i)		((((long)(i))&0x80800000)==0x00800000)
#define	IN_CLASSA_SUBNET	0xffff0000
#define	IN_CLASSA_SUBNSHIFT	(IN_CLASSA_NSHIFT - SUBNETSHIFT)
#define	IN_CLASSA_SUBHOST	0x0000ffff

#define	IN_SUBNETB(i)		((((long)(i))&0xc0008000)==0x80008000)
#define	IN_CLASSB_SUBNET	0xffffff00
#define	IN_CLASSB_SUBNSHIFT	(IN_CLASSB_NSHIFT - SUBNETSHIFT)
#define	IN_CLASSA_SUBHOST	0x0000ffff
#define	IN_CLASSB_SUBHOST	0x000000ff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
	short	sin_family;
	u_short	sin_port;
	struct	in_addr sin_addr;
	char	sin_zero[8];
};

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS      1               /* set/get IP per-packet options */

#if !defined(vax)
/*
 * Macros for number representation conversion.
 */
#define	ntohl(x)	(x)
#define	ntohs(x)	(x)
#define	htonl(x)	(x)
#define	htons(x)	(x)
#endif

#endif					/* __IN_LOADED */
#ifndef __INET_LOADED
#define __INET_LOADED	1

#include in

/* Some of these functions are not properly prototyped because
   the interface is poorly defined, and many programs use int's
   and struct in_addr's interchangeably. */
int inet_addr(char *cp);
int inet_network(char *cp);
/* char *inet_ntoa(struct in_addr in); */
char *inet_ntoa();
struct in_addr inet_makeaddr(int net, int lna);
/* int inet_lnaof(struct in_addr in); */
int inet_lnaof();
/* int inet_netof(struct in_addr in); */
int inet_netof();

#endif					/* __INET_LOADED */
#ifndef __IODEF_LOADED
#define __IODEF_LOADED	1

/*** MODULE $iodef ***/
/*+                                                                         */
/* I/O FUNCTION CODE DEFINITIONS                                            */
/*-                                                                         */
/*                                                                          */
/* *** START PHYSICAL I/O FUNCTION CODES ***                                */
/*                                                                          */
#define IO$_NOP 0                       /*NO OPERATION                      */
#define IO$_UNLOAD 1                    /*UNLOAD DRIVE                      */
#define IO$_LOADMCODE 1                 /*LOAD MICROCODE                    */
#define IO$_SEEK 2                      /*SEEK CYLINDER                     */
#define IO$_SPACEFILE 2                 /*SPACE FILES                       */
#define IO$_STARTMPROC 2                /*START MICROPROCESSOR              */
#define IO$_RECAL 3                     /*RECALIBRATE DRIVE                 */
#define IO$_STOP 3                      /*STOP                              */
#define IO$_DRVCLR 4                    /*DRIVE CLEAR                       */
#define IO$_INITIALIZE 4                /*INITIALIZE                        */
#define IO$_RELEASE 5                   /*RELEASE PORT                      */
#define IO$_SETCLOCKP 5                 /*SET CLOCK (PHYSICAL)              */
#define IO$_OFFSET 6                    /*OFFSET READ HEADS                 */
#define IO$_ERASETAPE 6                 /*ERASE TAPE                        */
#define IO$_STARTDATAP 6                /*START DATA TRANSFER (PHYSICAL)    */
#define IO$_RETCENTER 7                 /*RETURN TO CENTERLINE              */
#define IO$_QSTOP 7                     /*QUEUE STOP REQUEST                */
#define IO$_PACKACK 8                   /*PACK ACKNOWLEDGE                  */
#define IO$_SEARCH 9                    /*SEARCH FOR SECTOR                 */
#define IO$_SPACERECORD 9               /*SPACE RECORDS                     */
#define IO$_READRCT 9                   /*READ REPLACEMENT & CACHING TABLE  */
#define IO$_WRITECHECK 10               /*WRITE CHECK DATA                  */
#define IO$_WRITEPBLK 11                /*WRITE PHYSICAL BLOCK              */
#define IO$_READPBLK 12                 /*READ PHYSICAL BLOCK               */
#define IO$_WRITEHEAD 13                /*WRITE HEADER AND DATA             */
#define IO$_RDSTATS 13                  /*READ STATISTICS                   */
#define IO$_CRESHAD 13                  /*CREATE A SHADOW SET               */
#define IO$_READHEAD 14                 /*READ HEADER AND DATA              */
#define IO$_ADDSHAD 14                  /*ADD MEMBER TO SHADOW SET          */
#define IO$_WRITETRACKD 15              /*WRITE TRACK DATA                  */
#define IO$_COPYSHAD 15                 /*PERFORM SHADOW SET COPY OPERATIONS */
#define IO$_READTRACKD 16               /*READ TRACK DATA                   */
#define IO$_REMSHAD 16                  /*REMOVE MEMBER FROM SHADOW SET     */
#define IO$_AVAILABLE 17                /*AVAILABLE (DISK AND TAPE CLASS)   */
#define IO$_SETPRFPATH 18               /*SET PREFERRED PATH                */
#define IO$_DSE 21                      /*DATA SECURITY ERASE (AND REWIND)  */
#define IO$_REREADN 22                  /*REREAD NEXT                       */
#define IO$_REREADP 23                  /*REREAD PREVIOUS                   */
#define IO$_WRITERET 24                 /*WRITE RETRY                       */
#define IO$_WRITECHECKH 24              /*WRITE CHECK HEADER AND DATA       */
#define IO$_READPRESET 25               /*READIN PRESET                     */
#define IO$_STARTSPNDL 25               /*START SPINDLE                     */
#define IO$_SETCHAR 26                  /*SET CHARACTERISTICS               */
#define IO$_SENSECHAR 27                /*SENSE TAPE CHARACTERISTICS        */
#define IO$_WRITEMARK 28                /*WRITE TAPE MARK                   */
#define IO$_WRTTMKR 29                  /*WRITE TAPE MARK RETRY             */
#define IO$_DIAGNOSE 29                 /*DIAGNOSE                          */
#define IO$_SHADMV 29                   /*PREFORM MOUNT VER. ON SHADOW SET  */
#define IO$_FORMAT 30                   /*FORMAT                            */
#define IO$_CLEAN 30                    /*CLEAN TAPE                        */
#define IO$_PHYSICAL 31                 /*HIGHEST PHYSICAL I/O FUNCTION CODE  */
/*                                                                          */
/* *** START LOGICAL I/O FUNCTION CODES ***                                 */
/*                                                                          */
#define IO$_WRITELBLK 32                /*WRITE LOGICAL BLOCK               */
#define IO$_READLBLK 33                 /*READ LOGICAL BLOCK                */
#define IO$_REWINDOFF 34                /*REWIND AND SET OFFLINE            */
#define IO$_READRCTL 34                 /*READ RCT SECTOR ZERO              */
#define IO$_SETMODE 35                  /*SET MODE                          */
#define IO$_REWIND 36                   /*REWIND TAPE                       */
#define IO$_SKIPFILE 37                 /*SKIP FILES                        */
#define IO$_SKIPRECORD 38               /*SKIP RECORDS                      */
#define IO$_SENSEMODE 39                /*SENSE TAPE MODE                   */
#define IO$_WRITEOF 40                  /*WRITE END OF FILE                 */
#define IO$_TTY_PORT 41                 /*TERMINAL PORT FDT ROUTINE         */
#define IO$_FREECAP 41                  /*RETURN FREE CAPACITY              */
#define IO$_FLUSH 42                    /*FLUSH CONTROLLER CACHE            */
#define IO$_LOGICAL 47                  /*HIGHEST LOGICAL I/O FUNCTION CODE  */
/*                                                                          */
/* *** START VIRTUAL I/O FUNCTION CODES                                     */
/*                                                                          */
#define IO$_WRITEVBLK 48                /*WRITE VIRTUAL BLOCK               */
#define IO$_READVBLK 49                 /*READ VIRTUAL BLOCK                */
#define IO$_ACCESS 50                   /*ACCESS FILE                       */
#define IO$_CREATE 51                   /*CREATE FILE                       */
#define IO$_DEACCESS 52                 /*DEACCESS FILE                     */
#define IO$_DELETE 53                   /*DELETE FILE                       */
#define IO$_MODIFY 54                   /*MODIFY FILE                       */
#define IO$_NETCONTROL 54               /*X25 NETWORK CONTROL FUNCTION      */
#define IO$_READPROMPT 55               /*READ TERMINAL WITH PROMPT         */
#define IO$_SETCLOCK 55                 /*SET CLOCK                         */
#define IO$_ACPCONTROL 56               /*MISCELLANEOUS ACP CONTROL         */
#define IO$_STARTDATA 56                /*START DATA                        */
#define IO$_MOUNT 57                    /*MOUNT VOLUME                      */
#define IO$_TTYREADALL 58               /* TERMINAL READ PASSALL            */
#define IO$_TTYREADPALL 59              /* TERM READ W/PROMPT PASSALL       */
#define IO$_CONINTREAD 60               /* Connect to interrupt readonly    */
#define IO$_CONINTWRITE 61              /* Connect to interrupt with write  */
#define IO$_VIRTUAL 63                  /*HIGHEST VIRTUAL I/O FUNCTION      */
/*                                                                          */
/* FUNCTION MODIFIER BIT DEFINITIONS                                        */
/*                                                                          */
#define IO$M_FCODE 63
#define IO$M_FMODIFIERS 65472
#define IO$M_INHERLOG 2048
#define IO$M_ERASE 1024
#define IO$M_ENCRYPT 8192
#define IO$M_DATACHECK 16384
#define IO$M_INHRETRY 32768
#define IO$M_INHSEEK 4096
#define IO$M_REVERSE 64
#define IO$M_NOWAIT 128
#define IO$M_INHEXTGAP 4096
#define IO$M_MSCPMODIFS 256
#define IO$M_SHADOW 64
#define IO$M_LOCATE 128
#define IO$M_MSCP_FORMAT 64
#define IO$M_ALLHOSTS 64
#define IO$M_DISSOLVE 128
#define IO$M_NOCLEANUP 256
#define IO$M_SPINDOWN 64
#define IO$M_FORCEPATH 64
#define IO$M_COMMOD 64
#define IO$M_MOVETRACKD 128
#define IO$M_DIAGNOSTIC 256
#define IO$M_SKPSECINH 512
#define IO$M_DELDATA 64
#define IO$M_NOMRSP 64
#define IO$M_SWAP 256
#define IO$M_OPPOSITE 512
#define IO$M_CLSEREXCP 512
#define IO$M_ACCESS 64
#define IO$M_CREATE 128
#define IO$M_DELETE 256
#define IO$M_MOUNT 512
#define IO$M_DMOUNT 1024
#define IO$M_REMOUNT 2048
#define IO$M_BINARY 64
#define IO$M_PACKED 128
#define IO$M_NOW 64
#define IO$M_READATTN 128
#define IO$M_WRTATTN 256
#define IO$M_SETPROT 512
#define IO$M_NORSWAIT 1024
#define IO$M_NOECHO 64
#define IO$M_TIMED 128
#define IO$M_CVTLOW 256
#define IO$M_NOFILTR 512
#define IO$M_DSABLMBX 1024
#define IO$M_PURGE 2048
#define IO$M_TRMNOECHO 4096
#define IO$M_REFRESH 8192
#define IO$M_ESCAPE 16384
#define IO$M_EXTEND 32768
#define IO$M_CANCTRLO 64
#define IO$M_ENABLMBX 128
#define IO$M_NOFORMAT 256
#define IO$M_BREAKTHRU 512
#define IO$M_NEWLINE 1024
#define IO$M_TYPEAHDCNT 64
#define IO$M_MAINT 64
#define IO$M_CTRLYAST 128
#define IO$M_CTRLCAST 256
#define IO$M_HANGUP 512
#define IO$M_OUTBAND 1024
#define IO$M_TT_CONNECT 2048
#define IO$M_TT_DISCON 4096
#define IO$M_TT_PROCESS 8192
#define IO$M_BRDCST 16384
#define IO$M_LOOP 128
#define IO$M_UNLOOP 256
#define IO$M_LINE_OFF 512
#define IO$M_SET_MODEM 1024
#define IO$M_LINE_ON 2048
#define IO$M_LOOP_EXT 4096
#define IO$M_AUTXOF_ENA 8192
#define IO$M_AUTXOF_DIS 16384
#define IO$M_INCLUDE 2048
#define IO$M_TT_ABORT 4096
#define IO$M_INTERRUPT 64
#define IO$M_MULTIPLE 128
#define IO$M_LOCKBUF 256
#define IO$M_NOBLOCK 512
#define IO$M_ABORT 256
#define IO$M_SYNCH 512
#define IO$M_RESPONSE 64
#define IO$M_STARTUP 64
#define IO$M_SHUTDOWN 128
#define IO$M_ATTNAST 256
#define IO$M_CTRL 512
#define IO$M_RD_MEM 64
#define IO$M_RD_MODEM 128
#define IO$M_RD_COUNT 256
#define IO$M_CLR_COUNT 1024
#define IO$K_SRRUNOUT 0                 /* Send or rcv until cnt runout     */
#define IO$K_PTPBSC 8192                /* Point to point BSC control       */
#define IO$K_LOOPTEST 57344             /* Loop test                        */
/* X25 driver WRITEBLK function modifier bits.                              */
#define IO$M_MORE 64
#define IO$M_QUALIFIED 128
#define IO$M_REDIRECT 64
#define IO$M_ACCEPT 128
#define IO$M_SETEVF 64
#define IO$M_WORD 64
#define IO$M_SETFNCT 512
#define IO$M_DATAPATH 1024
#define IO$M_CYCLE 4096
#define IO$M_RESET 8192
#define IO$M_SETCUADR 256
#define IO$M_SETBSIZE 512
#define IO$M_SETPOOLSZ 1024
#define IO$M_SETENQCNT 2048
#define IO$M_CLEAR 4096
#define IO$M_LPBEXT 8192
#define IO$M_LPBINT 16384
#define IO$M_READCSR 32768
#define IO$M_NOCTSWAIT 64
#define IO$M_SLAVLOOP 128
#define IO$M_NODSRWAIT 256
#define IO$M_MAINTLOOP 512
#define IO$M_LASTBLOCK 1024
#define IO$M_INTCLOCK 4096
#define IO$M_LT_CONNECT 64
#define IO$M_LT_DISCON 128
#define IO$M_LT_READPORT 256
#define IO$M_LT_MAP_PORT 512
#define IO$M_LT_RATING 1024
#define IO$M_LT_SOL_INFO 2048
#define IO$M_LT_RCV_INFO 4096
#define IO$M_LT_MAP_FILLER 1
#define IO$M_LT_MAP_NODNAM 2
#define IO$M_LT_MAP_PORNAM 4
#define IO$M_LT_MAP_SRVNAM 8
#define IO$M_LT_MAP_LNKNAM 16
#define IO$M_LT_MAP_NETADR 32
#pragma nostandard
union iodef {
/* Basic I/O function code/modifiers structure                              */
    variant_struct  {
        unsigned io$v_fcode : 6;        /* Function Code Field              */
        unsigned io$v_fmodifiers : 10;  /* Function Modifiers Field         */
        } io$r_fcode_structure;
/* Function modifiers common to all drivers which do error logging          */
    variant_struct  {
        unsigned io$v_fcode_fill : 6;
        unsigned io$v_filler : 5;
        unsigned io$v_inherlog : 1;     /* Inhibit error logging            */
        unsigned io$v_fill_6 : 4;
        } io$r_errlog_modifiers;
/* General disk and tape function code modifiers                            */
    variant_struct  {
        unsigned io$v_fcode_fill_2 : 6;
        unsigned io$v_reserved_for_device_dependent : 4;
        unsigned io$v_erase : 1;        /* Erase data                       */
        unsigned io$v_filler_2 : 1;       /* IO$M_INHERLOG                    */
        unsigned io$v_reserved_for_device_dependent_2 : 1;
        unsigned io$v_encrypt : 1;      /* Encryption                       */
        unsigned io$v_datacheck : 1;    /* Write check data after transfer  */
        unsigned io$v_inhretry : 1;     /* Inhibit error retry              */
        } io$r_disk_tape_modifiers;
/* General disk function code modifiers                                     */
    variant_struct  {
        unsigned io$v_fcode_fill_3 : 6;
        unsigned io$v_reserved_for_device_dependent_3 : 6;
        unsigned io$v_inhseek : 1;      /* Inhibit implied seek on physical functions */
        unsigned io$v_fill_7 : 3;
        } io$r_disk_modifiers;
/* General tape function code modifiers                                     */
    variant_struct  {
        unsigned io$v_fcode_fill_4 : 6;
        unsigned io$v_reverse : 1;      /* Reverse operation                */
        unsigned io$v_nowait : 1;       /* No wait for rewind to complete   */
        unsigned io$v_reserved_for_device_dependent_4 : 4;
        unsigned io$v_inhextgap : 1;    /* Inhibit extended inter-record gap  */
        unsigned io$v_fill_8 : 3;
        } io$r_tape_modifiers;
/* DU  & TU, disk & tape class driver transfer function modifier bits       */
    variant_struct  {
        unsigned io$v_fcode_fill_5 : 6;
        unsigned io$v_dutux_reserved : 2;
        unsigned io$v_mscpmodifs : 1;   /* Use MSCP modifiers in P5         */
        unsigned io$v_fill_9 : 7;
        } io$r_dutu_xfer_modifiers;
    variant_struct  {
        unsigned io$v_fcode_fill_6 : 6;
        unsigned io$v_shadow : 1;       /* Shadowing SENSECHAR              */
        unsigned io$v_locate : 1;       /* Shadowing Locate function        */
        } io$r_du_sense_modifiers;
    variant_struct  {
        unsigned io$v_fcode_fill_7 : 6;
        unsigned io$v_mscp_format : 1;  /* PACKACK media for formatting     */
        unsigned io$v_fill_10 : 1;
        } io$r_du_packack_modifiers;
    variant_struct  {
        unsigned io$v_fcode_fill_8 : 6;
        unsigned io$v_allhosts : 1;     /* Do available as for all class drivers */
        unsigned io$v_dissolve : 1;     /* Dissolve shadow set              */
        unsigned io$v_nocleanup : 1;    /* Normal shadow set cleanup not necessary */
        unsigned io$v_fill_11 : 7;
        } io$r_du_avail_modifiers;
    variant_struct  {
        unsigned io$v_fcode_fill_9 : 6;
        unsigned io$v_spindown : 1;     /* Spin down removed member         */
        unsigned io$v_fill_12 : 1;
        } io$r_du_remshad_modifiers;
    variant_struct  {
        unsigned io$v_fcode_fill_10 : 6;
        unsigned io$v_forcepath : 1;    /* Make path change happen          */
        unsigned io$v_fill_13 : 1;
        } io$r_du_prfpath_modifiers;
/* DR driver function modifier bits.                                        */
    variant_struct  {
        unsigned io$v_fcode_fill_11 : 6;
        unsigned io$v_commod : 1;       /* Diagnostic command               */
        unsigned io$v_movetrackd : 1;   /* Move track descriptor            */
        unsigned io$v_diagnostic : 1;   /* Diagnostic function              */
        unsigned io$v_skpsecinh : 1;    /* Skip sector inhibit              */
        unsigned io$v_fill_14 : 6;
        } io$r_dr_modifiers;
/* DY driver function modifier bits.                                        */
    variant_struct  {
        unsigned io$v_fcode_fill_12 : 6;
        unsigned io$v_deldata : 1;      /* Write deleted data mark          */
        unsigned io$v_fill_15 : 1;
        } io$r_dy_modifiers;
/* DD driver (TU58) function modifier bits.                                 */
    variant_struct  {
        unsigned io$v_fcode_fill_13 : 6;
        unsigned io$v_nomrsp : 1;       /* Do not use MRSP for this operation */
        unsigned io$v_fill_16 : 1;
        } io$r_dd_modifiers;
/* Magnetic tape I/O function modifier bits for the TS11.                   */
    variant_struct  {
        unsigned io$v_fcode_fill_14 : 6;
        unsigned io$v_reserved_for_device_dependent_5 : 2;
        unsigned io$v_swap : 1;         /* Swap byte (TS11)                 */
        unsigned io$v_opposite : 1;     /* Opposite bit for rereads (TS11)  */
        unsigned io$v_fill_17 : 6;
        } io$r_ts11_modifiers;
/* TU driver function modifier bits                                         */
    variant_struct  {
        unsigned io$v_fcode_fill_15 : 6;
        unsigned io$v_reserved_for_device_dependent_6 : 3;
        unsigned io$v_clserexcp : 1;    /* Clear serious exception condition */
        unsigned io$v_fill_18 : 6;
        } io$r_tu_modifiers;
/* ACP function modifier bits.                                              */
    variant_struct  {
        unsigned io$v_fcode_fill_16 : 6;
        unsigned io$v_access : 1;       /* Access file                      */
        unsigned io$v_create : 1;       /* Create file                      */
        unsigned io$v_delete : 1;       /* Delete file                      */
        unsigned io$v_mount : 1;        /* Mount volume                     */
        unsigned io$v_dmount : 1;       /* Dismount volume                  */
        unsigned io$v_remount : 1;      /* Remount volume                   */
        unsigned io$v_fill_19 : 4;
        } io$r_acp_modifiers;
/* CR (card reader) driver function modifier bits.                          */
    variant_struct  {
        unsigned io$v_fcode_fill_17 : 6;
        unsigned io$v_binary : 1;       /* Binary read                      */
        unsigned io$v_packed : 1;       /* Packed read                      */
        } io$r_cr_modifiers;
/* MB (mailbox) driver function modifier bits.                              */
    variant_struct  {
        unsigned io$v_fcode_fill_18 : 6;
        unsigned io$v_now : 1;          /* Do not wait for operation complete */
        unsigned io$v_readattn : 1;     /* Request ast on waiting reader    */
        unsigned io$v_wrtattn : 1;      /* Request ast on waiting writer    */
        unsigned io$v_setprot : 1;      /* Set volume protection            */
        unsigned io$v_norswait : 1;     /* Do not allow resource waits      */
        unsigned io$v_fill_20 : 5;
        } io$r_mb_modifiers;
/* TT driver READ function modifier bits.                                   */
    variant_struct  {
        unsigned io$v_fcode_fill_19 : 6;
        unsigned io$v_noecho : 1;       /* Noecho                           */
        unsigned io$v_timed : 1;        /* Timed                            */
        unsigned io$v_cvtlow : 1;       /* Convert lower case               */
        unsigned io$v_nofiltr : 1;      /* No filter                        */
        unsigned io$v_dsablmbx : 1;     /* Disable mailbox                  */
        unsigned io$v_purge : 1;        /* Purge typeahead                  */
        unsigned io$v_trmnoecho : 1;    /* Terminators are not echoed       */
        unsigned io$v_refresh : 1;      /* Control-R interrupted read       */
        unsigned io$v_escape : 1;       /* Terminate read on escape sequence */
        unsigned io$v_extend : 1;       /* Used by alternate class drivers  */
        } io$r_tt_read_modifiers;
/* TT driver WRITE function modifier bits.                                  */
    variant_struct  {
        unsigned io$v_fcode_fill_20 : 6;
        unsigned io$v_canctrlo : 1;     /* Cancel control O                 */
        unsigned io$v_enablmbx : 1;     /* Enable mailbox                   */
        unsigned io$v_noformat : 1;     /* Do not format output             */
        unsigned io$v_breakthru : 1;    /* Broadcast I/O                    */
        unsigned io$v_newline : 1;      /* Output a newline                 */
        unsigned io$v_fill_21 : 5;
        } io$r_tt_write_modifiers;
/* TT driver SENSEMODE function modifier bits.                              */
    variant_struct  {
        unsigned io$v_fcode_fill_21 : 6;
        unsigned io$v_typeahdcnt : 1;   /* Sense typeahead information      */
        unsigned io$v_reserve_rd_modem : 1;
        } io$r_tt_sensemode_modifiers;
/* TT driver SETMODE subfunction modifier bits.                             */
    variant_struct  {
        unsigned io$v_fcode_fill_22 : 6;
        unsigned io$v_maint : 1;        /* Enable maint sub modifiers       */
        unsigned io$v_ctrlyast : 1;     /* Set control Y AST                */
        unsigned io$v_ctrlcast : 1;     /* Set Control C                    */
        unsigned io$v_hangup : 1;       /* Set mode and hang up line        */
        unsigned io$v_outband : 1;      /* Set out of band AST              */
        unsigned io$v_tt_connect : 1;   /* Connect to detached terminal     */
        unsigned io$v_tt_discon : 1;    /* Disconnect detached terminal     */
        unsigned io$v_tt_process : 1;   /* Define controlling process       */
        unsigned io$v_brdcst : 1;       /* Define broadcast mask            */
        unsigned io$v_fill_22 : 1;
        } io$r_tt_setmode_modifiers;
/* TT driver MAINTIANCE subfunction submodifier bits.                       */
    variant_struct  {
        unsigned io$v_fcode_fill_23 : 6;
        unsigned io$v_reserve_maint_escape : 1;
        unsigned io$v_loop : 1;         /* Diagnostic loopback              */
        unsigned io$v_unloop : 1;       /* Diagnostic reset loopback        */
        unsigned io$v_line_off : 1;     /* Disable line                     */
        unsigned io$v_set_modem : 1;    /* Diagnostic modem control         */
        unsigned io$v_line_on : 1;      /* Enable line                      */
        unsigned io$v_loop_ext : 1;     /* Diagnostic external loopback     */
        unsigned io$v_autxof_ena : 1;   /* Enable auto XOFF                 */
        unsigned io$v_autxof_dis : 1;   /* Disable auto XOFF                */
        unsigned io$v_reserve_int_disable : 1;
        } io$r_tt_maint_modifiers;
/* TT driver out-of-band modifier bits.                                     */
    variant_struct  {
        unsigned io$v_fcode_fill_24 : 6;
        unsigned io$v_reserve_maint_escape_2 : 5;
        unsigned io$v_include : 1;      /* Include character in stream      */
        unsigned io$v_tt_abort : 1;     /* Abort current I/O                */
        unsigned io$v_fill_23 : 3;
        } io$r_tt_outofband_modifiers;
/* Network WRITE and READ VIRTUAL function modifier bits.                   */
    variant_struct  {
        unsigned io$v_fcode_fill_25 : 6;
        unsigned io$v_interrupt : 1;    /* Interrupt message                */
        unsigned io$v_multiple : 1;     /* Multiple write/read request      */
        unsigned io$v_lockbuf : 1;      /* Direct I/O request               */
        unsigned io$v_noblock : 1;      /* Segment message w/o blocking     */
        unsigned io$v_fill_24 : 6;
        } io$r_net_write_read_modifiers;
/* Network ACCESS/DEACCESS function modifier bits.                          */
    variant_struct  {
        unsigned io$v_fcode_fill_26 : 6;
        unsigned io$v_reserved : 2;
        unsigned io$v_abort : 1;        /* Disconnect abort/connect reject  */
        unsigned io$v_synch : 1;        /* Synchronous disconnect           */
        unsigned io$v_fill_25 : 6;
        } io$r_net_accdea_modifiers;
/* DATALINK driver WRITE subfunction modifier bits.                         */
    variant_struct  {
        unsigned io$v_fcode_fill_27 : 6;
        unsigned io$v_response : 1;     /* Transmit this packet as a response */
        unsigned io$v_fill_26 : 1;
        } io$r_dlink_write_modifiers;
/* DATALINK driver SETMODE subfunction modifier bits.                       */
    variant_struct  {
        unsigned io$v_fcode_fill_28 : 6;
        unsigned io$v_startup : 1;      /* Start protocol                   */
        unsigned io$v_shutdown : 1;     /* Stop protocol                    */
        unsigned io$v_attnast : 1;      /* Attention AST                    */
        unsigned io$v_ctrl : 1;         /* Controller (ie. not station) function */
        unsigned io$v_reserve_set_modem : 1;
        unsigned io$v_fill_27 : 5;
        } io$r_dlink_setmode_modifiers;
/* DATALINK driver SENSEMODE subfunction modifier bits.                     */
    variant_struct  {
        unsigned io$v_fcode_fill_29 : 6;
        unsigned io$v_rd_mem : 1;       /* Read device memory               */
        unsigned io$v_rd_modem : 1;     /* Read modem status                */
        unsigned io$v_rd_count : 1;     /* Read counters                    */
        unsigned io$v_reserve_ctrl : 1;
        unsigned io$v_clr_count : 1;    /* Clear counters                   */
        unsigned io$v_fill_28 : 5;
        } io$r_dlink_sensemode_modifiers;
    variant_struct  {
        unsigned io$v_fcode_fill_30 : 6;
        unsigned io$v_more : 1;         /* More data follows (M-bit)        */
        unsigned io$v_qualified : 1;    /* Use qualified sub-channel (Q-bit) */
        } io$r_x25_write_modifiers;
/* X25 driver ACCESS function modifier bits.                                */
    variant_struct  {
        unsigned io$v_fcode_fill_31 : 6;
        unsigned io$v_redirect : 1;     /* Redirect virtual call            */
        unsigned io$v_accept : 1;       /* Accept virtual call              */
        } io$r_x25_access_modifiers;
/* LPA-11 driver STARTDATA modifier bits.                                   */
    variant_struct  {
        unsigned io$v_fcode_fill_32 : 6;
        unsigned io$v_setevf : 1;       /* Set event flag                   */
        unsigned io$v_fill_29 : 1;
        } io$r_lpa_start_modifiers;
/* XA (DR11-W) driver function modifier bits.                               */
    variant_struct  {
        unsigned io$v_fcode_fill_33 : 6;
        unsigned io$v_word : 1;         /* Word (interrupt)/block (DMA) mode specifier */
        unsigned io$v_filler_3 : 1;       /* IO$M_TIMED                       */
        unsigned io$v_filler_4 : 1;       /* IO$M_ATTNAST, IO$M_DIAGNOSTIC    */
        unsigned io$v_setfnct : 1;      /* Set "FNCT" bits in device CSR    */
        unsigned io$v_datapath : 1;     /* Change UBA datapath (direct/buffered) */
        unsigned io$v_filler_5 : 1;       /* IO$M_INHERLOG (former def'n for RESET) */
        unsigned io$v_cycle : 1;        /* Set "cycle" bit in device CSR    */
        unsigned io$v_reset : 1;        /* Device reset specifier           */
        unsigned io$v_fill_30 : 2;
        } io$r_xa_modifiers;
/* 3271 driver function modifier bits.                                      */
    variant_struct  {
        unsigned io$v_fcode_fill_34 : 6;
        unsigned io$v_filler_6 : 2;
        unsigned io$v_setcuadr : 1;     /* Set a new CU address             */
        unsigned io$v_setbsize : 1;     /* Set a new maximum buffer size    */
        unsigned io$v_setpoolsz : 1;    /* Set a new pool size              */
        unsigned io$v_setenqcnt : 1;    /* Set a new ENQ threshold          */
        unsigned io$v_clear : 1;        /* Zero status counters             */
        unsigned io$v_lpbext : 1;       /* Loopback is external loopback    */
        unsigned io$v_lpbint : 1;       /* Loopback is internal loopback (DUP11) */
        unsigned io$v_readcsr : 1;      /* Read CSRs on DUP11               */
        } io$r_ibm3271_modifiers;
/* XW driver function modifier bits.                                        */
    variant_struct  {
        unsigned io$v_fcode_fill_35 : 6;
        unsigned io$v_noctswait : 1;    /* Diagnostic function              */
        unsigned io$v_slavloop : 1;     /* Diagnostic function              */
        unsigned io$v_nodsrwait : 1;    /* Do not wait for DSR (diag)       */
        unsigned io$v_maintloop : 1;    /* Internal maint loop              */
        unsigned io$v_lastblock : 1;    /* Last block of message            */
        unsigned io$v_filler_7 : 1;
        unsigned io$v_intclock : 1;     /* Internal clock                   */
        unsigned io$v_fill_31 : 3;
        } io$r_xw_modifiers;
/* LAT driver function modifier bits.                                       */
    variant_struct  {
        unsigned io$v_fcode_fill_36 : 6;
        unsigned io$v_lt_connect : 1;   /* Solicit connection to remote LAT device */
        unsigned io$v_lt_discon : 1;    /* Disconnect LAT session           */
        unsigned io$v_lt_readport : 1;  /* Read LAT device info             */
        unsigned io$v_lt_map_port : 1;  /* Map application port             */
        unsigned io$v_lt_rating : 1;    /* Set service rating               */
        unsigned io$v_lt_sol_info : 1;  /* Request solicit info             */
        unsigned io$v_lt_rcv_info : 1;  /* Setup to recive reply            */
        unsigned io$v_fill_32 : 3;
        } io$r_lt_modifiers;
/* LAT item list definitions for MAP_PORT                                   */
    variant_struct  {
        unsigned io$v_lt_map_filler : 1; /* Item 0 not used                 */
        unsigned io$v_lt_map_nodnam : 1; /* Server node name                */
        unsigned io$v_lt_map_pornam : 1; /* Server port name                */
        unsigned io$v_lt_map_srvnam : 1; /* Server service name             */
        unsigned io$v_lt_map_lnknam : 1; /* Link name                       */
        unsigned io$v_lt_map_netadr : 1; /* Server Ethernet Add.            */
        unsigned io$v_fill_33 : 2;
        } io$r_lt_mapitem;
    } ;
#pragma standard

#endif					/* __IODEF_LOADED */
#ifndef __JBCMSGDEF_LOADED
#define __JBCMSGDEF_LOADED	1

/*** MODULE $jbcmsgdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:10.72 */
/*                                                                          */
/*                                                                          */
/* VERSION:	'X-10'                                                      */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	X-10	JAK0579		J A KRYCKA	18-NOV-1987                 */
/*		ADD MESSAGE JOBCTLABORT.                                    */
/*                                                                          */
/*	X-9	JES0038		JACK SPEIGHT	07-JAN-1987                 */
/*		ADD NEW ERRORS - NOSUCHENT, NOMOREENT.                      */
/*                                                                          */
/*	X-8	JES0037		JACK SPEIGHT    23-OCT-1986                 */
/*		FIX ERROR NFYQUESTATE TO ALLOW A PARAMETER, WHERE           */
/*		THAT PARAMETER WILL BE USED TO SPECIFY A NUMBER             */
/*		OF QUEUE STATES - STALLED, STOPPED, PAUSED ETC.             */
/*                                                                          */
/*	X-7	JES0036		JACK SPEIGHT	08-SEP-1986                 */
/*		ADD NEW MESSAGES FOR VERSION 5.0 - BASE LEVEL 1.            */
/*                                                                          */
/*	V04-007 JES0035		JACK SPEIGHT	04-OCT-1985                 */
/*		CHANGE TEXT FOR JBC$_NOSUCHNODE.                            */
/*                                                                          */
/*	V04-006 JES0034		JACK SPEIGHT	05-SEP-1985                 */
/*		ADD JBC$_NOSUCHNODE, JBC$_RESTARTCOM.                       */
/*                                                                          */
/*	V04-005	JAK0407		J A KRYCKA	29-APR-1985                 */
/*		MOVE JBC$_NOCMKRNL, JBC$_NOOPER, AND JBC$_SYSNAM DEFINITIONS */
/*		HERE FROM JOBCTLDEF.REQ.                                    */
/*                                                                          */
/*	V04-004	JAK0405		J A KRYCKA	26-APR-1985                 */
/*		ADD JBC$_NOMORECHAR, JBC$_NOMOREFILE, JBC$_NOMOREFORM,      */
/*		JBC$_NOMOREJOB, JBC$_NOMOREQUE, JBC$_NOJOBCTX, AND JBC$_NOQUECTX */
/*		MESSAGES.                                                   */
/*                                                                          */
/*	V04-003 JES0033		JACK SPEIGHT	26-APR-1985                 */
/*		SPECIFY AN EXPLICIT SEVERITY LEVEL FOR EACH ERROR MESSAGE   */
/*		SO THAT THE DEFINITIONS HERE AGREE WITH WHAT IS ACTUALLY    */
/*		RETURNED BY THE JOB CONTROLLER IN THE USER'S I/O STATUS BLOCK. */
/*		PRIOR TO THIS CHANGE ALL NON-SUCCESS CODES WERE DEFINED HERE */
/*		WITH A SEVERITY LEVEL OF WARNING AND THE JOB CONTROLLER ADDED */
/*		THE PROPER SEVERITY LEVEL. ALSO MAKE MINOR EDITS TO CERTAIN */
/*		MESSAGE TEXT.                                               */
/*		                                                            */
/*	V04-002 JES0032 	JACK SPEIGHT    03-APR-1985                 */
/*		ADD JBC$_RESTRICT, JBC$_NFY_FAILURE, JBC$_NFY_CPULIM,       */
/*		AND JBC$_NFY_WSVAL MESSAGES.                                */
/*                                                                          */
/*	V04-001 JES0031		JACK SPEIGHT    15-MAR-1985                 */
/*		ADD JBC$_QUENOTSTOP MESSAGE.                                */
#define JBC$_FACILITY 4
/*                                                                          */
/* THE FOLLOWING CODES ARE RETURNED BY THE $SNDJBC, $GETQUI, $SNDJBC, AND $SNDSMB */
/* SYSTEM SERVICES, OR PLACED IN THE ACCOUNTING FILE.                       */
/*                                                                          */
/* THESE VALUES ARE PUBLIC AND MUST NOT CHANGE FROM RELEASE TO RELEASE.     */
/*                                                                          */
/* NOTE:	ERROR CODES WITH ASSOCIATED TEXT OF <> ARE RETIRED ERROR CODES AND HAVE */
/*	A SEVERITY LEVEL OF SEVERE.                                         */
/*                                                                          */
#define JBC$_NORMAL 262145              /* <normal success completion>      */
#define JBC$_NOCMKRNL 272386            /* <operation requires CMKRNL privilege> */
#define JBC$_NOOPER 272530              /* <operation requires OPER privilege> */
#define JBC$_NOSYSNAM 272402            /* <operation requires SYSNAM privilege> */
#define JBC$_ILLDEVNAM 294916
#define JBC$_UNSDEVTYP 294924
#define JBC$_ILLFILNAM 294932
#define JBC$_INVQUENAM 294940
#define JBC$_NOPRIV 294946
#define JBC$_NOQUEHDR 294956
#define JBC$_NOQUESPACE 294962
#define JBC$_NOSUCHQUE 294970
#define JBC$_NOSUCHJOB 294978
#define JBC$_NOOPENJOB 294986
#define JBC$_REFERENCED 294994
#define JBC$_STARTED 295002
#define JBC$_INVITMCOD 295012
#define JBC$_INVFUNCOD 295020
#define JBC$_EMPTYJOB 295026
#define JBC$_JOBQUEDIS 295034
#define JBC$_JOBABORT 295044
#define JBC$_ACMINVOP 295052
#define JBC$_INVPARLEN 295060
#define JBC$_TRMMBXUSE 295068
#define JBC$_MAXSYMEXD 295076
#define JBC$_SCTTABFUL 295084
#define JBC$_CREPRCFAL 295092
#define JBC$_SYMNTBFUL 295100
#define JBC$_NODSTQUE 295106
#define JBC$_INVDSTQUE 295116
#define JBC$_JOBDELETE 295124
#define JBC$_NORESTART 295130
#define JBC$_JOBREQUEUE 295140
#define JBC$_QUERESET 295148
#define JBC$_SYSFAIL 295156
#define JBC$_EXECUTING 295162
#define JBC$_INVMSGBUF 295172
#define JBC$_MISREQPAR 295180
#define JBC$_INVPARVAL 295188
#define JBC$_INCQUETYP 295196
#define JBC$_INCDSTQUE 295204
#define JBC$_JOBQUEENA 295210
#define JBC$_NOTASSIGN 295218
#define JBC$_INCOMPLETE 295226
#define JBC$_INVCHANAM 295236
#define JBC$_INVFORNAM 295244
#define JBC$_NOSUCHCHAR 295250
#define JBC$_NOSUCHFORM 295258
#define JBC$_DUPFORM 295266
#define JBC$_INCFORMPAR 295276
#define JBC$_NOSUCHFILE 295282
#define JBC$_DELACCESS 295290
#define JBC$_QUENOTSTOP 295298
#define JBC$_NOMORECHAR 295306
#define JBC$_NOMOREFILE 295314
#define JBC$_NOMOREFORM 295322
#define JBC$_NOMOREJOB 295330
#define JBC$_NOMOREQUE 295338
#define JBC$_NOJOBCTX 295346
#define JBC$_NOQUECTX 295354
#define JBC$_NOSUCHNODE 295362
#define JBC$_GEN_MAX 295370
#define JBC$_QUE_CLOSED 295378
#define JBC$_NOSUCHENT 295386
#define JBC$_NOMOREENT 295394
#define JBC$_JOBCTLABORT 295404
/*                                                                          */
/* THE FOLLOWING CODES ARE SIGNALLED TO THE CONSOLE OR BROADCAST TO THE USER'S */
/* TERMINAL BY THE JOB CONTROLLER.                                          */
/*                                                                          */
/* THESE MESSAGES ARE NOT PUBLIC AND MAY CHANGE FROM RELEASE TO REALEASE.   */
/*                                                                          */
/* NOTE:  THE JOB CONTROLLER ABORTS EXECUTION AND RESTARTS ITSELF WHEN A SEVERE */
/*	 ERROR IS SIGNALLED TO THE CONSOLE.                                 */
/*                                                                          */
#define JBC$_ACCDISERR 295939
#define JBC$_ALLOCMEM 295948
#define JBC$_COMREMJBC 295956
#define JBC$_INVBLOCK 295964
#define JBC$_INVMSG 295970
#define JBC$_NEWQUEUE 295979
#define JBC$_OPEJBCMBX 295988
#define JBC$_PRCREAT 295996
#define JBC$_QUEFORMAT 296000
#define JBC$_REAJBCMBX 296012
#define JBC$_REQUEST 296019
#define JBC$_SETIMR 296026
#define JBC$_SYMCREPRC 296034
#define JBC$_SYMDEL 296042
#define JBC$_WRIRSPMSG 296050
#define JBC$_WRISMBMBX 296058
#define JBC$_NFY_COMPLETE 296067
#define JBC$_NFY_CURRENT 296075
#define JBC$_NFY_HOLD 296083
#define JBC$_NFY_PENDING 296091
#define JBC$_NFY_TIMER 296099
#define JBC$_STRUCT_LEVEL 296107
#define JBC$_DIAGNOSTIC 296112
#define JBC$_DIAG_TEXT 296120
#define JBC$_DIAG_DATA 296128
#define JBC$_RESTRICT 296136
#define JBC$_NFY_FAILURE 296147
#define JBC$_NFY_CPULIM 296155
#define JBC$_NFY_WSVAL 296163
#define JBC$_RESTARTCOM 296171
#define JBC$_NFY_NOACCESS 296179
#define JBC$_NFY_CHARAC 296187
#define JBC$_NFY_NOLOWER 296195
#define JBC$_NFY_SIZE_MIN 296203
#define JBC$_NFY_SIZE_MAX 296211
#define JBC$_NFY_FORM 296219
#define JBC$_NFY_QUESTATE 296227

#endif					/* __JBCMSGDEF_LOADED */
#ifndef __JPIDEF_LOADED
#define __JPIDEF_LOADED	1

/*** MODULE $jpidef ***/
/*+                                                                         */
/*                                                                          */
/* Get Job Process Information Data Identifier Definitions                  */
/*                                                                          */
/* **** NOTE ****                                                           */
/*                                                                          */
/*        New items must always be added to the END of each item list       */
/*        (preceeding the ENDlistname item) so that users will not have     */
/*        to relink.                                                        */
/*-                                                                         */
/* DEFINE TABLE NUMBERS                                                     */
/* STRUCTURE CODES MUST START AT 1                                          */
#define JPI$C_ADRTYPE 1                 /* ITEM IS ADDRESS OF DATA          */
#define JPI$C_CTLTYPE 2                 /* ITEM IS IN CONTROL REGION        */
#define JPI$C_PCBTYPE 3                 /* ITEM IN PCB                      */
#define JPI$C_PHDTYPE 4                 /* ITEM IN PHD                      */
#define JPI$C_PCBFLDTYPE 5              /* ITEM IS BIT FIELD                */
#define JPI$C_PHDFLDTYPE 6              /* ITEM IS BIT FIELD                */
#define JPI$C_JIBTYPE 7                 /* ITEM IN JIB (SUBTYPE)            */
#define JPI$C_ARBTYPE 8                 /* ITEM IN ARB (SUBTYPE)            */
#define JPI$C_MAXSTRUC 6                /* TOTAL OF 6 TABLES                */
#define JPI$C_LISTEND 0                 /* DEFINE ITMLST TERMINATOR         */
#define JPI$_CHAIN -1                   /* CHAIN INDICATOR                  */
/*                                                                          */
/* NOTE!! The following constants match values in $JIBDEF.                  */
/*                                                                          */
#define JPI$K_OTHER 0                   /* JPI$_Mode values                 */
#define JPI$K_NETWORK 1                 /* JPI$_Mode values                 */
#define JPI$K_BATCH 2                   /* JPI$_Mode values                 */
#define JPI$K_INTERACTIVE 3             /* JPI$_Mode values                 */
#define JPI$K_DETACHED 0                /* JPI$_JOBTYPE values              */
#define JPI$K_LOCAL 3                   /* JPI$_JOBTYPE values              */
#define JPI$K_DIALUP 4                  /* JPI$_JOBTYPE values              */
#define JPI$K_REMOTE 5                  /* JPI$_JOBTYPE values              */
/* (also BATCH & INTERACTIVE)                                               */
/* ITEM IDENTIFIERS FOR PCB                                                 */
#define JPI$_ASTACT 768                 /* ACCESS MODES WITH ACTIVE ASTS    */
#define JPI$_ASTEN 769                  /* ACCESS MODES WITH ASTS ENABLED   */
#define JPI$_PRI 770                    /* CURRENT PROCESS PRIORITY         */
#define JPI$_OWNER 771                  /* PID OF CREATOR PROCESS           */
#define JPI$_UIC 772                    /* UIC OF PROCESS                   */
#define JPI$_STS 773                    /* PROCESS STATUS                   */
#define JPI$_STATE 774                  /* PROCESS STATE                    */
#define JPI$_MEM 775                    /* MEMBER FIELD OF UIC              */
#define JPI$_GRP 776                    /* GROUP FIELD OF UIC               */
#define JPI$_PRIB 777                   /* PROCESS BASE PRIORITY            */
#define JPI$_APTCNT 778                 /* ACTIVE PAGE TABLE COUNT          */
#define JPI$_TMBU 779                   /* TERMINATION MAILBOX UNIT         */
#define JPI$_GPGCNT 780                 /* GLOBAL PAGE COUNT IN WORKING SET  */
#define JPI$_PPGCNT 781                 /* PROCESS PAGE COUNT IN WORKING SET  */
#define JPI$_ASTCNT 782                 /* AST COUNT REMAINING              */
#define JPI$_BIOCNT 783                 /* BUFFERED I/O COUNT REMAINING     */
#define JPI$_BIOLM 784                  /* BUFFERED I/O LIMIT               */
#define JPI$_BYTCNT 785                 /* BYTE COUNT REMAINING FOR BUFFERED I/O  */
#define JPI$_DIOCNT 786                 /* DIRECT I/O COUNT REMAINING       */
#define JPI$_DIOLM 787                  /* DIRECT I/O COUNT LIMIT           */
#define JPI$_FILCNT 788                 /* COUNT REMAINING OF OPEN FILES    */
#define JPI$_TQCNT 789                  /* COUNT REMAINING OF TIMER QUEUE ENTRIES  */
#define JPI$_EFWM 790                   /* EVENT FLAG WAIT MASK             */
#define JPI$_EFCS 791                   /* LOCAL EVENT FLAGS 0-31           */
#define JPI$_EFCU 792                   /* LOCAL EVENT FLAGS 32-63          */
#define JPI$_PID 793                    /* PROCESS IDENTIFICATION           */
#define JPI$_BYTLM 794                  /* BUFFERED I/0 BYTE COUNT LIMIT    */
#define JPI$_PRCCNT 795                 /* SUBPROCESS COUNT                 */
#define JPI$_PRCNAM 796                 /* PROCESS NAME                     */
#define JPI$_TERMINAL 797               /* LOGIN TERMINAL NAME              */
#define JPI$_JOBPRCCNT 798              /* TOTAL COUNT OF SUBPROCESSES IN A JOB  */
#define JPI$_ENQCNT 799                 /* ENQUEUE COUNT REMAINING          */
#define JPI$_ENQLM 800                  /* ENQUEUE COUNT LIMIT              */
#define JPI$_SWPFILLOC 801              /* SWAP FILE BACKING STORE ADDRESS  */
#define JPI$_MODE 802                   /* MODE VALUE (FROM STS) - DEFINED ABOVE */
#define JPI$_JOBTYPE 803                /* JOB TYPE CODE                    */
#define JPI$_PROC_INDEX 804             /* PROCESS INDEX                    */
#define JPI$_MASTER_PID 805             /* MASTER PROCESS PID               */
#define JPI$_RIGHTSLIST 806             /* PROCESS RIGHTSLIST               */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define JPI$_LASTPCB 807                /* MAX INDEX IN PCB TABLE           */
/* ITEM IDENTIFIERS FOR PHD                                                 */
#define JPI$_CURPRIV 1024               /* CURRENT PROCESS PRIVILEGE MASK   */
#define JPI$_WSAUTH 1025                /* AUTHORIZED WORKING SET SIZE      */
#define JPI$_WSQUOTA 1026               /* QUOTA ON WORKING SET SIZE        */
#define JPI$_DFWSCNT 1027               /* DEFAULT WORKING SET SIZE         */
#define JPI$_FREP0VA 1028               /* FIRST FREE VIRTUAL ADDR. AT END OF P0 SPACE  */
#define JPI$_FREP1VA 1029               /* FIRST FREE ADDR. AT END OF P1 SPACE  */
#define JPI$_DFPFC 1030                 /* DEFAULT PAGE FAULT CLUSTER       */
#define JPI$_CPUTIM 1031                /* ACCUMULATED CPU TIME             */
#define JPI$_PRCLM 1032                 /* SUBPROCESS QUOTA                 */
#define JPI$_ASTLM 1033                 /* AST LIMIT                        */
#define JPI$_PAGEFLTS 1034              /* COUNT OF PAGE FAULTS             */
#define JPI$_DIRIO 1035                 /* PROCESS DIRECT I/O OPERATIONS    */
#define JPI$_BUFIO 1036                 /* PROCESS BUFFERED I/O OPERATIONS  */
#define JPI$_CPULIM 1037                /* LIMIT ON CPUTIM FOR PROCESS      */
#define JPI$_PGFLQUOTA 1038             /* MAX. VIRTUAL PAGE COUNT          */
#define JPI$_FILLM 1039                 /* OPEN FILE LIMIT                  */
#define JPI$_TQLM 1040                  /* TIMER QUEUE LIMIT                */
#define JPI$_WSSIZE 1041                /* CURRENT WORKING SET SIZE         */
#define JPI$_AUTHPRIV 1042              /* AUTHORIZED PRIVILEGE MASK        */
#define JPI$_IMAGPRIV 1043              /* INSTALLED IMAGE PRIVILEGE MASK   */
#define JPI$_PAGFILCNT 1044             /* PAGES CHARGED TO PAGE FILE QUOTA  */
#define JPI$_FREPTECNT 1045             /* ROOM FOR EXPANSION OF P0 OR P1 SPACE  */
#define JPI$_WSEXTENT 1046              /* EXTENT OF WORKING SET SIZE       */
#define JPI$_WSAUTHEXT 1047             /* MAX EXTENT OF WORKING SET SIZE   */
#define JPI$_AUTHPRI 1048               /* AUTHORIZED PRIORITY FOR $SETPRI  */
#define JPI$_PAGFILLOC 1049             /* PAGE FILE BACKING STORE ADDRESS  */
#define JPI$_IMAGECOUNT 1050            /* IMAGE COUNTER (CLOCKED BY RUNDOWN)  */
#define JPI$_PHDFLAGS 1051              /* PROCESS HEADER FLAGS WORD        */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define JPI$_LASTPHD 1052               /* MAX INDEX IN PROCESS HEADER      */
/* ITEM IDENTIFIERS FOR CONTROL REGION                                      */
#define JPI$_VIRTPEAK 512               /* PEAK VIRTUAL SIZE                */
#define JPI$_WSPEAK 513                 /* PEAK WORKING SET SIZE            */
#define JPI$_USERNAME 514               /* USERNAME STRING                  */
#define JPI$_ACCOUNT 515                /* ACCOUNT NAME STRING              */
#define JPI$_PROCPRIV 516               /* PROCESS PRIVILEGE MASK           */
#define JPI$_VOLUMES 517                /* VOLUMES MOUNTED                  */
#define JPI$_LOGINTIM 518               /* TIME OF LOGIN OR PROCESS CREATION  */
#define JPI$_IMAGNAME 519               /* CURRENT IMAGE FILE NAME          */
#define JPI$_SITESPEC 520               /* PER-PROCESS SITE-SPECIFIC CELL   */
#define JPI$_MSGMASK 521                /* PROCESS DEFAULT MESSAGE FLAGS    */
#define JPI$_CLINAME 522                /* COMMAND LANGUAGE INTERPRETER NAME */
#define JPI$_TABLENAME 523              /* COMMAND LANGUAGE INTERPRETER TABLE NAME */
#define JPI$_CREPRC_FLAGS 524           /* $CREPRC FLAGS USED TO CREATE THIS PROCESS */
#define JPI$_UAF_FLAGS 525              /* FLAGS FROM UAF RECORD            */
#define JPI$_MAXDETACH 526              /* MAXIMUM DETACHED PROCESSES FOR SINGLE USER */
#define JPI$_MAXJOBS 527                /* MAXIMUM ACTIVE PROCESSES FOR SINGLE USER */
#define JPI$_SHRFILLM 528               /* MAXIMUM OPEN SHARED FILES        */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define JPI$_LASTCTL 529                /* MAX INDEX IN CONTROL REGION      */
/* ITEM IDENTIFIERS FOR ADDRESS DATA                                        */
#define JPI$_EXCVEC 256                 /* ADDRESS OF "EXCEPTION VECTOR" VECTOR  */
#define JPI$_FINALEXC 257               /* ADDRESS OF LAST CHANCE EXCEPTION VECTORS  */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define JPI$_LASTADR 258                /* MAX INDEX IN ADDRESS TABLE       */
/* ITEM IDENTIFIERS FOR PCBFLD                                              */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define JPI$_LASTPCBFLD 1280            /* MAX INDEX IN PCBFLD TABLE        */
/* ITEM IDENTIFIERS FOR PHDFLD                                              */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define JPI$_LASTPHDFLD 1536            /* MAX INDEX IN PHDFLD TABLE        */
 

#endif					/* __JPIDEF_LOADED */
#ifndef __KGBDEF_LOADED
#define __KGBDEF_LOADED	1

/*** MODULE $kgbdef ***/
/*++                                                                        */
/* Key Grant Block definitions: Format of records in the rights database    */
/* file. These records (1) associate identifier codes with names, and       */
/* (2) list the holders of all identifiers in the system.                   */
/*--                                                                        */
#define KGB$M_RESOURCE 1
#define KGB$M_DYNAMIC 2
#define KGB$M_ACCESS 4
#define KGB$K_HOLD_RECORD 16            /* End of holder record             */
#define KGB$K_IDENT_RECORD 48           /* End of identifier record         */
#define KGB$K_LEVEL1 257                /* Version 1 structure level        */
#define KGB$K_MAINT_RECORD 64           /* End of maintenance record        */
struct kgbdef {
    unsigned long int kgb$l_identifier; /* Binary identifier code           */
#pragma nostandard
    variant_union  {
        unsigned long int kgb$l_attributes; /* Attribute bit definitions    */
        variant_struct  {
            unsigned kgb$v_resource : 1; /* Resource use allowed            */
            unsigned kgb$v_dynamic : 1; /* Identifier may be enabled or disabled */
            unsigned kgb$v_access : 1;  /* Identifier used in protection checks */
            unsigned kgb$v_fill_36 : 5;
            } kgb$r_fill_35;
        } kgb$r_fill_34;
    unsigned int kgb$q_holder [2];      /* Holder identifier                */
    char kgb$t_name [32];               /* Identifier name (blank filled string) */
    unsigned short int kgb$w_level;     /* File structure level             */
    short int kgb$$$_fill_1;
    unsigned int kgb$q_sys_id [2];      /* System identifier                */
    unsigned long int kgb$l_next_id;    /* Next available identifier        */
    } ;
/*++                                                                        */
/* Define the environmental rights ID values                                */
/*--                                                                        */
#define KGB$K_BATCH_ID -2147483647      /* Batch ID value                   */
#define KGB$K_DIALUP_ID -2147483646     /* Dialup ID value                  */
#define KGB$K_INTERACTIVE_ID -2147483645 /* Interactive ID value            */
#define KGB$K_LOCAL_ID -2147483644      /* Local ID value                   */
#define KGB$K_NETWORK_ID -2147483643    /* Network ID value                 */
#define KGB$K_REMOTE_ID -2147483642     /* Remote ID value                  */
/*                                                                          */
/* Define the various access class ranges.                                  */
/*                                                                          */
#define KGB$K_SEC_LEVEL_BASE -2147482648
#define KGB$K_INT_LEVEL_BASE -2147482392
#define KGB$K_SEC_CATEGORY_BASE -2147482136
#define KGB$K_INT_CATEGORY_BASE -2147482072
 
#pragma standard

#endif					/* __KGBDEF_LOADED */
#ifndef __LADEF_LOADED
#define __LADEF_LOADED	1

/*** MODULE $ladef ***/
/*+                                                                         */
/*                                                                          */
/* LPA-11 CHARACTERISTICS DEFINITIONS                                       */
/*                                                                          */
/*-                                                                         */
/*MICROCODE TYPE VALUES                                                     */
#define LA$K_MRMCODE 1                  /* MULTIREQUEST MICROCODE           */
#define LA$K_ADMCODE 2                  /* DEDICATED A/D MICROCODE          */
#define LA$K_DAMCODE 3                  /* DEDICATED D/A MICROCODE          */
#define LA$M_MCVALID 1
#define LA$M_CLOCKA 8
#define LA$M_CLOCKB 16
#define LA$M_AD1 32
#define LA$M_AD2 64
#define LA$M_DA 128
#define LA$M_DIO1 256
#define LA$M_DIO2 512
#define LA$M_DIO3 1024
#define LA$M_DIO4 2048
#define LA$M_DIO5 4096
#define LA$M_BFROVRN 8388608
union ladef {
#pragma nostandard
    variant_struct  {
        unsigned la$v_mcvalid : 1;      /* MICROCODE VALID                  */
        unsigned la$v_mctype : 2;       /* MICROCODE TYPE                   */
        unsigned la$v_config : 10;      /* DEVICE CONFIGURATION BITS        */
        unsigned la$v_rate : 3;         /* CLOCK RATE                       */
        unsigned la$v_preset : 16;      /* CLOCK PRESET                     */
        } la$r_ladef_bits0;
    variant_struct  {
        unsigned ladef$$_fill_1 : 3;    /* SKIP OVER MICROCODE VALID AND TYPE  */
        unsigned la$v_clocka : 1;       /* CLOCK A                          */
        unsigned la$v_clockb : 1;       /* CLOCK B                          */
        unsigned la$v_ad1 : 1;          /* A/D ! 1                          */
        unsigned la$v_ad2 : 1;          /* A/D ! 2                          */
        unsigned la$v_da : 1;           /* D/A                              */
        unsigned la$v_dio1 : 1;         /* DIGITAL I/O ! 1                  */
        unsigned la$v_dio2 : 1;         /* DIGITAL I/O ! 2                  */
        unsigned la$v_dio3 : 1;         /* DIGITAL I/O ! 3                  */
        unsigned la$v_dio4 : 1;         /* DIGITAL I/O ! 4                  */
        unsigned la$v_dio5 : 1;         /* DIGITAL I/O ! 5                  */
        unsigned la$v_fill_37 : 3;
        } la$r_ladef_bits1;
    variant_struct  {
        unsigned ladef$$_fill_2 : 23;   /*(IN USER'S COMMAND TABLE)         */
        unsigned la$v_bfrovrn : 1;      /* BUFFER OVERRUN NON-FATAL BIT     */
        } la$r_ladef_bits2;
    } ;
 
#pragma standard

#endif					/* __LADEF_LOADED */
#ifndef __LATDEF_LOADED
#define __LATDEF_LOADED	1

/*** MODULE $latdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 00:43:09.31 */
/*                                                                          */
/*                                                                          */
/* MODULE:  LATMSG.MSG                                                      */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984, 1985, 1987 BY			    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/* VERSION:	'V05-002'                                                   */
/*                                                                          */
/*	V05-002	JFC0015		JAMES F. CAHILL			10-AUG-1987 */
/*		FIX CAPITALIZATION PROBLEMS                                 */
/*                                                                          */
/*	V05-001			(VARIOUS AUTHORS)                           */
/*		INITIAL VERSION                                             */
/*                                                                          */
/* THIS FILE REPRESENTS THE MERGE OF ERROR MESSAGES FOR LATCP, LAT, AND LGU */
/* LATCP MESSAGES APPEAR FIRST AS THIS FACILITY HAS BEEN SHIPPED. WHILE THE */
/* ERROR NAMES ARE CHANGED WITH THE ASSIGNMENT OF A LAT FACILITY CODE, THE  */
/* ERROR MESSAGE NUMBERS/MEANINGS ARE NOT. NEW ERROR MESSAGES ARE ADDED     */
/* AT THE SECTION BELOW WHERE .BASE VALUES HAVE BEEN ASSIGNED.              */
/*                                                                          */
#define LAT$_FACILITY 374
#define LAT$_CMDBUFOVFLW 24543244
#define LAT$_CANTBIND 24543250
#define LAT$_IVCMD 24543258
#define LAT$_IVDEV 24543266
#define LAT$_IVQUAL 24543274
#define LAT$_MAXSERV 24543282
#define LAT$_NOTERMS 24543290
#define LAT$_NONODE 24543298
#define LAT$_NOTLOADED 24543306
#define LAT$_NOTINITED 24543314
#define LAT$_NOTSTARTED 24543322
#define LAT$_NOTSTOPPED 24543330
#define LAT$_NOTSET 24543338
#define LAT$_NOHISTORY 24543346
#define LAT$_NOSTARTHIST 24543354
#define LAT$_NOSUCHSERV 24543362
#define LAT$_NOTFROMLAT 24543370
#define LAT$_INTERNAL 24543378
#define LAT$_SERVEXISTS 24543386
#define LAT$_LOCKED 24543394
#define LAT$_UNDEFLINK 24543402
#define LAT$_LINKEXISTS 24543410
#define LAT$_LINKACTIVE 24543418
#define LAT$_MAXLINKS 24543426
#define LAT$_NOLINK 24543432
#define LAT$_STARTED 24543443
#define LAT$_STOPPED 24543451
#define LAT$_SET 24543459
#define LAT$_NOSERVERS 24543467
/*                                                                          */
/* NEW MESSAGES ARE ADDED ONLY IN THE SECTIONS BELOW                        */
/*                                                                          */
#define LAT$_ALREADYDEF 24544835
#define LAT$_NOTDEF 24544843
#define LAT$_NOCONTEXT 24544851
#define LAT$_LOGSTOPPED 24546434
#define LAT$_CONTEXTINIT 24546442
#define LAT$_ILLSTRUCT 24546450
#define LAT$_CONSISTANCY 24546458
/*                                                                          */
/* LAT CONNECTION REJECTION REASON CODES. THESE MESSAGES CORRESPOND TO      */
/* THE REJECTION REASON CODES GENERATED BY LTDRIVER WHEN A CONNECTION       */
/* REQUEST IS ABORTED (IE. FAILS). THE REASON CODE IS RETURNED IN PART      */
/* OF THE IOSB AND MAY BE TRANSLATED TO THE CORRESPONDING CODE BELOW        */
/* WITH A SIMPLE TRANSLATION VECTOR.                                        */
/*                                                                          */
#define LAT$_LRJUNKNOWN 24551236
#define LAT$_LRJSHUTDOWN 24551244
#define LAT$_LRJRESOURCE 24551252
#define LAT$_LRJINUSE 24551260
#define LAT$_LRJNOSERVICE 24551268
#define LAT$_LRJDISABLE 24551276
#define LAT$_LRJNOTOFFERED 24551284
#define LAT$_LRJNAMEUNKNOWN 24551292
#define LAT$_LRJACCESSREJECT 24551300
#define LAT$_LRJACCESSDENIED 24551308
#define LAT$_LRJCORRUPT 24551316
#define LAT$_LRJNOTSUPPORT 24551324
#define LAT$_LRJNOSTART 24551332
#define LAT$_LRJDELETED 24551340
#define LAT$_LRJILLEGAL 24551348
#define LAT$_CONTIMEOUT 24551356
#define LAT$_CONAPPLICATION 24551364

#endif					/* __LATDEF_LOADED */
#ifndef __LBRCTLTBL_LOADED
#define __LBRCTLTBL_LOADED	1

/*** MODULE $lbrctltbl ***/
#define LBR$C_CTLTBLID 203              /* Ident for control table          */
#define LBR$M_LOCATE 1
#define LBR$M_OPEN 2
#define LBR$K_LENGTH 30
#define LBR$C_LENGTH 30
struct lbrctltbl {
    unsigned char lbr$b_id;             /* Control table ID                 */
    unsigned char lbr$b_tblsiz;         /* Control table size               */
    unsigned char lbr$b_type;           /* Type of library opened           */
    unsigned char lbr$b_func;           /* Operation (function) requested   */
    char lbrctltbl$$_fill_1 [2];        /* Reserved extra bytes             */
#pragma nostandard
    variant_union  {
        unsigned long int lbr$l_usrflg; /* Flags longword                   */
        variant_struct  {
            unsigned lbr$v_locate : 1;  /* Use "locate" rather than "move" mode  */
            unsigned lbr$v_open : 1;    /* Library open                     */
            unsigned lbr$v_fill_0 : 6;
            } lbr$r_usrflg_bits;
        } lbr$r_usrflg_overlay;
    unsigned long int lbr$l_hdrptr;     /* Pointer to in-core header        */
    unsigned long int lbr$l_ctxptr;     /* Pointer to context control block  */
    unsigned long int lbr$l_curidx;     /* Number of current index          */
    unsigned long int lbr$l_usrnam;     /* Pointer to user NAM block        */
    unsigned long int lbr$l_oldhdrptr;  /* Pointer to unmodified in-core header block  */
    } ;
 
#pragma standard

#endif					/* __LBRCTLTBL_LOADED */
#ifndef __LBRDEF_LOADED
#define __LBRDEF_LOADED	1

/*** MODULE $lbrdef ***/
/*                                                                          */
/* Types of libraries                                                       */
/*                                                                          */
/* Define the library types                                                 */
#define LBR$C_TYP_UNK 0                 /* Unknown/unspecified library type  */
#define LBR$C_TYP_OBJ 1                 /* Object/shareable image library   */
#define LBR$C_TYP_MLB 2                 /* Macro library                    */
#define LBR$C_TYP_HLP 3                 /* Help file library                */
#define LBR$C_TYP_TXT 4                 /* TEXT library                     */
#define LBR$C_TYP_SHSTB 5               /* Shareable image symbol library   */
#define LBR$C_TYP_NCS 6                 /* NCS library                      */
#define LBR$C_TYP_DECMX 6               /* Maximum Digital library type defined  */
#define LBR$C_TYP_RDEC 127              /* Types between DECMX and RDEC are  */
/*   reserved to Digital                                                    */
#define LBR$C_TYP_USRLW 128             /* User library types range from 128  */
#define LBR$C_TYP_USRHI 255             /* to 255.                          */
/*                                                                          */
/* Function codes for lbr$flush                                             */
/*                                                                          */
#define LBR$C_FLUSHDATA 1               /* Flush data blocks from cache     */
#define LBR$C_FLUSHALL 0                /* Flush data blocks, then index blocks  */
/*                                                                          */
/* Librarian fixed parameters                                               */
/*                                                                          */
#define LBR$C_MAXRECSIZ 2048            /* Maximum record size allowed      */
#define LBR$C_PAGESIZE 512              /* Size of memory page              */
#define LBR$C_HASHSIZE 512              /* Size of hash table ** Must be power of 2 **  */
#define LBR$C_TEXTPAGE 508              /* No. of useable bytes on a text page  */
#define LBR$C_DEXTQ 50                  /* Library default extend quantity  */
#define LBR$C_MAXCTL 16                 /* Maximum number of open libraries  */
#define LBR$C_MAXHDRSIZ 128             /* Maximum length of module header  */
/*  (max user length is:                                                    */
/*   lbr$c_maxhdrsiz-mhd$c_length)                                          */
#define LBR$C_DEFENTALL 300             /* Number of entries to allocate by default  */
#define LBR$C_RETRYOPEN 120             /* Number of times to retry open on RMS$_FLK  */
#define LBR$C_RETRYWAIT 1               /* Number of seconds to wait        */
#define LBR$C_MINREAD 2                 /* Minimum number of blocks to read  */
#define LBR$C_MAXREAD 50                /* Max blocks can ever read         */
#define LBR$C_MEMXTRA 50                /* Number blocks to expand region by above and beyond lbr$gl_maxread  */
#define LBR$C_PUTBUFSIZ 30              /* Block size of VM empty cache buffer  */
#define LBR$C_FLSHBFSIZ 1               /* Block size of stack mt_cache buffer  */
#define LBR$C_MAXIDXRD 20               /* Maximum blocks in one index read  */
#define LBR$C_MAXKEYLEN 128             /* Maximum length of an ASCII keyword, at most N, where  */
/* 3*(N+7) < or = 506                                                       */
#define LBR$C_MAXLUHREC 32768           /* maximum library update history record length  */
/*                                                                          */
/* LBR$INI_CONTROL argument list                                            */
/*                                                                          */
#define LBR$C_CREATE 0                  /* Create a new library             */
#define LBR$C_READ 1                    /* Read an existing library         */
#define LBR$C_UPDATE 2                  /* Update an exisiting library      */
#define LBR$C_MAXFUNC 2                 /* Maximum legal function           */
struct lbrdef {
    long int lbrdef$$_fill_1;           /* Argument count                   */
    unsigned long int lbr$l_ic_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_ic_func;    /* Function                         */
    unsigned long int lbr$l_ic_type;    /* Type of library expected to open  */
/*                                                                          */
/* LBR$OPEN argument list                                                   */
/*                                                                          */
    } ;
struct lbrdef1 {
    long int lbrdef$$_fill_2;           /* Argument count                   */
    unsigned long int lbr$l_op_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_op_fns;     /* Address of string descriptor for filename  */
    unsigned long int lbr$l_op_creopt;  /* Address of create options array  */
    unsigned long int lbr$l_op_dns;     /* Address of descriptor for default name string  */
    unsigned long int lbr$l_op_rlfna;   /* Address of NAM block for related file  */
    unsigned long int lbr$l_op_rns;     /* Address of descriptor for related filename string  */
    unsigned long int lbr$l_op_rnslen;  /* Address of longword to store resultant filename string length  */
/*                                                                          */
/* LBR$CLOSE argument list                                                  */
/*                                                                          */
    } ;
struct lbrdef2 {
    long int lbrdef$$_fill_3;           /* Argument count                   */
    unsigned long int lbr$l_cl_ctltbl;  /* Control index address            */
/*                                                                          */
/* LBR$GET_HEADER argument list                                             */
/*                                                                          */
    } ;
struct lbrdef3 {
    long int lbrdef$$_fill_4;           /* Argument count                   */
    unsigned long int lbr$l_gh_ctltbl;  /* Address of Control index         */
    unsigned long int lbr$l_gh_retary;  /* Address of 128-longword array for return info  */
/*                                                                          */
/* LBR$SET_INDEX argument list                                              */
/*                                                                          */
    } ;
struct lbrdef4 {
    long int lbrdef$$_fill_5;           /* Argument count                   */
    unsigned long int lbr$l_si_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_si_idxnum;  /* Address of index number          */
/*                                                                          */
/* LBR$LOOKUP_KEY argument list                                             */
/*                                                                          */
    } ;
struct lbrdef5 {
    long int lbrdef$$_fill_6;           /* Argument count                   */
    unsigned long int lbr$l_lk_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_lk_keynam;  /* Address of string descriptor or binary value  */
    unsigned long int lbr$l_lk_txtrfa;  /* Address of quadword to return RFA if found  */
/*                                                                          */
/* LBR$INSERT_KEY argument list                                             */
/*                                                                          */
    } ;
struct lbrdef6 {
    long int lbrdef$$_fill_7;           /* Argument count                   */
    unsigned long int lbr$l_ik_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_ik_keynam;  /* Address of string descriptor or binary value  */
    unsigned long int lbr$l_ik_txtrfa;  /* Address of RFA of text           */
/*                                                                          */
/* LBR$REPLACE_MOD argument list                                            */
/*                                                                          */
/*        F        ,L,1                         Argument count            */
/*        F        RM_CTLTBL,L                 Control index address      */
/*        F        RM_KEYNAM,L                 Address of string descriptor or binary value */
/*        F        RK_TXTRFA,L                 RFA of new text            */
/*        P        1                                                        */
/*                                                                          */
/* LBR$REPLACE_KEY argument list                                            */
/*                                                                          */
    } ;
struct lbrdef7 {
    long int lbrdef$$_fill_8;           /* Argument count                   */
    unsigned long int lbr$l_rk_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_rk_keynam;  /* Address of string descriptor or binary value  */
    unsigned long int lbr$l_rk_oldrfa;  /* Address of RFA of old text       */
    unsigned long int lbr$l_rk_newrfa;  /* Address of RFA of new text       */
/*                                                                          */
/* LBR$DELETE_KEY argument list                                             */
/*                                                                          */
    } ;
struct lbrdef8 {
    long int lbrdef$$_fill_9;           /* Argument count                   */
    unsigned long int lbr$l_dk_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_dk_keynam;  /* Address of string descriptor or binary value  */
/*                                                                          */
/* LBR$DELETE_DATA argument list                                            */
/*                                                                          */
    } ;
struct lbrdef9 {
    long int lbrdef$$_fill_10;          /* Argument count                   */
    unsigned long int lbr$l_dd_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_dd_txtrfa;  /* Address of RFA to delete from    */
/*                                                                          */
/* LBR$GET_RECORD argument list                                             */
/*                                                                          */
    } ;
struct lbrdef10 {
    long int lbrdef$$_fill_11;          /* Argument count                   */
    unsigned long int lbr$l_gr_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_gr_bufdes;  /* Address of descriptor of buffer  */
    unsigned long int lbr$l_gr_buflen;  /* Address of longword to return record size  */
/*                                                                          */
/* LBR$PUT_RECORD argument list                                             */
/*                                                                          */
    } ;
struct lbrdef11 {
    long int lbrdef$$_fill_12;          /* Argument count                   */
    unsigned long int lbr$l_pr_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_pr_bufdes;  /* Address of descriptor of buffer to output  */
    unsigned long int lbr$l_pr_txtrfa;  /* Address of quadword to return RFA  */
/*  of text record                                                          */
/*                                                                          */
/* LBR$PUT_END argument list                                                */
/*                                                                          */
    } ;
struct lbrdef12 {
    long int lbrdef$$_fill_13;          /* Argument count                   */
    unsigned long int lbr$l_pe_ctltbl;  /* Control index address            */
/*                                                                          */
/* LBR$SEARCH argument list                                                 */
/*                                                                          */
    } ;
struct lbrdef13 {
    long int lbrdef$$_fill_14;          /* Argument count                   */
    unsigned long int lbr$l_sr_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_sr_idxnum;  /* Address of index number          */
    unsigned long int lbr$l_sr_rfa;     /* Address of RFA to search index for  */
    unsigned long int lbr$l_sr_usrtn;   /* User routine to call on match    */
/*                                                                          */
/* Argument list for user routine called by LBR$SEARCH                      */
/*                                                                          */
    } ;
struct lbrdef14 {
    long int lbrdef$$_fill_15;          /* Argument count                   */
    unsigned long int lbr$l_su_keydes;  /* Address of string descriptor or binary value  */
    unsigned long int lbr$l_su_txtrfa;  /* Address of array containing rfa of module  */
/*                                                                          */
/* LBR$GET_INDEX argument list                                              */
/*                                                                          */
    } ;
struct lbrdef15 {
    long int lbrdef$$_fill_16;          /* Argument count                   */
    unsigned long int lbr$l_gi_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_gi_idxnum;  /* Index number                     */
    unsigned long int lbr$l_gi_usrtn;   /* User routine to call for each entry  */
/*                                                                          */
/* Argument list for user routine called by LBR$GET_INDEX                   */
/*                                                                          */
    } ;
struct lbrdef16 {
    long int lbrdef$$_fill_17;          /* Argument count                   */
    unsigned long int lbr$l_gu_keyadr;  /* Address of descriptor or binary value  */
    unsigned long int lbr$l_gu_txtrfa;  /* RFA of associated text           */
/*                                                                          */
/* LBR$ADD_UPDATE argument list                                             */
/*                                                                          */
    } ;
#define LBR$C_ADDMOD 1                  /* Add module                       */
#define LBR$C_DELMOD 2                  /* Delete module                    */
#define LBR$C_REPMOD 3                  /* Replace module                   */
/*                                                                          */
struct lbrdef17 {
    long int lbrdef$$_fill_18;          /* Argument count                   */
    unsigned long int lbr$l_au_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_au_flags;   /* Flags                            */
    unsigned long int lbr$l_au_keynam;  /* Address of string descriptor or binary value  */
/* Types of operations logged                                               */
/* LBR$GET_UPDATES argument list                                            */
/*                                                                          */
    } ;
struct lbrdef18 {
    long int lbrdef$$_fill_19;          /* Argument count                   */
    unsigned long int lbr$l_gu_ctltbl;  /* Control index address            */
    unsigned long int lbr$l_gu_usrtn;   /* User routine to call for each update  */
/*                                                                          */
/* Argument list for user routine called by LBR$GET_UPDATES                 */
/*                                                                          */
    } ;
struct lbrdef19 {
    long int lbrdef$$_fill_20;          /* Argument list                    */
    unsigned long int lbr$l_uu_updesc;  /* String descriptor for history line  */
    } ;
 

#endif					/* __LBRDEF_LOADED */
#ifndef __LCKDEF_LOADED
#define __LCKDEF_LOADED	1

/*** MODULE $lckdef ***/
/*+                                                                         */
/* LOCK MANAGER DEFINITIONS                                                 */
/*-                                                                         */
#define LCK$M_VALBLK 1
#define LCK$M_CONVERT 2
#define LCK$M_NOQUEUE 4
#define LCK$M_SYNCSTS 8
#define LCK$M_SYSTEM 16
#define LCK$M_NOQUOTA 32
#define LCK$M_CVTSYS 64
#define LCK$M_RECOVER 128
#define LCK$M_PROTECT 256
#define LCK$M_NODLCKWT 512
#define LCK$M_NODLCKBLK 1024
#define LCK$M_DEQALL 1
#define LCK$M_CANCEL 2
#define LCK$M_INVVALBLK 4
#define LCK$K_NLMODE 0                  /* NULL                             */
#define LCK$K_CRMODE 1                  /* CONCURRENT READ                  */
#define LCK$K_CWMODE 2                  /* CONCURRENT WRITE                 */
#define LCK$K_PRMODE 3                  /* PROTECTED READ                   */
#define LCK$K_PWMODE 4                  /* PROTECTED WRITE                  */
#define LCK$K_EXMODE 5                  /* EXCLUSIVE                        */
#pragma nostandard
union lckdef {
    variant_struct  {
        unsigned lck$v_valblk : 1;      /* VALUE BLOCK INCLUDED             */
        unsigned lck$v_convert : 1;     /* CONVERSION REQUEST               */
        unsigned lck$v_noqueue : 1;     /* DO NOT QUEUE REQUEST             */
        unsigned lck$v_syncsts : 1;     /* SYNCHRONOUS STATUS REQUESTED     */
        unsigned lck$v_system : 1;      /* SYSTEM LOCK                      */
        unsigned lck$v_noquota : 1;     /* DON'T CHARGE QUOTA               */
        unsigned lck$v_cvtsys : 1;      /* CONVERT TO SYSTEM                */
        unsigned lck$v_recover : 1;     /* RECOVER LOCK DURING FAILOVER     */
        unsigned lck$v_protect : 1;     /* PROTECT LOCK DURING FAILOVER     */
        unsigned lck$v_nodlckwt : 1;    /* NO DEADLOCK WAITING              */
        unsigned lck$v_nodlckblk : 1;   /* NO DEADLOCK BLOCKING             */
        unsigned lck$v_fill_38 : 5;
        } lck$r_lckdef_bits0;
    variant_struct  {
        unsigned lck$v_deqall : 1;      /* DEQUEUE ALL LOCKS                */
        unsigned lck$v_cancel : 1;      /* CANCEL REQUEST                   */
        unsigned lck$v_invvalblk : 1;   /* INVALIDATE VALUE BLOCK           */
        unsigned lck$v_fill_39 : 5;
        } lck$r_lckdef_bits1;
/*LOCK MODES                                                                */
    } ;
#pragma standard

#endif					/* __LCKDEF_LOADED */
#ifndef __LEPMDEF_LOADED
#define __LEPMDEF_LOADED	1

/*** MODULE $lepmdef ***/
/*                                                                          */
/* GSD entry - Module local entry point definition                          */
/*                                                                          */
#define LEPM$K_NAME 15
#define LEPM$C_NAME 15
struct lepmdef {
#pragma nostandard
    variant_union  {
        unsigned char lepm$b_gsdtyp;    /*Maps over LSY$B_GSDTYP            */
        variant_struct  {
            char lepm$t_start [];
            char lepmdef$$_fill_1;
            } lepm$r_gsdtyp_fields;
        } lepm$r_gsdtyp_overlay;
    unsigned char lepm$b_datyp;         /*Maps over LSY$B_DATYP             */
    unsigned short int lepm$w_flags;    /*Maps over LSY$W_FLAGS             */
    unsigned short int lepm$w_envindx;  /*Environment index symbol defined in  */
    unsigned short int lepm$w_psindx;   /*Maps over LSDF$W_PSINDX           */
    unsigned long int lepm$l_addrs;     /*Entry point address, maps         */
/* over LSDF$L_VALUE                                                        */
    unsigned short int lepm$w_mask;     /*Entry point mask                  */
    unsigned char lepm$b_namlng;        /*Length of name                    */
    char lepm$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __LEPMDEF_LOADED */
#ifndef __LHIDEF_LOADED
#define __LHIDEF_LOADED	1

/*** MODULE $lhidef ***/
/*                                                                          */
/* Library header information array offsets                                 */
/*                                                                          */
struct lhidef {
    unsigned long int lhi$l_type;       /* Library type                     */
    unsigned long int lhi$l_nindex;     /* Number of indices                */
    unsigned long int lhi$l_majorid;    /* Library format major id          */
    unsigned long int lhi$l_minorid;    /* Library format minor id          */
    char lhi$t_lbrver [32];             /* ASCIC version of librarian that created  */
    unsigned long int lhi$l_credat;     /* Creation date/time               */
    long int lhidef$$_fill_1;           /* ...                              */
    unsigned long int lhi$l_updtim;     /* Date/time of last update         */
    long int lhidef$$_fill_2;           /* ...                              */
    unsigned long int lhi$l_updhis;     /* VBN of start of update history   */
    unsigned long int lhi$l_freevbn;    /* 1st logically deleted block      */
    unsigned long int lhi$l_freeblk;    /* Number of deleted blocks         */
    unsigned char lhi$b_nextrfa [6];    /* RFA of end of library            */
    unsigned short int lhi$w_rfaxtr;    /* Spare word, zeroed               */
    unsigned long int lhi$l_nextvbn;    /* Next VBN to allocate at end of file  */
    unsigned long int lhi$l_freidxblk;  /* Number of free pre-allocated index blocks  */
    unsigned long int lhi$l_freeidx;    /* Listhead for pre-allocated index blocks  */
    unsigned long int lhi$l_hipreal;    /* VBN of highest pre-allocated block  */
    unsigned long int lhi$l_idxblks;    /* Number of index blocks in use    */
    unsigned long int lhi$l_idxcnt;     /* Number of index entries (total)  */
    unsigned long int lhi$l_modcnt;     /* Number of entries in index 1 (module names)  */
    unsigned long int lhi$l_mhdusz;     /* Length of user-maintained info in module header  */
    unsigned long int lhi$l_maxluhrec;  /* Maximum number of library update histories records maintained  */
    unsigned long int lhi$l_numluhrec;  /* Number of LUH records in history  */
    unsigned long int lhi$l_libstatus;  /* False if there was an error closing lib  */
    } ;
 

#endif					/* __LHIDEF_LOADED */
#ifndef __LIB$ROUTINES_LOADED
#define __LIB$ROUTINES_LOADED	1

/*** MODULE lib$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    LIB$ADAWI                                                             */
/*                                                                          */
/*    Add Adjacent Word with Interlock                                      */
/*                                                                          */
/*    The Add Aligned Word with Interlock routine allows the user to perform an  */
/*    interlocked add operation using an aligned word.                      */
/*                                                                          */
unsigned long int lib$adawi() ;
/*    LIB$ADD_TIMES                                                         */
/*                                                                          */
/*    Add Two Quadword Times                                                */
/*                                                                          */
/*    The Add Two Quadword Times routine adds two VMS internal time format times. */
/*                                                                          */
unsigned long int lib$add_times() ;
/*    LIB$ADDX                                                              */
/*                                                                          */
/*    Add Two Multiple-Precision Binary Numbers                             */
/*                                                                          */
/*    The Add Two Multiple-Precision Binary Numbers routine adds two signed two's */
/*    complement integers of arbitrary length.                              */
/*                                                                          */
unsigned long int lib$addx() ;
/*    LIB$ANALYZE_SDESC                                                     */
/*                                                                          */
/*    Analyze String Descriptors                                            */
/*                                                                          */
/*    The Analyze String Descriptors routine extracts the length and the address at */
/*    which the data starts for a variety of string descriptor classes.     */
/*                                                                          */
unsigned long int lib$analyze_sdesc() ;
/*    LIB$ASN_WTH_MBX                                                       */
/*                                                                          */
/*    Assign Channel with Mailbox                                           */
/*                                                                          */
/*    The Assign Channel with Mailbox routine assigns a channel to a specified device */
/*    and associates a mailbox with the device. It returns both the device channel and */
/*    the mailbox channel.                                                  */
/*                                                                          */
unsigned long int lib$asn_wth_mbx() ;
/*    LIB$AST_IN_PROG                                                       */
/*                                                                          */
/*    AST in Progress                                                       */
/*                                                                          */
/*    The AST in Progress routine indicates whether an AST is currently in progress.  */
/*                                                                          */
char lib$ast_in_prog() ;
/*    LIB$ATTACH                                                            */
/*                                                                          */
/*    Attach Terminal to Process                                            */
/*                                                                          */
/*    The Attach Terminal to Process routine requests the calling process's Command */
/*    Language Interpreter (CLI) to detach the terminal of the calling process and to */
/*    reattach it to a different process.                                   */
/*                                                                          */
unsigned long int lib$attach() ;
/*    LIB$BBCCI                                                             */
/*                                                                          */
/*    Test and Clear Bit with Interlock                                     */
/*                                                                          */
/*    The Test and Clear Bit with Interlock routine tests and clears a selected bit */
/*    under memory interlock. LIB$BBCCI makes the VAX BBCCI instruction available as a */
/*    callable routine.                                                     */
/*                                                                          */
unsigned long int lib$bbcci() ;
/*    LIB$BBSSI                                                             */
/*                                                                          */
/*    Test and Set Bit with Interlock                                       */
/*                                                                          */
/*    The Test and Set Bit with Interlock routine tests and sets a selected bit under */
/*    memory interlock. LIB$BBSSI makes the VAX BBSSI instruction available as a */
/*    callable routine.                                                     */
/*                                                                          */
unsigned long int lib$bbssi() ;
/*    LIB$CALLG                                                             */
/*                                                                          */
/*    Call Routine with General Argument List                               */
/*                                                                          */
/*    The Call Routine with General Argument List routine calls a routine with an */
/*    argument list specified as an array of longwords, the first of which is a count */
/*    of the remaining longwords. LIB$CALLG is a callable version of the VAX CALLG */
/*    instruction.                                                          */
/*                                                                          */
unsigned long int lib$callg() ;
/*    LIB$CREATE_DIR                                                        */
/*                                                                          */
/*    Create a Directory                                                    */
/*                                                                          */
/*    The Create a Directory routine creates a directory or subdirectory.   */
/*                                                                          */
unsigned long int lib$create_dir() ;
/*    LIB$CHAR                                                              */
/*                                                                          */
/*    Transform Byte to First Character of String                           */
/*                                                                          */
/*    The Transform Byte to First Character of String routine transforms a single */
/*    8-bit ASCII character to an ASCII string consisting of a single character */
/*    followed by trailing spaces, if needed, to fill out the string.  The range of */
/*    the input byte is 0 through 255.                                      */
/*                                                                          */
unsigned long int lib$char() ;
/*    LIB$CONVERT_DATE_STRING                                               */
/*                                                                          */
/*    Convert Date String to Quadword                                       */
/*                                                                          */
/*    The Convert Date String to Quadword routine converts an absolute date */
/*    string into a VMS internal format date-time quadword. That is, given  */
/*    an input date/time string of a specified format,                      */
/*    LIB$CONVERT_DATE_STRING converts this string to a VMS internal format  */
/*    time.                                                                 */
/*                                                                          */
unsigned long int lib$convert_date_string() ;
/*    LIB$CRC                                                               */
/*                                                                          */
/*    Calculate a Cyclic Redundancy Check (CRC)                             */
/*                                                                          */
/*    The Calculate a Cyclic Redundancy Check routine calculates the cyclic redundancy */
/*    check (CRC) for a data stream. LIB$CRC makes the VAX CRC instruction available */
/*    as a callable routine.                                                */
/*                                                                          */
unsigned long int lib$crc() ;
/*    LIB$CRC_TABLE                                                         */
/*                                                                          */
/*    Construct a Cyclic Redundancy Check (CRC) Table                       */
/*                                                                          */
/*    The Construct a Cyclic Redundancy Check Table routine constructs a 16-longword */
/*    table that uses a cyclic redundancy check polynomial specification as a bit */
/*    mask.                                                                 */
/*                                                                          */
int lib$crc_table() ;
/*    LIB$CRF_INS_KEY                                                       */
/*                                                                          */
/*    Insert Key in Cross-Reference Table                                   */
/*                                                                          */
/*    The Insert Key in Cross-Reference Table routine inserts information about a key */
/*    into a cross-reference table.                                         */
/*                                                                          */
int lib$crf_ins_key() ;
/*    LIB$CRF_INS_REF                                                       */
/*                                                                          */
/*    Insert Reference to a Key in the Cross-Reference Table                */
/*                                                                          */
/*    The Insert Reference to a Key in the Cross-Reference Table routine inserts a */
/*    reference to a key in a cross-reference symbol table.                 */
/*                                                                          */
int lib$crf_ins_ref() ;
/*    LIB$CRF_OUTPUT                                                        */
/*                                                                          */
/*    Output Cross-Reference Table Information                              */
/*                                                                          */
/*    The Output Cross-Reference Table Information routine extracts the information */
/*    from the cross-reference tables and formats the output pages.         */
/*                                                                          */
int lib$crf_output() ;
/*    LIB$CURRENCY                                                          */
/*                                                                          */
/*    Get System Currency Symbol                                            */
/*                                                                          */
/*    The Get System Currency Symbol routine returns the system's currency symbol.  */
/*                                                                          */
unsigned long int lib$currency() ;
/*    LIB$CREATE_USER_VM_ZONE                                               */
/*                                                                          */
/*    Create User-Defined Storage Zone                                      */
/*                                                                          */
/*    The Create User-Defined Storage Zone routine creates a new user-defined storage */
/*    zone.                                                                 */
/*                                                                          */
unsigned long int lib$create_user_vm_zone() ;
/*    LIB$CVT_DX_DX                                                         */
/*                                                                          */
/*    General Data Type Conversion Routine                                  */
/*                                                                          */
/*    The General Data Type Conversion routine converts a VAX standard atomic or string datum described by a */
/*    source descriptor to another VAX standard atomic or string datum described */
/*    by a destination descriptor. This conversion is supported over a subset of */
/*    the VAX standard data types.                                          */
/*                                                                          */
unsigned long int lib$cvt_dx_dx() ;
/*    LIB$CVTF_FROM_INTERNAL_TIME                                           */
/*                                                                          */
/*    Convert Internal Time to External Time (F-floating Point Value)       */
/*                                                                          */
/*    The Convert Internal Time to External Time (F-floating point value)   */
/*    routine converts a delta internal VMS system time into an external    */
/*    F-floating time.                                                      */
/*                                                                          */
unsigned long int lib$cvtf_from_internal_time() ;
/*    LIB$CVT_FROM_INTERNAL_TIME                                            */
/*                                                                          */
/*    Convert Internal Time to External Time                                */
/*                                                                          */
/*    The Convert Internal Time to External Time routine converts an internal VMS system time  */
/*    (either absolute or delta) into an external time.                     */
/*                                                                          */
unsigned long int lib$cvt_from_internal_time() ;
/*    LIB$CVTF_TO_INTERNAL_TIME                                             */
/*                                                                          */
/*    Convert External Time to Internal Time (F-Floating Point Value)       */
/*                                                                          */
/*    The Convert External Time to Internal Time (F-floating point value) routine  */
/*    converts an external time interval into a VMS internal format F-floating delta */
/*    time.                                                                 */
/*                                                                          */
unsigned long int lib$cvtf_to_internal_time() ;
/*    LIB$CVT_TO_INTERNAL_TIME                                              */
/*                                                                          */
/*    Convert External Time to Internal Time                                */
/*                                                                          */
/*    The Convert External Time to Internal Time routine converts an external time */
/*    interval into a VMS internal format delta time.                       */
/*                                                                          */
unsigned long int lib$cvt_to_internal_time() ;
/*    LIB$CVT_VECTIM                                                        */
/*                                                                          */
/*    Convert Seven-Word Vector to Internal Time                            */
/*                                                                          */
/*    The Convert Seven-Word Vector to Internal Time routine converts a     */
/*    seven-word vector                                                     */
/*    into a VMS internal format delta or absolute time.                    */
/*                                                                          */
unsigned long int lib$cvt_vectim() ;
/*    LIB$CVT_DTB                                                           */
/*                                                                          */
/*    Convert Numeric Text to Binary                                        */
/*                                                                          */
/*    The Convert Numeric Text to Binary routines return a binary representation of */
/*    the ASCII text string representation of a decimal, hexadecimal, or octal number. */
/*                                                                          */
unsigned long int lib$cvt_dtb() ;
/*    LIB$CVT_HTB                                                           */
/*                                                                          */
/*    Convert Numeric Text to Binary                                        */
/*                                                                          */
/*    The Convert Numeric Text to Binary routines return a binary representation of */
/*    the ASCII text string representation of a decimal, hexadecimal, or octal number. */
/*                                                                          */
unsigned long int lib$cvt_htb() ;
/*    LIB$CVT_OTB                                                           */
/*                                                                          */
/*    Convert Numeric Text to Binary                                        */
/*                                                                          */
/*    The Convert Numeric Text to Binary routines return a binary representation of */
/*    the ASCII text string representation of a decimal, hexadecimal, or octal number. */
/*                                                                          */
unsigned long int lib$cvt_otb() ;
/*    LIB$CREATE_VM_ZONE                                                    */
/*                                                                          */
/*    Create a New Zone                                                     */
/*                                                                          */
/*    The Create a New Zone routine creates a new storage zone according to specified */
/*    arguments.                                                            */
/*                                                                          */
unsigned long int lib$create_vm_zone() ;
/*    LIB$DATE_TIME                                                         */
/*                                                                          */
/*    Date and Time Returned as a String                                    */
/*                                                                          */
/*    The Date and Time Returned as a String routine returns the VMS system date */
/*    and time in the semantics of a user-provided string.                  */
/*                                                                          */
unsigned long int lib$date_time() ;
/*    LIB$DAY                                                               */
/*                                                                          */
/*    Day Number Returned as a Longword Integer                             */
/*                                                                          */
/*    The Day Number Returned as a Longword Integer routine returns the number of days */
/*    since the system zero date of November 17, 1858, or the number of days from */
/*    November 17, 1858, to a user-supplied date.                           */
/*                                                                          */
unsigned long int lib$day() ;
/*    LIB$DAY_OF_WEEK                                                       */
/*                                                                          */
/*    Show Numeric Day of Week                                              */
/*                                                                          */
/*    The Show Numeric Day of Week routine returns the numeric day of the week for an */
/*    input time value. If 0 is the input time value, the current day of the week is */
/*    returned.  The days are numbered 1 through 7, with Monday as day 1 and Sunday as */
/*    day 7.                                                                */
/*                                                                          */
unsigned long int lib$day_of_week() ;
/*    LIB$DEC_OVER                                                          */
/*                                                                          */
/*    Enable or Disable Decimal Overflow Detection                          */
/*                                                                          */
/*    The Enable or Disable Decimal Overflow Detection routine enables or disables */
/*    decimal overflow detection for the calling routine activation.  The previous */
/*    decimal overflow setting is returned.                                 */
/*                                                                          */
unsigned long int lib$dec_over() ;
/*    LIB$DECODE_FAULT                                                      */
/*                                                                          */
/*    Decode Instruction Stream During Fault                                */
/*                                                                          */
/*    The Decode Instruction Stream During Fault routine is a tool for building */
/*    condition handlers that process instruction fault exceptions.  It is called */
/*    from a condition handler.                                             */
/*                                                                          */
unsigned long int lib$decode_fault() ;
/*    LIB$DELETE_FILE                                                       */
/*                                                                          */
/*    Delete One Or More Files                                              */
/*                                                                          */
/*    The Delete One or More Files routine deletes one or more files. The   */
/*    specification of the file(s) to be deleted may include wildcards.     */
/*                                                                          */
/*    LIB$DELETE_FILE is similar in function to the DCL command DELETE.     */
/*                                                                          */
unsigned long int lib$delete_file() ;
/*    LIB$DIGIT_SEP                                                         */
/*                                                                          */
/*    Get Digit Separator Symbol                                            */
/*                                                                          */
/*    The Get Digit Separator Symbol routine returns the system's digit separator */
/*    symbol.                                                               */
/*                                                                          */
unsigned long int lib$digit_sep() ;
/*    LIB$DISABLE_CTRL                                                      */
/*                                                                          */
/*    Disable CLI Interception of Control Characters                        */
/*                                                                          */
/*    The Disable CLI Interception of Control Characters routine requests the calling */
/*    process's Command Language Interpreter (CLI) to not intercept the selected */
/*    control characters when they are typed during an interactive terminal session. */
/*    LIB$DISABLE_CTRL provides the same function as the DCL command SET NOCONTROL.  */
/*                                                                          */
unsigned long int lib$disable_ctrl() ;
/*    LIB$DELETE_LOGICAL                                                    */
/*                                                                          */
/*    Delete Logical Name                                                   */
/*                                                                          */
/*    The Delete Logical Name routine requests the calling process's Command Language */
/*    Interpreter (CLI) to delete a supervisor-mode process logical name.   */
/*    LIB$DELETE_LOGICAL provides the same function as the DCL command DEASSIGN.  */
/*                                                                          */
unsigned long int lib$delete_logical() ;
/*    LIB$DO_COMMAND                                                        */
/*                                                                          */
/*    Execute Command                                                       */
/*                                                                          */
/*    The Execute Command routine stops program execution and directs the Command */
/*    Language Interpreter to execute a command which you supply as the argument. If */
/*    successful, LIB$DO_COMMAND does not return control to the calling program. */
/*    Instead, LIB$DO_COMMAND begins execution of the specified command.    */
/*                                                                          */
/*    If you want control to return to the caller, use LIB$SPAWN instead.   */
/*                                                                          */
unsigned long int lib$do_command() ;
/*    LIB$DELETE_SYMBOL                                                     */
/*                                                                          */
/*    Delete CLI Symbol                                                     */
/*                                                                          */
/*    The Delete CLI Symbol routine requests the calling process's Command Language */
/*    Interpreter (CLI) to delete an existing CLI symbol.                   */
/*                                                                          */
unsigned long int lib$delete_symbol() ;
/*    LIB$FORMAT_DATE_TIME                                                  */
/*                                                                          */
/*    Format Date And/Or Time                                               */
/*                                                                          */
/*    The Format Date And/Or Time routine allows the user to select at run time a */
/*    specific output language and format for a date or time, or both.      */
/*                                                                          */
unsigned long int lib$format_date_time() ;
/*    LIB$DELETE_VM_ZONE                                                    */
/*                                                                          */
/*    Delete Virtual Memory Zone                                            */
/*                                                                          */
/*    The Delete Virtual Memory Zone routine deletes a zone and returns all pages */
/*    owned by the zone to the processwide page pool.                       */
/*                                                                          */
unsigned long int lib$delete_vm_zone() ;
/*    LIB$EDIV                                                              */
/*                                                                          */
/*    Extended-Precision Divide                                             */
/*                                                                          */
/*    The Extended-Precision Divide routine performs extended-precision division. */
/*    LIB$EDIV makes the VAX EDIV instruction available as a callable routine.  */
/*                                                                          */
unsigned long int lib$ediv() ;
/*    LIB$EMODD                                                             */
/*                                                                          */
/*    Extended Multiply and Integerize Routines for D-floating Point Values */
/*                                                                          */
/*    The Extended Multiply and Integerize routine (D-floating point values) allows */
/*    higher-level language users to perform accurate range reduction of D-floating */
/*    arguments.                                                            */
/*                                                                          */
unsigned long int lib$emodd() ;
/*    LIB$EMODF                                                             */
/*                                                                          */
/*    Extended Multiply and Integerize Routines for F-floating Point Values */
/*                                                                          */
/*    The Extended Multiply and Integerize routine (F-floating point values) allows */
/*    higher-level language users to perform accurate range reduction of F-floating */
/*    arguments.                                                            */
/*                                                                          */
unsigned long int lib$emodf() ;
/*    LIB$EMODG                                                             */
/*                                                                          */
/*    Extended Multiply and Integerize Routines for G-floating Point Values */
/*                                                                          */
/*    The Extended Multiply and Integerize routine (G-floating point values) allows */
/*    higher-level language users to perform accurate range reduction of G-floating */
/*    arguments.                                                            */
/*                                                                          */
unsigned long int lib$emodg() ;
/*    LIB$EMODH                                                             */
/*                                                                          */
/*    Extended Multiply and Integerize Routines for H-floating Point Values */
/*                                                                          */
/*    The Extended Multiply and Integerize routine (H-floating point values) allows */
/*    higher-level language users to perform accurate range reduction of H-floating */
/*    arguments.                                                            */
/*                                                                          */
unsigned long int lib$emodh() ;
/*    LIB$EMUL                                                              */
/*                                                                          */
/*    Extended-Precision Multiply                                           */
/*                                                                          */
/*    The Extended-Precision Multiply routine performs extended-precision   */
/*    multiplication. LIB$EMUL makes the VAX EMUL instruction available as a callable */
/*    routine.                                                              */
/*                                                                          */
unsigned long int lib$emul() ;
/*    LIB$ENABLE_CTRL                                                       */
/*                                                                          */
/*    Enable CLI Interception of Control Characters                         */
/*                                                                          */
/*    The Enable CLI Interception of Control Characters routine requests the calling */
/*    process's Command Language Interpreter (CLI) to resume interception of the */
/*    selected control characters when they are typed during an interactive terminal */
/*    session. LIB$ENABLE_CTRL provides the same function as the DCL command SET */
/*    CONTROL.                                                              */
/*                                                                          */
unsigned long int lib$enable_ctrl() ;
/*    LIB$ESTABLISH                                                         */
/*                                                                          */
/*    Establish a Condition Handler                                         */
/*                                                                          */
/*    The Establish a Condition Handler routine moves the address of a condition */
/*    handling routine (which can be a user-written or a library routine) to */
/*    longword 0 of the stack frame of the caller of LIB$ESTABLISH.         */
/*                                                                          */
int *lib$establish() ;
/*    LIB$EXTV                                                              */
/*                                                                          */
/*    Extract a Field and Sign-Extend                                       */
/*                                                                          */
/*    The Extract a Field and Sign-Extend routine returns a sign-extended longword */
/*    field that has been extracted from the specified variable bit field. LIB$EXTV */
/*    makes the VAX EXTV instruction available as a callable routine.       */
/*                                                                          */
long int lib$extv() ;
/*    LIB$EXTZV                                                             */
/*                                                                          */
/*    Extract a Zero-Extended Field                                         */
/*                                                                          */
/*    The Extract a Zero-Extended Field routine returns a longword zero-extended field */
/*    that has been extracted from the specified variable bit field. LIB$EXTZV makes */
/*    the VAX EXTZV instruction available as a callable routine.            */
/*                                                                          */
long int lib$extzv() ;
/*    LIB$FREE_DATE_TIME_CONTEXT                                            */
/*                                                                          */
/*    Free The Context Area Used When Formatting Dates And Times for Input or Output */
/*                                                                          */
/*    The Free The Context Area Used When Formatting Dates And Times for    */
/*    Input or Output routine frees                                         */
/*    the virtual memory associated with the context area used by the date/time */
/*    input and output Formatting Routines.                                 */
/*                                                                          */
unsigned long int lib$free_date_time_context() ;
/*    LIB$FREE_EF                                                           */
/*                                                                          */
/*    Free Event Flag                                                       */
/*                                                                          */
/*    The Free Event Flag routine frees a local event flag previously allocated by */
/*    LIB$GET_EF. LIB$FREE_EF is the complement of LIB$GET_EF.              */
/*                                                                          */
unsigned long int lib$free_ef() ;
/*    LIB$FIND_FILE_END                                                     */
/*                                                                          */
/*    End of Find File                                                      */
/*                                                                          */
/*    The End of Find File routine is called once after each sequence of calls to */
/*    LIB$FIND_FILE. LIB$FIND_FILE_END deallocates any saved Record Management Service */
/*    (RMS) context and deallocates the virtual memory used to hold the allocated */
/*    context block.                                                        */
/*                                                                          */
unsigned long int lib$find_file_end() ;
/*    LIB$FIND_FILE                                                         */
/*                                                                          */
/*    Find File                                                             */
/*                                                                          */
/*    The Find File routine is called with a wildcard file specification for which it */
/*    searches.  LIB$FIND_FILE returns all file specifications that satisfy */
/*    that wildcard file specification.                                     */
/*                                                                          */
unsigned long int lib$find_file() ;
/*    LIB$FFC                                                               */
/*                                                                          */
/*    Find First Clear or Set Bit                                           */
/*                                                                          */
/*    The Find First Clear or Set Bit routines search the field specified by the start */
/*    position, size, and base for the first clear or set bit. LIB$FFC and LIB$FFS */
/*    make the VAX FFC and FFS instructions available as callable routines.  */
/*                                                                          */
unsigned long int lib$ffc() ;
/*    LIB$FFS                                                               */
/*                                                                          */
/*    Find First Clear or Set Bit                                           */
/*                                                                          */
/*    The Find First Clear or Set Bit routines search the field specified by the start */
/*    position, size, and base for the first clear or set bit. LIB$FFC and LIB$FFS */
/*    make the VAX FFC and FFS instructions available as callable routines.  */
/*                                                                          */
unsigned long int lib$ffs() ;
/*    LIB$FID_TO_NAME                                                       */
/*                                                                          */
/*    Convert Device and File ID to File Specification                      */
/*                                                                          */
/*    The Convert Device and File ID to File Specification routine converts a disk */
/*    device name and file identifier to a file specification.              */
/*                                                                          */
unsigned long int lib$fid_to_name() ;
/*    LIB$FIND_IMAGE_SYMBOL                                                 */
/*                                                                          */
/*    Find Universal Symbol in Shareable Image File                         */
/*                                                                          */
/*    The Find Universal Symbol in Shareable Image File routine reads universal */
/*    symbols from the shareable image file. This routine then dynamically activates a */
/*    shareable image into the P0 address space of a process.               */
/*                                                                          */
unsigned long int lib$find_image_symbol() ;
/*    LIB$FIXUP_FLT                                                         */
/*                                                                          */
/*    Fix Floating Reserved Operand                                         */
/*                                                                          */
/*    The Fix Floating Reserved Operand routine finds the reserved operand of any */
/*    F_floating, D_floating, G_floating, or H_floating instruction (with some */
/*    exceptions) after a reserved operand fault has been signaled. LIB$FIXUP_FLT */
/*    changes the reserved operand from --0.0 to the value of the           */
/*    new-operand argument, if present; or to +0.0 if                       */
/*    new-operand is absent.                                                */
/*                                                                          */
unsigned long int lib$fixup_flt() ;
/*    LIB$FLT_UNDER                                                         */
/*                                                                          */
/*    Floating-Point Underflow Detection                                    */
/*                                                                          */
/*    The Floating-Point Underflow Detection routine enables or disables    */
/*    floating-point underflow detection for the calling routine activation.  The */
/*    previous setting is returned as a function value.                     */
/*                                                                          */
unsigned long int lib$flt_under() ;
/*    LIB$FREE_LUN                                                          */
/*                                                                          */
/*    Free Logical Unit Number                                              */
/*                                                                          */
/*    The Free Logical Unit Number routine releases a logical unit number allocated by */
/*    LIB$GET_LUN to the pool of available numbers. LIB$FREE_LUN is the complement of */
/*    LIB$GET_LUN.                                                          */
/*                                                                          */
unsigned long int lib$free_lun() ;
/*    LIB$FREE_VM_PAGE                                                      */
/*                                                                          */
/*    Free Virtual Memory Page                                              */
/*                                                                          */
/*    The Free Virtual Memory Page routine deallocates a block of contiguous pages  */
/*    that were allocated by previous calls to LIB$GET_VM_PAGE.             */
/*                                                                          */
unsigned long int lib$free_vm_page() ;
/*    LIB$FILE_SCAN                                                         */
/*                                                                          */
/*    File Scan                                                             */
/*                                                                          */
/*    The File Scan routine searches an area, such as a directory, for all files */
/*    matching the file specification given and transfers program execution to the */
/*    specified user-written routine.  Wildcards are acceptable. An action routine is */
/*    called for each file and/or error found. LIB$FILE_SCAN allows the search */
/*    sequence to continue even if an error occurs while processing a particular file. */
/*                                                                          */
unsigned long int lib$file_scan() ;
/*    LIB$FILE_SCAN_END                                                     */
/*                                                                          */
/*    End-of-File Scan                                                      */
/*                                                                          */
/*    The End of File Scan routine is called after each sequence of calls to */
/*    LIB$FILE_SCAN. LIB$FILE_SCAN_END deallocates any saved Record Management Service */
/*    (RMS) context and/or deallocates the virtual memory that had been allocated for */
/*    holding the related file specification information.                   */
/*                                                                          */
unsigned long int lib$file_scan_end() ;
/*    LIB$FREE_TIMER                                                        */
/*                                                                          */
/*    Free Timer Storage                                                    */
/*                                                                          */
/*    The Free Timer Storage routine frees the storage allocated by LIB$INIT_TIMER. */
/*                                                                          */
unsigned long int lib$free_timer() ;
/*    LIB$FREE_VM                                                           */
/*                                                                          */
/*    Free Virtual Memory from Program Region                               */
/*                                                                          */
/*    The Free Virtual Memory from Program Region routine deallocates an entire block */
/*    of contiguous bytes that were allocated by a previous call to LIB$GET_VM. The */
/*    arguments passed are the same as for LIB$GET_VM.                      */
/*                                                                          */
unsigned long int lib$free_vm() ;
/*    LIB$FIND_VM_ZONE                                                      */
/*                                                                          */
/*    Return the Next Valid Zone Identifier                                 */
/*                                                                          */
/*    The Return the Next Valid Zone Identifier routine returns the         */
/*    zone identifier of the next valid zone in the heap management         */
/*    database.                                                             */
/*                                                                          */
unsigned long int lib$find_vm_zone() ;
/*    LIB$GET_COMMAND                                                       */
/*                                                                          */
/*    Get Line from SYS$COMMAND                                             */
/*                                                                          */
/*    The Get Line from SYS$COMMAND routine gets  one record of ASCII text  from the */
/*    current controlling input device, specified by the logical name SYS$COMMAND.  */
/*                                                                          */
unsigned long int lib$get_command() ;
/*    LIB$GET_COMMON                                                        */
/*                                                                          */
/*    Get String from Common                                                */
/*                                                                          */
/*    The Get String from Common routine copies a string in the common area to the */
/*    destination string. (The common area is an area of storage which remains defined */
/*    across multiple image activations in a process.) The string length is taken from */
/*    the first longword of the common area.                                */
/*                                                                          */
unsigned long int lib$get_common() ;
/*    LIB$GET_DATE_FORMAT                                                   */
/*                                                                          */
/*    Get the User's Date Input Format                                      */
/*                                                                          */
/*    The Get The User's Date Input Format routine returns information about */
/*    the user's choice of a date/time input format.                        */
/*                                                                          */
unsigned long int lib$get_date_format() ;
/*    LIB$GET_MAXIMUM_DATE_LENGTH                                           */
/*                                                                          */
/*    Retrieve the Maximum Length of a Date/Time String                     */
/*                                                                          */
/*    Given an output format and language, the Retrieve the Maximum Length of a */
/*    Date/Time String routine determines the maximum possible length for the */
/*    date-string string returned by LIB$FORMAT_DATE_TIME.                  */
/*                                                                          */
unsigned long int lib$get_maximum_date_length() ;
/*    LIB$GETDVI                                                            */
/*                                                                          */
/*    Get Device/Volume Information                                         */
/*                                                                          */
/*    The Get Device/Volume Information routine provides a simplified interface to the */
/*    $GETDVI system service. It returns information about the primary and secondary */
/*    device characteristics of an I/O device. The calling process need not have a */
/*    channel assigned to the device about which it wants information.      */
/*                                                                          */
unsigned long int lib$getdvi() ;
/*    LIB$GET_EF                                                            */
/*                                                                          */
/*    Get Event Flag                                                        */
/*                                                                          */
/*    The Get Event Flag routine allocates one local event flag from a process-wide */
/*    pool and returns the number of the allocated flag to the caller. If no flags are */
/*    available, LIB$GET_EF returns an error as its function value.         */
/*                                                                          */
unsigned long int lib$get_ef() ;
/*    LIB$GET_FOREIGN                                                       */
/*                                                                          */
/*    Get Foreign Command Line                                              */
/*                                                                          */
/*    The Get Foreign Command Line routine requests the calling image's Command */
/*    Language Interpreter (CLI) to return the contents of the foreign      */
/*    command line that activated the current image.                        */
/*    foreign                                                               */
/*                                                                          */
unsigned long int lib$get_foreign() ;
/*    LIB$GET_INPUT                                                         */
/*                                                                          */
/*    Get Line from SYS$INPUT                                               */
/*                                                                          */
/*    The Get Line from SYS$INPUT routine gets  one record of ASCII text  from the */
/*    current controlling input device, specified by SYS$INPUT.             */
/*                                                                          */
unsigned long int lib$get_input() ;
/*    LIB$GETJPI                                                            */
/*                                                                          */
/*    Get Job/Process Information                                           */
/*                                                                          */
/*    The Get Job/Process Information routine provides a simplified interface to the */
/*    $GETJPI system service. It provides accounting, status, and identification */
/*    information about a specified process.                                */
/*                                                                          */
/*    LIB$GETJPI obtains only one item of information in a single call.     */
/*                                                                          */
unsigned long int lib$getjpi() ;
/*    LIB$GET_USERS_LANGUAGE                                                */
/*                                                                          */
/*    Return the User's Language                                            */
/*                                                                          */
/*    The Return The User's Language routine determines the user's choice of a natural */
/*    language. The choice is determined by translating the logical SYS$LANGUAGE.  */
/*                                                                          */
unsigned long int lib$get_users_language() ;
/*    LIB$GET_LUN                                                           */
/*                                                                          */
/*    Get Logical Unit Number                                               */
/*                                                                          */
/*    The Get Logical Unit Number routine allocates one logical unit number from a */
/*    process-wide pool.  If a unit is available, its number is returned to the */
/*    caller.  Otherwise, an error is returned as the function value.       */
/*                                                                          */
unsigned long int lib$get_lun() ;
/*    LIB$GET_VM_PAGE                                                       */
/*                                                                          */
/*    Get Virtual Memory Page                                               */
/*                                                                          */
/*    The Get Virtual Memory Page routine allocates a specified number of contiguous */
/*    pages of memory in the program region and returns the virtual address of the */
/*    first page allocated.                                                 */
/*                                                                          */
unsigned long int lib$get_vm_page() ;
/*    LIB$GETQUI                                                            */
/*                                                                          */
/*    Get Queue Information                                                 */
/*                                                                          */
/*    The Get Queue Information routine provides a simplified interface to the */
/*    $GETQUI system service. It provides queue, job, file, characteristic,  */
/*    and form                                                              */
/*    information about a specified process.                                */
/*                                                                          */
/*    LIB$GETQUI obtains only one item of information in a single call.     */
/*                                                                          */
unsigned long int lib$getqui() ;
/*    LIB$GETSYI                                                            */
/*                                                                          */
/*    Get Systemwide Information                                            */
/*                                                                          */
/*    The Get Systemwide Information routine provides a simplified interface to the */
/*    $GETSYI system service. The $GETSYI system service obtains status and */
/*    identification information about the system. LIB$GETSYI returns only one item of */
/*    information in a single call.                                         */
/*                                                                          */
unsigned long int lib$getsyi() ;
/*    LIB$GET_SYMBOL                                                        */
/*                                                                          */
/*    Get Value of CLI Symbol                                               */
/*                                                                          */
/*    The Get Value of CLI Symbol routine requests the calling process's Command */
/*    Language Interpreter (CLI) to return the value of a CLI symbol as a string. */
/*    LIB$GET_SYMBOL then returns the string to the caller. Optionally, LIB$GET_SYMBOL */
/*    can return the length of the returned value and the table in which the symbol */
/*    was found.                                                            */
/*                                                                          */
unsigned long int lib$get_symbol() ;
/*    LIB$GET_VM                                                            */
/*                                                                          */
/*    Allocate Virtual Memory                                               */
/*                                                                          */
/*    The Allocate Virtual Memory routine allocates a specified number of contiguous */
/*    bytes in the program region and returns the virtual address of the first byte */
/*    allocated.                                                            */
/*                                                                          */
unsigned long int lib$get_vm() ;
/*    LIB$ICHAR                                                             */
/*                                                                          */
/*    Convert First Character of String to Integer                          */
/*                                                                          */
/*    The Convert First Character of String to Integer routine converts the first */
/*    character of a source string to an 8-bit ASCII integer extended to a longword.  */
/*                                                                          */
unsigned long int lib$ichar() ;
/*    LIB$INDEX                                                             */
/*                                                                          */
/*    Index to Relative Position of Substring                               */
/*                                                                          */
/*    The Index to Relative Position of Substring routine returns an index, which is */
/*    the relative position of the first occurrence of a substring in the source */
/*    string.                                                               */
/*                                                                          */
unsigned long int lib$index() ;
/*    LIB$INIT_TIMER                                                        */
/*                                                                          */
/*    Initialize Times and Counts                                           */
/*                                                                          */
/*    The Initialize Times and Counts routine stores the current values of specified */
/*    times and counts for use by LIB$SHOW_TIMER or LIB$STAT_TIMER.         */
/*                                                                          */
unsigned long int lib$init_timer() ;
/*    LIB$INSERT_TREE                                                       */
/*                                                                          */
/*    Insert Entry in a Balanced Binary Tree                                */
/*                                                                          */
/*    The Insert Entry in a Balanced Binary Tree routine inserts a node in a balanced */
/*    binary tree.                                                          */
/*                                                                          */
long int lib$insert_tree() ;
/*    LIB$INSQHI                                                            */
/*                                                                          */
/*    Insert Entry at Head of Queue                                         */
/*                                                                          */
/*    The Insert Entry at Head of Queue routine inserts a queue entry at the head of */
/*    the specified self-relative interlocked queue. LIB$INSQHI makes the VMS */
/*    INSQHI instruction available as a callable routine.                   */
/*                                                                          */
unsigned long int lib$insqhi() ;
/*    LIB$INSQTI                                                            */
/*                                                                          */
/*    Insert Entry at Tail of Queue                                         */
/*                                                                          */
/*    The Insert Entry at Tail of Queue routine inserts a queue entry at the tail of */
/*    the specified self-relative interlocked queue. LIB$INSQTI makes the VAX INSQTI */
/*    instruction available as a callable routine.                          */
/*                                                                          */
unsigned long int lib$insqti() ;
/*    LIB$INSV                                                              */
/*                                                                          */
/*    Insert a Variable Bit Field                                           */
/*                                                                          */
/*    The Insert a Variable Bit Field routine replaces the variable bit field */
/*    specified by the base, position, and size arguments with bits 0 through */
/*    size - 1 of the source field. If the size of the bit field            */
/*    is zero, nothing is inserted. LIB$INSV makes the VAX INSV instruction available */
/*    as a callable routine.                                                */
/*                                                                          */
int lib$insv() ;
/*    LIB$INT_OVER                                                          */
/*                                                                          */
/*    Integer Overflow Detection                                            */
/*                                                                          */
/*    The Integer Overflow Detection routine enables or disables integer overflow */
/*    detection for the calling routine activation.  The previous integer overflow */
/*    enable setting is returned.                                           */
/*                                                                          */
unsigned long int lib$int_over() ;
/*    LIB$INIT_DATE_TIME_CONTEXT                                            */
/*                                                                          */
/*    Initialize the Context Area Used in Formatting Dates and Times for Input or Output */
/*                                                                          */
/*    The Initialize The Context Area Used In Formatting Dates and Times for  */
/*    Input or Output                                                       */
/*    routine allows the user to initialize the context area used by        */
/*    LIB$FORMAT_DATE_TIME or LIB$CONVERT_DATE_STRING with specific strings, */
/*    instead of through logical name translation.                          */
/*                                                                          */
unsigned long int lib$init_date_time_context() ;
/*    LIB$LEN                                                               */
/*                                                                          */
/*    Length of String Returned as Longword Value                           */
/*                                                                          */
/*    The Length of String Returned as Longword Value routine returns the length of a */
/*    string.                                                               */
/*                                                                          */
unsigned short int lib$len() ;
/*    LIB$LOCC                                                              */
/*                                                                          */
/*    Locate a Character                                                    */
/*                                                                          */
/*    The Locate a Character routine locates a character in a string by comparing */
/*    successive bytes in the string with the character specified. The search */
/*    continues until the character is found or the string has no more characters. */
/*    LIB$LOCC makes the VAX LOCC instruction available as a callable routine.  */
/*                                                                          */
unsigned long int lib$locc() ;
/*    LIB$LOOKUP_KEY                                                        */
/*                                                                          */
/*    Look Up Keyword in Table                                              */
/*                                                                          */
/*    The Look Up Keyword In Table routine scans a table of keywords to find one that */
/*    matches the keyword or keyword abbreviation specified by              */
/*    search-string.                                                        */
/*                                                                          */
unsigned long int lib$lookup_key() ;
/*    LIB$LOOKUP_TREE                                                       */
/*                                                                          */
/*    Look Up an Entry in a Balanced Binary Tree                            */
/*                                                                          */
/*    The Look Up an Entry in a Balanced Binary Tree routine looks up an entry in a */
/*    balanced binary tree.                                                 */
/*                                                                          */
unsigned long int lib$lookup_tree() ;
/*    LIB$LP_LINES                                                          */
/*                                                                          */
/*    Lines on Each Printer Page                                            */
/*                                                                          */
/*    The Lines on Each Printer Page routine computes the default number of lines on a */
/*    printer page. This routine can be used by native-mode VMS utilities that */
/*    produce listing files and paginate files.                             */
/*                                                                          */
long int lib$lp_lines() ;
/*    LIB$MATCHC                                                            */
/*                                                                          */
/*    Match Characters, Return Relative Position                            */
/*                                                                          */
/*    The Match Characters and Return Relative Position routine searches a source */
/*    string for a specified substring and returns an index, which is the relative */
/*    position of the first occurrence of a substring in the source string.  */
/*    The relative character positions returned by LIB$MATCHC are numbered  */
/*    1, 2, ..., n. Thus, zero means that the substring was not found.      */
/*    LIB$MATCHC makes the VAX MATCHC instruction available as a callable   */
/*    routine.                                                              */
/*                                                                          */
unsigned long int lib$matchc() ;
/*    LIB$MATCH_COND                                                        */
/*                                                                          */
/*    Match Condition Values                                                */
/*                                                                          */
/*    The Match Condition Values routine checks to see if a given condition value */
/*    matches a list of condition values that you supply.                   */
/*                                                                          */
unsigned long int lib$match_cond() ;
/*    LIB$MOVC3                                                             */
/*                                                                          */
/*    Move Characters                                                       */
/*                                                                          */
/*    The Move Characters routine makes the VAX MOVC3 instruction available as a */
/*    callable routine. The source item is moved to the destination item. Overlap of */
/*    the source and destination items does not affect the result.          */
/*                                                                          */
int lib$movc3() ;
/*    LIB$MOVC5                                                             */
/*                                                                          */
/*    Move Characters with Fill                                             */
/*                                                                          */
/*    The Move Characters with Fill routine makes the VAX MOVC5 instruction available */
/*    as a callable routine. The source item is moved to the destination item. */
/*    Overlap of the source and destination items does not affect the result.  */
/*                                                                          */
int lib$movc5() ;
/*    LIB$MOVTC                                                             */
/*                                                                          */
/*    Move Translated Characters                                            */
/*                                                                          */
/*    The Move Translated Characters routine moves the source string, character by */
/*    character, to the destination string after translating each character using the */
/*    specified translation table. LIB$MOVTC makes the VAX MOVTC instruction available */
/*    as a callable routine.                                                */
/*                                                                          */
unsigned long int lib$movtc() ;
/*    LIB$MOVTUC                                                            */
/*                                                                          */
/*    Move Translated Until Character                                       */
/*                                                                          */
/*    The Move Translated Until Character routine moves the source string, character */
/*    by character, to the destination string after translating each character using */
/*    the specified translation table until the stop character is encountered. */
/*    LIB$MOVTUC makes the VAX MOVTUC instruction available as a callable routine.  */
/*                                                                          */
unsigned long int lib$movtuc() ;
/*    LIB$MULT_DELTA_TIME                                                   */
/*                                                                          */
/*    Multiply Delta Time by Scalar                                         */
/*                                                                          */
/*    The Multiply Delta Time by Scalar routine multiplies a delta time by a longword integer  */
/*    scalar.                                                               */
/*                                                                          */
unsigned long int lib$mult_delta_time() ;
/*    LIB$MULTF_DELTA_TIME                                                  */
/*                                                                          */
/*    Multiply Delta Time by an F_floating Scalar                           */
/*                                                                          */
/*    The Multiply Delta Time by an F-Floating Scalar routine multiplies a delta time */
/*    by an F-floating scalar.                                              */
/*                                                                          */
unsigned long int lib$multf_delta_time() ;
/*    LIB$PAUSE                                                             */
/*                                                                          */
/*    Pause Program Execution                                               */
/*                                                                          */
/*    The Pause Program Execution routine suspends program execution and returns */
/*    control to the calling command level.                                 */
/*                                                                          */
unsigned long int lib$pause() ;
/*    LIB$POLYD                                                             */
/*                                                                          */
/*    Evaluate Polynomials                                                  */
/*                                                                          */
/*    The Evaluate Polynomials routine (D-floating point values) allows higher-level */
/*    language users to evaluate D-floating point value polynomials.        */
/*                                                                          */
unsigned long int lib$polyd() ;
/*    LIB$POLYF                                                             */
/*                                                                          */
/*    Evaluate Polynomials                                                  */
/*                                                                          */
/*    The Evaluate Polynomials routine (F-floating point values) allows higher-level */
/*    language users to evaluate F-floating point polynomials.              */
/*                                                                          */
unsigned long int lib$polyf() ;
/*    LIB$POLYG                                                             */
/*                                                                          */
/*    Evaluate Polynomials                                                  */
/*                                                                          */
/*    The Evaluate Polynomials routine (G-floating point values) allows higher-level */
/*    language users to evaluate G-floating point value polynomials.        */
/*                                                                          */
unsigned long int lib$polyg() ;
/*    LIB$POLYH                                                             */
/*                                                                          */
/*    Evaluate Polynomials                                                  */
/*                                                                          */
/*    The Evaluate Polynomials routine (H-floating point values) allows higher-level */
/*    language users to evaluate H-floating point value polynomials.        */
/*                                                                          */
unsigned long int lib$polyh() ;
/*    LIB$PUT_COMMON                                                        */
/*                                                                          */
/*    Put String to Common                                                  */
/*                                                                          */
/*    The Put String to Common routine copies the contents of a string into the common */
/*    area. The common area is an area of storage which remains defined across */
/*    multiple image activations in a process. Optionally, LIB$PUT_COMMON returns the */
/*    actual number of characters copied. The maximum number of characters that can be */
/*    copied is 252.                                                        */
/*                                                                          */
unsigned long int lib$put_common() ;
/*    LIB$PUT_OUTPUT                                                        */
/*                                                                          */
/*    Put Line to SYS$OUTPUT                                                */
/*                                                                          */
/*    The Put Line to SYS$OUTPUT routine writes a record to the current controlling */
/*    output device, specified by SYS$OUTPUT using the RMS $PUT service.    */
/*                                                                          */
unsigned long int lib$put_output() ;
/*    LIB$RADIX_POINT                                                       */
/*                                                                          */
/*    Radix Point Symbol                                                    */
/*                                                                          */
/*    The Radix Point Symbol routine returns the system's radix point symbol. This */
/*    symbol is used inside a digit string to separate the integer part from the */
/*    fraction part. This routine works by attempting to translate the logical name */
/*    SYS$RADIX_POINT as a process, group, or system logical name.          */
/*                                                                          */
unsigned long int lib$radix_point() ;
/*    LIB$REMQHI                                                            */
/*                                                                          */
/*    Remove Entry from Head of Queue                                       */
/*                                                                          */
/*    The Remove Entry from Head of Queue routine removes an entry from the head of */
/*    the specified self-relative interlocked queue. LIB$REMQHI makes the VAX REMQHI */
/*    instruction available as a callable routine.                          */
/*                                                                          */
unsigned long int lib$remqhi() ;
/*    LIB$REMQTI                                                            */
/*                                                                          */
/*    Remove Entry from Tail of Queue                                       */
/*                                                                          */
/*    The Remove Entry from Tail of Queue routine removes an entry from the tail of */
/*    the specified self-relative interlocked queue. LIB$REMQTI makes the VAX REMQTI */
/*    instruction available as a callable routine.                          */
/*                                                                          */
unsigned long int lib$remqti() ;
/*    LIB$RENAME_FILE                                                       */
/*                                                                          */
/*    Rename One or More Files                                              */
/*                                                                          */
/*    The Rename One or More Files routine changes the names of one or more files. */
/*    The specification of the files to be renamed may include wildcards.   */
/*                                                                          */
/*    LIB$RENAME_FILE is similar in function to the DCL command RENAME.     */
/*                                                                          */
unsigned long int lib$rename_file() ;
/*    LIB$RESERVE_EF                                                        */
/*                                                                          */
/*    Reserve Event Flag                                                    */
/*                                                                          */
/*    The Reserve Event Flag routine allocates a local event flag number specified by */
/*    event-flag-number.                                                    */
/*                                                                          */
unsigned long int lib$reserve_ef() ;
/*    LIB$RESET_VM_ZONE                                                     */
/*                                                                          */
/*    Reset Virtual Memory Zone                                             */
/*                                                                          */
/*    The Reset Virtual Memory Zone routine frees all blocks of memory that were */
/*    previously allocated from the zone.                                   */
/*                                                                          */
unsigned long int lib$reset_vm_zone() ;
/*    LIB$REVERT                                                            */
/*                                                                          */
/*    Revert to the Handler of the Routine Activator                        */
/*                                                                          */
/*    The Revert to the Handler of the Routine Activator routine deletes the */
/*    condition handler established by LIB$ESTABLISH by clearing the address pointing */
/*    to the condition handler from the activated routine's stack frame.    */
/*                                                                          */
int *lib$revert() ;
/*    LIB$RUN_PROGRAM                                                       */
/*                                                                          */
/*    Run New Program                                                       */
/*                                                                          */
/*    The Run New Program routine causes the current program to stop running and */
/*    begins execution of another program.                                  */
/*                                                                          */
unsigned long int lib$run_program() ;
/*    LIB$SYS_ASCTIM                                                        */
/*                                                                          */
/*    Invoke $ASCTIM to Convert Binary Time to ASCII String                 */
/*                                                                          */
/*    The Invoke $ASCTIM to Convert Binary Time to ASCII String routine calls the */
/*    system service $ASCTIM to convert a binary date and time value, returning the */
/*    ASCII string using the semantics of the caller's string.              */
/*                                                                          */
unsigned long int lib$sys_asctim() ;
/*    LIB$SCANC                                                             */
/*                                                                          */
/*    Scan for Characters, Return Relative Position                         */
/*                                                                          */
/*    The Scan for Characters and Return Relative Position routine is used to find a */
/*    specified set of characters in the source string. LIB$SCANC makes the VAX SCANC */
/*    instruction available as a callable routine.                          */
/*                                                                          */
unsigned long int lib$scanc() ;
/*    LIB$SCOPY_DXDX                                                        */
/*                                                                          */
/*    Copy Source String Passed by Descriptor to Destination                */
/*                                                                          */
/*    The Copy Source String Passed by Descriptor to Destination routine copies a */
/*    source string passed by descriptor to a destination string.           */
/*                                                                          */
unsigned long int lib$scopy_dxdx() ;
/*    LIB$SCOPY_R_DX                                                        */
/*                                                                          */
/*    Copy Source String Passed by Reference to Destination String          */
/*                                                                          */
/*    The Copy Source String Passed by Reference to Destination String routine copies */
/*    a source string passed by reference to a destination string.          */
/*                                                                          */
unsigned long int lib$scopy_r_dx() ;
/*    LIB$SET_LOGICAL                                                       */
/*                                                                          */
/*    Set Logical Name                                                      */
/*                                                                          */
/*    The Set Logical Name routine requests the calling process's Command Language */
/*    Interpreter (CLI) to define or redefine a supervisor-mode process logical name. */
/*    It provides the same function as the DCL DEFINE command.              */
/*                                                                          */
unsigned long int lib$set_logical() ;
/*    LIB$SET_SYMBOL                                                        */
/*                                                                          */
/*    Set Value of CLI Symbol                                               */
/*                                                                          */
/*    The Set Value of CLI Symbol routine requests the calling process's Command */
/*    Language Interpreter (CLI) to define or redefine a CLI symbol.        */
/*                                                                          */
unsigned long int lib$set_symbol() ;
/*    LIB$SYS_FAO                                                           */
/*                                                                          */
/*    Invoke $FAO System Service to Format Output                           */
/*                                                                          */
/*    The Invoke $FAO System Service to Format Output routine calls $FAO, returning a */
/*    string in the semantics you provide. If called with other than a fixed-length */
/*    string for output, the length of the resultant string is limited to 256 bytes */
/*    and truncation will occur.                                            */
/*                                                                          */
unsigned long int lib$sys_fao() ;
/*    LIB$SYS_FAOL                                                          */
/*                                                                          */
/*    Invoke $FAOL System Service to Format Output                          */
/*                                                                          */
/*    The Invoke $FAOL System Service to Format Output routine calls the system */
/*    service routine $FAOL, returning the string in the semantics you provide. If */
/*    called with other than a fixed-length string for output, the length of the */
/*    resultant string is limited to 256 bytes and truncation will occur.   */
/*                                                                          */
unsigned long int lib$sys_faol() ;
/*    LIB$SFREE1_DD                                                         */
/*                                                                          */
/*    Free One Dynamic String                                               */
/*                                                                          */
/*    The Free One Dynamic String routine returns one dynamic string area to free */
/*    storage.                                                              */
/*                                                                          */
unsigned long int lib$sfree1_dd() ;
/*    LIB$SFREEN_DD                                                         */
/*                                                                          */
/*    Free One or More Dynamic Strings                                      */
/*                                                                          */
/*    The Free One or More Dynamic Strings routine returns one or more dynamic strings */
/*    to free storage.                                                      */
/*                                                                          */
unsigned long int lib$sfreen_dd() ;
/*    LIB$SGET1_DD                                                          */
/*                                                                          */
/*    Get One Dynamic String                                                */
/*                                                                          */
/*    The Get One Dynamic String routine allocates dynamic virtual memory to the */
/*    string descriptor you specify.                                        */
/*                                                                          */
unsigned long int lib$sget1_dd() ;
/*    LIB$SYS_GETMSG                                                        */
/*                                                                          */
/*    Invoke $GETMSG System Service to Get Message Text                     */
/*                                                                          */
/*    The Invoke $GETMSG System Service to Get Message Text routine calls the System */
/*    Service $GETMSG and returns a message string into destination-string  */
/*    using the semantics of the caller's string.                           */
/*                                                                          */
unsigned long int lib$sys_getmsg() ;
/*    LIB$SHOW_TIMER                                                        */
/*                                                                          */
/*    Show Accumulated Times and Counts                                     */
/*                                                                          */
/*    The Show Accumulated Times and Counts routine returns times and counts */
/*    accumulated since the last call to LIB$INIT_TIMER and displays them on */
/*    SYS$OUTPUT. (LIB$INIT_TIMER must be called prior to invoking this     */
/*    routine.) A user-supplied action routine may change this default      */
/*    behavior.                                                             */
/*                                                                          */
unsigned long int lib$show_timer() ;
/*    LIB$SHOW_VM                                                           */
/*                                                                          */
/*    Show Virtual Memory Statistics                                        */
/*                                                                          */
/*    The Show Virtual Memory Statistics routine returns the statistics accumulated */
/*    from calls to LIB$GET_VM/LIB$FREE_VM and LIB$GET_VM_PAGE/LIB$FREE_VM_PAGE.  */
/*                                                                          */
unsigned long int lib$show_vm() ;
/*    LIB$SHOW_VM_ZONE                                                      */
/*                                                                          */
/*    Return Information About a Zone                                       */
/*                                                                          */
/*    The Return Information About a Zone routine returns formatted information about */
/*    the specified zone, detailing such information as the zone's name,    */
/*    characteristics, and areas, and then passes the information to the specified or */
/*    default action routine.                                               */
/*                                                                          */
unsigned long int lib$show_vm_zone() ;
/*    LIB$SIGNAL                                                            */
/*                                                                          */
/*    Signal Exception Condition                                            */
/*                                                                          */
/*    The Signal Exception Condition routine generates a signal that indicates that an */
/*    exception condition has occurred in your program. If a condition handler does */
/*    not take corrective action and the condition is severe, then your program will */
/*    exit.                                                                 */
/*                                                                          */
int lib$signal() ;
/*    LIB$SIG_TO_RET                                                        */
/*                                                                          */
/*    Signal Converted to a Return Status                                   */
/*                                                                          */
/*    The Signal Converted to a Return Status routine converts any signaled condition */
/*    value to a value returned as a function. The signaled condition is returned to */
/*    the caller of the user routine that established the handler that is calling */
/*    LIB$SIG_TO_RET. This routine may be established as or called from a condition */
/*    handler.                                                              */
/*                                                                          */
unsigned long int lib$sig_to_ret() ;
/*    LIB$SIG_TO_STOP                                                       */
/*                                                                          */
/*    Convert a Signaled Condition to a Signaled Stop                       */
/*                                                                          */
/*    The Convert a Signaled Condition to a Signaled Stop routine converts a signaled */
/*    condition to a signaled condition that cannot be continued.           */
/*                                                                          */
unsigned long int lib$sig_to_stop() ;
/*    LIB$SIM_TRAP                                                          */
/*                                                                          */
/*    Simulate Floating Trap                                                */
/*                                                                          */
/*    The Simulate Floating Trap routine converts floating faults to floating traps. */
/*    It can be enabled as a condition handler or can be called by one.     */
/*                                                                          */
unsigned long int lib$sim_trap() ;
/*    LIB$SKPC                                                              */
/*                                                                          */
/*    Skip Equal Characters                                                 */
/*                                                                          */
/*    The Skip Equal Characters routine compares each character of a given string with */
/*    a given character and returns the relative position of the first nonequal */
/*    character as an index. LIB$SKPC makes the VAX SKPC instruction available as a */
/*    callable routine.                                                     */
/*                                                                          */
unsigned long int lib$skpc() ;
/*    LIB$SPANC                                                             */
/*                                                                          */
/*    Skip Selected Characters                                              */
/*                                                                          */
/*    The Skip Selected Characters routine is used to skip a specified set of */
/*    characters in the source string. LIB$SPANC makes the VAX SPANC instruction */
/*    available as a callable routine.                                      */
/*                                                                          */
unsigned long int lib$spanc() ;
/*    LIB$SPAWN                                                             */
/*                                                                          */
/*    Spawn Subprocess                                                      */
/*                                                                          */
/*    The Spawn Subprocess routine requests the command language interpreter (CLI) of */
/*    the calling process to spawn a subprocess for executing CLI commands.  LIB$SPAWN */
/*    provides the same function as the DCL SPAWN command.                  */
/*                                                                          */
unsigned long int lib$spawn() ;
/*    LIB$STAT_TIMER                                                        */
/*                                                                          */
/*    Statistics, Return Accumulated Times and Counts                       */
/*                                                                          */
/*    The Statistics, Return Accumulated Times and Counts routine returns to its */
/*    caller one of five available statistics accumulated since the last call to */
/*    LIB$INIT_TIMER. Unlike LIB$SHOW_TIMER, which formats the values for output, */
/*    LIB$STAT_TIMER returns the value as an unsigned longword or quadword.  */
/*                                                                          */
unsigned long int lib$stat_timer() ;
/*    LIB$STAT_VM                                                           */
/*                                                                          */
/*    Return Virtual Memory Statistics                                      */
/*                                                                          */
/*    The Return Virtual Memory Statistics routine returns to its caller one of six */
/*    statistics available from calls to LIB$GET_VM/LIB$FREE_VM and         */
/*    LIB$GET_VM_PAGE/LIB$FREE_VM_PAGE. Unlike LIB$SHOW_VM, which formats the values */
/*    for output and displays them on SYS$OUTPUT, LIB$STAT_VM returns the statistic in */
/*    the value-argument argument. Only one of the statistics is returned   */
/*    by each call to LIB$STAT_VM.                                          */
/*                                                                          */
unsigned long int lib$stat_vm() ;
/*    LIB$STOP                                                              */
/*                                                                          */
/*    Stop Execution and Signal the Condition                               */
/*                                                                          */
/*    The Stop Execution and Signal the Condition routine generates a signal that */
/*    indicates that an exception condition has occurred in your program. Exception */
/*    conditions signaled by LIB$STOP cannot be continued from the point of the */
/*    signal.                                                               */
/*                                                                          */
int lib$stop() ;
/*    LIB$SYS_TRNLOG                                                        */
/*                                                                          */
/*    Invoke $TRNLOG\System Service to Translate Logical Name               */
/*                                                                          */
/*    The Invoke $TRNLOG System Service to Translate Logical Name routine uses the */
/*    system service $TRNLOG to translate a logical name, LIB$SYS_TRNLOG returns the */
/*    logical name's translation using the semantics of the caller's string.  */
/*                                                                          */
unsigned long int lib$sys_trnlog() ;
/*    LIB$STAT_VM_ZONE                                                      */
/*                                                                          */
/*    Return Information About a Zone                                       */
/*                                                                          */
/*    The Return Information About a Zone routine returns a single piece of */
/*    information about the specified zone.                                 */
/*                                                                          */
unsigned long int lib$stat_vm_zone() ;
/*    LIB$SUB_TIMES                                                         */
/*                                                                          */
/*    Subtract Two Quadword Times                                           */
/*                                                                          */
/*    The Subtract Two Quadword Times routine subtracts two VMS             */
/*    internal-time-format times.                                           */
/*                                                                          */
unsigned long int lib$sub_times() ;
/*    LIB$SUBX                                                              */
/*                                                                          */
/*    Multiple-Precision Binary Subtraction                                 */
/*                                                                          */
/*    The Multiple-Precision Binary Subtraction routine performs subtraction on signed */
/*    two's complement integers of arbitrary length.                        */
/*                                                                          */
unsigned long int lib$subx() ;
/*    LIB$TPARSE                                                            */
/*                                                                          */
/*    Table-Driven Finite-State Parser                                      */
/*                                                                          */
/*    The Table-Driven Finite State Parser routine is a general-purpose, table-driven */
/*    parser implemented as a finite-state automaton, with extensions that make it */
/*    suitable for a wide range of applications. LIB$TPARSE parses a string and */
/*    returns a message indicating whether or not the input string is valid.  */
/*                                                                          */
unsigned long int lib$tparse() ;
/*    LIB$TRA_ASC_EBC                                                       */
/*                                                                          */
/*    Translate ASCII to EBCDIC                                             */
/*                                                                          */
/*    The Translate ASCII to EBCDIC routine translates an ASCII string to an EBCDIC */
/*    string.                                                               */
/*                                                                          */
unsigned long int lib$tra_asc_ebc() ;
/*    LIB$TRA_EBC_ASC                                                       */
/*                                                                          */
/*    Translate EBCDIC to ASCII                                             */
/*                                                                          */
/*    The Translate EBCDIC to ASCII routine translates an EBCDIC string to an ASCII */
/*    string.                                                               */
/*                                                                          */
unsigned long int lib$tra_ebc_asc() ;
/*    LIB$TRAVERSE_TREE                                                     */
/*                                                                          */
/*    Traverse a Balanced Binary Tree                                       */
/*                                                                          */
/*    The Traverse a Balanced Binary Tree routine calls an action routine for each */
/*    node in a binary tree.                                                */
/*                                                                          */
unsigned long int lib$traverse_tree() ;
/*    LIB$TRIM_FILESPEC                                                     */
/*                                                                          */
/*    Fit Long File Specification into Fixed Field                          */
/*                                                                          */
/*    The Fit Long File Specification into Fixed Field routine takes a file */
/*    specification, such as an RMS resultant name string, and shortens it (if */
/*    necessary) so that it fits into a field of fixed width.               */
/*                                                                          */
unsigned long int lib$trim_filespec() ;
/*    LIB$VERIFY_VM_ZONE                                                    */
/*                                                                          */
/*    Verify a Zone                                                         */
/*                                                                          */
/*    The Verify a Zone routine performs verification of a zone.            */
/*                                                                          */
unsigned long int lib$verify_vm_zone() ;
/*    LIB$WAIT                                                              */
/*                                                                          */
/*    Wait a Specified Period of Time                                       */
/*                                                                          */
/*    The Wait a Specified Period of Time routine places the current process into */
/*    hibernation for the number of seconds specified in its argument.      */
/*                                                                          */
unsigned long int lib$wait() ;

#endif					/* __LIB$ROUTINES_LOADED */
#ifndef __LIBCLIDEF_LOADED
#define __LIBCLIDEF_LOADED	1

/*** MODULE $libclidef ***/
/* Definitions for LIB$ CLI callback procedures                             */
#define LIB$K_CLI_LOCAL_SYM 1
#define LIB$K_CLI_GLOBAL_SYM 2
#define LIB$M_CLI_CTRLT 1048576
#define LIB$M_CLI_CTRLY 33554432
struct cli$ctrl_fields {
    unsigned lib$v_fill_a_s : 20;       /* Ctrl-A to Ctrl-S are unused      */
    unsigned lib$v_cli_ctrlt : 1;
    unsigned lib$v_fill_u_x : 4;        /* Ctrl-U to Ctrl-X are unused      */
    unsigned lib$v_cli_ctrly : 1;
    unsigned lib$v_fill_0 : 6;
    } ;

#endif					/* __LIBCLIDEF_LOADED */
#ifndef __LIBDCFDEF_LOADED
#define __LIBDCFDEF_LOADED	1

/*** MODULE $libdcfdef ***/
/* Definitions for LIB$DECODE_FAULT                                         */
/*                                                                          */
/* Operand definition codes                                                 */
/*                                                                          */
#define LIB$M_DCFACC 7
#define LIB$M_DCFTYP 248
struct lib$b_dcf_operand {
    unsigned lib$v_dcfacc : 3;          /* Operand access type              */
    unsigned lib$v_dcftyp : 5;          /* Operand data type                */
    } ;
/*                                                                          */
/* Operand access type codes                                                */
/*                                                                          */
#define LIB$K_DCFACC_R 1                /* Operand is to be read            */
#define LIB$K_DCFACC_M 2                /* Operand is to be modified        */
#define LIB$K_DCFACC_W 3                /* Operand is to be written         */
#define LIB$K_DCFACC_A 4                /* Operand is an address            */
#define LIB$K_DCFACC_V 5                /* Operand is a field (may be register or address) */
#define LIB$K_DCFACC_B 6                /* Operand is a branch displacement */
/*                                                                          */
/* Operand data type codes                                                  */
/*                                                                          */
#define LIB$K_DCFTYP_B 1                /* Operand is a byte                */
#define LIB$K_DCFTYP_W 2                /* Operand is a word                */
#define LIB$K_DCFTYP_L 3                /* Operand is a longword            */
#define LIB$K_DCFTYP_Q 4                /* Operand is a quadword            */
#define LIB$K_DCFTYP_O 5                /* Operand is an octaword           */
#define LIB$K_DCFTYP_F 6                /* Operand is an F_floating         */
#define LIB$K_DCFTYP_D 7                /* Operand is a D_floating          */
#define LIB$K_DCFTYP_G 8                /* Operand is a G_floating          */
#define LIB$K_DCFTYP_H 9                /* Operand is an H_floating         */
/*                                                                          */
/* Combined operand access and data type codes                              */
/*                                                                          */
#define LIB$K_DCFOPR_AB 8
#define LIB$K_DCFOPR_RB 9
#define LIB$K_DCFOPR_MB 10
#define LIB$K_DCFOPR_WB 11
#define LIB$K_DCFOPR_VB 12
#define LIB$K_DCFOPR_BB 13
#define LIB$K_DCFOPR_AW 16
#define LIB$K_DCFOPR_RW 17
#define LIB$K_DCFOPR_MW 18
#define LIB$K_DCFOPR_WW 19
#define LIB$K_DCFOPR_VW 20
#define LIB$K_DCFOPR_BW 21
#define LIB$K_DCFOPR_AL 24
#define LIB$K_DCFOPR_RL 25
#define LIB$K_DCFOPR_ML 26
#define LIB$K_DCFOPR_WL 27
#define LIB$K_DCFOPR_VL 28
#define LIB$K_DCFOPR_BL 29
#define LIB$K_DCFOPR_AQ 32
#define LIB$K_DCFOPR_RQ 33
#define LIB$K_DCFOPR_MQ 34
#define LIB$K_DCFOPR_WQ 35
#define LIB$K_DCFOPR_VQ 36
#define LIB$K_DCFOPR_AO 40
#define LIB$K_DCFOPR_RO 41
#define LIB$K_DCFOPR_MO 42
#define LIB$K_DCFOPR_WO 43
#define LIB$K_DCFOPR_VO 44
#define LIB$K_DCFOPR_AF 48
#define LIB$K_DCFOPR_RF 49
#define LIB$K_DCFOPR_MF 50
#define LIB$K_DCFOPR_WF 51
#define LIB$K_DCFOPR_VF 52
#define LIB$K_DCFOPR_AD 56
#define LIB$K_DCFOPR_RD 57
#define LIB$K_DCFOPR_MD 58
#define LIB$K_DCFOPR_WD 59
#define LIB$K_DCFOPR_VD 60
#define LIB$K_DCFOPR_AG 64
#define LIB$K_DCFOPR_RG 65
#define LIB$K_DCFOPR_MG 66
#define LIB$K_DCFOPR_WG 67
#define LIB$K_DCFOPR_VG 68
#define LIB$K_DCFOPR_AH 72
#define LIB$K_DCFOPR_RH 73
#define LIB$K_DCFOPR_MH 74
#define LIB$K_DCFOPR_WH 75
#define LIB$K_DCFOPR_VH 76
#define LIB$K_DCFOPR_END 0
/*                                                                          */

#endif					/* __LIBDCFDEF_LOADED */
#ifndef __LIBDEF_LOADED
#define __LIBDEF_LOADED	1

/*** MODULE $libdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:34.14 */
/*                                                                          */
/* FILE: LIBMSG.MSG  EDIT: EGM2023                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984, 1986 BY			    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 1-013 - ADD LIB$_KEYALRINS, LIB$_KEYNOTFOU.  SBL 20-MAR-1981             */
/* 1-014	- ADD LIB$_INVCVT. FM 24-MAR-81                             */
/* 1-015 - ADD LIB$_INVDTYDSC, LIB$_INVCLADSC, LIB$_INVCLADTY, LIB$_INVNBDS */
/*	      LIB$_DESSTROVF, LIB$_OUTSTRTRU.  FM 21-APR-81                 */
/* 2-001 - CONVERT TO MESSAGE UTILITY SOURCE FORMAT.  ADAPTED FROM LIBMSG.MDL */
/*	  VERSION 1-015.  SBL 23-APR-1981                                   */
/* 2-002 - USE LIB$ FACILITY FOR LIB$_NORMAL.  SBL 27-APR-1981              */
/* 2-003 - ADD LIB$_INTOVF, LIB$_FLTOVF, LIB$_FLTUND, LIB$_DECOVF, LIB$_ROPRAND. */
/* 2-004 - ADD LIB$_WRONUMARG.  RKR 4-SEP-1981                              */
/* 2-005 - ADD MESSAGES FOR LIB$CLI_CALLBACK.  SBL 14-SEPT-1981             */
/* 2-006 - ADD LIB$_INVSYMNAM, MESSAGES FOR LIB$EXTEND_RANGE.  SBL 1-OCT-1981 */
/* 2-007 - ADD LIB$_WASSET AND LIB$_WASCLR.  SBL 16-OCT-1981                */
/* 2-008 - CORRECT TYPO IN LIB$_UNAEXTRAN.  SBL 30-OCT-1981                 */
/* 2-009 - REMOVE LIB$_WASSET AND LIB$_WASCLR.  ADD LIB$_ATTREQREF.  SBL 21-DEC-1981 */
/* 2-010 - REMOVE MESSAGES FOR LIB$EXTEND_RANGE.  SBL 22-DEC-1981           */
/* 2-011 - CORRECT TYPO.  SBL 23-DEC-1981                                   */
/* 2-012 - ADD LIB$_INVFILSPE FOR FILE MANIPULATION PROCEDURES.  MLJ 30-DEC-1981 */
/* 2-013 - ADD LIB$_ERRROUCAL AND .TITLE.  SBL 28-AUG-1982                  */
/* 2-014 - ADD LIB$_INVXAB, LIB$_FILFAIMAT, LIB$_NEGANS, LIB$_QUIPRO,       */
/*	  LIB$_QUICONACT. TSK 20-SEP-1982                                   */
/* 2-015 - ADD LIB$_RESTART.  SBL 1-MAR-1983                                */
/* 2-016 - ADD LIB$_NO_STRACT FOR SCREEN PACKAGE. PLL 19-JUL-1983           */
/* 2-017 - ADD SEVERAL NEW MESSAGES FOR LIB$$READ_OBJECT. BLS 25-FEB-1984   */
/* 2-018 - ADD NEW MESSAGES FOR FUTURE LIB$VM. BLS 11-APR-1984              */
/* 2-019 - ADD LIB$_NOTIMP.  MDL 11-JUL-1985                                */
/* 2-020 - ADD LIB$_BADZONE.  SMM  09-APR-1986                              */
/*                                                                          */
/* 2-021 - ADD ERROR MESSAGES FOR DATE/TIME ROUTINES.  LIB$_IVTIME,         */
/*         LIB$_ONEDELTIM, LIB$_NEGTIM, LIB$_INVARGORD, LIB$_INVOPER,       */
/*	  LIB$_ABSTIMREQ, LIB$_DELTIMREQ  JWN 14-NOV-1986                   */
/* 2-022 - ADD SEVERAL NEW MESSAGES FOR LIB$DATE_FORMAT AKS 20-NOV-1986     */
/* 2-023 - ADD NEW MESSAGES AND UPDATES FOR LIB$DATE_STRING. EGM 12-JAN-1987 */
/*                                                                          */
/*-                                                                         */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	LIB$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$LIBDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS AS EXTERNAL;                 */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*-                                                                         */
/*			; SET LH TO 21 (DECIMAL).                           */
#define LIB$_FACILITY 21
#define LIB$_NORMAL 1409025
#define LIB$_STRTRU 1409041
#define LIB$_ONEENTQUE 1409049
/*			;  LIB$INSQHI, LIB$INSQTI, LIB$REMQHI, LIB$REMQTI   */
#define LIB$_KEYALRINS 1409057
/*			; LIB$INSERT_TREE                                   */
#define LIB$_ERRROUCAL 1409065
/*			; LIB$DELETE_FILE, LIB$RENAME_FILE                  */
#define LIB$_RESTART 1409073
/*			; LIB$DECODE_FAULT                                  */
/*			; NOTE: ERROR CODES MUST NOT OVERLAP SUCESS CODES!!! */
/*			; SET SUB-SYSTEM SPECIFIC BIT FOR NOW.              */
/*			; SET LH TO 21 (DECIMAL).                           */
/*			; SO THAT EACH CODE WILL BE AN WARNING CODE.        */
/*			; SET SUB-SYSTEM SPECIFIC BIT FOR NOW.              */
#define LIB$_BADSTA 1409540
/*			;    LIB$FIXUP_FLT                                  */
#define LIB$_FATERRLIB 1409548
/*			;    LIB$VM_GET                                     */
#define LIB$_INSVIRMEM 1409556
/*			;    LIB$VM_GET, LIB$LOOKUP_KEY                     */
#define LIB$_INPSTRTRU 1409564
/*			;    LIB$GET_INPUT                                  */
#define LIB$_INVSTRDES 1409572
/*			;    LIB$SCOPY_XXXX                                 */
#define LIB$_INTLOGERR 1409580
#define LIB$_INVARG 1409588
/*			;    LIB$LOOKUP_KEY                                 */
#define LIB$_AMBKEY 1409596
/*			;    LIB$LOOKUP_KEY                                 */
#define LIB$_UNRKEY 1409604
#define LIB$_PUSSTAOVE 1409612
/*			;    LIB$FIXUP_FLT                                  */
#define LIB$_USEFLORES 1409620
/*			;    LIB$LOOKUP_KEY                                 */
#define LIB$_SIGNO_ARG 1409628
/*			;    LIB$SIGNAL, LIB$STOP                           */
#define LIB$_BADBLOADR 1409636
/*			; LIB$FREE_VM                                       */
#define LIB$_BADBLOSIZ 1409644
/*			; LIB$GET_VM                                        */
#define LIB$_NOTFOU 1409652
/*			; LIB$FFS, LIB$FFC                                  */
#define LIB$_ATTCONSTO 1409660
/*			; LIB$SIGNAL, LIB$STOP                              */
#define LIB$_SYNTAXERR 1409668
#define LIB$_INVTYPE 1409676
/*			; LIB$TPARSE                                        */
#define LIB$_INSEF 1409684
/*			; LIB$GET_EF                                        */
#define LIB$_EF_ALRFRE 1409692
/*			; LIB$FREE_EF                                       */
#define LIB$_EF_ALRRES 1409700
/*			; LIB$RESERVE_EF                                    */
#define LIB$_EF_RESSYS 1409708
/*			; LIB$FREE_EF, LIB$RESERVE_EF                       */
#define LIB$_INSLUN 1409716
/*			; LIB$GET_LUN                                       */
#define LIB$_LUNALRFRE 1409724
/*			; LIB$FREE_LUN                                      */
#define LIB$_LUNRESSYS 1409732
/*			; LIB$FREE_LUN, LIB$RESERVE_LUN                     */
#define LIB$_SCRBUFOVF 1409740
/*			; SCR PACKAGE                                       */
#define LIB$_INVSCRPOS 1409748
/*			; SCR PACKAGE                                       */
#define LIB$_SECINTFAI 1409756
/*			; LIB$INSQHI, LIB$INSQTI, LIB$REMQHI, LIB$REMQTI    */
#define LIB$_INVCHA 1409764
/*			; LIB$TRA_ASC_EBC, LIB$TRA_EBC_ASC                  */
#define LIB$_QUEWASEMP 1409772
/*			; LIB$REMQHI, LIB$REMQTI                            */
#define LIB$_STRIS_INT 1409780
/*			; LIB$SCOPY, ETC.                                   */
#define LIB$_KEYNOTFOU 1409788
/*			; LIB$LOOKUP_TREE                                   */
#define LIB$_INVCVT 1409796
/*			; LIB$CVTDXDX                                       */
#define LIB$_INVDTYDSC 1409804
/*			; LIB$CVTDXDX                                       */
#define LIB$_INVCLADSC 1409812
/*			; LIB$CVTDXDX                                       */
#define LIB$_INVCLADTY 1409820
/*			; LIB$CVTDXDX                                       */
#define LIB$_INVNBDS 1409828
/*			; LIB$CVTDXDX                                       */
#define LIB$_DESSTROVF 1409836
/*			; LIB$CVTDXDX                                       */
#define LIB$_INTOVF 1409844
/*			; LIB$CVTDXDX                                       */
#define LIB$_DECOVF 1409852
/*			; LIB$CVTDXDX                                       */
#define LIB$_FLTOVF 1409860
/*			; LIB$CVTDXDX                                       */
#define LIB$_FLTUND 1409868
/*			; LIB$CVTDXDX                                       */
#define LIB$_ROPRAND 1409876
/*			; LIB$CVTDXDX                                       */
#define LIB$_WRONUMARG 1409884
/*			; LIB$ANALYZE_SDESC                                 */
#define LIB$_NOSUCHSYM 1409892
/*			; LIB$CLI_CALLBACK                                  */
#define LIB$_INSCLIMEM 1409900
/*			; LIB$CLI_CALLBACK                                  */
#define LIB$_AMBSYMDEF 1409908
/*			; LIB$CLI_CALLBACK                                  */
#define LIB$_NOCLI 1409916
/*			; LIB$CLI_CALLBACK                                  */
#define LIB$_UNECLIERR 1409924
/*			; LIB$CLI_CALLBACK                                  */
#define LIB$_INVSYMNAM 1409932
/*			; LIB$CLI_CALLBACK                                  */
#define LIB$_ATTREQREF 1409940
/*			; LIB$ATTACH                                        */
#define LIB$_INVFILSPE 1409948
/*			; LIB$FID_TO_NAME, LIB$EXTRACT_CONCEALED,           */
/*			; LIB$SET_FILE_PROT, LIB$UNLOCK_FILE, LIB$CREATE_DIR */
#define LIB$_INVXAB 1409956
/*			; LIB$QUAL_FILE_PARSE                               */
#define LIB$_NO_STRACT 1409964
/*			; SCR PACKAGE                                       */
#define LIB$_BADTAGVAL 1409972
/*			; LIB$VM                                            */
#define LIB$_INVOPEZON 1409980
/*			; LIB$VM                                            */
#define LIB$_PAGLIMEXC 1409988
/*			; LIB$VM                                            */
#define LIB$_NOTIMP 1409996
/*			; LIB$NOT_IMPLEMENTED                               */
#define LIB$_BADZONE 1410004
/*			; LIB$VERIFY_VM_ZONE, LIB$SHOW_VM_ZONE, LIB$STAT_VM_ZONE */
/*			; LIB$FIND_VM_ZONE                                  */
#define LIB$_IVTIME 1410012
/*			; LIB$ADD_TIMES, LIB$SUB_TIMES, LIB$MULIPLY_DELTA_TIME */
/*			; LIB$MULTIPLY_DELTA_TIME_F, LIB$CVT_TO_INTERNAL_TIME */
/*			; LIB$CVT_FROM_INTERNAL_TIME, LIB$CONVERT_DATE_STRING */
#define LIB$_ONEDELTIM 1410020
/*			; LIB$ADD_TIMES                                     */
#define LIB$_NEGTIM 1410028
/*			; LIB$SUB_TIMES                                     */
#define LIB$_INVARGORD 1410036
/*			; LIB$SUB_TIMES                                     */
#define LIB$_ABSTIMREQ 1410044
/*			; LIB$CVT_FROM_INTERNAL_TIME                        */
#define LIB$_DELTIMREQ 1410052
/*			; LIB$CVT_FROM_INTERNAL_TIME                        */
#define LIB$_INVOPER 1410060
/*			; LIB$CVT_XXX_INTERNAL_TIME                         */
#define LIB$_REENTRANCY 1410068
/*			;LIB$FORMAT_DATE_TIME, LIB$INIT_DATE_TIME_CONTEXT,  */
/*			;LIB$CONVERT_DATE_STRING, LIB$GET_DATE_FORMAT       */
#define LIB$_UNRFORCOD 1410076
/*			;LIB$FORMAT_DATE_TIME, LIB$CONVERT_DATE_STRING,     */
/*			;LIB$GET_DATE_FORMAT                                */
#define LIB$_ILLINISTR 1410084
/*			;LIB$INIT_DATE_TIME_CONTEXT                         */
#define LIB$_NUMELEMENTS 1410092
/*			;LIB$INIT_DATE_TIME_CONTEXT                         */
#define LIB$_ELETOOLON 1410100
/*			;LIB$INIT_DATE_TIME_CONTEXT                         */
#define LIB$_ILLCOMPONENT 1410108
/*			;LIB$INIT_DATE_TIME_CONTEXT                         */
#define LIB$_AMBDATTIM 1410116
/*			;LIB$CONVERT_DATE_STRING                            */
#define LIB$_INCDATTIM 1410124
/*			;LIB$CONVERT_DATE_STRING                            */
#define LIB$_ILLFORMAT 1410132
/*			;LIB$CONVERT_DATE_STRING, LIB$GET_DATE_FORMAT       */
#define LIB$_OUTSTRTRU 1413120
/*			; LIB$CVTDXDX                                       */
#define LIB$_FILFAIMAT 1413128
/*			; LIB$QUAL_FILE_MATCH                               */
#define LIB$_NEGANS 1413136
/*			; LIB$CONFIRM_ACT                                   */
#define LIB$_QUIPRO 1413144
/*			; LIB$CONFIRM_ACT, LIB$QUAL_FILE_MATCH              */
#define LIB$_QUICONACT 1413152
/*			; LIB$CONFIRM_ACT, LIB$QUAL_FILE_MATCH              */
#define LIB$_ENGLUSED 1413160
/*			;LIB$FORMAT_DATE_TIME, LIB$CONVERT_DATE_STRING,     */
/*			;LIB$GET_DATE_FORMAT                                */
#define LIB$_DEFFORUSE 1413168
/*			;LIB$FORMAT_DATE_TIME, LIB$CONVERT_DATE_STRING,     */
/*			;LIB$GET_DATE_FORMAT                                */
#define LIB$_BADCCC 1425408
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_EOMERROR 1425416
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_EOMFATAL 1425424
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_EOMWARN 1425432
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_GSDTYP 1425440
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLFMLCNT 1425448
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLMODNAM 1425456
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLPSCLEN 1425464
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLRECLEN 1425472
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLRECLN2 1425480
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLRECTYP 1425488
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLRECTY2 1425496
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_ILLSYMLEN 1425504
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_NOEOM 1425512
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_RECTOOSML 1425520
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_SEQUENCE 1425528
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_SEQUENCE2 1425536
/*			; LIB$$READ_OBJECT                                  */
#define LIB$_STRLVL 1425544
/*			; LIB$$READ_OBJECT                                  */

#endif					/* __LIBDEF_LOADED */
#ifndef __LIBDTDEF_LOADED
#define __LIBDTDEF_LOADED	1

/*** MODULE $libdtdef ***/
/*                                                                          */
/* Interface definitions for LIB$DT (date/time) package                     */
/*                                                                          */
/*                                                                          */
/* Request codes for LIB$INIT_DATE_TIME_CONTEXT                             */
/*                                                                          */
#define LIB$K_MONTH_NAME 0              /*Pre-init the month names          */
#define LIB$K_MONTH_NAME_ABB 3          /*Pre-init the month names          */
#define LIB$K_WEEKDAY_NAME 6            /*Pre-init the week names           */
#define LIB$K_WEEKDAY_NAME_ABB 9        /*Pre-init the week names           */
#define LIB$K_MERIDIEM_INDICATOR 12     /*Pre-init the AM/PM names          */
#define LIB$K_OUTPUT_FORMAT 1           /*Pre-init the format               */
#define LIB$K_INPUT_FORMAT 2            /*Pre-init the format               */
#define LIB$K_RELATIVE_DAY_NAME 15      /*Pre-init "TODAY", etc.            */
#define LIB$K_FORMAT_MNEMONICS 18       /*Pre-init MM, DD, YYYY, etc.       */
/*                                                                          */
/* Operation codes (flags) for date time conversion routines.               */
/* NOTE:  any new operation codes MUST be added just BEFORE MAX_OPERATION   */
/*                                                                          */
#define LIB$K_MONTH_OF_YEAR 1           /* requests output in units of month of year */
#define LIB$K_DAY_OF_YEAR 2             /* requests output in days of year 1-366 */
#define LIB$K_HOUR_OF_YEAR 3            /* requests output in hours of year 1-8784 */
#define LIB$K_MINUTE_OF_YEAR 4          /* requests output in minutes of year 1-527040 */
#define LIB$K_SECOND_OF_YEAR 5          /* requests output in seconds of year 1-31622400 */
#define LIB$K_DAY_OF_MONTH 6            /* request output in days of month 1-31 */
#define LIB$K_HOUR_OF_MONTH 7           /* request output in hours of month 1-744 */
#define LIB$K_MINUTE_OF_MONTH 8         /* request output in minutes of month 1-44640 */
#define LIB$K_SECOND_OF_MONTH 9         /* requests output in seconds of month 1-2678400 */
#define LIB$K_DAY_OF_WEEK 10            /* requests output in days of week 1-7 with monday = 1 */
#define LIB$K_HOUR_OF_WEEK 11           /* requests output in hours of week 1-168 */
#define LIB$K_MINUTE_OF_WEEK 12         /* requests in minutes of week 1-10080 */
#define LIB$K_SECOND_OF_WEEK 13         /* requests output in seconds of week 1-604800 */
#define LIB$K_HOUR_OF_DAY 14            /* requests output in hours of day 1-24 */
#define LIB$K_MINUTE_OF_DAY 15          /* requests output in minutes of day 1-1440 */
#define LIB$K_SECOND_OF_DAY 16          /* requests output in seconds of day 1-3600 */
#define LIB$K_MINUTE_OF_HOUR 17         /* requests output in minutes of hour 1-60 */
#define LIB$K_SECOND_OF_HOUR 18         /* requests output in minutes of hour 1-3600 */
#define LIB$K_SECOND_OF_MINUTE 19       /* requests output in seconds of minutes 1-60 */
#define LIB$K_JULIAN_DATE 20            /* requests output as a julian day number */
#define LIB$K_DELTA_WEEKS 21            /* input/output in terms of delta weeks */
#define LIB$K_DELTA_DAYS 22             /* input/output in terms of delta days */
#define LIB$K_DELTA_HOURS 23            /* input/output in terns of delta hours */
#define LIB$K_DELTA_MINUTES 24          /* input/output in terms of delta minutes */
#define LIB$K_DELTA_SECONDS 25          /* input/output in terms of delta seconds */
#define LIB$K_DELTA_WEEKS_F 26          /* input/output in terms of fractional delta weeks */
#define LIB$K_DELTA_DAYS_F 27           /* input/output in terms of fractional delta days */
#define LIB$K_DELTA_HOURS_F 28          /* input/output in terms of fractional delta hours */
#define LIB$K_DELTA_MINUTES_F 29        /* input/output in terms of fractional delta minutess */
#define LIB$K_DELTA_SECONDS_F 30        /* input/output in terms of fractional delta seconds */
#define LIB$K_MAX_OPERATION 31          /* 1+ max # of conversion flags     */
/*                                                                          */
/* Masks for outputting date or time fields only                            */
/*                                                                          */
#define LIB$M_TIME_FIELDS 1
#define LIB$M_DATE_FIELDS 2
struct dt_print_fields {
    unsigned lib$v_time_fields : 1;     /* Force printing of time fields    */
    unsigned lib$v_date_fields : 1;     /* Force printing of date fields    */
    unsigned lib$v_fill_0 : 6;
    } ;
/*                                                                          */
/* Masks for input defaulting flag longword                                 */
/*                                                                          */
#define LIB$M_YEAR 1
#define LIB$M_MONTH 2
#define LIB$M_DAY 4
#define LIB$M_HOUR 8
#define LIB$M_MINUTE 16
#define LIB$M_SECOND 32
#define LIB$M_HUNDREDTHS 64
struct dt_default_fields {
    unsigned lib$v_year : 1;            /* Allow the year to be defaulted   */
    unsigned lib$v_month : 1;           /* Allow the month to be defaulted  */
    unsigned lib$v_day : 1;             /* Allow the day to be defaulted    */
    unsigned lib$v_hour : 1;            /* Allow the hour to be defaulted   */
    unsigned lib$v_minute : 1;          /* Allow the minute to be defaulted */
    unsigned lib$v_second : 1;          /* Allow the second to be defaulted */
    unsigned lib$v_hundredths : 1;      /* Allow the fract to be defaulted  */
    unsigned lib$v_fill_1 : 1;
    } ;

#endif					/* __LIBDTDEF_LOADED */
#ifndef __LIBVMDEF_LOADED
#define __LIBVMDEF_LOADED	1

/*** MODULE $libvmdef ***/
/* Interface definitions for LIB$VM package                                 */
/*                                                                          */
/* LIB$CREATE_VM_ZONE algorithm codes                                       */
#define LIB$K_VM_FIRST_FIT 1            /* First fit                        */
#define LIB$K_VM_QUICK_FIT 2            /* Quick fit, with fixed queues of preferred sizes */
#define LIB$K_VM_FREQ_SIZES 3           /* First fit, with frequent sizes cache */
#define LIB$K_VM_FIXED 4                /* Fixed size blocks                */
/* LIB$CREATE_VM_ZONE flag definitions                                      */
#define LIB$M_VM_BOUNDARY_TAGS 1        /* Boundary tagged blocks           */
#define LIB$M_VM_GET_FILL0 2            /* 0-fill for LIB$GET_VM            */
#define LIB$M_VM_GET_FILL1 4            /* 1-fill for LIB$GET_VM            */
#define LIB$M_VM_FREE_FILL0 8           /* 0-fill for LIB$FREE_VM           */
#define LIB$M_VM_FREE_FILL1 16          /* 1-fill for LIB$FREE_VM           */
#define LIB$M_VM_EXTEND_AREA 32         /* Add extent to existing area if possible */

#endif					/* __LIBVMDEF_LOADED */
#ifndef __LIMITS_LOADED
#define __LIMITS_LOADED	1

/*	LIMITS - V3.0	*/

# define CHAR_BIT	8
# define CHAR_MAX	127
# define CHAR_MIN	-128
# define INT_MAX	2147483647
# define INT_MIN	-2147483648
# define LONG_MAX	2147483647
# define LONG_MIN	-2147483648
# define SCHAR_MAX	127	
# define SCHAR_MIN	-128
# define SHRT_MAX	32767
# define SHRT_MIN	-32768

/* Section 2.2.4.2 of the Rationale states "The limits for the maxima
 * and minima of unsigned types are specified as unsigned constants..."
 * The alert reader will notice there are no minima for the unsigned
 * types.   But we will follow the Rationale's advice anyway.
 */
# define UCHAR_MAX	255u
# define UINT_MAX	4294967295u
# define ULONG_MAX	4294967295u
# define USHRT_MAX	65535u

#endif					/* __LIMITS_LOADED */
#ifndef __LKIDEF_LOADED
#define __LKIDEF_LOADED	1

/*** MODULE $lkidef ***/
/*+                                                                         */
/*                                                                          */
/* Get Lock Information Data Identifier Definitions                         */
/*                                                                          */
/* **** NOTE ****                                                           */
/*                                                                          */
/*        New items must always be added to the END of each item list       */
/*        (preceeding the ENDlistname item) so that users will not have     */
/*        to relink.                                                        */
/*-                                                                         */
/* ITEM LIST BLOCKS                                                         */
#define LKI$K_LENGTH 24                 /*LENGTH OF LIST BLOCK              */
#define LKI$C_LENGTH 24                 /*LENGTH OF LIST BLOCK              */
#pragma nostandard
struct lkidef {
    variant_union  {
        unsigned long int lki$l_mstlkid; /*LOCK ID ON MASTER                */
        unsigned long int lki$l_lockid; /*OLD SYMBOL                        */
        } lki$r_u1;
    unsigned long int lki$l_pid;        /*PROCESS ID                        */
    variant_union  {
        unsigned long int lki$l_mstcsid; /*CSID OF MASTER                   */
        unsigned long int lki$l_sysid;  /*OLD SYMBOL                        */
        } lki$r_u2;
    unsigned char lki$b_rqmode;         /*REQUEST MODE                      */
    unsigned char lki$b_grmode;         /*GRANTED MODE                      */
    char lki$b_queue;                   /*LOCK QUEUE                        */
    char lki$$$_spare;                  /*SPARE BYTE                        */
    variant_union  {
        unsigned long int lki$l_lkid;   /*LOCK ID ON PROCESS NODE           */
        unsigned long int lki$l_remlkid; /*OLD SYMBOL                       */
        } lki$r_u3;
    variant_union  {
        unsigned long int lki$l_csid;   /*CSID OF PROCESS NODE              */
        unsigned long int lki$l_remsysid; /*OLD SYMBOL                      */
        } lki$r_u4;
    } ;
/* DEFINE NAMSPACE FIELDS                                                   */
#define LKI$M_SYSNAM -2147483648
struct namspace {
    variant_union  {
        variant_struct  {
            unsigned short int lki$w_group; /*GROUP OF OWNER UIC            */
            unsigned char lki$b_rmod;   /*ACCESS MODE OF REQUEST            */
            unsigned char lki$b_status; /*STATUS OF RESOURCE                */
            } lki$r_namspace_fields;
        variant_struct  {
            unsigned lki$$_fill : 31;   /* SPARE                            */
            unsigned lki$v_sysnam : 1;  /* SYSTEM WIDE RSB                  */
            } lki$r_status_bits;
        } lki$r_namspace_union;
    } ;
/* DEFINE STATE FIELDS                                                      */
struct statef {
    unsigned char lki$b_state_rqmode;   /*REQUEST MODE                      */
    unsigned char lki$b_state_grmode;   /*GRANTED MODE                      */
    char lki$b_state_queue;             /*LOCK STATE CODE                   */
    } ;
#pragma standard
/*LOCK STATE CODE VALUES                                                    */
#define LKI$C_GRANTED 1                 /* GRANTED                          */
#define LKI$C_CONVERT 0                 /* CONVERSION                       */
#define LKI$C_WAITING -1                /* WAITING                          */
#define LKI$C_RETRY -2                  /* RETRY REQUEST                    */
#define LKI$C_SCSWAIT -3                /* SCS WAIT                         */
#define LKI$C_RSPNOTQED -4              /* RESPONSE NOT QUEUED              */
#define LKI$C_RSPQUEUED -5              /* RESPONSE QUEUED                  */
#define LKI$C_RSPGRANTD -6              /* RESPONSE GRANTED                 */
#define LKI$C_RSPDOLOCL -7              /* RESPONSE DO LOCALLY              */
#define LKI$C_RSPRESEND -8              /* RESPONSE RESEND                  */
/* DEFINE TABLE NUMBERS                                                     */
/* STRUCTURE CODES MUST START AT 1                                          */
#define LKI$C_LKBTYPE 1                 /* ITEM IN LKB                      */
#define LKI$C_RSBTYPE 2                 /* ITEM IN RSB                      */
#define LKI$C_LISTEND 0                 /* DEFINE ITMLST TERMINATOR         */
/* ITEM IDENTIFIERS FOR LKB                                                 */
#define LKI$_PID 256                    /* PROCESS ID                       */
#define LKI$_STATE 257                  /* CURRENT LOCK STATE               */
#define LKI$_PARENT 258                 /* ID OF PARENT LOCK                */
#define LKI$_LCKREFCNT 259              /* SUB-LOCK REFERENCE COUNT         */
#define LKI$_LOCKID 260                 /* LOCK ID                          */
#define LKI$_REMLKID 261                /* REMOTE LOCK ID                   */
#define LKI$_MSTLKID 262                /* LOCK ID ON RESOURCE MASTER       */
#define LKI$_LKID 263                   /* LOCK ID ON PROCESS NODE          */
#define LKI$_CSID 264                   /* CSID OF PROCESS NODE             */
#define LKI$_LASTLKB 265                /* MAX INDEX IN LKB TABLE           */
/* ITEM IDENTIFIERS FOR RSB                                                 */
#define LKI$_NAMSPACE 512               /* RESOURCE NAME SPACE              */
#define LKI$_RESNAM 513                 /* RESOURCE NAME                    */
#define LKI$_RSBREFCNT 514              /* SUB-RESOURCE REFERENCE COUNT     */
#define LKI$_VALBLK 515                 /* VALUE BLOCK                      */
#define LKI$_SYSTEM 516                 /* SYSTEM ID OF SYSTEM WITH RESOURCE */
#define LKI$_LCKCOUNT 517               /* COUNT OF LOCKS ON RESOURCE       */
#define LKI$_BLOCKEDBY 518              /* LIST OF LOCKS BLOCKED BY CURRENT LOCK */
#define LKI$_BLOCKING 519               /* LIST OF LOCKS BLOCKING CURRENT LOCK */
#define LKI$_LOCKS 520                  /* LIST OF ALL LOCKS ON RESOURCE    */
#define LKI$_CVTCOUNT 521               /* COUNT OF LOCKS ON CONVERSION QUEUE */
#define LKI$_WAITCOUNT 522              /* COUNT OF LOCKS ON WAIT QUEUE     */
#define LKI$_GRANTCOUNT 523             /* COUNT OF LOCKS ON GRANT QUEUE    */
#define LKI$_MSTCSID 524                /* CSID OF RESOURCE MASTER          */
#define LKI$_LASTRSB 525                /* MAX INDEX IN RSB                 */

#endif					/* __LKIDEF_LOADED */
#ifndef __LMFDEF_LOADED
#define __LMFDEF_LOADED	1

/*** MODULE $lmfdef ***/
#define LMF$_PROD_TOKEN 1
#define LMF$_HW_ID 2
#define LMF$_PROD_VERSION 3
#define LMF$_PROD_DATE 4
#define LMF$_CHARGE_TYPE 5
#define LMF$_UNITS_IN_USE 6
#define LMF$C_PRDNAMLEN 24
#define LMF$K_PRDNAMLEN 24
#define LMF$C_PRDUCERLEN 24
#define LMF$K_PRDUCERLEN 24
#define LMF$C_CONTEXTLEN 16
#define LMF$K_CONTEXTLEN 16
#define LMF$C_TOKENLEN 31
#define LMF$K_TOKENLEN 31
#define LMF$C_HW_IDLEN 31
#define LMF$K_HW_IDLEN 31
#define LMF$C_VERSIONLEN 4
#define LMF$K_VERSIONLEN 4
#define LMF$K_DATELEN 8
#define LMF$C_DATELEN 8
#define LMF$M_RETURN_FAILURES 1
#define LMF$M_BROADCAST_FAILURES 2
#define LMF$M_OUTPUT_FAILURES 4
#define LMF$M_LOOKUP_LICENSE_SPARE -8
struct dvspm_masks {
    unsigned lmf$v_return_failures : 1; /* return status .vs. signal        */
    unsigned lmf$v_broadcast_failures : 1; /* do an OPCOM                   */
    unsigned lmf$v_output_failures : 1; /* do a PUTMSG                      */
    unsigned lmf$v_lookup_license_spare : 29; /* spare area                 */
    } ;
 

#endif					/* __LMFDEF_LOADED */
#ifndef __LNKDEF_LOADED
#define __LNKDEF_LOADED	1

/*** MODULE $lnkdef ***/
/*                                                                          */
/* Linker Options Record (LNK)                                              */
/*                                                                          */
#define LNK$C_OLB 0                     /* object library spec              */
#define LNK$C_SHR 1                     /* shareable image library spec     */
#define LNK$C_OLI 2                     /* object library with inclusion list   */
#define LNK$C_OBJ 3                     /* object file or symbol table file */
#define LNK$C_SHA 4                     /* individually specified shr img   */
#define LNK$C_MAXRECTYP 4               /* highest current record type      */
#define LNK$M_SELSER 1
#define LNK$M_LIBSRCH 2
struct lnkdef {
    unsigned char lnk$b_rectyp;         /* record type LNK                  */
    unsigned char lnk$b_lnktyp;         /* sub record type                  */
#pragma nostandard
    variant_union  {
        unsigned short int lnk$w_flags;
        variant_struct  {
            unsigned lnk$v_selser : 1;  /* selectively searched (LNK$C_OBJ) */
            unsigned lnk$v_libsrch : 1;
            unsigned lnk$v_fill_14 : 6;
            } lnk$r_flags_bits;
        } lnk$r_flags_overlay;
    variant_union  {
        unsigned short int lnk$w_namlng; /* length of filespec name         */
        variant_struct  {
            char lnkdef$$_fill_1 [2];
            char lnk$t_name [];         /* actual name                      */
            } lnk$r_namlng_fields;
        } lnk$r_namlng_overlay;
    } ;
 
#pragma standard

#endif					/* __LNKDEF_LOADED */
#ifndef __LNMDEF_LOADED
#define __LNMDEF_LOADED	1

/*** MODULE $lnmdef ***/
#define LNM$M_NO_ALIAS 1
#define LNM$M_CONFINE 2
#define LNM$M_CRELOG 4
#define LNM$M_TABLE 8
#define LNM$M_CONCEALED 256
#define LNM$M_TERMINAL 512
#define LNM$M_EXISTS 1024
#define LNM$M_SHAREABLE 65536
#define LNM$M_CREATE_IF 16777216
#define LNM$M_CASE_BLIND 33554432
struct lnmdef {
/* Logical name attributes -- bits 0-7                                      */
    unsigned lnm$v_no_alias : 1;        /* Do not allow outer mode alias    */
    unsigned lnm$v_confine : 1;         /* Do not copy into subprocess      */
    unsigned lnm$v_crelog : 1;          /* Created with old $CRELOG service */
    unsigned lnm$v_table : 1;           /* This is a table name             */
    unsigned lnm$v_fill_0 : 4;          /* Fill out logical name byte       */
/* Logical name translation attributes -- bits 8-15                         */
    unsigned lnm$v_concealed : 1;       /* Do not display result of translation */
    unsigned lnm$v_terminal : 1;        /* Do not retranslate result of translation */
    unsigned lnm$v_exists : 1;          /* Translation does exist at this index */
    unsigned lnm$v_fill_1 : 5;          /* Fill out translation byte        */
/* Logical name table characteristics -- bits 16-23                         */
    unsigned lnm$v_shareable : 1;       /* Logical name table is shareable (S0 space) */
    unsigned lnm$v_fill_2 : 3;          /* Reserved bit numbers 17-19       */
    unsigned lnm$v_fill_3 : 4;          /* Fill out table byte              */
/* System service options -- bits 24-31                                     */
    unsigned lnm$v_create_if : 1;       /* May map to existing logical name table */
    unsigned lnm$v_case_blind : 1;      /* Perform case-insensitive translation */
    unsigned lnm$v_fill_4 : 6;          /* Fill out options byte            */
    } ;
#define LNM$C_TABNAMLEN 31              /* Maximum length of a name contained within a directory table */
#define LNM$C_NAMLENGTH 255             /* Maximum logical name / translation length */
#define LNM$C_MAXDEPTH 10               /* Maximum logical name recursion depth */
#define LNM$_INDEX 1                    /* Translation index                */
#define LNM$_STRING 2                   /* Translation string               */
#define LNM$_ATTRIBUTES 3               /* Attribute bits                   */
#define LNM$_TABLE 4                    /* Logical name table name          */
#define LNM$_LENGTH 5                   /* Length of translation string     */
#define LNM$_ACMODE 6                   /* Access mode of name              */
#define LNM$_MAX_INDEX 7                /* Maximum translation index        */
#define LNM$_PARENT 8                   /* Parent logical name table name   */
#define LNM$_LNMB_ADDR 9                /* Return LNM block address         */
/*  internal use by MTL                                                     */
/*  and mailbox UCB                                                         */
/* Define item list codes                                                   */
#define LNM$_CHAIN -1                   /* Chain to next list               */
 

#endif					/* __LNMDEF_LOADED */
#ifndef __LPDEF_LOADED
#define __LPDEF_LOADED	1

/*** MODULE $lpdef ***/
/*+                                                                         */
/* LINE PRINTER CHARACTERISTICS DEFINITIONS                                 */
/*-                                                                         */
#define LP$M_CR 1
#define LP$M_MECHFORM 2
#define LP$M_PRINTALL 4
#define LP$M_DAVFU 8
#define LP$M_WRAP 16
#define LP$M_TRUNCATE 32
#define LP$M_TAB 64
#define LP$M_LOWER 128
#define LP$M_PASSALL 256
#define LP$M_FALLBACK 512
#define LP$M_SIXELS 1024
#define LP$M_BITMAPPED 2048
#define LP$M_PAGE_L -16777216
#define LP$_LP11 1
#define LP$_LA11 2
#define LP$_LA180 3
union lpdef {
#pragma nostandard
    variant_struct  {
        unsigned lp$v_cr : 1;           /* CARRIAGE RETURN NEEDED           */
        unsigned lp$v_mechform : 1;     /* MECHANICAL FORM FEED             */
        unsigned lp$v_printall : 1;     /* NON PRINTABLE CHAR. ACCEPT(DMF-32)  */
        unsigned lp$v_davfu : 1;        /* DAVFU AVAIL.                     */
        unsigned lp$v_wrap : 1;         /* CHAR. WRAP MODE                  */
        unsigned lp$v_truncate : 1;     /* TRUNCATE output at carriage width */
        unsigned lp$v_tab : 1;          /* TAB needed                       */
        unsigned lp$v_lower : 1;        /* PRINTER HAS LOWER CASE           */
        unsigned lp$v_passall : 1;      /* PASSALL MODE                     */
        unsigned lp$v_fallback : 1;     /* FALLBACK MODE                    */
        unsigned lp$v_sixels : 1;       /* HANDLES SIXELS                   */
        unsigned lp$v_bitmapped : 1;    /* HANDLES BIT MAPS                 */
        unsigned lpdef$$_fill_2 : 12;   /* SPARE UNUSED BITS                */
        unsigned lp$v_page_l : 8;       /* PAGE LENGTH                      */
        } lp$r_lpdef_bits;
    } ;
#pragma standard

#endif					/* __LPDEF_LOADED */
#ifndef __LPRODEF_LOADED
#define __LPRODEF_LOADED	1

/*** MODULE $lprodef ***/
/*                                                                          */
/* GSD entry - Module Local Procedure definition                            */
/*                                                                          */
#define LPRO$K_NAME 15
#define LPRO$C_NAME 15
struct lprodef {
#pragma nostandard
    variant_union  {
        unsigned char lpro$b_gsdtyp;    /*Maps over LSY$B_GSDTYP            */
        variant_struct  {
            char lpro$t_start [];
            char lprodef$$_fill_1;
            } lpro$r_gsdtyp_fields;
        } lpro$r_gsdtyp_overlay;
    unsigned char lpro$b_datyp;         /*Maps over LSY$B_DATYP             */
    unsigned short int lpro$w_flags;    /*Maps over LSY$W_FLAGS             */
    unsigned short int lpro$w_envindx;  /*Environment index symbol defined in  */
    unsigned short int lpro$w_psindx;   /*Maps over LSDF$W_PSINDX           */
    unsigned long int lpro$l_addrs;     /*Entry point address, maps         */
/* over LSDF$L_VALUE                                                        */
    unsigned short int lpro$w_mask;     /*Entry point mask                  */
    unsigned char lpro$b_namlng;        /*Length of name                    */
    char lpro$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __LPRODEF_LOADED */
#ifndef __LSDFDEF_LOADED
#define __LSDFDEF_LOADED	1

/*** MODULE $lsdfdef ***/
/*                                                                          */
/* Module-local Symbol definition                                           */
/*                                                                          */
#define LSDF$K_NAME 13
#define LSDF$C_NAME 13
struct lsdfdef {
#pragma nostandard
    variant_union  {
        unsigned char lsdf$b_gsdtyp;    /*Maps over LSY$B_GSDTYP            */
        variant_struct  {
            char lsdf$t_start [];
            char lsdfdef$$_fill_1;
            } lsdf$r_gsdtyp_fields;
        } lsdf$r_gsdtyp_overlay;
    unsigned char lsdf$b_datyp;         /*Maps over LSY$B_DATYP             */
    unsigned short int lsdf$w_flags;    /*Maps over LSY$W_FLAGS             */
    unsigned short int lsdf$w_envindx;  /*Environment index symbol defined in  */
    unsigned short int lsdf$w_psindx;   /*Owning psect number               */
    unsigned long int lsdf$l_value;     /*Value of symbol                   */
    unsigned char lsdf$b_namlng;        /*Length of name                    */
    char lsdf$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __LSDFDEF_LOADED */
#ifndef __LSRFDEF_LOADED
#define __LSRFDEF_LOADED	1

/*** MODULE $lsrfdef ***/
/*                                                                          */
/* Module-local Symbol reference (LSY$M_DEF in LSY$W_FLAGS is 0)            */
/*                                                                          */
#define LSRF$K_NAME 7
#define LSRF$C_NAME 7
struct lsrfdef {
#pragma nostandard
    variant_union  {
        unsigned char lsrf$b_gsdtyp;    /*Maps over LSY$B_GSDTYP            */
        variant_struct  {
            char lsrf$t_start [];
            char lsrfdef$$_fill_1;
            } lsrf$r_gsdtyp_fields;
        } lsrf$r_gsdtyp_overlay;
    unsigned char lsrf$b_datyp;         /*Maps over LSY$B_DATYP             */
    unsigned short int lsrf$w_flags;    /*Maps over LSY$W_FLAGS             */
    unsigned short int lsrf$w_envindx;  /*Maps over LSY$W_ENVINDX           */
    unsigned char lsrf$b_namlng;        /*Length of symbol name             */
    char lsrf$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __LSRFDEF_LOADED */
#ifndef __LSYDEF_LOADED
#define __LSYDEF_LOADED	1

/*** MODULE $lsydef ***/
/*                                                                          */
/* LSY - Module-Local symbol definition                                     */
/*                                                                          */
/* Common to definitions, references, entry points, and procedure definitions */
/*                                                                          */
#define LSY$M_WEAK 1
#define LSY$M_DEF 2
#define LSY$M_UNI 4
#define LSY$M_REL 8
struct lsydef {
#pragma nostandard
    variant_union  {
        unsigned char lsy$b_gsdtyp;     /*Type field                        */
        variant_struct  {
            char lsy$t_start [];
            char lsydef$$_fill_1;
            } lsy$r_gsdtyp_fields;
        } lsy$r_gsdtyp_overlay;
    unsigned char lsy$b_datyp;          /*Symbol type                       */
    variant_union  {
        unsigned short int lsy$w_flags; /*Symbol flags                      */
        variant_struct  {
            unsigned lsy$v_weak : 1;    /*Weak symbol (not used)            */
            unsigned lsy$v_def : 1;     /*Defined symbol                    */
            unsigned lsy$v_uni : 1;     /*Universal (not used)              */
            unsigned lsy$v_rel : 1;     /*Relocatable                       */
            unsigned lsy$v_fill_21 : 4;
            } lsy$r_flags_bits;
        } lsy$r_flags_overlay;
    unsigned short int lsy$w_envindx;   /*Environment index                 */
    } ;
 
#pragma standard

#endif					/* __LSYDEF_LOADED */
#ifndef __MAILDEF_LOADED
#define __MAILDEF_LOADED	1

/*** MODULE $maildef ***/
/*                                                                          */
/* Definitions needed for callable mail.                                    */
/*                                                                          */
/*                                                                          */
/* NOTE: New item codes must be appended to the end of                      */
/*       each category so users will not have to relink.                    */
/*       We allow 1024 entries in eatch category.                           */
/*                                                                          */
/*                                                                          */
/* Send input codes                                                         */
/*                                                                          */
#define MAIL$_SEND_SPARE_0 1
#define MAIL$_SEND_FOREIGN 2            /* Send foreign format message      */
#define MAIL$_SEND_CC_LINE 3            /* CC text specification            */
#define MAIL$_SEND_DEFAULT_NAME 4       /* Default file name for send       */
#define MAIL$_SEND_DEFAULT_TRANSPORT 5  /* Default transport used for addressees */
#define MAIL$_SEND_ERROR_ENTRY 6        /* Entry point for send error routine */
#define MAIL$_SEND_FILENAME 7           /* Specification of file name to send */
#define MAIL$_SEND_FROM_LINE 8          /* From text specification          */
#define MAIL$_SEND_NO_DEFAULT_TRANSPORT 9 /* Don't use any default transport on send */
#define MAIL$_SEND_PERS_NAME 10         /* Personal name text for message   */
#define MAIL$_SEND_RECORD 11            /* Record to be sent                */
#define MAIL$_SEND_RESULTSPEC 12        /* Resultant filespec bodypart      */
#define MAIL$_SEND_SERVER 13            /* Operate in server mode (signal success) */
#define MAIL$_SEND_SUBJECT 14           /* Subject text specification       */
#define MAIL$_SEND_SUCCESS_ENTRY 15     /* Entry point for send success routine */
#define MAIL$_SEND_TO_LINE 16           /* To line text specification       */
#define MAIL$_SEND_UFLAGS 17            /* User flags (for header) to send  */
#define MAIL$_SEND_USER_DATA 18         /* User specified context for action routines */
#define MAIL$_SEND_USERNAME 19          /* Username to add to the "To" list */
#define MAIL$_SEND_USERNAME_TYPE 20     /* Username type - TO or CC         */
#define MAIL$_SEND_FID 21               /* FID of file to send              */
#define MAIL$_SEND_NO_PERS_NAME 22      /* Send message without personal name */
#define MAIL$_SEND_IN_SPARE3 23
#define MAIL$_SEND_IN_SPARE4 24
#define MAIL$_SEND_IN_SPARE5 25
/*                                                                          */
/* Send output codes                                                        */
/*                                                                          */
#define MAIL$_SEND_COPY_REPLY 26        /* Copy self reply set in profile   */
#define MAIL$_SEND_COPY_SEND 27         /* Copy self send  set in profile   */
#define MAIL$_SEND_USER 28              /* Username of caller               */
#define MAIL$_SEND_COPY_FORWARD 29      /* Copy self forward set in profile */
#define MAIL$_SEND_OUT_SPARE2 30
#define MAIL$_SEND_OUT_SPARE3 31
#define MAIL$_SEND_OUT_SPARE4 32
#define MAIL$_SEND_OUT_SPARE5 33
#define MAIL$K_SEND_MIN_ITEM 1
#define MAIL$K_SEND_MAX_ITEM 33
#define MAIL$K_SEND_ITEMS 33
/*                                                                          */
/* file input codes                                                         */
/*                                                                          */
#define MAIL$_MAILFILE_SPARE_0 1025
#define MAIL$_MAILFILE_DEFAULT_NAME 1026 /* Default filespec to open        */
#define MAIL$_MAILFILE_FOLDER_ROUTINE 1027 /* Entry point of routine to process foldernames */
#define MAIL$_MAILFILE_FULL_CLOSE 1028  /* Do a PURGE, CONVERT/RECLAIM if necessary on close */
#define MAIL$_MAILFILE_NAME 1029        /* File spec to open                */
#define MAIL$_MAILFILE_RECLAIM 1030     /* Do RECLAIM on PURGE command      */
#define MAIL$_MAILFILE_USER_DATA 1031   /* User specified context for action routines */
#define MAIL$_MAILFILE_WASTEBASKET_NAME 1032 /* New wastebasket name for file */
#define MAIL$_MAILFILE_IN_SPARE1 1033
#define MAIL$_MAILFILE_IN_SPARE2 1034
#define MAIL$_MAILFILE_IN_SPARE3 1035
#define MAIL$_MAILFILE_IN_SPARE4 1036
#define MAIL$_MAILFILE_IN_SPARE5 1037
#define MAIL$_MAILFILE_IN_SPARE6 1038
#define MAIL$_MAILFILE_IN_SPARE7 1039
#define MAIL$_MAILFILE_IN_SPARE8 1040
#define MAIL$_MAILFILE_IN_SPARE9 1041
#define MAIL$_MAILFILE_IN_SPARE10 1042
#define MAIL$_MAILFILE_IN_SPARE11 1043
#define MAIL$_MAILFILE_IN_SPARE12 1044
#define MAIL$_MAILFILE_IN_SPARE13 1045
#define MAIL$_MAILFILE_IN_SPARE14 1046
#define MAIL$_MAILFILE_IN_SPARE15 1047
#define MAIL$_MAILFILE_IN_SPARE16 1048
#define MAIL$_MAILFILE_IN_SPARE17 1049
#define MAIL$_MAILFILE_IN_SPARE18 1050
#define MAIL$_MAILFILE_IN_SPARE19 1051
#define MAIL$_MAILFILE_IN_SPARE20 1052
/*                                                                          */
/* file output codes                                                        */
/*                                                                          */
#define MAIL$_MAILFILE_DATA_RECLAIM 1053 /* Number of data buckets reclaimed */
#define MAIL$_MAILFILE_DATA_SCAN 1054   /* Number of data buckets scanned   */
#define MAIL$_MAILFILE_DELETED_BYTES 1055 /* Number of free bytes in mail file */
#define MAIL$_MAILFILE_INDEX_RECLAIM 1056 /* Number of index buckets reclaimed */
#define MAIL$_MAILFILE_MAIL_DIRECTORY 1057 /* Mail sub-directory specification */
#define MAIL$_MAILFILE_MESSAGES_DELETED 1058 /* Number of messages deleted  */
#define MAIL$_MAILFILE_RESULTSPEC 1059  /* Resultant file spec              */
#define MAIL$_MAILFILE_TOTAL_RECLAIM 1060 /* Total buckets reclaimed        */
#define MAIL$_MAILFILE_WASTEBASKET 1061 /* Wastebasket name                 */
#define MAIL$_MAILFILE_INDEXED 1062     /* ISAM file                        */
#define MAIL$_MAILFILE_OUT_SPARE2 1063
#define MAIL$_MAILFILE_OUT_SPARE3 1064
#define MAIL$_MAILFILE_OUT_SPARE4 1065
#define MAIL$_MAILFILE_OUT_SPARE5 1066
#define MAIL$_MAILFILE_OUT_SPARE6 1067
#define MAIL$_MAILFILE_OUT_SPARE7 1068
#define MAIL$_MAILFILE_OUT_SPARE8 1069
#define MAIL$_MAILFILE_OUT_SPARE9 1070
#define MAIL$_MAILFILE_OUT_SPARE10 1071
#define MAIL$_MAILFILE_OUT_SPARE11 1072
#define MAIL$_MAILFILE_OUT_SPARE12 1073
#define MAIL$_MAILFILE_OUT_SPARE13 1074
#define MAIL$_MAILFILE_OUT_SPARE14 1075
#define MAIL$_MAILFILE_OUT_SPARE15 1076
#define MAIL$_MAILFILE_OUT_SPARE16 1077
#define MAIL$_MAILFILE_OUT_SPARE17 1078
#define MAIL$_MAILFILE_OUT_SPARE18 1079
#define MAIL$_MAILFILE_OUT_SPARE19 1080
#define MAIL$_MAILFILE_OUT_SPARE20 1081
#define MAIL$K_MAILFILE_MIN_ITEM 1025
#define MAIL$K_MAILFILE_MAX_ITEM 1081
#define MAIL$K_MAILFILE_ITEMS 57
/*                                                                          */
/* message input codes                                                      */
/*                                                                          */
#define MAIL$_MESSAGE_SPARE_0 2048
#define MAIL$_MESSAGE_BACK 2049         /* Get previous message             */
#define MAIL$_MESSAGE_BEFORE 2050       /* Select messages BEFORE date      */
#define MAIL$_MESSAGE_CC_SUBSTRING 2051 /* Select messages containing CC substring */
#define MAIL$_MESSAGE_CONTINUE 2052     /* Read next record                 */
#define MAIL$_MESSAGE_FILE_ACTION 2053  /* File create action routine       */
#define MAIL$_MESSAGE_FOLDER_ACTION 2054 /* Folder create action routine    */
#define MAIL$_MESSAGE_DEFAULT_NAME 2055 /* Default file name                */
#define MAIL$_MESSAGE_DELETE 2056       /* Delete message                   */
#define MAIL$_MESSAGE_ERASE 2057        /* Erase message                    */
#define MAIL$_MESSAGE_FILE_CTX 2058     /* File level context               */
#define MAIL$_MESSAGE_FILENAME 2059     /* File name specification          */
#define MAIL$_MESSAGE_FLAGS 2060        /* Header flags specification       */
#define MAIL$_MESSAGE_FOLDER 2061       /* Folder name specification        */
#define MAIL$_MESSAGE_FROM_SUBSTRING 2062 /* Select messages containing FROM substring */
#define MAIL$_MESSAGE_ID 2063           /* ID of message                    */
#define MAIL$_MESSAGE_NEXT 2064         /* Retrive NEXT message             */
#define MAIL$_MESSAGE_SINCE 2065        /* Select messages SINCE date       */
#define MAIL$_MESSAGE_SUBJ_SUBSTRING 2066 /* Select messages containing SUBJ substring */
#define MAIL$_MESSAGE_TO_SUBSTRING 2067 /* Select messages containing TO substring */
#define MAIL$_MESSAGE_UFLAGS 2068       /* User flags specification         */
#define MAIL$_MESSAGE_AUTO_NEWMAIL 2069 /* Move newmail to MAIL auto        */
#define MAIL$_MESSAGE_USER_DATA 2070    /* User context for action routines */
#define MAIL$_MESSAGE_FLAGS_MBZ 2071    /* Select messages with these flags set at zero */
#define MAIL$_MESSAGE_MIN_CLASS 2072    /* Min access class for message     */
#define MAIL$_MESSAGE_MAX_CLASS 2073    /* Max access class for message     */
#define MAIL$_MESSAGE_IN_SPARE1 2074
#define MAIL$_MESSAGE_IN_SPARE2 2075
#define MAIL$_MESSAGE_IN_SPARE3 2076
#define MAIL$_MESSAGE_IN_SPARE4 2077
#define MAIL$_MESSAGE_IN_SPARE5 2078
#define MAIL$_MESSAGE_IN_SPARE6 2079
#define MAIL$_MESSAGE_IN_SPARE7 2080
#define MAIL$_MESSAGE_IN_SPARE8 2081
#define MAIL$_MESSAGE_IN_SPARE9 2082
#define MAIL$_MESSAGE_IN_SPARE10 2083
#define MAIL$_MESSAGE_IN_SPARE11 2084
#define MAIL$_MESSAGE_IN_SPARE12 2085
#define MAIL$_MESSAGE_IN_SPARE13 2086
#define MAIL$_MESSAGE_IN_SPARE14 2087
#define MAIL$_MESSAGE_IN_SPARE15 2088
#define MAIL$_MESSAGE_IN_SPARE16 2089
#define MAIL$_MESSAGE_IN_SPARE17 2090
#define MAIL$_MESSAGE_IN_SPARE18 2091
#define MAIL$_MESSAGE_IN_SPARE19 2092
#define MAIL$_MESSAGE_IN_SPARE20 2093
/*                                                                          */
/* message output codes                                                     */
/*                                                                          */
#define MAIL$_MESSAGE_CC 2094           /* CC text of message               */
#define MAIL$_MESSAGE_CURRENT_ID 2095   /* ID of current message            */
#define MAIL$_MESSAGE_DATE 2096         /* Date of current message          */
#define MAIL$_MESSAGE_EXTID 2097        /* Filespec of external message     */
#define MAIL$_MESSAGE_FILE_CREATED 2098 /* Mailfile created...              */
#define MAIL$_MESSAGE_FOLDER_CREATED 2099 /* Folder created...              */
#define MAIL$_MESSAGE_FROM 2100         /* From text of message             */
#define MAIL$_MESSAGE_RECORD 2101       /* Record from message              */
#define MAIL$_MESSAGE_RECORD_TYPE 2102  /* Type of record, header or text   */
#define MAIL$_MESSAGE_REPLY_PATH 2103   /* Reply path of sender             */
#define MAIL$_MESSAGE_RESULTSPEC 2104   /* Resultant file spec              */
#define MAIL$_MESSAGE_RETURN_FLAGS 2105 /* Message header system flags      */
#define MAIL$_MESSAGE_RETURN_UFLAGS 2106 /* Message header user flags       */
#define MAIL$_MESSAGE_SELECTED 2107     /* Number of messages selected      */
#define MAIL$_MESSAGE_SENDER 2108       /* Sender name                      */
#define MAIL$_MESSAGE_SIZE 2109         /* Size of the current message      */
#define MAIL$_MESSAGE_SUBJECT 2110      /* Subject text of the message      */
#define MAIL$_MESSAGE_TO 2111           /* To text of the message           */
#define MAIL$_MESSAGE_BUFFER 2112       /* Buffer address                   */
#define MAIL$_MESSAGE_RETURN_CLASS 2113 /* Class of current message         */
#define MAIL$_MESSAGE_BINARY_DATE 2114  /* Binary date/time quadword        */
#define MAIL$_MESSAGE_SPARE4 2115
#define MAIL$_MESSAGE_SPARE5 2116
#define MAIL$_MESSAGE_SPARE6 2117
#define MAIL$_MESSAGE_SPARE7 2118
#define MAIL$_MESSAGE_SPARE8 2119
#define MAIL$_MESSAGE_SPARE9 2120
#define MAIL$_MESSAGE_SPARE10 2121
#define MAIL$_MESSAGE_SPARE11 2122
#define MAIL$_MESSAGE_SPARE12 2123
#define MAIL$_MESSAGE_SPARE13 2124
#define MAIL$_MESSAGE_SPARE14 2125
#define MAIL$_MESSAGE_SPARE15 2126
#define MAIL$_MESSAGE_SPARE16 2127
#define MAIL$_MESSAGE_SPARE17 2128
#define MAIL$_MESSAGE_SPARE18 2129
#define MAIL$_MESSAGE_SPARE19 2130
/*                                                                          */
/* Constants returned                                                       */
/*                                                                          */
#define MAIL$_MESSAGE_NULL 2131         /* Null bodypart                    */
#define MAIL$_MESSAGE_HEADER 2132       /* Header record returned           */
#define MAIL$_MESSAGE_TEXT 2133         /* Text record returned             */
#define MAIL$_MESSAGE_SPARE20 2134
#define MAIL$K_MESSAGE_MIN_ITEM 2048
#define MAIL$K_MESSAGE_MAX_ITEM 2134
#define MAIL$K_MESSAGE_ITEMS 87
/*                                                                          */
/* user input codes                                                         */
/*                                                                          */
#define MAIL$_USER_SPARE_0 3072
#define MAIL$_USER_FIRST 3073           /* Retrive first user record        */
#define MAIL$_USER_NEXT 3074            /* Retrive next user record         */
#define MAIL$_USER_USERNAME 3075        /* Retrive record for username      */
#define MAIL$_USER_SET_AUTO_PURGE 3076  /* Set auto-purge                   */
#define MAIL$_USER_SET_NO_AUTO_PURGE 3077 /* Clear auto-purge               */
#define MAIL$_USER_SET_SUB_DIRECTORY 3078 /* Set sub-dir field              */
#define MAIL$_USER_SET_NO_SUB_DIRECTORY 3079 /* Clear sub-dir field         */
#define MAIL$_USER_SET_FORWARDING 3080  /* Set forwarding address           */
#define MAIL$_USER_SET_NO_FORWARDING 3081 /* Clear forwarding address       */
#define MAIL$_USER_SET_PERSONAL_NAME 3082 /* Set personal name              */
#define MAIL$_USER_SET_NO_PERSONAL_NAME 3083 /* Clear personal name         */
#define MAIL$_USER_SET_COPY_SEND 3084   /* Set copy-send                    */
#define MAIL$_USER_SET_NO_COPY_SEND 3085 /* Clear copy send                 */
#define MAIL$_USER_SET_COPY_REPLY 3086  /* Set copy reply                   */
#define MAIL$_USER_SET_NO_COPY_REPLY 3087 /* Clear copy reply               */
#define MAIL$_USER_SET_NEW_MESSAGES 3088 /* Set new message count           */
#define MAIL$_USER_CREATE_IF 3089       /* Create record if does not exist  */
#define MAIL$_USER_SET_MAILPLUS 3090    /* Set M+                           */
#define MAIL$_USER_SET_NO_MAILPLUS 3091 /* Clear M+                         */
#define MAIL$_USER_SET_TRANSPORT 3092   /* Set transport field              */
#define MAIL$_USER_SET_NO_TRANSPORT 3093 /* Clear transport field           */
#define MAIL$_USER_SET_EDITOR 3094      /* Set editor field                 */
#define MAIL$_USER_SET_NO_EDITOR 3095   /* Clear editor field               */
#define MAIL$_USER_SET_QUEUE 3096       /* Set queue field                  */
#define MAIL$_USER_SET_NO_QUEUE 3097    /* Clear queue field                */
#define MAIL$_USER_SET_USER1 3098       /* Set user1 field                  */
#define MAIL$_USER_SET_NO_USER1 3099    /* Clear user1 field                */
#define MAIL$_USER_SET_USER2 3100       /* Set user2 field                  */
#define MAIL$_USER_SET_NO_USER2 3101    /* Clear user2 field                */
#define MAIL$_USER_SET_USER3 3102       /* Set user3 field                  */
#define MAIL$_USER_SET_NO_USER3 3103    /* Clear user3 field                */
#define MAIL$_USER_SET_FORM 3104        /* Set form field                   */
#define MAIL$_USER_SET_NO_FORM 3105     /* Clear form field                 */
#define MAIL$_USER_SET_COPY_FORWARD 3106 /* Set copy self forward           */
#define MAIL$_USER_SET_NO_COPY_FORWARD 3107 /* Clear copy self forward      */
#define MAIL$_USER_SET_CC_PROMPT 3108   /* Set CC prompting                 */
#define MAIL$_USER_SET_NO_CC_PROMPT 3109 /* Clear CC prompting              */
#define MAIL$_USER_SET_SPARE3 3110
#define MAIL$_USER_SET_NO_SPARE3 3111
#define MAIL$_USER_IN_SPARE1 3112
#define MAIL$_USER_IN_SPARE2 3113
#define MAIL$_USER_IN_SPARE3 3114
#define MAIL$_USER_IN_SPARE4 3115
#define MAIL$_USER_IN_SPARE5 3116
#define MAIL$_USER_IN_SPARE6 3117
#define MAIL$_USER_IN_SPARE7 3118
#define MAIL$_USER_IN_SPARE8 3119
#define MAIL$_USER_IN_SPARE9 3120
#define MAIL$_USER_IN_SPARE10 3121
#define MAIL$_USER_IN_SPARE11 3122
#define MAIL$_USER_IN_SPARE12 3123
#define MAIL$_USER_IN_SPARE13 3124
#define MAIL$_USER_IN_SPARE14 3125
#define MAIL$_USER_IN_SPARE15 3126
#define MAIL$_USER_IN_SPARE16 3127
#define MAIL$_USER_IN_SPARE17 3128
#define MAIL$_USER_IN_SPARE18 3129
#define MAIL$_USER_IN_SPARE19 3130
#define MAIL$_USER_IN_SPARE20 3131
/*                                                                          */
/* Output item parameters                                                   */
/*                                                                          */
#define MAIL$_USER_MAILPLUS 3132        /* M+ field                         */
#define MAIL$_USER_TRANSPORT 3133       /* Transport field                  */
#define MAIL$_USER_EDITOR 3134          /* Editor field                     */
#define MAIL$_USER_QUEUE 3135           /* Queue field                      */
#define MAIL$_USER_USER1 3136           /* User1 field                      */
#define MAIL$_USER_USER2 3137           /* User2 field                      */
#define MAIL$_USER_USER3 3138           /* User3 field                      */
#define MAIL$_USER_FORM 3139            /* Form field                       */
#define MAIL$_USER_COPY_FORWARD 3140    /* Copy forward flag                */
#define MAIL$_USER_SPARE3 3141
#define MAIL$_USER_RETURN_USERNAME 3142 /* Username of current record       */
#define MAIL$_USER_AUTO_PURGE 3143      /* Auto purge flag                  */
#define MAIL$_USER_SUB_DIRECTORY 3144   /* Sub-dir spec                     */
#define MAIL$_USER_FULL_DIRECTORY 3145  /* Full directory spec              */
#define MAIL$_USER_NEW_MESSAGES 3146    /* New message count                */
#define MAIL$_USER_FORWARDING 3147      /* Forwarding field                 */
#define MAIL$_USER_PERSONAL_NAME 3148   /* Personal name field              */
#define MAIL$_USER_COPY_SEND 3149       /* Copy send flag                   */
#define MAIL$_USER_COPY_REPLY 3150      /* Copy reply flag                  */
#define MAIL$_USER_CAPTIVE 3151         /* User is captive                  */
#define MAIL$_USER_CC_PROMPT 3152       /* CC prompting flag                */
#define MAIL$_USER_OUT_SPARE2 3153
#define MAIL$_USER_OUT_SPARE3 3154
#define MAIL$_USER_OUT_SPARE4 3155
#define MAIL$_USER_OUT_SPARE5 3156
#define MAIL$_USER_OUT_SPARE6 3157
#define MAIL$_USER_OUT_SPARE7 3158
#define MAIL$_USER_OUT_SPARE8 3159
#define MAIL$_USER_OUT_SPARE9 3160
#define MAIL$_USER_OUT_SPARE10 3161
#define MAIL$_USER_OUT_SPARE11 3162
#define MAIL$_USER_OUT_SPARE12 3163
#define MAIL$_USER_OUT_SPARE13 3164
#define MAIL$_USER_OUT_SPARE14 3165
#define MAIL$_USER_OUT_SPARE15 3166
#define MAIL$_USER_OUT_SPARE16 3167
#define MAIL$_USER_OUT_SPARE17 3168
#define MAIL$_USER_OUT_SPARE18 3169
#define MAIL$_USER_OUT_SPARE19 3170
#define MAIL$_USER_OUT_SPARE20 3171
#define MAIL$K_USER_MIN_ITEM 3072
#define MAIL$K_USER_MAX_ITEM 3171
#define MAIL$K_USER_ITEMS 100
/*                                                                          */
/* Special items                                                            */
/*                                                                          */
#define MAIL$_NOOP 4097                 /* Do nothing - used for testing    */
#define MAIL$_NOSIGNAL 4098             /* Don't signal errors              */
#define MAIL$_NOPROBE 4099              /* Don't probe the item list buffers */
#define MAIL$_TLD_INPUT 4100            /* This item is a tld to be used as input */
#define MAIL$_TLD_OUTPUT 4101           /* This item describes a buffer to fill */
/*                                                                          */
/* Username types for mail$send_add_address                                 */
/*                                                                          */
#define MAIL$_TO 1                      /* Address part of the TO line      */
#define MAIL$_CC 2                      /* Address part of the CC line      */
#define MAIL$_SPARE1 3
#define MAIL$_SPARE2 4
/*                                                                          */
/* Define the flag values for mail system flags                             */
/*                                                                          */
#define MAIL$M_NEWMSG 1
#define MAIL$M_REPLIED 2
#define MAIL$M_DEL 4
#define MAIL$M_EXTMSG 8
#define MAIL$M_EXTFNF 16
#define MAIL$M_SYSMSG 32
#define MAIL$M_EXTNSTD 64
#define MAIL$M_MARKED 128
#define MAIL$M_RECMODE 256
struct flagsdef {
#pragma nostandard
    variant_union  {
        unsigned short int mail$w_flags; /*Flags word                       */
        variant_struct  {
            unsigned mail$v_newmsg : 1; /*This is a new message             */
            unsigned mail$v_replied : 1; /*This message has been replied to */
            unsigned mail$v_del : 1;    /*This message is deleted           */
            unsigned mail$v_extmsg : 1; /*Message text in external file     */
            unsigned mail$v_extfnf : 1; /*External message file not found   */
            unsigned mail$v_sysmsg : 1; /*Message text in system file       */
            unsigned mail$v_extnstd : 1; /*External file is not var-seq file */
            unsigned mail$v_marked : 1; /*This message has been marked      */
            unsigned mail$v_recmode : 1; /*This message should be read in record mode */
            unsigned mail$v_fill_2 : 7;
            } mail$r_fill_1;
        } mail$r_fill_0;
    } ;
 
#pragma standard

#endif					/* __MAILDEF_LOADED */
#ifndef __MATH_LOADED
#define __MATH_LOADED	1

/*	MATH - V3.0-005 - RTL Math Function Declarations	*/

/* 
 * CC$gfloat's definition was modified so that it's defined when
 * g_float is in effect, and undefined otherwise.  The following makes
 * the new behavior compatible with the old...
 */
#ifndef CC$gfloat
#define CC$gfloat 0
#endif

#if CC$gfloat
# define HUGE_VAL 8.988465674311578540726371186585e+307
#else
# define HUGE_VAL 1.70141183460469229e+38
#endif

#pragma NOSTANDARD
#undef acos
#undef asin
#undef atan
#undef atan2
#undef cabs
#undef ceil
#undef cos
#undef cosh
#undef exp
#undef fabs
#undef floor
#undef frexp
#undef hypot
#undef ldexp
#undef log
#undef log10
#undef modf
#undef pow
#undef sin
#undef sinh
#undef sqrt
#undef tan
#undef tanh
#undef fmod
#pragma STANDARD

double acos (double x);

double asin (double x);

double atan (double x);

double atan2 (double x, double y);

double cos (double x);
double sin (double x);

#if CC$gfloat
 double MTH$GCOS_R7 (double x);
 double MTH$GSIN_R7 (double x);
#pragma safe_call (MTH$GCOS_R7, MTH$GSIN_R7)
#else
 double MTH$DCOS_R7 (double x);
 double MTH$DSIN_R7 (double x);
#pragma safe_call (MTH$DCOS_R7, MTH$DSIN_R7)
#endif

double tan (double x);

double cosh (double x);

double sinh (double x);

double tanh (double x);
#define VAXC$TANH 1

double exp (double x);

double frexp (double value, int *exp);

double ldexp  (double x, int e);

double log (double x);

double log10 (double x);

double modf (double value, double *iptr);

double pow (double base, double exp);

double sqrt (double x);

double ceil (double x);

double fabs (double x);

struct CABS_T {double x, y;};
typedef struct CABS_T cabs_t; 

double cabs (cabs_t z);

double hypot (double x, double y);

double floor (double x);

double fmod (double x, double y);

#pragma safe_call (acos, asin, atan, atan2, cos, sin, tan, cosh, sinh, tanh)
#pragma safe_call (exp, ldexp, log, log10, pow, sqrt, ceil)
#pragma safe_call (fabs, cabs, hypot, floor, fmod)

#if defined(CC$mixed_float) || defined(CC$VAXCSHR)
#if CC$gfloat

double vaxc$gacos (double x);

double vaxc$gasin (double x);

double vaxc$gatan(double x);

double vaxc$gatan2 (double x, double y);

double vaxc$gcabs (cabs_t x);

double vaxc$gceil (double x);

double vaxc$gcos(double x);

double vaxc$gcosh (double x);

double vaxc$gexp (double x);

double vaxc$gfabs (double x);

double vaxc$gfloor (double x);

double vaxc$gfrexp (double value, int *exp);

double vaxc$ghypot (double x, double y);

double vaxc$gldexp  (double x, int e);

double vaxc$glog (double x);

double vaxc$glog10(double x);

double vaxc$gmodf (double value, double *iptr);

double vaxc$gpow (double base, double exp);

double vaxc$gsin (double x);

double vaxc$gsinh (double x);

double vaxc$gsqrt (double x);

double vaxc$gtan (double x);

double vaxc$gtanh (double x);

double vaxc$gfmod (double x, double y);

#define acos vaxc$gacos
#define asin vaxc$gasin
#define atan vaxc$gatan
#define atan2 vaxc$gatan2
#define cabs vaxc$gcabs
#define ceil vaxc$gceil
#define cos vaxc$gcos
#define cosh vaxc$gcosh
#define exp vaxc$gexp
#define fabs vaxc$gfabs
#define floor vaxc$gfloor
#define frexp vaxc$gfrexp
#define hypot vaxc$ghypot
#define ldexp vaxc$gldexp
#define log vaxc$glog
#define log10 vaxc$glog10
#define modf vaxc$gmodf
#define pow vaxc$gpow
#define sin vaxc$gsin
#define sinh vaxc$gsinh
#define sqrt vaxc$gsqrt
#define tan vaxc$gtan
#define tanh vaxc$gtanh
#define fmod vaxc$gfmod

#else

double vaxc$dacos (double x);

double vaxc$dasin (double x);

double vaxc$datan(double x);

double vaxc$datan2 (double x, double y);

double vaxc$dcabs (cabs_t x);

double vaxc$dceil (double x);

double vaxc$dcos(double x);

double vaxc$dcosh (double x);

double vaxc$dexp (double x);

double vaxc$dfabs (double x);

double vaxc$dfloor (double x);

double vaxc$dfrexp (double value, int *exp);

double vaxc$dhypot (double x, double y);

double vaxc$dldexp  (double x, int e);

double vaxc$dlog (double x);

double vaxc$dlog10(double x);

double vaxc$dmodf (double value, double *iptr);

double vaxc$dpow (double base, double exp);

double vaxc$dsin (double x);

double vaxc$dsinh (double x);

double vaxc$dsqrt (double x);

double vaxc$dtan (double x);

double vaxc$dtanh (double x);

double vaxc$dfmod (double x, double y);

#define acos vaxc$dacos
#define asin vaxc$dasin
#define atan vaxc$datan
#define atan2 vaxc$datan2
#define cabs vaxc$dcabs
#define ceil vaxc$dceil
#define cos vaxc$dcos
#define cosh vaxc$dcosh
#define exp vaxc$dexp
#define fabs vaxc$dfabs
#define floor vaxc$dfloor
#define frexp vaxc$dfrexp
#define hypot vaxc$dhypot
#define ldexp vaxc$dldexp
#define log vaxc$dlog
#define log10 vaxc$dlog10
#define modf vaxc$dmodf
#define pow vaxc$dpow
#define sin vaxc$dsin
#define sinh vaxc$dsinh
#define sqrt vaxc$dsqrt
#define tan vaxc$dtan
#define tanh vaxc$dtanh
#define fmod vaxc$dfmod

#endif
#endif

#endif					/* __MATH_LOADED */
#ifndef __MHDDEF_LOADED
#define __MHDDEF_LOADED	1

/*** MODULE $mhddef ***/
/*                                                                          */
/* Module header                                                            */
/*                                                                          */
#define MHD$C_MHDID 173                 /* Value that must be in the ident  */
#define MHD$K_REFLNG 8                  /* Length of record to end of ref count  */
#define MHD$C_REFLNG 8                  /* Length of record to end of ref count  */
#define MHD$K_INSTIME 8                 /* Label for start of insert time   */
#define MHD$C_INSTIME 8                 /* Label for start of insert time   */
#define MHD$K_USRDAT 16                 /* Start of user additional header data  */
#define MHD$C_USRDAT 16                 /* Start of user additional header data  */
#define MHD$K_MHDLEN 16                 /* Length of fixed part of MHD      */
#define MHD$C_MHDLEN 16                 /* Length of fixed part of MHD      */
#define MHD$M_SELSRC 1
#define MHD$M_OBJTIR 2
#define MHD$K_OBJIDENT 18               /*                                  */
#define MHD$C_OBJIDENT 18               /*                                  */
struct mhddef {
    unsigned char mhd$b_lbrflag;        /* Librarian-controlled flag byte   */
    unsigned char mhd$b_id;             /* Ident                            */
    short int mhddef$$_fill_1;          /* Reserved word                    */
    unsigned long int mhd$l_refcnt;     /* Reference count                  */
    unsigned long int mhd$l_datim;      /* Date/time inserted               */
#pragma nostandard
    variant_union  {
        long int mhddef$$_fill_2;       /* ...                              */
        variant_struct  {
            char mhddef$$_fill_3 [4];
            char mhd$b_usrdat [];       /* Start of user additional header data  */
            } mhd$r_fill_2_fields;
        } mhd$r_fill_2_overlay;
    variant_union  {
        unsigned char mhd$b_objstat;    /* Status of object module          */
        variant_struct  {
            unsigned mhd$v_selsrc : 1;  /* Selective search                 */
            unsigned mhd$v_objtir : 1;  /* Module contains TIR records      */
            unsigned mhd$v_fill_1 : 6;
            } mhd$r_objstat_bits;
        } mhd$r_objstat_overlay;
    variant_union  {
        unsigned char mhd$b_objidlng;   /* Length of ident                  */
        variant_struct  {
            char mhddef$$_fill_4;
            char mhd$t_objident [];     /* Object module ident              */
            } mhd$r_objidlng_fields;
        } mhd$r_objidlng_overlay;
    } ;
 
#pragma standard

#endif					/* __MHDDEF_LOADED */
#ifndef __MHDEF_LOADED
#define __MHDEF_LOADED	1

/*** MODULE $mhdef ***/
/*                                                                          */
/* Module header record (MHD)                                               */
/*                                                                          */
#define MHD$C_MHD 0                     /*Main header record                */
#define MHD$C_LNM 1                     /*Language name and version         */
#define MHD$C_SRC 2                     /*Source file specification         */
#define MHD$C_TTL 3                     /*Title text of module              */
#define MHD$C_CPR 4                     /*Copyright notice                  */
#define MHD$C_MTC 5                     /*Maintenence status                */
#define MHD$C_GTX 6                     /*General text                      */
#define MHD$C_MAXHDRTYP 6               /*Maximum allowable type            */
struct mhdef {
    unsigned char mhd$b_rectyp;         /*Record type (OBJ$C_MHD)           */
    unsigned char mhd$b_hdrtyp;         /*Type field for MHD                */
/*Types of header records                                                   */
    unsigned char mhd$b_strlvl;         /*Structure level                   */
    unsigned short int mhd$w_recsiz;    /*Maximum record size               */
    unsigned char mhd$b_namlng;         /*Module name length                */
    char mhd$t_name [31];               /*Module name                       */
                                        /*Module version (ASCIC)          */
                                        /*Creation date/time (17 bytes)   */
                                        /*Time of last patch (17 bytes)   */
    } ;
 

#endif					/* __MHDEF_LOADED */
#ifndef __MNTDEF_LOADED
#define __MNTDEF_LOADED	1

/*** MODULE $mntdef ***/
/*+                                                                         */
/*                                                                          */
/* FLAG BITS FOR THE $MOUNT SYSTEM SERVICE.                                 */
/*                                                                          */
/*-                                                                         */
#define MNT$M_FOREIGN 1
#define MNT$M_GROUP 2
#define MNT$M_NOASSIST 4
#define MNT$M_NODISKQ 8
#define MNT$M_NOHDR3 16
#define MNT$M_NOLABEL 32
#define MNT$M_NOWRITE 64
#define MNT$M_OVR_ACCESS 128
#define MNT$M_OVR_EXP 256
#define MNT$M_OVR_IDENT 512
#define MNT$M_OVR_SETID 1024
#define MNT$M_READCHECK 2048
#define MNT$M_SHARE 4096
#define MNT$M_MESSAGE 8192
#define MNT$M_SYSTEM 16384
#define MNT$M_WRITECHECK 32768
#define MNT$M_WRITETHRU 65536
#define MNT$M_NOCACHE 131072
#define MNT$M_OVR_LOCK 262144
#define MNT$M_NOMNTVER 524288
#define MNT$M_NOUNLOAD 1048576
#define MNT$M_TAPE_DATA_WRITE 2097152
#define MNT$M_NOCOPY 4194304
#define MNT$M_NOAUTO 8388608
#define MNT$M_INIT_ALL 16777216
#define MNT$M_INIT_CONT 33554432
#define MNT$M_OVR_VOLO 67108864
#define MNT$M_INTERCHG 134217728
#define MNT$M_CLUSTER 268435456
#define MNT$M_NOREBUILD 536870912
#define MNT$M_OVR_SHAMEM 1073741824
#define MNT$M_MULTI_VOL -2147483648
#define MNT$_DEVNAM 1                   /* DEVICE NAME                      */
#define MNT$_VOLNAM 2                   /* VOLUME NAME                      */
#define MNT$_LOGNAM 3                   /* LOGICAL NAME                     */
#define MNT$_FLAGS 4                    /* MOUNT FLAGS                      */
#define MNT$_ACCESSED 5                 /* ACCESSED VALUE                   */
#define MNT$_PROCESSOR 6                /* PROCESSOR NAME                   */
#define MNT$_VOLSET 7                   /* VOLUME SET NAME                  */
#define MNT$_BLOCKSIZE 8                /* BLOCKSIZE VALUE                  */
#define MNT$_DENSITY 9                  /* TAPE DENSITY VALUE               */
#define MNT$_EXTENT 10                  /* NUMBER OF EXTENT CACHE ENTRIES   */
#define MNT$_FILEID 11                  /* FILE ID CACHE SIZE               */
#define MNT$_LIMIT 12                   /* EXTENT CACHE LIMIT               */
#define MNT$_OWNER 13                   /* VOLUME OWNER UIC                 */
#define MNT$_VPROT 14                   /* VOLUME PROTECTION                */
#define MNT$_QUOTA 15                   /* QUOTA CACHE SIZE                 */
#define MNT$_RECORDSIZ 16               /* RECORD SIZE VALUE                */
#define MNT$_WINDOW 17                  /* NUMBER OF WINDOWS                */
#define MNT$_EXTENSION 18               /* DEFAULT FILE EXTENSION           */
#define MNT$_VISUAL_ID 19               /* VISUAL IDENTIFICATION            */
#define MNT$_COMMENT 20                 /* USER COMMENT                     */
#define MNT$_UNUSED1 21                 /* SPARE (was used for now obsolete journaling-related items) */
#define MNT$_UNUSED2 22                 /* SPARE (was used for now obsolete journaling-related items) */
#define MNT$_UNUSED3 23                 /* SPARE (was used for now obsolete journaling-related items) */
#define MNT$_SHACOPY_BUF 24             /* SHADOW COPY BUFFER               */
#define MNT$_SHANAM 25                  /* SHADOW SET VIRTUAL UNIT NAME     */
#define MNT$_SHAMEM 26                  /* SHADOW SET MEMBER UNIT NAME      */
#define MNT$_SHAMEM_MGCOPY 27           /* SHADOW SET MEMBER UNIT NAME (MERGE COPY) */
#define MNT$_SHAMEM_COPY 28             /* SHADOW SET MEMBER UNIT NAME (FULL COPY) */
#define MNT$_PRFD_PATH 29               /* PREFERRED DSA PATH               */
#pragma nostandard
union mntdef {
    variant_struct  {
        unsigned mnt$v_foreign : 1;     /* FOREIGN OPTION SELECTED          */
        unsigned mnt$v_group : 1;       /* GROUP OPTION SELECTED            */
        unsigned mnt$v_noassist : 1;    /* NOASSIST OPTION SELECTED         */
        unsigned mnt$v_nodiskq : 1;     /* NODISKQ OPTION SELECTED          */
        unsigned mnt$v_nohdr3 : 1;      /* NOHDR3 OPTION SELECTED           */
        unsigned mnt$v_nolabel : 1;     /* NOLABEL OPTION SELECTED          */
        unsigned mnt$v_nowrite : 1;     /* NOWRITE OPTION SELECTED          */
        unsigned mnt$v_ovr_access : 1;  /* OVERRIDE ACCESSIBLITY OPTION SELECTED  */
        unsigned mnt$v_ovr_exp : 1;     /* OVERRIDE EXPIRATON OPTION SELECTED  */
        unsigned mnt$v_ovr_ident : 1;   /* OVERRIDE VOLUME LABEL            */
        unsigned mnt$v_ovr_setid : 1;   /* OVERRIDE VOLUME SET IDENT OPTION SELECTIED  */
        unsigned mnt$v_readcheck : 1;   /* READCHECK OPTION SELECTED        */
        unsigned mnt$v_share : 1;       /* SHARE OPTION SELECTED            */
        unsigned mnt$v_message : 1;     /* ALLOW $MOUNT TO PRINT MESSAGES   */
        unsigned mnt$v_system : 1;      /* SYSTEM OPTION SELECTED           */
        unsigned mnt$v_writecheck : 1;  /* WRITECHECK OPTION SELECTED       */
        unsigned mnt$v_writethru : 1;   /* WRITETHRU OPTION SELECTED        */
        unsigned mnt$v_nocache : 1;     /* TURN OFF ALL CACHING             */
        unsigned mnt$v_ovr_lock : 1;    /* OVERRIDE AUTOMATIC WRITE-LOCK    */
        unsigned mnt$v_nomntver : 1;    /* DISABLE MOUNT VERIFICATION       */
        unsigned mnt$v_nounload : 1;    /* DO NOT UNLOAD VOLUME AT DISMOUNT  */
        unsigned mnt$v_tape_data_write : 1; /* ENABLE WRITE-BACK CACHE ON TAPE */
        unsigned mnt$v_nocopy : 1;      /* DO NOT ALLOW SHADOW COPY OPERATION */
        unsigned mnt$v_noauto : 1;      /* DO NOT SET THE MTAACP INTO AVR AND AVL MODE */
        unsigned mnt$v_init_all : 1;    /* INITIALIZE ALL VOLUMES IN SET BEFORE WRITING */
        unsigned mnt$v_init_cont : 1;   /* INITIALIZE CONTINUATION VOLUMES BEFORE WRITING */
        unsigned mnt$v_ovr_volo : 1;    /* OVERRIDE VOL1 VOLUME IDENTIFIER FIELD */
        unsigned mnt$v_interchg : 1;    /* VOL FOR INTERCHG NO VMS SPECIFIC INFO WRITTEN TO TAPE */
        unsigned mnt$v_cluster : 1;     /* CLUSTER-WIDE MOUNT OPTION SELECTED */
        unsigned mnt$v_norebuild : 1;   /* DO NOT REBUILD VOLUME            */
        unsigned mnt$v_ovr_shamem : 1;  /* OVERRIDE SHADOW MEMBERSHIP RESTRICTION */
        unsigned mnt$v_multi_vol : 1;   /* MULTI_VOLUME TAPE SET            */
        } mnt$r_mntdef_bits;
/*                                                                          */
/* Item codes for mount parameters.                                         */
/*                                                                          */
/* DEFINE CODES AS CONSTANTS                                                */
    } ;
#pragma standard
#define MNT$S_MNTDEF 4
#define MNT$V_FOREIGN 0
#define MNT$V_GROUP 1
#define MNT$V_NOASSIST 2
#define MNT$V_NODISKQ 3
#define MNT$V_NOHDR3 4
#define MNT$V_NOLABEL 5
#define MNT$V_NOWRITE 6
#define MNT$V_OVR_ACCESS 7
#define MNT$V_OVR_EXP 8
#define MNT$V_OVR_IDENT 9
#define MNT$V_OVR_SETID 10
#define MNT$V_READCHECK 11
#define MNT$V_SHARE 12
#define MNT$V_MESSAGE 13
#define MNT$V_SYSTEM 14
#define MNT$V_WRITECHECK 15
#define MNT$V_WRITETHRU 16
#define MNT$V_NOCACHE 17
#define MNT$V_OVR_LOCK 18
#define MNT$V_NOMNTVER 19
#define MNT$V_NOUNLOAD 20
#define MNT$V_TAPE_DATA_WRITE 21
#define MNT$V_NOCOPY 22
#define MNT$V_NOAUTO 23
#define MNT$V_INIT_ALL 24
#define MNT$V_INIT_CONT 25
#define MNT$V_OVR_VOLO 26
#define MNT$V_INTERCHG 27
#define MNT$V_CLUSTER 28
#define MNT$V_NOREBUILD 29
#define MNT$V_OVR_SHAMEM 30

#endif					/* __MNTDEF_LOADED */
#ifndef __MSGDEF_LOADED
#define __MSGDEF_LOADED	1

/*** MODULE $msgdef ***/
/*+                                                                         */
/*                                                                          */
/* SYSTEM WIDE MAILBOX MESSAGE TYPES                                        */
/*                                                                          */
/*-                                                                         */
/* DEFINE CODES AS CONSTANTS                                                */
#define MSG$_TRMUNSOLIC 1               /* UNSOLICITED TERMINAL DATA        */
#define MSG$_CRUNSOLIC 2                /* UNSOLICTED CARD READER DATA      */
#define MSG$_DELPROC 3                  /* DELETE PROCESS                   */
#define MSG$_SNDSMB 4                   /* SEND TO SYMBIONT MANAGER         */
#define MSG$_DEVOFFLIN 5                /* DEVICE OFFLINE                   */
#define MSG$_TRMHANGUP 6                /* TERMINAL HANG UP                 */
#define MSG$_DEVONLIN 7                 /* DEVICE ONLINE                    */
#define MSG$_OPRQST 8                   /* OPERATOR REQUEST *** OVERLAPPED CODE ***  */
#define MSG$_OPREPLY 9                  /* OPERATOR REPLY *** OVERLAPPED CODE ***  */
/* DEFINE SYMBIONT RESPONSE MESSAGES                                        */
#define MSG$_SMBINI 8                   /* SYMBIONT HAS INITED              */
#define MSG$_SMBDON 9                   /* SYMBIONT FINISHED                */
#define MSG$_SNDACC 10                  /* SEND MESSAGE TO ACCOUNTING MANAGER  */
#define MSG$_PURPROC 11                 /* PURGE PROCESS *** OVERLAPPED CODE ***  */
#define MSG$_DELIMAG 12                 /* DELETE IMAGE *** OVERLAPPED CODE ***  */
#define MSG$_PURIMAG 13                 /* PURGE IMAGE *** OVERLAPPED CODE ***  */
#define MSG$_SYSFUNC 14                 /* SYSTEM FUNCTION *** OVERLAPPED CODE ***  */
#define MSG$_SNDJBC 15                  /* Send message to job controller   */
#define MSG$_GETQUI 16                  /* Get queue information (from job controller) */
/* DEFINE DMC MESSAGES                                                      */
#define MSG$_XM_DATAVL 11               /* DMC UNSOLICITED DATA             */
#define MSG$_XM_SHUTDN 12               /* DMC LINE DOWN                    */
#define MSG$_XM_ATTN 13                 /* DMC ATTENTION MESSAGE            */
/* SYMBIONT COMMAND MESSAGES                                                */
#define MSG$_INIOPR 16                  /* INITIATE PRINTING A FILE         */
#define MSG$_ABOOPR 17                  /* ABORT PRINTING A FILE            */
#define MSG$_SUSOPR 18                  /* PAUSE PRINTING THE FILE          */
#define MSG$_RESOPR 19                  /* RESUME PRINTING THE FILE         */
#define MSG$_DELSMB 20                  /* SYMBIONT SHOULD DELETE ITSELF    */
#define MSG$_REQUE 21                   /* REQUEUE A FILE FOR PRINTING      */
/*                                                                          */
#define MSG$_SMBRSP 32                  /* SYMBIONT MANAGER RESPONSE        */
#define MSG$_ACCRSP 33                  /* ACCOUNTING MANAGER RESPONSE      */
/* FILE ACP MESSAGES                                                        */
#define MSG$_SCANBAD 40                 /* SCAN FILE FOR BAD BLOCKS         */
#define MSG$_SCANRSP 41                 /* RESPONSE FROM FILE SCANNER       */
/* NETWORK ATTENTION CODES                                                  */
#define MSG$_ABORT 48                   /* PARTNER ABORTED LINK             */
#define MSG$_CONFIRM 49                 /* CONNECT CONFIRM                  */
#define MSG$_CONNECT 50                 /* INBOUND CONNECT INITIATE         */
#define MSG$_DISCON 51                  /* PARTNER DISCONNECTED - HANGUP    */
#define MSG$_EXIT 52                    /* PARTNER EXITED PREMATURELY       */
#define MSG$_INTMSG 53                  /* INTERRUPT MESSAGE - UNSOLICITED DATA  */
#define MSG$_PATHLOST 54                /* NFW - PATH LOST TO PARTNER       */
#define MSG$_PROTOCOL 55                /* PROTOCOL ERROR                   */
#define MSG$_REJECT 56                  /* CONNECT REJECT                   */
#define MSG$_THIRDPARTY 57              /* THIRD PARTY DISCONNECT           */
#define MSG$_TIMEOUT 58                 /* CONNECT TIMEOUT                  */
#define MSG$_NETSHUT 59                 /* Network shutting down            */
#define MSG$_NODEACC 60                 /* Node has become accessible       */
#define MSG$_NODEINACC 61               /* Node has become inaccessible     */
#define MSG$_EVTAVL 62                  /* Events are available to EVL      */
#define MSG$_EVTRCVCHG 63               /* Event receiver database change   */
#define MSG$_INCDAT 64                  /* X25 INCOMING DATA                */
#define MSG$_RESET 65                   /* X25 CIRCUIT RESET                */
#define MSG$_LINUP 66                   /* X25 PVC LINE UP                  */
#define MSG$_LINDWN 67                  /* X25 PVC LINE DOWN                */
#define MSG$_EVTXMTCHG 68               /* Event transmitter database change  */
/* MOUNT VERIFICATION MESSAGES                                              */
#define MSG$_DEVOFFLINX 80              /* DEVICE OFFLINE                   */
#define MSG$_WRONGVOL 81                /* WRONG VOLUME IN DEVICE           */
#define MSG$_DEVWRTLCK 82               /* DEVICE HAS BEEN WRITE LOCKED     */
#define MSG$_TRMBRDCST 83               /* TERMINAL BROADCAST               */
#define MSG$_MVCOMPLETE 84              /* MOUNT VERIFICATION COMPLETED     */
#define MSG$_MVABORTED 85               /* MOUNT VERIFICATION ABORTED       */
#define MSG$_DISMOUNTED 86              /* VOLUME DISMOUNTED                */
#define MSG$_UDA50MVER 87               /* UDA50 MICORCODE NOT UPTO REV     */
#define MSG$_DUPUNITNO 88               /* MSCP CONTROLLER - DUPLICATE UNIT !  */
#define MSG$_CLUMBX 89                  /* CNXMGR to OPCOM messages         */
#define MSG$_TM78MVER 90                /* TM78 Microcode not up to rev level */
#define MSG$_SHAMEMFAL 91               /* Member failed out of shadow set  */
#define MSG$_SHARDUCED 92               /* Shadow set reduced               */
#define MSG$_RC25MVER 93                /* RC25 MICORCODE NOT UPTO REV      */
#define MSG$_RDRXMVER 94                /* RDRX MICORCODE NOT UPTO REV      */
#define MSG$_TU81MVER 95                /* TU81 MICORCODE NOT UPTO REV      */
#define MSG$_MAYAMVER 96                /* MAYA MICORCODE NOT UPTO REV      */
#define MSG$_SHACHASTA 97               /* Shadow set has changed state     */
#define MSG$_SHACOPCOM 98               /* Shadow copy operation has completed */
#define MSG$_SHAREDZER 99               /* Shadow set reduced to zero members */
#define MSG$_SHAPOSMEM 100              /* Possible shadow set member       */
#define MSG$_SHAALLCOM 101              /* All shadow set copy operations completed */
#define MSG$_SHACOPBEG 102              /* Shadow copy operation begun      */
#define MSG$_SHAWROMEM 103              /* Shadow member contains wrong volume */
#define MSG$_SHAORGMEM 104              /* Shadow system disk missing VMB R3 member */
#define MSG$_TRMLOSE_KB 105             /* terminal lost physical KB        */
#define MSG$_TRMGAIN_KB 106             /* terminal gained physical KB      */
#define MSG$_TRMSHRINK 107              /* terminal window shrunk to icon   */
#define MSG$_TRMEXPAND 108              /* terminal window icon expanded    */
#define MSG$_TRMRESIZE 109              /* terminal window resized          */
#define MSG$_TRMMOVE 110                /* terminal window moved            */
 

#endif					/* __MSGDEF_LOADED */
#ifndef __MT2DEF_LOADED
#define __MT2DEF_LOADED	1

/*** MODULE $mt2def ***/
/*+                                                                         */
/* EXTENDED MAGTAPE CHARACTERISTICS BITS                                    */
/*-                                                                         */
#define MT2$M_SUP_DENS 65535
#define MT2$M_WBC_ENABLE 65536
#define MT2$M_RDC_DISABLE 131072
#define MT2$M_CACHED_DATA 262144
#define MT2$M_CD_LOST 524288
#define MT2$M_TAPE_MARK 1048576
union mt2def {
#pragma nostandard
    variant_struct  {
        unsigned mt2$v_sup_dens : 16;   /* SUPPORTED DENSITIES              */
        unsigned mt2$v_wbc_enable : 1;  /* WRITE-BACK CACHING IS ENABLED    */
        unsigned mt2$v_rdc_disable : 1; /* READ CACHING IS DISABLED         */
        unsigned mt2$v_cached_data : 1; /* CLASS DRIVER DETECTED DATA IN CACHE */
        unsigned mt2$v_cd_lost : 1;     /* CLASS DRIVER DETECTED CACHED DATA LOST */
        unsigned mt2$v_tape_mark : 1;   /* TAPE MARK HAS BEEN WRITTEN       */
        unsigned mt2$v_fill_3 : 3;
        } mt2$r_mt2def_bits;
    } ;
 
#pragma standard

#endif					/* __MT2DEF_LOADED */
#ifndef __MTADEF_LOADED
#define __MTADEF_LOADED	1

/*** MODULE $mtadef ***/
/*+                                                                         */
/* MAGTAPE ACCESSIBILTY ROUTINE CODES                                       */
/*-                                                                         */
/* DEFINITIONS FOR ACCESS_SPEC                                              */
#define MTA$K_NOCHAR 0                  /* ACCESS CHAR IS NOVALID           */
#define MTA$K_CHARVALID 1               /* ACCESS CHAR IS VALID             */
/* DEFINITIONS FOR TYPE                                                     */
#define MTA$K_INVOL1 0                  /* INPUT A VOL1 ACCESS CODE         */
#define MTA$K_INHDR1 1                  /* INPUT A HDR1 ACCESS CODE         */
#define MTA$K_OUTVOL1 2                 /* OUTPUT A VOL1 ACCESS CODE        */
#define MTA$K_OUTHDR1 3                 /* OUTPUT A HDR1 ACCESS CODE        */
 

#endif					/* __MTADEF_LOADED */
#ifndef __MTDEF_LOADED
#define __MTDEF_LOADED	1

/*** MODULE $mtdef ***/
/*+                                                                         */
/* MAGTAPE STATUS BITS                                                      */
/*-                                                                         */
#define MT$M_SEREXCP 1
#define MT$M_ENAUTOPACK 2
#define MT$M_ENSEREXCP 4
#define MT$M_PARITY 8
#define MT$M_FORMAT 240
#define MT$M_DENSITY 7936
#define MT$M_LOGSOFT 16384
#define MT$M_LOGSOFTOG 32768
#define MT$M_BOT 65536
#define MT$M_EOF 131072
#define MT$M_EOT 262144
#define MT$M_HWL 524288
#define MT$M_LOST 1048576
#define MT$M_SUP_NRZI 2097152
#define MT$M_SUP_PE 4194304
#define MT$M_SUP_GCR 8388608
#define MT$M_SPEED -16777216
#define MT$K_DEFAULT 0                  /* DEFAULT FORMAT                   */
#define MT$K_NORMAL11 12                /* PDP-11 NORMAL                    */
#define MT$K_CORDMP11 13                /* PDP-11 CORE DUMP                 */
#define MT$K_NORMAL15 14                /* PDP-15 NORMAL                    */
/*                                                                          */
#define MT$K_NRZI_800 3                 /* NRZI 800 BPI                     */
#define MT$K_PE_1600 4                  /* PE 1600 BPI                      */
#define MT$K_GCR_6250 5                 /* GCR 6250 BPI                     */
#define MT$K_WOD_6250 8                 /* RV80 6250 BPI EQUIVALENT         */
#define MT$K_HPC_40K 12                 /* HPC 39872 BPI                    */
#define MT$K_BLK_833 17                 /* BLOCK (TK50) 833 BPI             */
#define MT$K_BLK_1250 18                /* BLOCK (TK70) 1250 BPI            */
/*                                                                          */
#define MT$K_SPEED_DEF 0                /* DEFAULT SPEED                    */
#define MT$K_SPEED_25 25                /* 25 IPS                           */
#define MT$K_SPEED_75 75                /* 75 IPS                           */
union mtdef {
#pragma nostandard
    variant_struct  {
        unsigned mt$v_serexcp : 1;      /* SERIOUS EXCEPTION PRESENT        */
        unsigned mt$v_enautopack : 1;   /* ENABLE AUTO PACKACK              */
        unsigned mt$v_enserexcp : 1;    /* ENABLE SERIOUS EXCEPTION MODE    */
        unsigned mt$v_parity : 1;       /* PARITY SELECT (0=ODD, 1=EVEN)    */
        unsigned mt$v_format : 4;       /* RECORDING FORMAT                 */
        unsigned mt$v_density : 5;      /* RECORDING DENSITY AND METHOD     */
        unsigned mtdef$$_fill_2 : 1;    /* SPARE UNUSED BIT                 */
        unsigned mt$v_logsoft : 1;      /* LOG SOFT (TU78) ERRORS (0=NO, 1=YES)  */
        unsigned mt$v_logsoftog : 1;    /* TOGGLE TO REVERSE LOGSOFT STATE BIT  */
        unsigned mt$v_bot : 1;          /* AT BEGINNING OF TAPE             */
        unsigned mt$v_eof : 1;          /* AT END OF FILE                   */
        unsigned mt$v_eot : 1;          /* AT END OF TAPE                   */
        unsigned mt$v_hwl : 1;          /* TAPE IS HARDWARE WRITELOCKED     */
        unsigned mt$v_lost : 1;         /* TAPE POSITION LOST               */
        unsigned mt$v_sup_nrzi : 1;     /* DRIVE SUPPORTS NRZI (800 BPI)    */
        unsigned mt$v_sup_pe : 1;       /* DRIVE SUPPORTS PE (1600 BPI)     */
        unsigned mt$v_sup_gcr : 1;      /* DRIVE SUPPORTS GCR (6250 BPI)    */
        unsigned mt$v_speed : 8;        /* TAPE SPEED                       */
        } mt$r_mtdef_bits;
/*                                                                          */
/* RECORDING FORMAT DEFINTIONS                                              */
/*                                                                          */
/*                                                                          */
/* RECORDING DENSITY AND METHOD DEFINITIONS                                 */
/*                                                                          */
/*	Default				 0                                  */
/*	9 Track				 1 - 7                              */
/*	Optical Disk			 8 - 11                             */
/*	High Performance Cartridge	12 - 15                             */
/*	Block Mode			16 - 23                             */
/*	Reserved			24 - 31                             */
/*                                                                          */
/*                                                                          */
/*                DEFAULT,0                /* DEFAULT DENSITY (SAME AS ABOVE) */
/* TAPE SPEED VALUE DEFINITIONS                                             */
/*                                                                          */
    } ;
 
#pragma standard

#endif					/* __MTDEF_LOADED */
#ifndef __MTHDEF_LOADED
#define __MTHDEF_LOADED	1

/*** MODULE $mthdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:38.40 */
/*                                                                          */
/* FILE: MTHMSG.MSG  EDIT: SMM2003                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 2-001 - CONVERT TO MESSAGE UTILITY SOURCE FORMAT.  ADAPTED FROM MTHMSG.MDL */
/*	  VERSION 1-004.  SBL 22-APR-1981                                   */
/* 2-002 - ADD .TITLE.  SBL 28-AUG-1982                                     */
/* 2-003 - ADD MTH$_NOTIMP.  SMM 03-SEP-1985                                */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	MTH$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$MTHDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE STS$V_MSG_ID IS THE FORTRAN ERROR NUMBER (1:94).                     */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS EXTERNAL;                    */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*-                                                                         */
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
/*			; SET LH TO 22 (DECIMAL) MTH$ PREFIX                */
#define MTH$_FACILITY 22
#define MTH$_WRONUMARG 1475204
#define MTH$_INVARGMAT 1475212
#define MTH$_UNDEXP 1475220
#define MTH$_LOGZERNEG 1475228
#define MTH$_SQUROONEG 1475236
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
/*			; SET LH TO 22 (DECIMAL) MTH$ PREFIX                */
#define MTH$_SIGLOSMAT 1475260
#define MTH$_FLOOVEMAT 1475268
#define MTH$_FLOUNDMAT 1475276
#define MTH$_NOTIMP 1475284
/* MTH$NOT_IMPLEMENTED                                                      */
#define MTH$_SINCOSSIG 1475260

#endif					/* __MTHDEF_LOADED */
#ifndef __NAM_LOADED
#define __NAM_LOADED	1
#pragma nostandard

/*** MODULE $namdef ***/
/*                                                                          */
/*         name block field definitions                                     */
/*                                                                          */
/*  the nam block is used to communicate optional                           */
/*  filename-related information                                            */
/*                                                                          */
#define NAM$C_BID 2                     /* code for nam block               */
#define NAM$C_MAXRSS 255                /* maximum resultant name string size (network)  */
#define NAM$C_MAXRSSLCL 255             /* maximum resultant name string size (local)  */
#define NAM$M_PWD 1
#define NAM$M_FILL_1 2
#define NAM$M_FILL_2 4
#define NAM$M_SYNCHK 8
#define NAM$M_NOCONCEAL 16
#define NAM$M_SLPARSE 32
#define NAM$M_SRCHXABS 64
#define NAM$C_UFS 0                     /* Unknown file system for remote file access or  */
/*  not applicable for local file access or                                 */
#define NAM$C_NO_RFS 0                  /*  task-to-task operation          */
#define NAM$C_RMS11 1                   /* RMS-11                           */
#define NAM$C_RMS20 2                   /* RMS-20                           */
#define NAM$C_RMS32 3                   /* RMS-32                           */
#define NAM$C_FCS11 4                   /* FCS-11                           */
#define NAM$C_RT11FS 5                  /* RT-11 file system                */
#define NAM$C_TOPS20FS 7                /* TOPS-20 file system              */
#define NAM$C_TOPS10FS 8                /* TOPS-10 file system              */
#define NAM$C_RMS32S 10                 /* RMS-32 subset (e.g., VAXELAN)    */
#define NAM$C_CPMFS 11                  /* CP/M file system                 */
#define NAM$C_MS_DOSFS 12               /* MS/DOS file system               */
#define NAM$C_ULTRIX32_FS 13            /* Ultrix-32 file system            */
#define NAM$C_ULTRIX11_FS 14            /* Ultrix-11 file system            */
#define DAP$K_SNADTF_FS 15              /* SNADTF compatable FS             */
/*+++++++++++++++++++++++                                                   */
#define NAM$C_DVI 16                    /* length of dvi field              */
/*+++++*****                                                                */
#define NAM$M_IFI 65536
#define NAM$M_SRCHNMF 1073741824
#define NAM$M_SVCTX -2147483648
#define NAM$K_BLN_V2 56                 /* Version 2 name block length      */
#define NAM$C_BLN_V2 56                 /* Version 2 name block length      */
#define NAM$M_EXP_VER 1
#define NAM$M_EXP_TYPE 2
#define NAM$M_EXP_NAME 4
#define NAM$M_WILD_VER 8
#define NAM$M_WILD_TYPE 16
#define NAM$M_WILD_NAME 32
#define NAM$M_EXP_DIR 64
#define NAM$M_EXP_DEV 128
#define NAM$M_WILDCARD 256
#define NAM$M_SEARCH_LIST 2048
#define NAM$M_CNCL_DEV 4096
#define NAM$M_ROOT_DIR 8192
#define NAM$M_LOWVER 16384
#define NAM$M_HIGHVER 32768
#define NAM$M_PPF 65536
#define NAM$M_NODE 131072
#define NAM$M_QUOTED 262144
#define NAM$M_GRP_MBR 524288
#define NAM$M_WILD_DIR 1048576
#define NAM$M_DIR_LVLS 14680064
#define NAM$M_WILD_UFD 16777216
#define NAM$M_WILD_SFD1 33554432
#define NAM$M_WILD_SFD2 67108864
#define NAM$M_WILD_SFD3 134217728
#define NAM$M_WILD_SFD4 268435456
#define NAM$M_WILD_SFD5 536870912
#define NAM$M_WILD_SFD6 1073741824
#define NAM$M_WILD_SFD7 -2147483648
#define NAM$M_WILD_GRP 16777216
#define NAM$M_WILD_MBR 33554432
#define NAM$K_BLN_DIRWC 96              /* Not documented optional length   */
#define NAM$C_BLN_DIRWC 96              /* Not documented optional length   */
#define NAM$K_BLN 96                    /* Name block length                */
#define NAM$C_BLN 96                    /* Name block length                */
struct NAM {
    unsigned char nam$b_bid;            /* block id                         */
    unsigned char nam$b_bln;            /* block length                     */
/*+++++++++++++++++++++++                                                   */
/*  the following 3 fields must not be rearranged relative to each other    */
/*                                                                          */
    unsigned char nam$b_rss;            /* resultant string area size       */
    unsigned char nam$b_rsl;            /* resultant string length          */
    char *nam$l_rsa;		        /* resultant string area address    */
/*-----------------------                                                   */
    variant_union  {
        unsigned char nam$b_nop;        /* Name options                     */
        variant_struct  {
            unsigned nam$v_pwd : 1;     /* Return password if present in nodespec string and any */
/* other task-specific data of the form /netacp_data"                       */
/*  (default is to mask out password from expanded and                      */
/*  resultant name strings and to create a logical name                     */
/*  whose equivalence string is the unaltered nodespec)                     */
            unsigned nam$v_fill_1 : 1;  /* unused.  (used to be undocumented ROD) */
            unsigned nam$v_fill_2 : 1;  /* unused.  (used to be undocumented SOD) */
            unsigned nam$v_synchk : 1;  /* Only do syntax check on $parse operation */
            unsigned nam$v_noconceal : 1; /* Do not conceal device/root directory */
            unsigned nam$v_slparse : 1; /* Parse search list (not documented) -- used by BACKUP. */
            unsigned nam$v_srchxabs : 1; /* Fill in attached XABS on $SEARCH operations over the */
/*  network (not documented) -- used by directory.                          */
            unsigned nam$v_fill_7 : 1;
            } nam$r_nop_bits;
        } nam$r_nop_overlay;
    unsigned char nam$b_rfs;            /* Remote file system type (currently not documented)  */
/* Note: This field is reserved for use by Digital                          */
/*  the following 3 fields must not be rearranged relative to each other    */
/*                                                                          */
    unsigned char nam$b_ess;            /* espanded string area size        */
    unsigned char nam$b_esl;            /* expanded string length           */
    char *nam$l_esa;		        /* expanded string area address     */
/*-----------------------                                                   */
    struct NAM *nam$l_rlf;	        /* related file nam block addr      */
    char nam$t_dvi [16];                /* device id                        */
/*  the location of the following fields must not                           */
/*  be changed due to their commonality with the fib                        */
    variant_union  {
        unsigned short int nam$w_fid [3]; /* file id                        */
        variant_struct  {
            unsigned short int nam$w_fid_num; /* file number                */
            unsigned short int nam$w_fid_seq; /* sequence number            */
            variant_union  {
                unsigned short int nam$w_fid_rvn; /* relative volume number  */
                variant_struct  {
                    unsigned char nam$b_fid_rvn; /* alternate format RVN    */
                    unsigned char nam$b_fid_nmx; /* alternate format file number extension  */
                    } nam$r_fid_rvn_fields;
                } nam$r_fid_rvn_overlay;
            } nam$r_fid_fields;
        } nam$r_fid_overlay;
    variant_union  {
        unsigned short int nam$w_did [3]; /* directory id                   */
        variant_struct  {
            unsigned short int nam$w_did_num; /* file number                */
            unsigned short int nam$w_did_seq; /* sequence number            */
            variant_union  {
                unsigned short int nam$w_did_rvn; /* relative volume number  */
                variant_struct  {
                    unsigned char nam$b_did_rvn; /* alternate format RVN    */
                    unsigned char nam$b_did_nmx; /* alternate format file number extension  */
                    } nam$r_did_rvn_fields;
                } nam$r_did_rvn_overlay;
            } nam$r_did_fields;
        } nam$r_did_overlay;
    variant_union  {
        unsigned long int nam$l_wcc;    /* wild card context                */
        variant_struct  {
            unsigned namdef$$_fill_1 : 16; /* the first word is reserved for IFI/ACP context  */
            unsigned nam$v_ifi : 1;     /* the first word contains an IFI   */
            unsigned namdef$$_fill_2 : 13; /* grow from top down, start at top bit  */
            unsigned nam$v_srchnmf : 1; /* no-more-files has been encountered on a search  */
            unsigned nam$v_svctx : 1;   /* save context across search calls  */
            } nam$r_wcc_bits;
        } nam$r_wcc_overlay;
    variant_union  {
        unsigned long int nam$l_fnb;    /* file name status bits            */
        variant_struct  {
            unsigned nam$v_exp_ver : 1; /* version was explicit             */
            unsigned nam$v_exp_type : 1; /* type was explicit               */
            unsigned nam$v_exp_name : 1; /* name was explicit               */
            unsigned nam$v_wild_ver : 1; /* version contained a wild card   */
            unsigned nam$v_wild_type : 1; /* type contained a wild card     */
            unsigned nam$v_wild_name : 1; /* name contained a wild card     */
            unsigned nam$v_exp_dir : 1; /* directory was explicit           */
            unsigned nam$v_exp_dev : 1; /* device was explicit              */
            unsigned nam$v_wildcard : 1; /* filename string included a wild card  */
/* (inclusive or of other wild card bits)                                   */
            unsigned namdef$$_fill_3 : 2; /* (spares)                       */
            unsigned nam$v_search_list : 1; /* search list present          */
            unsigned nam$v_cncl_dev : 1; /* concealed device present        */
            unsigned nam$v_root_dir : 1; /* root directory present          */
            unsigned nam$v_lowver : 1;  /* lower numbered version(s) of file exist(s)  */
            unsigned nam$v_highver : 1; /* higher "                         */
/*                                                                          */
            unsigned nam$v_ppf : 1;     /* process-permanent file referenced indirectly  */
            unsigned nam$v_node : 1;    /* filename specification included a nodename  */
            unsigned nam$v_quoted : 1;  /* filename spec included a quoted string  */
            unsigned nam$v_grp_mbr : 1; /* directory spec was of group-member format  */
            unsigned nam$v_wild_dir : 1; /* directory spec included a wild card  */
            unsigned nam$v_dir_lvls : 3; /* number of directory levels (0=ufd only)  */
            } nam$r_fnb_bits0;
        variant_struct  {
            unsigned namdef$$_fill_4 : 24; /* separate byte for wild card directory flags  */
            unsigned nam$v_wild_ufd : 1; /* ufd included a wild card        */
            unsigned nam$v_wild_sfd1 : 1; /* sfd1 included a wild card      */
            unsigned nam$v_wild_sfd2 : 1; /* sfd2 included a wild card      */
            unsigned nam$v_wild_sfd3 : 1; /* sfd3 included a wild card      */
            unsigned nam$v_wild_sfd4 : 1; /* sfd4 included a wild card      */
            unsigned nam$v_wild_sfd5 : 1; /* sfd5 included a wild card      */
            unsigned nam$v_wild_sfd6 : 1; /* sfd6 included a wild card      */
            unsigned nam$v_wild_sfd7 : 1; /* sfd7 included a wild card      */
            } nam$r_fnb_bits1;
        variant_struct  {
            unsigned namdef$$_fill_5 : 24; /* alternate definitions for wild_ufd and wild_sfd1  */
            unsigned nam$v_wild_grp : 1; /* group contained a wild card     */
            unsigned nam$v_wild_mbr : 1; /* member contained a wild card    */
            unsigned nam$v_fill_8 : 6;
            } nam$r_fnb_bits2;
/*-----*****                                                                */
/* (prior to 40 byte extension)                                             */
/*                                                                          */
/* Extend the NAM block by 40 bytes.                                        */
/*                                                                          */
        } nam$r_fnb_overlay;
    unsigned char nam$b_node;           /* Nodespec length                  */
    unsigned char nam$b_dev;            /* Device length                    */
    unsigned char nam$b_dir;            /* Directory length                 */
    unsigned char nam$b_name;           /* Filename length                  */
    unsigned char nam$b_type;           /* Filetype length                  */
    unsigned char nam$b_ver;            /* Version number length            */
    char namdef$$_fill_6 [2];           /* Currently unused                 */
    char *nam$l_node;			/* Nodespec address                 */
    char *nam$l_dev;			/* Device address                   */
    char *nam$l_dir;			/* Directory address                */
    char *nam$l_name;			/* Filename address                 */
    char *nam$l_type;			/* Filetype address                 */
    char *nam$l_ver;			/* Version number address           */
    long int namdef$$_fill_7 [2];       /* Currently unused                 */
    } ;

/* These are tradtional macros that should be hand-maintained for compatibility */
#define NAM$V_PWD	0		/* return password if present in nodespec string */
#define NAM$V_FILL_1	1
#define NAM$V_FILL_2	2
#define NAM$V_SYNCHK	3		/* Only do syntax check on $PARSE operation */
#define NAM$V_NOCONCEAL	4		/* do not conceal device/root directory */
#define NAM$V_SLPARSE	5		/* parse search list */
#define NAM$V_SRCHXABS	6		/* fill in attached XABS on $SEARCH ops over the network */
#define NAM$V_IFI	16		/* Internal file identifier */
#define NAM$V_SRCHNMF	30		/* no-more-files has been encountered on $SEARCH */
#define NAM$V_SVCTX	31		/* save context across search calls */
#define NAM$V_EXP_VER	0		/* version number is explicit */
#define NAM$V_EXP_TYPE	1		/* file type is explicit */
#define NAM$V_EXP_NAME	2		/* file name is explicit */
#define NAM$V_WILD_VER	3		/* version number containes a wild card */
#define NAM$V_WILD_TYPE	4		/* file type containes a wild card */
#define NAM$V_WILD_NAME	5		/* file name containes a wild card */
#define NAM$V_EXP_DIR	6		/* directory spec is explicit */
#define NAM$V_EXP_DEV	7		/* device name is explicit */
#define NAM$V_WILDCARD	8		/* file name string includes a wild card */
#define NAM$V_SEARCH_LIST 11		/* search list present */
#define NAM$V_CNCL_DEV	12		/* device name is a concealed device */
#define NAM$V_ROOT_DIR	13		/* device name incorporates a root directory */
#define NAM$V_LOWVER	14		/* lower numbered version(s) of the file exist(s) */
#define NAM$V_HIGHVER	15		/* higher numbered version(s) of the file exist(s) */
#define NAM$V_PPF	16		/* indirectly accessed process permanent file */
#define NAM$V_NODE	17		/* file specification includes a node name */
#define NAM$V_QUOTED	18		/* file spec includes a quoted string */
#define NAM$V_GRP_MBR	19		/* directory spec is of group-member number format */
#define NAM$V_WILD_DIR	20		/* directory spec includes a wild card */
#define NAM$V_DIR_LVLS	21		/* number of subdirectory levels (0 = ufd only) */
#define NAM$S_DIR_LVLS	3
#define NAM$V_WILD_UFD	24		/* user file directory spec includes a wild card */
#define NAM$V_WILD_SFD1	25		/* subfile directory 1 spec includes a wild card */
#define NAM$V_WILD_SFD2	26		/* sfd2 includes a wild card */
#define NAM$V_WILD_SFD3	27		/* sfd3 includes a wild card */
#define NAM$V_WILD_SFD4	28		/* sfd4 includes a wild card */
#define NAM$V_WILD_SFD5	29		/* sfd5 includes a wild card */
#define NAM$V_WILD_SFD6	30		/* sfd6 includes a wild card */
#define NAM$V_WILD_SFD7	31		/* sfd7 includes a wild card */
#define NAM$V_WILD_GRP	24		/* group containes a wild card */
#define NAM$V_WILD_MBR	25		/* member containes a wild card */

globalref struct NAM cc$rms_nam;	/* Declare initialized prototype data structure */

#pragma standard
#endif					/* __NAM_LOADED */
#ifndef __NCS$ROUTINES_LOADED
#define __NCS$ROUTINES_LOADED	1

/*** MODULE ncs$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    NCS$COMPARE                                                           */
/*                                                                          */
/*    Compare Strings                                                       */
/*                                                                          */
/*    Compares two strings using specified collating sequence as comparison */
/*    basis.                                                                */
/*                                                                          */
long int ncs$compare() ;
/*    NCS$CONVERT                                                           */
/*                                                                          */
/*    Convert String                                                        */
/*                                                                          */
/*    Convert a string using the specified conversion function.             */
/*                                                                          */
unsigned long int ncs$convert() ;
/*    NCS$END_CF                                                            */
/*                                                                          */
/*    End Conversion Function                                               */
/*                                                                          */
/*    Terminates the use of a conversion function by the calling program.   */
/*                                                                          */
unsigned long int ncs$end_cf() ;
/*    NCS$END_CS                                                            */
/*                                                                          */
/*    End Collating Sequence                                                */
/*                                                                          */
/*    Terminates the use of a collating sequence by the calling program.    */
/*                                                                          */
unsigned long int ncs$end_cs() ;
/*    NCS$GET_CF                                                            */
/*                                                                          */
/*    Get Conversion Function                                               */
/*                                                                          */
/*    Retrieves the definition of the named conversion function from the NCS */
/*    library.                                                              */
/*                                                                          */
unsigned long int ncs$get_cf() ;
/*    NCS$GET_CS                                                            */
/*                                                                          */
/*    Get Collating Sequence                                                */
/*                                                                          */
/*    Retrieves the definition of the named collating sequence from the NCS */
/*    library.                                                              */
/*                                                                          */
unsigned long int ncs$get_cs() ;
/*    NCS$RESTORE_CF                                                        */
/*                                                                          */
/*    Restore Conversion Function                                           */
/*                                                                          */
/*    Permits the calling program to restore the definition of a "saved"    */
/*    conversion function from a data base or an RMS file.                  */
/*                                                                          */
unsigned long int ncs$restore_cf() ;
/*    NCS$RESTORE_CS                                                        */
/*                                                                          */
/*    Restore Collating Sequence                                            */
/*                                                                          */
/*    Permits the calling program to restore the definition of a "saved" collating */
/*    sequence from a data base or an RMS file.                             */
/*                                                                          */
unsigned long int ncs$restore_cs() ;
/*    NCS$SAVE_CF                                                           */
/*                                                                          */
/*    Save Conversion Function                                              */
/*                                                                          */
/*    Provides the calling program with information that permits the application */
/*    to store the definition of a conversion function in a local data base or an */
/*    RMS file rather than the NCS$LIBRARY.                                 */
/*                                                                          */
unsigned long int ncs$save_cf() ;
/*    NCS$SAVE_CS                                                           */
/*                                                                          */
/*    Save Collating Sequence                                               */
/*                                                                          */
/*    Provides the calling program with information that permits the application */
/*    to store the definition of a collating sequence in a local data base or an */
/*    RMS file rather than the NCS$LIBRARY.                                 */
/*                                                                          */
unsigned long int ncs$save_cs() ;

#endif					/* __NCS$ROUTINES_LOADED */
#ifndef __NCSDEF_LOADED
#define __NCSDEF_LOADED	1

/*** MODULE $ncsdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 02:38:52.38 */
/*                                                                          */
/* FILE: NCSMSG.MSG EDIT: PDG1001                                           */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1982 BY						    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/*                                                                          */
/* FACILITY:	VAX-11 NCS                                                  */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS FILE CONTAINS THE DEFINITION FOR THE NCS FACILITY SPECIFIC     */
/*	ERROR MESSAGES.  THE FACILITY CODE FOR NCS IS ???.                  */
/*                                                                          */
/* ENVIRONMENT:	VAX/VMS USER MODE                                           */
/*                                                                          */
/* AUTHOR: P. GILBERT, CREATION DATE: 11-OCT-1983                           */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	E01-001		ORIGINAL                                            */
/*--                                                                        */
#define NCS$_FACILITY 561
#define NCS$_CVTNUM 36798466
#define NCS$_EXPCHAR 36798474
#define NCS$_EXPMORTXT 36798482
#define NCS$_DUMMY_1 36798490
#define NCS$_INVCOLSEQ 36798498
#define NCS$_NOMEMORY 36798508
#define NCS$_NUMTRUNC 36798512
#define NCS$_QUOTOOLONG 36798522
#define NCS$_COL_ADJ 36798532
#define NCS$_COL_CMPLX 36798540
#define NCS$_COL_CHAR 36798548
#define NCS$_COL_PAD 36798556
#define NCS$_COL_THREE 36798564
#define NCS$_ON_LINE 36798571
#define NCS$_LOOKUPERR 36798578
#define NCS$_INVAPPEND 36798586
#define NCS$_NYI 36798594
#define NCS$_NOT_CS 36798602
#define NCS$_NOT_CF 36798610
#define NCS$_LINEINFO 36798619
#define NCS$_CONMODEQL 36798626
#define NCS$_EXPECTED 36798634
#define NCS$_EXP1CHAR 36798642
#define NCS$_RANDIF 36798650
#define NCS$_BADCS 36798660
#define NCS$_BADCF 36798668
 
/*** MODULE $ncsdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 02:38:52.46 */
/*                                                                          */
#define NCS$_FACILITY 561
#define LIB$_INSERTED 36799265
#define LIB$_DELETED 36799273
#define LIB$_REPLACED 36799281
#define LIB$_REMOVED 36799289
#define LIB$_EXTRACTED 36799297
#define LIB$_DIFTYP 36799304
#define LIB$_NOMTCHFOU 36799312
#define LIB$_BRKNLIB 36799320
#define LIB$_HISTERR 36799328
#define LIB$_INVKEYCHAR 36799336
#define LIB$_DELKEYERR 36799346
#define LIB$_DELDATERR 36799354
#define LIB$_DUPMOD 36799362
#define LIB$_FAOFAIL 36799370
#define LIB$_INDEXERR 36799378
#define LIB$_INSERTERR 36799386
#define LIB$_LOOKUPERR 36799394
#define LIB$_MODNAMLNG 36799402
#define LIB$_NOMODNAM 36799410
#define LIB$_NOTOBJLIB 36799418
#define LIB$_NOTFORUNK 36799426
#define LIB$_CNVRTING 36799435
#define LIB$_EMPTYLIBRARY 36799443
#define LIB$_MHDERR 36799452
#define LIB$_INITERR 36799460
 
/*** MODULE $ncsdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 02:38:52.56 */
/*                                                                          */
#define NCS$_FACILITY 561
#define TFF$_LIBEMPTY 36800064
#define TFF$_DUPLTAB 36800072
#define TFF$_NOREADLIB 36800080
#define TFF$_NOWRTLIB 36800088
#define TFF$_IVTABNAM 36800098
#define TFF$_NOSUCHTAB 36800106
#define TFF$_NOWILD 36800114

#endif					/* __NCSDEF_LOADED */
#ifndef __NETDB_LOADED
#define __NETDB_LOADED	1


/*
 * Structures returned by network
 * data base library.  All addresses
 * are supplied in host order, and
 * returned in network order (suitable
 * for use in system calls).
 */
struct	hostent {
	char	*h_name;	/* official name of host */
	char	**h_aliases;	/* alias list */
	int	h_addrtype;	/* host address type */
	int	h_length;	/* length of address */
	char	**h_addr_list;	/* address */
#define h_addr h_addr_list[0]
};

/*
 * Assumption here is that a network number
 * fits in 32 bits -- probably a poor one.
 */
struct	netent {
	char	*n_name;	/* official name of net */
	char	**n_aliases;	/* alias list */
	int	n_addrtype;	/* net address type */
	int	n_net;		/* network # */
};

struct	servent {
	char	*s_name;	/* official service name */
	char	**s_aliases;	/* alias list */
	int	s_port;		/* port # */
	char	*s_proto;	/* protocol to use */
};

struct	protoent {
	char	*p_name;	/* official protocol name */
	char	**p_aliases;	/* alias list */
	int	p_proto;	/* protocol # */
};

struct rpcent {
	char    *r_name;        /* name of server for this rpc program */
	char    **r_aliases;    /* alias list */
	int     r_number;       /* rpc program number */
};

struct hostent *gethostbyaddr( char *addr, int len, int type);
struct hostent *gethostbyname( char *name);
struct hostent *gethostent();
struct netent *getnetbyaddr( long net, int type);
struct netent *getnetbyname( char *name);
struct netent *getnetent();
struct servent *getservbyname( char *name, char *proto);
struct servent *getservbyport(int port, char *proto);
struct servent *getservent();
struct protoent	*getprotobyname(char *name);
struct protoent	*getprotobynumber(int proto);
struct protoent	*getprotoent();

#endif					/* __NETDB_LOADED */
#ifndef __NFBDEF_LOADED
#define __NFBDEF_LOADED	1

/*	NFBDEF - V3.0	*/

/*
 *	$NFBDEF symbol definitions from LIB.MLB
 */

# define	NFB$B_DATABASE	0X2
# define	NFB$B_FCT	0X0
# define	NFB$B_FLAGS	0X1
# define	NFB$B_MBZ1	0XD
# define	NFB$B_OPER	0X3
# define	NFB$B_OPER2	0XC
# define	NFB$B_STR_TEXT	0X2
# define	NFB$C_AJI_ADD	0X13010010
# define	NFB$C_AJI_BLO	0X13010013
# define	NFB$C_AJI_CIR	0X13020042
# define	NFB$C_AJI_COL	0X13020040
# define	NFB$C_AJI_LCK	0X13000001
# define	NFB$C_AJI_LIT	0X13010012
# define	NFB$C_AJI_NNA	0X13020041
# define	NFB$C_AJI_REA	0X13000002
# define	NFB$C_AJI_RPR	0X13010014
# define	NFB$C_AJI_TYP	0X13010011
# define	NFB$C_ARI_ADD	0X14010010
# define	NFB$C_ARI_COL	0X14020040
# define	NFB$C_ARI_DCO	0X14010011
# define	NFB$C_ARI_DHO	0X14010012
# define	NFB$C_ARI_DLI	0X14020041
# define	NFB$C_ARI_LCK	0X14000001
# define	NFB$C_ARI_NND	0X14010013
# define	NFB$C_ARI_REA	0X14000002
# define	NFB$C_CRI_ACB	0X4010029
# define	NFB$C_CRI_ACI	0X401002A
# define	NFB$C_CRI_BBT	0X4010025
# define	NFB$C_CRI_BLK	0X4000003
# define	NFB$C_CRI_BLO	0X4010017
# define	NFB$C_CRI_CHN	0X4010021
# define	NFB$C_CRI_CHR	0X4020043
# define	NFB$C_CRI_CNT	0X4020044
# define	NFB$C_CRI_COL	0X4020040
# define	NFB$C_CRI_COS	0X4010018
# define	NFB$C_CRI_CTA	0X4010011
# define	NFB$C_CRI_DEVNAM	0X402004A
# define	NFB$C_CRI_DLM	0X4000005
# define	NFB$C_CRI_DRT	0X4010036
# define	NFB$C_CRI_DTE	0X4020049
# define	NFB$C_CRI_DTH	0X4010031
# define	NFB$C_CRI_DYB	0X401002E
# define	NFB$C_CRI_DYI	0X401002F
# define	NFB$C_CRI_DYT	0X4010030
# define	NFB$C_CRI_HET	0X4010019
# define	NFB$C_CRI_IAB	0X401002B
# define	NFB$C_CRI_IAI	0X401002C
# define	NFB$C_CRI_IAT	0X401002D
# define	NFB$C_CRI_LCK	0X4000001
# define	NFB$C_CRI_LCT	0X4010015
# define	NFB$C_CRI_LIT	0X401001A
# define	NFB$C_CRI_LOO	0X4020046
# define	NFB$C_CRI_MBL	0X4010022
# define	NFB$C_CRI_MRB	0X4010027
# define	NFB$C_CRI_MRC	0X401001B
# define	NFB$C_CRI_MRT	0X4010034
# define	NFB$C_CRI_MST	0X4010032
# define	NFB$C_CRI_MTR	0X4010028
# define	NFB$C_CRI_MWI	0X4010023
# define	NFB$C_CRI_NAM	0X4020041
# define	NFB$C_CRI_NUM	0X4020048
# define	NFB$C_CRI_OWPID	0X4010010
# define	NFB$C_CRI_P2P	0X4020045
# define	NFB$C_CRI_PLS	0X401001E
# define	NFB$C_CRI_PNA	0X4010016
# define	NFB$C_CRI_PNN	0X4020047
# define	NFB$C_CRI_POL	0X401001D
# define	NFB$C_CRI_RCT	0X401001C
# define	NFB$C_CRI_RPR	0X4010035
# define	NFB$C_CRI_SER	0X4000002
# define	NFB$C_CRI_SRV	0X4010012
# define	NFB$C_CRI_STA	0X4010013
# define	NFB$C_CRI_SUB	0X4010014
# define	NFB$C_CRI_TRI	0X4010024
# define	NFB$C_CRI_TRT	0X4010026
# define	NFB$C_CRI_TYP	0X4010020
# define	NFB$C_CRI_USE	0X401001F
# define	NFB$C_CRI_VER	0X4000004
# define	NFB$C_CRI_VMSNAM	0X4020042
# define	NFB$C_CRI_XPT	0X4010033
# define	NFB$C_CTX_SIZE	0X40
# define	NFB$C_DB_AJI	0X13
# define	NFB$C_DB_ARI	0X14
# define	NFB$C_DB_CRI	0X4
# define	NFB$C_DB_EFI	0X6
# define	NFB$C_DB_ESI	0X7
# define	NFB$C_DB_LLI	0X8
# define	NFB$C_DB_LNI	0X1
# define	NFB$C_DB_MAX	0X1B
# define	NFB$C_DB_NDI	0X2
# define	NFB$C_DB_OBI	0X3
# define	NFB$C_DB_PLI	0X5
# define	NFB$C_DB_PSI1	0X15
# define	NFB$C_DB_PSI2	0X16
# define	NFB$C_DB_PSI3	0X17
# define	NFB$C_DB_PSI4	0X18
# define	NFB$C_DB_PSI5	0X19
# define	NFB$C_DB_SDI	0X1A
# define	NFB$C_DB_SPI	0X12
# define	NFB$C_DB_XAI	0X1B
# define	NFB$C_DB_XD5	0XD
# define	NFB$C_DB_XD9	0XF
# define	NFB$C_DB_XDI	0XB
# define	NFB$C_DB_XGI	0XA
# define	NFB$C_DB_XNI	0X9
# define	NFB$C_DB_XS5	0XC
# define	NFB$C_DB_XS9	0XE
# define	NFB$C_DB_XTI	0X10
# define	NFB$C_DB_XTT	0X11
# define	NFB$C_DB_XXX	0X1C
# define	NFB$C_DECLNAME	0X15
# define	NFB$C_DECLOBJ	0X16
# define	NFB$C_DECLSERV	0X17
# define	NFB$C_EFI_B1	0X6010012
# define	NFB$C_EFI_B2	0X6010013
# define	NFB$C_EFI_COL	0X6020040
# define	NFB$C_EFI_EVE	0X6020041
# define	NFB$C_EFI_LCK	0X6000001
# define	NFB$C_EFI_SB1	0X6020042
# define	NFB$C_EFI_SB2	0X6020043
# define	NFB$C_EFI_SB3	0X6020044
# define	NFB$C_EFI_SIN	0X6010010
# define	NFB$C_EFI_SP1	0X6010011
# define	NFB$C_ENDOFLIST	0X0
# define	NFB$C_ESI_B1	0X7010013
# define	NFB$C_ESI_B2	0X7010014
# define	NFB$C_ESI_COL	0X7020040
# define	NFB$C_ESI_LCK	0X7000001
# define	NFB$C_ESI_LNA	0X7020041
# define	NFB$C_ESI_SB1	0X7020042
# define	NFB$C_ESI_SB2	0X7020043
# define	NFB$C_ESI_SB3	0X7020044
# define	NFB$C_ESI_SNK	0X7010010
# define	NFB$C_ESI_SP1	0X7010012
# define	NFB$C_ESI_STA	0X7010011
# define	NFB$C_FC_CLEAR	0X24
# define	NFB$C_FC_DELETE	0X21
# define	NFB$C_FC_LOOP	0X26
# define	NFB$C_FC_MAX	0X26
# define	NFB$C_FC_SET	0X23
# define	NFB$C_FC_SHOW	0X22
# define	NFB$C_FC_ZERCOU	0X25
# define	NFB$C_LENGTH	0X10
# define	NFB$C_LLI_CNT	0X8010018
# define	NFB$C_LLI_COL	0X8020040
# define	NFB$C_LLI_DLY	0X8010010
# define	NFB$C_LLI_IPID	0X8010016
# define	NFB$C_LLI_LCK	0X8000001
# define	NFB$C_LLI_LLN	0X8010012
# define	NFB$C_LLI_PID	0X8010015
# define	NFB$C_LLI_PNA	0X8010014
# define	NFB$C_LLI_PNN	0X8020043
# define	NFB$C_LLI_PRC	0X8020042
# define	NFB$C_LLI_RID	0X8020044
# define	NFB$C_LLI_RLN	0X8010013
# define	NFB$C_LLI_STA	0X8010011
# define	NFB$C_LLI_USR	0X8020041
# define	NFB$C_LLI_XWB	0X8010017
# define	NFB$C_LNI_ACL	0X1010011
# define	NFB$C_LNI_ADD	0X1010010
# define	NFB$C_LNI_ALI	0X1010033
# define	NFB$C_LNI_AMC	0X1010030
# define	NFB$C_LNI_AMH	0X1010031
# define	NFB$C_LNI_BRT	0X101002C
# define	NFB$C_LNI_BUS	0X1010024
# define	NFB$C_LNI_CNT	0X1020042
# define	NFB$C_LNI_COL	0X1020040
# define	NFB$C_LNI_DAC	0X1010028
# define	NFB$C_LNI_DFA	0X1010016
# define	NFB$C_LNI_DPX	0X1010029
# define	NFB$C_LNI_DWE	0X1010017
# define	NFB$C_LNI_ETY	0X101001A
# define	NFB$C_LNI_IAT	0X1010018
# define	NFB$C_LNI_IDE	0X1020043
# define	NFB$C_LNI_ITI	0X1010012
# define	NFB$C_LNI_LCK	0X1000001
# define	NFB$C_LNI_LPC	0X1010025
# define	NFB$C_LNI_LPD	0X1010027
# define	NFB$C_LNI_LPH	0X101002B
# define	NFB$C_LNI_LPL	0X1010026
# define	NFB$C_LNI_MAD	0X101001E
# define	NFB$C_LNI_MAR	0X101002D
# define	NFB$C_LNI_MBE	0X101002E
# define	NFB$C_LNI_MBR	0X101002F
# define	NFB$C_LNI_MBU	0X1010023
# define	NFB$C_LNI_MCO	0X1010020
# define	NFB$C_LNI_MHO	0X1010021
# define	NFB$C_LNI_MLK	0X1010015
# define	NFB$C_LNI_MLN	0X101001F
# define	NFB$C_LNI_MVE	0X1020044
# define	NFB$C_LNI_MVI	0X1010022
# define	NFB$C_LNI_NAM	0X1020041
# define	NFB$C_LNI_NVE	0X1020045
# define	NFB$C_LNI_OTI	0X1010013
# define	NFB$C_LNI_PHA	0X1020047
# define	NFB$C_LNI_PIQ	0X101002A
# define	NFB$C_LNI_RFA	0X1010019
# define	NFB$C_LNI_RSI	0X101001C
# define	NFB$C_LNI_RTI	0X101001B
# define	NFB$C_LNI_RVE	0X1020046
# define	NFB$C_LNI_SAD	0X101001D
# define	NFB$C_LNI_SBS	0X1010032
# define	NFB$C_LNI_STA	0X1010014
# define	NFB$C_LNI_SUP	0X1000002
# define	NFB$C_LOGEVENT	0X1C
# define	NFB$C_NDI_ACC	0X2010020
# define	NFB$C_NDI_ACL	0X2010014
# define	NFB$C_NDI_ADD	0X2010012
# define	NFB$C_NDI_CNT	0X2020042
# define	NFB$C_NDI_COL	0X2020040
# define	NFB$C_NDI_CPU	0X201001A
# define	NFB$C_NDI_CTA	0X2010011
# define	NFB$C_NDI_CTI	0X2010013
# define	NFB$C_NDI_DAD	0X201001C
# define	NFB$C_NDI_DCO	0X2010017
# define	NFB$C_NDI_DCT	0X201001D
# define	NFB$C_NDI_DEL	0X2010015
# define	NFB$C_NDI_DFL	0X2020056
# define	NFB$C_NDI_DHO	0X2010018
# define	NFB$C_NDI_DLI	0X202004D
# define	NFB$C_NDI_DTY	0X2010016
# define	NFB$C_NDI_DUM	0X202004A
# define	NFB$C_NDI_HAC	0X2020041
# define	NFB$C_NDI_HWA	0X2020057
# define	NFB$C_NDI_IHO	0X201001F
# define	NFB$C_NDI_LCK	0X2000001
# define	NFB$C_NDI_LOA	0X2020046
# define	NFB$C_NDI_LOO	0X2000002
# define	NFB$C_NDI_LPA	0X2020058
# define	NFB$C_NDI_NAC	0X2020052
# define	NFB$C_NDI_NLI	0X202004C
# define	NFB$C_NDI_NNA	0X2020043
# define	NFB$C_NDI_NND	0X2010022
# define	NFB$C_NDI_NNN	0X2020059
# define	NFB$C_NDI_NPW	0X2020053
# define	NFB$C_NDI_NUS	0X2020051
# define	NFB$C_NDI_OHO	0X201001E
# define	NFB$C_NDI_PAC	0X202004F
# define	NFB$C_NDI_PPW	0X2020050
# define	NFB$C_NDI_PRX	0X2010021
# define	NFB$C_NDI_PUS	0X202004E
# define	NFB$C_NDI_REA	0X2000003
# define	NFB$C_NDI_RPA	0X2020054
# define	NFB$C_NDI_SDU	0X202004B
# define	NFB$C_NDI_SDV	0X2010019
# define	NFB$C_NDI_SID	0X2020049
# define	NFB$C_NDI_SLI	0X2020044
# define	NFB$C_NDI_SLO	0X2020047
# define	NFB$C_NDI_SNV	0X2010023
# define	NFB$C_NDI_SPA	0X2020045
# define	NFB$C_NDI_STY	0X201001B
# define	NFB$C_NDI_TAD	0X2010010
# define	NFB$C_NDI_TLO	0X2020048
# define	NFB$C_NDI_TPA	0X2020055
# define	NFB$C_OBI_ACC	0X3020047
# define	NFB$C_OBI_CHN	0X3010013
# define	NFB$C_OBI_COL	0X3020040
# define	NFB$C_OBI_FID	0X3020045
# define	NFB$C_OBI_HPR	0X3010011
# define	NFB$C_OBI_IAC	0X3020043
# define	NFB$C_OBI_LCK	0X3000001
# define	NFB$C_OBI_LPR	0X3010010
# define	NFB$C_OBI_NAM	0X3020044
# define	NFB$C_OBI_NUM	0X3010014
# define	NFB$C_OBI_PID	0X3010015
# define	NFB$C_OBI_PRX	0X3010016
# define	NFB$C_OBI_PSW	0X3020048
# define	NFB$C_OBI_SET	0X3000002
# define	NFB$C_OBI_SFI	0X3020042
# define	NFB$C_OBI_UCB	0X3010012
# define	NFB$C_OBI_USR	0X3020046
# define	NFB$C_OBI_ZNA	0X3020041
# define	NFB$C_OP_EQL	0X0
# define	NFB$C_OP_FNDMAX	0X5
# define	NFB$C_OP_FNDMIN	0X4
# define	NFB$C_OP_FNDPOS	0X6
# define	NFB$C_OP_GTRU	0X1
# define	NFB$C_OP_LSSU	0X2
# define	NFB$C_OP_MAXFCT	0X3
# define	NFB$C_OP_MAXINT	0X6
# define	NFB$C_OP_NEQ	0X3
# define	NFB$C_PLI_BFN	0X501001E
# define	NFB$C_PLI_BFS	0X5010027
# define	NFB$C_PLI_BUS	0X501001F
# define	NFB$C_PLI_CHR	0X5020043
# define	NFB$C_PLI_CLO	0X5000005
# define	NFB$C_PLI_CNT	0X5020044
# define	NFB$C_PLI_COL	0X5020040
# define	NFB$C_PLI_CON	0X5000004
# define	NFB$C_PLI_CTA	0X5010010
# define	NFB$C_PLI_DDT	0X501001B
# define	NFB$C_PLI_DEVNAM	0X5020047
# define	NFB$C_PLI_DLT	0X501001C
# define	NFB$C_PLI_DUP	0X5000003
# define	NFB$C_PLI_EPT	0X5010026
# define	NFB$C_PLI_HTI	0X5010016
# define	NFB$C_PLI_HWA	0X5020046
# define	NFB$C_PLI_LCK	0X5000001
# define	NFB$C_PLI_LCT	0X5010013
# define	NFB$C_PLI_LPC	0X5010023
# define	NFB$C_PLI_LPD	0X5010025
# define	NFB$C_PLI_LPL	0X5010024
# define	NFB$C_PLI_MBL	0X5010017
# define	NFB$C_PLI_MCD	0X5020045
# define	NFB$C_PLI_MOD	0X5010022
# define	NFB$C_PLI_MRT	0X5010018
# define	NFB$C_PLI_MWI	0X5010019
# define	NFB$C_PLI_NAM	0X5020041
# define	NFB$C_PLI_PLVEC	0X5010020
# define	NFB$C_PLI_PRO	0X5010014
# define	NFB$C_PLI_RTT	0X5010021
# define	NFB$C_PLI_SER	0X5000002
# define	NFB$C_PLI_SLT	0X501001A
# define	NFB$C_PLI_SRT	0X501001D
# define	NFB$C_PLI_STA	0X5010011
# define	NFB$C_PLI_STI	0X5010015
# define	NFB$C_PLI_SUB	0X5010012
# define	NFB$C_PLI_VMSNAM	0X5020042
# define	NFB$C_READEVENT	0X1D
# define	NFB$C_SDI_CIR	0X1A020041
# define	NFB$C_SDI_COL	0X1A020040
# define	NFB$C_SDI_LCK	0X1A000001
# define	NFB$C_SDI_PHA	0X1A020042
# define	NFB$C_SDI_PID	0X1A010011
# define	NFB$C_SDI_PRC	0X1A020043
# define	NFB$C_SDI_SUB	0X1A010010
# define	NFB$C_SPI_ACS	0X12020041
# define	NFB$C_SPI_CHN	0X12010012
# define	NFB$C_SPI_COL	0X12020040
# define	NFB$C_SPI_IRP	0X12010011
# define	NFB$C_SPI_LCK	0X12000001
# define	NFB$C_SPI_NCB	0X12020044
# define	NFB$C_SPI_PID	0X12010010
# define	NFB$C_SPI_PNM	0X12020045
# define	NFB$C_SPI_PRL	0X12000002
# define	NFB$C_SPI_RID	0X12020042
# define	NFB$C_SPI_RNA	0X12010013
# define	NFB$C_SPI_SFI	0X12020043
# define	NFB$C_TYP_BIT	0X0
# define	NFB$C_TYP_L	0X1
# define	NFB$C_TYP_LNG	0X1
# define	NFB$C_TYP_S	0X2
# define	NFB$C_TYP_STR	0X2
# define	NFB$C_TYP_V	0X0
# define	NFB$C_WILDCARD	0X1
# define	NFB$C_XAI_ACC	0X1B020044
# define	NFB$C_XAI_COL	0X1B020040
# define	NFB$C_XAI_LCK	0X1B000001
# define	NFB$C_XAI_NDA	0X1B010010
# define	NFB$C_XAI_NET	0X1B020041
# define	NFB$C_XAI_NOD	0X1B020045
# define	NFB$C_XAI_PSW	0X1B020043
# define	NFB$C_XAI_USR	0X1B020042
# define	NFB$C_XD5_ACC	0XD02004A
# define	NFB$C_XD5_CMK	0XD020042
# define	NFB$C_XD5_COL	0XD020040
# define	NFB$C_XD5_CVL	0XD020043
# define	NFB$C_XD5_DST	0XD020041
# define	NFB$C_XD5_FIL	0XD020047
# define	NFB$C_XD5_GRP	0XD020044
# define	NFB$C_XD5_LCK	0XD000001
# define	NFB$C_XD5_NOD	0XD010012
# define	NFB$C_XD5_NUM	0XD020045
# define	NFB$C_XD5_OBJ	0XD020046
# define	NFB$C_XD5_PRI	0XD010010
# define	NFB$C_XD5_PSW	0XD020049
# define	NFB$C_XD5_SAD	0XD010011
# define	NFB$C_XD5_USR	0XD020048
# define	NFB$C_XD9_ACC	0XF02004A
# define	NFB$C_XD9_CMK	0XF020042
# define	NFB$C_XD9_COL	0XF020040
# define	NFB$C_XD9_CVL	0XF020043
# define	NFB$C_XD9_DST	0XF020041
# define	NFB$C_XD9_FIL	0XF020047
# define	NFB$C_XD9_GRP	0XF020044
# define	NFB$C_XD9_LCK	0XF000001
# define	NFB$C_XD9_NOD	0XF010012
# define	NFB$C_XD9_NUM	0XF020045
# define	NFB$C_XD9_OBJ	0XF020046
# define	NFB$C_XD9_PRI	0XF010010
# define	NFB$C_XD9_PSW	0XF020049
# define	NFB$C_XD9_SAD	0XF010011
# define	NFB$C_XD9_USR	0XF020048
# define	NFB$C_XDI_ACH	0XB010010
# define	NFB$C_XDI_ASW	0XB010011
# define	NFB$C_XDI_CHN	0XB020042
# define	NFB$C_XDI_CNT	0XB020045
# define	NFB$C_XDI_COL	0XB020040
# define	NFB$C_XDI_CTM	0XB010012
# define	NFB$C_XDI_DTE	0XB020041
# define	NFB$C_XDI_LCK	0XB000001
# define	NFB$C_XDI_LIN	0XB020043
# define	NFB$C_XDI_MCH	0XB010013
# define	NFB$C_XDI_MCI	0XB010016
# define	NFB$C_XDI_NET	0XB020044
# define	NFB$C_XDI_STA	0XB010014
# define	NFB$C_XDI_SUB	0XB010015
# define	NFB$C_XGI_COL	0XA020040
# define	NFB$C_XGI_GDT	0XA020042
# define	NFB$C_XGI_GNM	0XA010010
# define	NFB$C_XGI_GRP	0XA020041
# define	NFB$C_XGI_GTY	0XA010011
# define	NFB$C_XGI_LCK	0XA000001
# define	NFB$C_XNI_CAT	0X9010010
# define	NFB$C_XNI_CLT	0X9010011
# define	NFB$C_XNI_COL	0X9020040
# define	NFB$C_XNI_DBL	0X9010012
# define	NFB$C_XNI_DWI	0X9010013
# define	NFB$C_XNI_LCK	0X9000001
# define	NFB$C_XNI_MBL	0X9010014
# define	NFB$C_XNI_MCL	0X9010015
# define	NFB$C_XNI_MNS	0X9000002
# define	NFB$C_XNI_MRS	0X9010016
# define	NFB$C_XNI_MST	0X9010017
# define	NFB$C_XNI_MWI	0X9010018
# define	NFB$C_XNI_NET	0X9020041
# define	NFB$C_XNI_RST	0X9010019
# define	NFB$C_XNI_STT	0X901001A
# define	NFB$C_XS5_ACI	0XC010012
# define	NFB$C_XS5_CNT	0XC020041
# define	NFB$C_XS5_COL	0XC020040
# define	NFB$C_XS5_CTM	0XC010013
# define	NFB$C_XS5_LCK	0XC000001
# define	NFB$C_XS5_MCI	0XC010010
# define	NFB$C_XS5_STA	0XC010011
# define	NFB$C_XS9_ACI	0XE010012
# define	NFB$C_XS9_CNT	0XE020041
# define	NFB$C_XS9_COL	0XE020040
# define	NFB$C_XS9_CTM	0XE010013
# define	NFB$C_XS9_LCK	0XE000001
# define	NFB$C_XS9_MCI	0XE010010
# define	NFB$C_XS9_STA	0XE010011
# define	NFB$C_XTI_BFZ	0X10010011
# define	NFB$C_XTI_COL	0X10020040
# define	NFB$C_XTI_CPL	0X10010012
# define	NFB$C_XTI_FNM	0X10020041
# define	NFB$C_XTI_LCK	0X10000001
# define	NFB$C_XTI_MBF	0X10010014
# define	NFB$C_XTI_MBK	0X10010013
# define	NFB$C_XTI_MVR	0X10010015
# define	NFB$C_XTI_STA	0X10010010
# define	NFB$C_XTT_COL	0X11020040
# define	NFB$C_XTT_CPS	0X11010011
# define	NFB$C_XTT_LCK	0X11000001
# define	NFB$C_XTT_TPT	0X11020041
# define	NFB$C_XTT_TST	0X11010010
# define	NFB$K_LENGTH	0X10
# define	NFB$L_BIT_VALUE	0X0
# define	NFB$L_FLDID	0X10
# define	NFB$L_LNG_VALUE	0X0
# define	NFB$L_PARAM_ID	0X0
# define	NFB$L_SRCH2_KEY	0X8
# define	NFB$L_SRCH_KEY	0X4
# define	NFB$M_DB	0XFF000000
# define	NFB$M_ERRUPD	0X1
# define	NFB$M_INX	0XFFFF
# define	NFB$M_MULT	0X2
# define	NFB$M_NOCTX	0X4
# define	NFB$M_SPARE	0XFC0000
# define	NFB$M_TYP	0X30000
# define	NFB$S_DB	0X8
# define	NFB$S_INX	0X10
# define	NFB$S_SPARE	0X6
# define	NFB$S_TYP	0X2
# define	NFB$V_DB	0X18
# define	NFB$V_ERRUPD	0X0
# define	NFB$V_INX	0X0
# define	NFB$V_MULT	0X1
# define	NFB$V_NOCTX	0X2
# define	NFB$V_SPARE	0X12
# define	NFB$V_TYP	0X10
# define	NFB$W_CELL_SIZE	0XE
# define	NFB$W_STR_COUNT	0X0
# define	NFB$_ERR_CELL	0X9
# define	NFB$_ERR_DB	0X2
# define	NFB$_ERR_FCT	0X1
# define	NFB$_ERR_FLAGS	0XE
# define	NFB$_ERR_OPER	0XA
# define	NFB$_ERR_OPER2	0XD
# define	NFB$_ERR_P1	0X3
# define	NFB$_ERR_P2	0X4
# define	NFB$_ERR_P3	0X5
# define	NFB$_ERR_P4	0X6
# define	NFB$_ERR_P5	0X7
# define	NFB$_ERR_P6	0X8
# define	NFB$_ERR_SRCH	0XB
# define	NFB$_ERR_SRCH2	0XC

#endif					/* __NFBDEF_LOADED */
#ifndef __NSARECDEF_LOADED
#define __NSARECDEF_LOADED	1

/*** MODULE $nsarecdef ***/
/*+                                                                         */
/* Security Auditing record definitions                                     */
/*-                                                                         */
#define NSA$C_REC_MAXLENGTH 1024        /* Maximum record size              */
#define NSA$K_REC_MAXLENGTH 1024        /* Maximum record size              */
#define NSA$S_REC_MAXLENGTH 1024        /* Maximum record size              */
/*+                                                                         */
/* Audit record type definitions                                            */
/*-                                                                         */
#define NSA$K_RECTYP_FIL 1              /* File access                      */
#define NSA$K_RECTYP_SYSUAF 2           /* System UAF                       */
#define NSA$K_RECTYP_NETUAF 3           /* Network UAF                      */
#define NSA$K_RECTYP_LOGB 4             /* Login breakin detection          */
#define NSA$K_RECTYP_LOGI 5             /* Successful login                 */
#define NSA$K_RECTYP_LOGF 6             /* Login failure                    */
#define NSA$K_RECTYP_LOGO 7             /* Logout                           */
#define NSA$K_RECTYP_VOL 8              /* Volume operations                */
#define NSA$K_RECTYP_GBL 9              /* Global section access            */
#define NSA$K_RECTYP_INSTAL 10          /* INSTALL operations               */
#define NSA$K_RECTYP_RIGHTS 11          /* Rights database operations       */
#define NSA$K_RECTYP_AUDIT 12           /* SET AUDIT operations             */
#define NSA$K_RECTYPNUM 12
/*+                                                                         */
/* Audit record subtype and ID definitions                                  */
/*-                                                                         */
/* File access                                                              */
#define NSA$K_RECTYP_FIL_SUCC 1         /* Successful file access           */
#define NSA$K_RECTYP_FIL_FAIL 2         /* File access failure              */
#define NSA$K_RECTYPNUM_FIL 2
#define NSA$K_RECID_FIL_SUCC 65537
#define NSA$K_RECID_FIL_FAIL 131073
/* Global section access                                                    */
#define NSA$K_RECTYP_GBL_SUCC 1         /* Successful Global section access */
#define NSA$K_RECTYP_GBL_FAIL 2         /* Global section access failure    */
#define NSA$K_RECTYPNUM_GBL 2
#define NSA$K_RECID_GBL_SUCC 65545
#define NSA$K_RECID_GBL_FAIL 131081
/* System UAF                                                               */
#define NSA$K_RECTYP_SYSUAF_ADD 1       /* System UAF record addition       */
#define NSA$K_RECTYP_SYSUAF_DEL 2       /* System UAF record deletion       */
#define NSA$K_RECTYP_SYSUAF_MOD 3       /* System UAF record modification   */
#define NSA$K_RECTYP_SYSUAF_COP 4       /* System UAF record copied         */
#define NSA$K_RECTYP_SYSUAF_REN 5       /* System UAF record renamed        */
#define NSA$K_RECTYPNUM_SYSUAF 5
#define NSA$K_RECID_SYSUAF_ADD 65538
#define NSA$K_RECID_SYSUAF_DEL 131074
#define NSA$K_RECID_SYSUAF_MOD 196610
#define NSA$K_RECID_SYSUAF_COP 262146
#define NSA$K_RECID_SYSUAF_REN 327682
/* Network UAF                                                              */
#define NSA$K_RECTYP_NETUAF_ADD 1       /* Network UAF record addition      */
#define NSA$K_RECTYP_NETUAF_DEL 2       /* Network UAF record deletion      */
#define NSA$K_RECTYP_NETUAF_MOD 3       /* Network UAF record modification  */
#define NSA$K_RECTYPNUM_NETUAF 3
#define NSA$K_RECID_NETUAF_ADD 65539
#define NSA$K_RECID_NETUAF_DEL 131075
#define NSA$K_RECID_NETUAF_MOD 196611
/* Login breakin detection                                                  */
#define NSA$K_RECTYP_LOGB_DIA 1         /* Dialup interactive breakin detection */
#define NSA$K_RECTYP_LOGB_LOC 2         /* Local interactive breakin detection */
#define NSA$K_RECTYP_LOGB_REM 3         /* Remote interactive breakin detection */
#define NSA$K_RECTYP_LOGB_NET 4         /* Network breakin detection        */
#define NSA$K_RECTYP_LOGB_DET 5         /* Detached process breakin detection */
#define NSA$K_RECTYPNUM_LOGB 5
#define NSA$K_RECID_LOGB_DIA 65540
#define NSA$K_RECID_LOGB_LOC 131076
#define NSA$K_RECID_LOGB_REM 196612
#define NSA$K_RECID_LOGB_NET 262148
#define NSA$K_RECID_LOGB_DET 327684
/* Successful login                                                         */
#define NSA$K_RECTYP_LOGI_BAT 1         /* Batch process login              */
#define NSA$K_RECTYP_LOGI_DIA 2         /* Dialup interactive login         */
#define NSA$K_RECTYP_LOGI_LOC 3         /* Local interactive login          */
#define NSA$K_RECTYP_LOGI_REM 4         /* Remote interactive login         */
#define NSA$K_RECTYP_LOGI_NET 5         /* Network login                    */
#define NSA$K_RECTYP_LOGI_SUB 6         /* Subprocess login                 */
#define NSA$K_RECTYP_LOGI_DET 7         /* Detached process login           */
#define NSA$K_RECTYPNUM_LOGI 7
#define NSA$K_RECID_LOGI_BAT 65541
#define NSA$K_RECID_LOGI_DIA 131077
#define NSA$K_RECID_LOGI_LOC 196613
#define NSA$K_RECID_LOGI_REM 262149
#define NSA$K_RECID_LOGI_NET 327685
#define NSA$K_RECID_LOGI_SUB 393221
#define NSA$K_RECID_LOGI_DET 458757
/* Login failure                                                            */
#define NSA$K_RECTYP_LOGF_BAT 1         /* Batch process login failure      */
#define NSA$K_RECTYP_LOGF_DIA 2         /* Dialup interactive login failure */
#define NSA$K_RECTYP_LOGF_LOC 3         /* Local interactive login failure  */
#define NSA$K_RECTYP_LOGF_REM 4         /* Remote interactive login failure */
#define NSA$K_RECTYP_LOGF_NET 5         /* Network login failure            */
#define NSA$K_RECTYP_LOGF_SUB 6         /* Subprocess login failure         */
#define NSA$K_RECTYP_LOGF_DET 7         /* Detached process login failure   */
#define NSA$K_RECTYPNUM_LOGF 7
#define NSA$K_RECID_LOGF_BAT 65542
#define NSA$K_RECID_LOGF_DIA 131078
#define NSA$K_RECID_LOGF_LOC 196614
#define NSA$K_RECID_LOGF_REM 262150
#define NSA$K_RECID_LOGF_NET 327686
#define NSA$K_RECID_LOGF_SUB 393222
#define NSA$K_RECID_LOGF_DET 458758
/* Logout                                                                   */
#define NSA$K_RECTYP_LOGO_BAT 1         /* Batch process logout             */
#define NSA$K_RECTYP_LOGO_DIA 2         /* Dialup interactive logout        */
#define NSA$K_RECTYP_LOGO_LOC 3         /* Local interactive logout         */
#define NSA$K_RECTYP_LOGO_REM 4         /* Remote interactive logout        */
#define NSA$K_RECTYP_LOGO_NET 5         /* Network logout                   */
#define NSA$K_RECTYP_LOGO_SUB 6         /* Subprocess logout                */
#define NSA$K_RECTYP_LOGO_DET 7         /* Detached process logout          */
#define NSA$K_RECTYPNUM_LOGO 7
#define NSA$K_RECID_LOGO_BAT 65543
#define NSA$K_RECID_LOGO_DIA 131079
#define NSA$K_RECID_LOGO_LOC 196615
#define NSA$K_RECID_LOGO_REM 262151
#define NSA$K_RECID_LOGO_NET 327687
#define NSA$K_RECID_LOGO_SUB 393223
#define NSA$K_RECID_LOGO_DET 458759
/* Volume operations                                                        */
#define NSA$K_RECTYP_VOL_MOU 1          /* Volume mounts                    */
#define NSA$K_RECTYP_VOL_DMOU 2         /* Volume dismounts                 */
#define NSA$K_RECTYPNUM_VOL 2
#define NSA$K_RECID_VOL_MOU 65544
#define NSA$K_RECID_VOL_DMOU 131080
/* INSTALL operations                                                       */
#define NSA$K_RECTYP_INSTAL_ADD 1       /* Add known file                   */
#define NSA$K_RECTYP_INSTAL_REM 2       /* Remove known file                */
#define NSA$K_RECTYPNUM_INSTAL 2
/* Rights database operations                                               */
#define NSA$K_RECTYP_RIGHTS_CRE 1       /* Create rights database           */
#define NSA$K_RECTYP_RIGHTS_ADD 2       /* Add identifier                   */
#define NSA$K_RECTYP_RIGHTS_REM 3       /* Remove identifier                */
#define NSA$K_RECTYP_RIGHTS_MOD_ID 4    /* Modify identifier                */
#define NSA$K_RECTYP_RIGHTS_MOD_HO 5    /* Modify identifier holder         */
#define NSA$K_RECTYP_RIGHTS_GRANT 6     /* Grant identifier                 */
#define NSA$K_RECTYP_RIGHTS_REVOK 7     /* Revoke identifier                */
#define NSA$K_RECTYPNUM_RIGHTS 7
/* SET AUDIT operations                                                     */
#define NSA$K_RECTYP_AUDIT_ENA_AL 1     /* Enable alarm                     */
#define NSA$K_RECTYP_AUDIT_DIS_AL 2     /* Disable alarm                    */
#define NSA$K_RECTYP_AUDIT_ENA_JL 3     /* Enable journal                   */
#define NSA$K_RECTYP_AUDIT_DIS_JL 4     /* Disable journal                  */
#define NSA$K_RECTYPNUM_AUDIT 4
/*+                                                                         */
/* SYSUAFF stuff                                                            */
/*-                                                                         */
struct sysuaff_bits {
#pragma nostandard
    variant_union  {
        unsigned int nsa$q_sysuaff [2]; /* SYSUAFF flags:                   */
        variant_struct  {
            unsigned nsa$v_access : 1;  /*  ACCESS modified                 */
            unsigned nsa$v_account : 1; /*  ACCOUNT modified                */
            unsigned nsa$v_astlm : 1;   /*  ASTLM modified                  */
            unsigned nsa$v_batch : 1;   /*  BATCH modified                  */
            unsigned nsa$v_biolm : 1;   /*  BIOLM modified                  */
            unsigned nsa$v_bytlm : 1;   /*  BYTLM modified                  */
            unsigned nsa$v_cli : 1;     /*  CLI modified                    */
            unsigned nsa$v_clitables : 1; /*  CLITABLES modified            */
            unsigned nsa$v_cputime : 1; /*  CPUTIME modified                */
            unsigned nsa$v_defprivileges : 1; /*  DEFPRIVILEGES modified    */
            unsigned nsa$v_device : 1;  /*  DEVICE modified                 */
            unsigned nsa$v_dialup : 1;  /*  DIALUP modified                 */
            unsigned nsa$v_diolm : 1;   /*  DIOLM modified                  */
            unsigned nsa$v_directory : 1; /*  DIRECTORY modified            */
            unsigned nsa$v_enqlm : 1;   /*  ENQLM modified                  */
            unsigned nsa$v_expiration : 1; /*  EXPIRATION modified          */
            unsigned nsa$v_fillm : 1;   /*  FILLM modified                  */
            unsigned nsa$v_flags : 1;   /*  FLAGS modified                  */
            unsigned nsa$v_interactive : 1; /*  INTERACTIVE modified        */
            unsigned nsa$v_jtquota : 1; /*  JTQUOTA modified                */
            unsigned nsa$v_lgicmd : 1;  /*  LGICMD modified                 */
            unsigned nsa$v_local : 1;   /*  LOCAL modified                  */
            unsigned nsa$v_maxdetach : 1; /*  MAXDETACH modified            */
            unsigned nsa$v_maxjobs : 1; /*  MAXJOBS modified                */
            unsigned nsa$v_maxacctjobs : 1; /*  MAXACCTJOBS modified        */
            unsigned nsa$v_network : 1; /*  NETWORK modified                */
            unsigned nsa$v_owner : 1;   /*  OWNER modified                  */
            unsigned nsa$v_password : 1; /*  PASSWORD modified              */
            unsigned nsa$v_pbytlm : 1;  /*  PBYTLM modified                 */
            unsigned nsa$v_pflags : 1;  /*  PFLAGS modified                 */
            unsigned nsa$v_p_restrict : 1; /*  P_RESTRICT modified          */
            unsigned nsa$v_pgflquota : 1; /*  PGFLQUOTA modified            */
            unsigned nsa$v_prclm : 1;   /*  PRCLM modified                  */
            unsigned nsa$v_primedays : 1; /*  PRIMEDAYS modified            */
            unsigned nsa$v_priority : 1; /*  PRIORITY modified              */
            unsigned nsa$v_privileges : 1; /*  PRIVILEGES modified          */
            unsigned nsa$v_pwdlifetime : 1; /*  PWDLIFETIME modified        */
            unsigned nsa$v_pwdminimum : 1; /*  PWDMINIMUM modified          */
            unsigned nsa$v_quepriority : 1; /*  QUEPRIORITY modified        */
            unsigned nsa$v_remote : 1;  /*  REMOTE modified                 */
            unsigned nsa$v_sflags : 1;  /*  SFLAGS modified                 */
            unsigned nsa$v_s_restrict : 1; /*  S_RESTRICT modified          */
            unsigned nsa$v_shrfillm : 1; /*  SHRFILLM modified              */
            unsigned nsa$v_tqelm : 1;   /*  TQELM modified                  */
            unsigned nsa$v_uic : 1;     /*  UIC modified                    */
            unsigned nsa$v_wsdefault : 1; /*  WSDEFAULT modified            */
            unsigned nsa$v_wsextent : 1; /*  WSEXTENT modified              */
            unsigned nsa$v_wsquota : 1; /*  WSQUOTA modified                */
            } nsa$r_fill_5;
        } nsa$r_fill_4;
    } ;
/*+                                                                         */
/* Record header offset definitions                                         */
/*-                                                                         */
#define NSA$M_REC_FLAGS_PKTCON 1
#define NSA$C_RECHDR_LENGTH 76
#define NSA$K_RECHDR_LENGTH 76
struct nsarechdrdef {
    variant_union  {
        unsigned long int nsa$l_rec_id; /* Record identification longword   */
        variant_struct  {
            unsigned short int nsa$w_rec_type; /* Record type               */
            unsigned short int nsa$w_rec_subtype; /* Record subtype         */
            } nsa$r_rec_id_fields;
        } nsa$r_rec_id_overlay;
    unsigned char nsa$b_rec_seqnum;     /* This records sequence number     */
    unsigned char nsa$b_rec_seqlast;    /* Last records sequence number     */
    variant_union  {
        unsigned char nsa$b_rec_flags;  /* Record flags byte                */
        variant_struct  {
            unsigned nsa$v_rec_flags_pktcon : 1; /* Last packet in record is */
/* continued in next record                                                 */
            unsigned nsa$v_fill_6 : 7;
            } nsa$r_rec_flags_bits;
        } nsa$r_rec_flags_overlay;
    unsigned char nsa$b_rec_pktnum;     /* Number of data packets in record */
    unsigned short int nsa$w_rec_pktoff; /* Offset to first packet          */
    unsigned short int nsa$w_rec_pkthdrsiz; /* Data packet header size      */
    unsigned long int nsa$l_rec_epid;   /* Extended PID                     */
    unsigned int nsa$q_rec_time [2];    /* Event time (EXE$GQ_SYSTIME)      */
    char nsa$t_rec_clusnam [16];        /* Cluster node name                */
    char nsa$t_rec_procnam [16];        /* Process name                     */
    char nsa$t_rec_usernam [12];        /* username                         */
    char nsa$t_rec_acctnam [8];         /* Account name                     */
    } ;
/*+                                                                         */
/* Data packet type definitions                                             */
/*-                                                                         */
#define NSA$K_PKTTYP_IMGNAM 1           /* Image name packet                */
#define NSA$K_PKTTYP_FACMOD 2           /* File access mode                 */
#define NSA$K_PKTTYP_PRIVUSED 3         /* Privilege used to access file    */
#define NSA$K_PKTTYP_FILNAM 4           /* File name                        */
#define NSA$K_PKTTYP_DEVNAM 5           /* Device name                      */
#define NSA$K_PKTTYP_LOGNAM 6           /* Logical name                     */
#define NSA$K_PKTTYP_VOLNAM 7           /* Volume name                      */
#define NSA$K_PKTTYP_VOLSNAM 8          /* Volume set name                  */
#define NSA$K_PKTTYP_NODENAM 9          /* Node name                        */
#define NSA$K_PKTTYP_USERNAM 10         /* User name                        */
#define NSA$K_PKTTYP_PASSWORD 11        /* Password                         */
#define NSA$K_PKTTYP_UIC 12             /* User identification code         */
#define NSA$K_PKTTYP_VOLPRO 13          /* Volume protection                */
#define NSA$K_PKTTYP_MOUFLG 14          /* Mount flags                      */
#define NSA$K_PKTTYP_DMOUFLG 15         /* Dismount flags                   */
#define NSA$K_PKTTYP_NODEID 16          /* Node ID                          */
#define NSA$K_PKTTYP_EPID 17            /* Extended PID                     */
#define NSA$K_PKTTYP_SYSUAFF 18         /* System UAF record fields         */
#define NSA$K_PKTTYP_STATUS 19          /* Status longword                  */
#define NSA$K_PKTTYP_SECNAM 20          /* Global section name              */
#define NSA$K_PKTTYP_PRIVS 21           /* Full privilege mask              */
#define NSA$K_PKTTYP_INSFLG 22          /* Install flags                    */
#define NSA$K_PKTTYP_IDNAME 23          /* Identifier name                  */
#define NSA$K_PKTTYP_IDVAL 24           /* Identifier value                 */
#define NSA$K_PKTTYP_IDATTR 25          /* Identifier attributes            */
#define NSA$K_PKTTYP_HOLDER 26          /* Identifier holder                */
#define NSA$K_PKTTYP_AUDIT 27           /* Audit item                       */
#define NSA$K_PKTTYP_DEFUSERNAM 28      /* Default proxy name               */
#define NSA$K_PKTTYP_OLDUSERNAM 29      /* Old proxy name                   */
#define NSA$K_PKTTYP_OLDDEFUNAM 30      /* Old default local proxy name     */
#define NSA$K_PKTTYP_OLDNODENAM 31      /* Old remote node name             */
#define NSA$K_PKTTYPNUM 31
/*+                                                                         */
/* Data packet offset definitions                                           */
/*-                                                                         */
#define NSA$C_PKTHDR_LENGTH 4
#define NSA$K_PKTHDR_LENGTH 4
#define NSA$M_PKT_INS_OPEN 2
#define NSA$M_PKT_INS_HDR 4
#define NSA$M_PKT_INS_SHARE 8
#define NSA$M_PKT_INS_EXEC 16
#define NSA$M_PKT_INS_WRITE 32
#define NSA$M_PKT_INS_PRIV 64
#define NSA$M_PKT_INS_PROT 128
#define NSA$M_PKT_INS_NOPRG 256
#define NSA$M_PKT_INS_ACC 512
struct nsapktdef { /* WARNING: aggregate has origin of -4 */
    unsigned short int nsa$w_pkt_type;  /* Packet data type                 */
    unsigned short int nsa$w_pkt_size;  /* Packet size                      */
    char nsa$t_pkt_data [];
    variant_union  {
        char nsa$t_pkt_imgnam [444];    /* Image name                       */
        unsigned long int nsa$l_pkt_facmod; /* File access mode             */
        unsigned long int nsa$l_pkt_privused; /* Privilege used to access file */
        char nsa$t_pkt_filnam [444];    /* File name                        */
        char nsa$t_pkt_devnam [64];     /* Device and access port name      */
        char nsa$t_pkt_lognam [255];    /* Logical name                     */
        char nsa$t_pkt_volnam [12];     /* Volume name                      */
        char nsa$t_pkt_volsnam [12];    /* Volume set name                  */
        char nsa$t_pkt_nodenam [6];     /* Node name                        */
        char nsa$t_pkt_usernam [32];    /* User name                        */
        char nsa$t_pkt_password [32];   /* Password                         */
        unsigned long int nsa$l_pkt_uic; /* Volume UIC                      */
        unsigned short int nsa$w_pkt_volpro; /* Volume protection           */
        unsigned long int nsa$l_pkt_mouflg; /* Mount flags                  */
        unsigned short int nsa$w_pkt_dmouflg; /* Dismount flags             */
        unsigned int nsa$q_pkt_nodeid [2]; /* Node ID                       */
        unsigned long int nsa$l_pkt_epid; /* Extended PID                   */
        unsigned int nsa$q_pkt_sysuaff [2]; /* System UAF record fields     */
        unsigned long int nsa$l_pkt_status; /* Status longword              */
        char nsa$t_pkt_secnam [54];     /* Global section name              */
        unsigned int nsa$q_pkt_privs [2]; /* Full privilege mask            */
        variant_union  {
            unsigned long int nsa$l_pkt_insflg; /* Install flags            */
            variant_struct  {
                unsigned nsa$v_pkt_ins_fill : 1; /* Bit 0 must be unused    */
                unsigned nsa$v_pkt_ins_open : 1; /* /OPEN                   */
                unsigned nsa$v_pkt_ins_hdr : 1; /* /HEADER_RESIDENT         */
                unsigned nsa$v_pkt_ins_share : 1; /* /SHARE                 */
                unsigned nsa$v_pkt_ins_exec : 1; /* /EXECUTE                */
                unsigned nsa$v_pkt_ins_write : 1; /* /WRITE                 */
                unsigned nsa$v_pkt_ins_priv : 1; /* /PRIVILEGE              */
                unsigned nsa$v_pkt_ins_prot : 1; /* /PROTECTED              */
                unsigned nsa$v_pkt_ins_noprg : 1; /* /NOPURGE               */
                unsigned nsa$v_pkt_ins_acc : 1; /* /ACCOUNTING              */
                unsigned nsa$v_fill_9 : 6;
                } nsa$r_fill_8;
            } nsa$r_fill_7;
        char nsa$t_pkt_idname [32];     /* Identifier name                  */
        unsigned long int nsa$l_pkt_idval; /* Identifier value              */
        unsigned long int nsa$l_pkt_idattr; /* Identifier attributes        */
        unsigned int nsa$q_pkt_holder [2]; /* Identifier holder             */
        char nsa$r_pkt_audit [];        /* Audit item (not used)            */
        char nsa$t_pkt_defusernam [32]; /* Default proxy name               */
        char nsa$t_pkt_oldusernam [32]; /* Old proxy name                   */
        char nsa$t_pkt_olddefunam [32]; /* Old default local proxy name     */
        char nsa$t_pkt_oldnodenam [6];  /* Old remote node name             */
        } nsa$r_pkt_data_overlay;
    } ;
 
#pragma standard

#endif					/* __NSARECDEF_LOADED */
#ifndef __OBJRECDEF_LOADED
#define __OBJRECDEF_LOADED	1

/*** MODULE $objrecdef ***/
#define OBJ$M_PSC_PIC 1
#define OBJ$M_PSC_LIB 2
#define OBJ$M_PSC_OVL 4
#define OBJ$M_PSC_REL 8
#define OBJ$M_PSC_GBL 16
#define OBJ$M_PSC_SHR 32
#define OBJ$M_PSC_EXE 64
#define OBJ$M_PSC_RD 128
#define OBJ$M_PSC_WRT 256
#define OBJ$M_SYM_WEAK 1
#define OBJ$M_SYM_DEF 2
#define OBJ$M_SYM_UNI 4
#define OBJ$M_SYM_REL 8
#define OBJ$M_SYMV_WEAK 1
#define OBJ$M_SYMV_DEF 2
#define OBJ$M_SYMV_UNI 4
#define OBJ$M_SYMV_REL 8
#define OBJ$M_SYMM_WEAK 1
#define OBJ$M_SYMM_DEF 2
#define OBJ$M_SYMM_UNI 4
#define OBJ$M_SYMM_REL 8
struct sdadefs {
#pragma nostandard
    variant_union  {
        unsigned char obj$b_type;       /* Type of record                   */
        unsigned char obj$b_gsd_type;   /* Type of GSD record               */
        } obj$r_type_overlay;
    variant_union  {
        variant_struct  {
            unsigned char obj$b_psc_ali; /* PSECT alignment (2**n)          */
            variant_union  {
                unsigned short int obj$w_psc_flag; /* PSECT flags:          */
                variant_struct  {
                    unsigned obj$v_psc_pic : 1; /*   Position independent   */
                    unsigned obj$v_psc_lib : 1; /*   Defined from sharable image */
                    unsigned obj$v_psc_ovl : 1; /*   Overlaid psect         */
                    unsigned obj$v_psc_rel : 1; /*   Requires relocation    */
                    unsigned obj$v_psc_gbl : 1; /*   PSECT is global        */
                    unsigned obj$v_psc_shr : 1; /*   Potentially sharable   */
                    unsigned obj$v_psc_exe : 1; /*   Executable             */
                    unsigned obj$v_psc_rd : 1; /*   Can be read             */
                    unsigned obj$v_psc_wrt : 1; /*   Can be written         */
                    unsigned obj$v_fill_2 : 7;
                    } obj$r_fill_1;
                } obj$r_fill_0;
            unsigned long int obj$l_psc_len; /* Length of PSECT             */
            char obj$t_psc_name;        /* PSECT name (counted string)      */
            } obj$r_psect_record;
        variant_struct  {
            unsigned char obj$b_sym_dtype; /* Data type (see Arch. Handbook, Ap. C) */
            variant_union  {
                unsigned short int obj$w_sym_flags; /* Symbol flags:        */
                variant_struct  {
                    unsigned obj$v_sym_weak : 1; /*   Weak resolution (0 = strong) */
                    unsigned obj$v_sym_def : 1; /*   Definition (0 = reference) */
                    unsigned obj$v_sym_uni : 1; /*   Universal definition (0 = local) */
                    unsigned obj$v_sym_rel : 1; /*   Relative symbol (0 = absolute) */
                    unsigned obj$v_fill_5 : 4;
                    } obj$r_fill_4;
                } obj$r_fill_3;
            unsigned char obj$b_sym_psind; /* PSECT index (only if def)     */
            unsigned long int obj$l_sym_value; /* Value of symbol (only if def) */
            char obj$t_sym_name;        /* Symbol name (counted string)     */
            } obj$r_global_sym_record;
        variant_struct  {
            unsigned char obj$b_epm_dtype; /* Data type (see Arch. Handbook, Ap. C) */
            unsigned short int obj$w_epm_flags; /* Flags (same as SYM_FLAGS) */
            unsigned char obj$b_epm_psind; /* PSECT index (only if def)     */
            unsigned long int obj$l_epm_value; /* Value of symbol (only if def) */
            unsigned short int obj$w_epm_mask; /* Entry mask                */
            char obj$t_epm_name;        /* Symbol name (counted string)     */
            } obj$r_entry_point_record;
        variant_struct  {
            unsigned char obj$b_symv_dtype; /* Data type (see Arch. Handbook, Ap. C) */
            variant_union  {
                unsigned short int obj$w_symv_flags; /* Symbol flags:       */
                variant_struct  {
                    unsigned obj$v_symv_weak : 1; /*   Weak resolution (0 = strong) */
                    unsigned obj$v_symv_def : 1; /*   Definition (0 = reference) */
                    unsigned obj$v_symv_uni : 1; /*   Universal definition (0 = local) */
                    unsigned obj$v_symv_rel : 1; /*   Relative symbol (0 = absolute) */
                    unsigned obj$v_fill_8 : 4;
                    } obj$r_fill_7;
                } obj$r_fill_6;
            unsigned char obj$b_symv_psind; /* PSECT index (only if def)    */
            unsigned long int obj$l_symv_value; /* Value of symbol (only if def) */
            unsigned long int obj$l_symv_vector; /* Vectored value of symbol (only if def) */
            char obj$t_symv_name;       /* Symbol name (counted string)     */
            } obj$r_global_symv_record;
        variant_struct  {
            unsigned char obj$b_epmv_dtype; /* Data type (see Arch. Handbook, Ap. C) */
            unsigned short int obj$w_epmv_flags; /* Flags (same as SYM_FLAGS) */
            unsigned char obj$b_epmv_psind; /* PSECT index (only if def)    */
            unsigned long int obj$l_epmv_value; /* Value of symbol (only if def) */
            unsigned long int obj$l_epmv_vector; /* Vectored value of symbol (only if def) */
            unsigned short int obj$w_epmv_mask; /* Entry mask               */
            char obj$t_epmv_name;       /* Symbol name (counted string)     */
            } obj$r_global_epmv_record;
        variant_struct  {
            unsigned char obj$b_symm_dtype; /* Data type (see Arch. Handbook, Ap. C) */
            variant_union  {
                unsigned short int obj$w_symm_flags; /* Symbol flags:       */
                variant_struct  {
                    unsigned obj$v_symm_weak : 1; /*   Weak resolution (0 = strong) */
                    unsigned obj$v_symm_def : 1; /*   Definition (0 = reference) */
                    unsigned obj$v_symm_uni : 1; /*   Universal definition (0 = local) */
                    unsigned obj$v_symm_rel : 1; /*   Relative symbol (0 = absolute) */
                    unsigned obj$v_fill_11 : 4;
                    } obj$r_fill_10;
                } obj$r_fill_9;
            unsigned char obj$b_symm_psind; /* PSECT index (only if def)    */
            unsigned long int obj$l_symm_value; /* Value of symbol (only if def) */
            unsigned long int obj$l_symm_version_mask; /* Version mask of symbol (only if def) */
            char obj$t_symm_name;       /* Symbol name (counted string)     */
            } obj$r_global_symm_record;
        variant_struct  {
            unsigned char obj$b_epmm_dtype; /* Data type (see Arch. Handbook, Ap. C) */
            unsigned short int obj$w_epmm_flags; /* Flags (same as SYM_FLAGS) */
            unsigned char obj$b_epmm_psind; /* PSECT index (only if def)    */
            unsigned long int obj$l_epmm_value; /* Value of symbol (only if def) */
            unsigned long int obj$l_epmm_version_mask; /* Version mask of symbol (only if def) */
            unsigned short int obj$w_epmm_mask; /* Entry mask               */
            char obj$t_epmm_name;       /* Symbol name (counted string)     */
            } obj$r_global_epmm_record;
        variant_struct  {
            unsigned char obj$b_eom_sev; /* Error severity for module       */
            unsigned char obj$b_eom_psind; /* PSECT index of transfer address */
            unsigned long int obj$l_eom_trans; /* Transfer address          */
            } obj$r_eom_record;
        } obj$r_records_overlay;
    } ;
#define OBJ$C_HDR 0                     /*Module header record              */
#define OBJ$C_HDR_MHD 0                 /* Main header record               */
#define OBJ$C_HDR_LNM 1                 /* Language processor record        */
#define OBJ$C_HDR_SRC 2                 /* Source files description         */
#define OBJ$C_HDR_TTL 3                 /* Title text                       */
#define OBJ$C_HDR_CPR 4                 /* Copyright text                   */
#define OBJ$C_HDR_MTC 5                 /* Maintenance text                 */
#define OBJ$C_HDR_GTX 6                 /* General text                     */
#define OBJ$C_GSD 1                     /*Global symbol definition record   */
#define OBJ$C_GSD_PSC 0                 /* P-sect definition                */
#define OBJ$C_GSD_SYM 1                 /* Symbol (simple) definition       */
#define OBJ$C_GSD_EPM 2                 /* Entry point definition           */
#define OBJ$C_GSD_PRO 3                 /* Procedure definition             */
#define OBJ$C_GSD_SYMW 4                /* Symbol definition with word psect  */
#define OBJ$C_GSD_EPMW 5                /* Entry point definition with word psect  */
#define OBJ$C_GSD_PROW 6                /* Procedure definition with word psect  */
#define OBJ$C_GSD_IDC 7                 /* Random entity check              */
#define OBJ$C_GSD_ENV 8                 /* Environment definition           */
#define OBJ$C_GSD_LSY 9                 /* Local symbol definition/reference  */
#define OBJ$C_GSD_LEPM 10               /* Local symbol entry point def.    */
#define OBJ$C_GSD_LPRO 11               /* Local symbol procedure def.      */
#define OBJ$C_GSD_SPSC 12               /* Shareable image psect definition  */
#define OBJ$C_GSD_SYMV 13               /* Global symbol definition (vectored) */
#define OBJ$C_GSD_EPMV 14               /* Entry point definition (vectored) */
#define OBJ$C_GSD_PROV 15               /* Procedure definition (vectored)  */
#define OBJ$C_GSD_SYMM 16               /* Global symbol definition (special double valued) */
#define OBJ$C_GSD_EPMM 17               /* Entry point definition (special double valued) */
#define OBJ$C_GSD_PROM 18               /* Procedure definition (special double valued) */
#define OBJ$C_TIR 2                     /*Text information record           */
#define OBJ$C_EOM 3                     /*End of module record              */
#define OBJ$C_DBG 4                     /*Debugger information record       */
#define OBJ$C_TBT 5                     /*Traceback information record      */
#define OBJ$C_LNK 6                     /*Linker options record             */
#define OBJ$C_EOMW 7                    /*End of module record with word psect  */
#define OBJ$C_MAXRECTYP 7               /*Last assigned record type         */
#define OBJ$K_SUBTYP 1
#define OBJ$C_SUBTYP 1
#define OBJ$C_MAXRECSIZ 2048            /*Maximum legal record size         */
#define OBJ$C_STRLVL 0                  /*Structure level                   */
#define OBJ$C_SYMSIZ 31                 /*Maximum symbol length             */
#define OBJ$C_STOREPLIM -1              /*Maximum repeat count on store commands  */
#define OBJ$C_PSCALILIM 9               /*Maximum p-sect alignment          */
struct objrecdef {
    unsigned char obj$b_rectyp;         /*First byte always record type     */
/*Permissable record types                                                  */
    unsigned char obj$b_subtyp;         /*Record sub-type byte              */
    unsigned char obj$b_mhd_strlv;      /*Structure level                   */
    variant_union  {
        unsigned short int obj$w_mhd_recsz; /*Maximum record size           */
        variant_struct  {
            char objrecdef$$_fill_1 [2];
            char obj$t_mhd_name [];     /*Module name field                 */
/*Misc. constants                                                           */
            } obj$r_mhd_recsz_fields;
        } obj$r_mhd_recsz_overlay;
    } ;
 
#pragma standard

#endif					/* __OBJRECDEF_LOADED */
#ifndef __OPCDEF_LOADED
#define __OPCDEF_LOADED	1

/*** MODULE $opcdef ***/
#define OPC$_RQ_TERME 1                 /* ENABLE TERMINAL                  */
#define OPC$_RQ_LOGI 2                  /* INITIALIZE THE LOG               */
#define OPC$_RQ_RQST 3                  /* OPERATOR REQUEST                 */
#define OPC$_RQ_REPLY 4                 /* OPERATOR REPLY                   */
#define OPC$_RQ_CANCEL 5                /* CANCEL REQUEST                   */
#define OPC$_RQ_STATUS 6                /* REQUEST OPERATOR STATUS          */
#define OPC$_RQ_SECURITY 7              /* MESSAGE TO SECURITY OPERATOR     */
#define OPC$_RQ_LICENSE 8               /* MESSAGE TO LICENSE OPERATOR      */

#define OPC$V_NM_CENTRL	0
#define OPC$V_NM_PRINT	1
#define OPC$V_NM_TAPES	2
#define OPC$V_NM_DISKS	3
#define OPC$V_NM_DEVICE	4
#define OPC$V_NM_CARDS	5
#define OPC$V_NM_NTWORK	6
#define OPC$V_NM_CLUSTER  7
#define OPC$V_NM_SECURITY 8
#define OPC$V_NM_REPLY    9
#define OPC$V_NM_SOFTWARE 10
#define OPC$V_NM_FILL_11  11
#define OPC$V_NM_OPER1	12
#define OPC$V_NM_OPER2	13
#define OPC$V_NM_OPER3	14
#define OPC$V_NM_OPER4	15
#define OPC$V_NM_OPER5	16
#define OPC$V_NM_OPER6	17
#define OPC$V_NM_OPER7	18
#define OPC$V_NM_OPER8	19
#define OPC$V_NM_OPER9	20
#define OPC$V_NM_OPER10	21
#define OPC$V_NM_OPER11	22

#define OPC$M_NM_CENTRL 1
#define OPC$M_NM_PRINT 2
#define OPC$M_NM_TAPES 4
#define OPC$M_NM_DISKS 8
#define OPC$M_NM_DEVICE 16
#define OPC$M_NM_CARDS 32
#define OPC$M_NM_NTWORK 64
#define OPC$M_NM_CLUSTER 128
#define OPC$M_NM_SECURITY 256
#define OPC$M_NM_REPLY 512
#define OPC$M_NM_SOFTWARE 1024
#define OPC$M_NM_LICENSE 2048
#define OPC$M_NM_OPER1 4096
#define OPC$M_NM_OPER2 8192
#define OPC$M_NM_OPER3 16384
#define OPC$M_NM_OPER4 32768
#define OPC$M_NM_OPER5 65536
#define OPC$M_NM_OPER6 131072
#define OPC$M_NM_OPER7 262144
#define OPC$M_NM_OPER8 524288
#define OPC$M_NM_OPER9 1048576
#define OPC$M_NM_OPER10 2097152
#define OPC$M_NM_OPER11 4194304
#define OPC$M_NM_OPER12 8388608

#define OPCOM$_FACILITY 5
#define OPC$_TERMENAB 360449
#define OPC$_LOGINIT 360457
#define OPC$_TERMDSBL 360465
#define OPC$_RQSTABORT 360476
#define OPC$_RQSTPEND 360481
#define OPC$_RQSTCMPLTE 360489
#define OPC$_LOGFAIL 360500
#define OPC$_TERMFAIL 360508
#define OPC$_NOSUCHRQST 360516
#define OPC$_DEVOFFLINE 360524
#define OPC$_DEVONLINE 360532
#define OPC$_NOCLI 360540
#define OPC$_NOPERATOR 360545
#define OPC$_UNKNOPR 360556
#define OPC$_DEVNOTERM 360564
#define OPC$_ILLRQST 360572
#define OPC$_RQSTCAN 360580
#define OPC$_OPRNOTIF 360585
#define OPC$_OPREPLY 360593
#define OPC$_LOGTIME 360601
#define OPC$_LOGCLOS 360612
#define OPC$_USERQST 360619
#define OPC$_USERMSG 360627
#define OPC$_LOGSTS 360635
#define OPC$_OPERSTS 360643
#define OPC$_RQSTSTST 360651
#define OPC$_SHUTDOWN 360659
#define OPC$_SYSTEMOPER 360667
#define OPC$_GROUPOPER 360675
#define OPC$_USEROPER 360683
#define OPC$_NOTENABLED 360691
/*                                                                          */
/* THE FOLLOWING MESSAGES GIVE THE ASCII TEXT FOR THE OPERATOR TYPES.  IT IS */
/* POSSIBLE TO CHANGE THE MESSAGE TEXT TO ANYTHING DESIRED.  FOR EXAMPLE, AN */
/* INSTALLATION MIGHT WANT TO CALL OPER12 BY ANOTHER NAME, SAY FRONT_DESK.  */
/* THAT INSTALLATION WOULD CHANGE THE LINE WITH OPER12 TO READ:             */
/*                                                                          */
/*			OPER12	<FRONT_DESK>                                */
/*                                                                          */
/* AFTERWARDS, USERS ON THAT SYSTEM COULD REPLY /ENABLE=FRONT_DESK, REQUEST /TO=FRONT, */
/* A FRONT_DESK OPERATOR COULD DO A REPLY /STAT AND SEE THAT FRONT_DESK WAS ENABLED. */
/* OF COURSE, A PROGRAMMER ON THAT SYSTEM WOULD USE THE SYMBOL OPC$_OPER12 TO SEND */
/* A MESSAGE TO THE FRONT_DESK, SINCE THE MESSAGE NAME CAN NOT BE CHANGED.  */
/*                                                                          */
#define OPC$_CENTRL 360699
#define OPC$_PRINT 360707
#define OPC$_TAPES 360715
#define OPC$_DISKS 360723
#define OPC$_DEVICE 360731
#define OPC$_CARDS 360739
#define OPC$_NTWORK 360747
#define OPC$_CLUSTER 360755
#define OPC$_SECURITY 360763
#define OPC$_REPLY 360771
#define OPC$_SOFTWARE 360779
#define OPC$_LICENSE 360787
#define OPC$_OPER1 360795
#define OPC$_OPER2 360803
#define OPC$_OPER3 360811
#define OPC$_OPER4 360819
#define OPC$_OPER5 360827
#define OPC$_OPER6 360835
#define OPC$_OPER7 360843
#define OPC$_OPER8 360851
#define OPC$_OPER9 360859
#define OPC$_OPER10 360867
#define OPC$_OPER11 360875
#define OPC$_OPER12 360883
/*                                                                          */
#define OPC$_DEVOFFLINX 360891
#define OPC$_WRONGVOL 360899
#define OPC$_DEVWRTLCK 360907
/*                                                                          */
#define OPC$_INITAPE 360915
#define OPC$_RQSTDONE 360923
#define OPC$_BLANKTAPE 360931
/*                                                                          */
#define OPC$_MVCOMPLETE 360939
#define OPC$_MVABORTED 360947
#define OPC$_CTLRUCODE 360955
#define OPC$_DUPUNITNO 360963
#define OPC$_SECUR_ALARM 360971
#define OPC$_COUNTERFEIT 360979
#define OPC$_NODE_ACTIVE 360987
#define OPC$_NODE_DELETE 360995
#define OPC$_NODE_DEPARTED 361003
#define OPC$_NODE_INIT 361011
#define OPC$_NODE_RETRY 361019
#define OPC$_NODE_START 361027
#define OPC$_UNKNOWN 361035
#define OPC$_CLUSCOMM 361043
#define OPC$_VALUERR 361052
#define OPC$_NOTRQCB 361060
#define OPC$_REPLY_GENERAL 361067
#define OPC$_REPLY_SHUTDOWN 361075
#define OPC$_REPLY_URGENT 361083
#define OPC$_REPLY_NOTALL 361091
#define OPC$_REPLY_NOTALLN 361099
#define OPC$_REPLY_NOTDEV 361107
#define OPC$_REPLY_NOTUSE 361115
#define OPC$_REPLY_NOTUSEN 361123
#define OPC$_ON_NODE 361131             /* PREPOSITION FOR "on nodename"  ("on ATHENS") MESSAGES */
#define OPC$_HEADER 361139
#define OPC$_RQST_PROMPT 361147
#define OPC$_NOLCLBROAD 361152
#define OPC$_NOREMBROAD 361160
#define OPC$_NOREMWAIT 361168
/*                                                                          */
/* CLUSTER MAILBOX MESSAGES                                                 */
/*   FAO PARAMETER LIST IS:                                                 */
/*                                                                          */
/*	TIMESTAMP - POINTER TO QUADWORD TIME                                */
/*	LSYSNAML  - LENGTH OF NAME OF LOCAL SYSTEM                          */
/*	LSYSNAMA  - ADDRESS OF NAME OF LOCAL SYSTEM                         */
/*	LSYSIDW   - HIGH ORDER WORD OF LOCAL SYSTEM ID                      */
/*	LSYSIDL   - LOW ORDER LONGWORD OF LOCAL SYSTEM ID                   */
/*	LCSID     - LOCAL SYSTEM CSID                                       */
/*	RSYSNAML  - LENGTH OF NAME OF REMOTE SYSTEM                         */
/*	RSYSNAMA  - ADDRESS OF NAME OF REMOTE SYSTEM                        */
/*	RSYSIDW   - HIGH ORDER WORD OF REMOTE SYSTEM ID                     */
/*	RSYSIDL   - LOW ORDER LONGWORD OF REMOTE SYSTEM ID                  */
/*	RCSID     - REMOTE SYSTEM CSID                                      */
/*                                                                          */
/* MESSAGES USE THE "!+" DIRECTIVE TO SKIP OVER ITEMS WHICH                 */
/* ARE NOT MEANINGFUL OR USEFUL FOR A PARTICULAR MESSAGE.                   */
/*                                                                          */
#define OPC$_CLU_NEWSYS 361179
#define OPC$_CLU_CNX 361187
#define OPC$_CLU_RECNX 361195
#define OPC$_CLU_LOSTCNX 361203
#define OPC$_CLU_TIMCNX 361211
#define OPC$_CLU_INIFORM 361219
#define OPC$_CLU_INIADD 361227
#define OPC$_CLU_INIRECNFIG 361235
#define OPC$_CLU_MEMREQ 361243
#define OPC$_CLU_ABORT 361251
#define OPC$_CLU_ADD 361259
#define OPC$_CLU_DROPNODE 361267
#define OPC$_CLU_FORNCLUS 361275
#define OPC$_CLU_INQUORUM 361283
#define OPC$_CLU_LOSTDISK 361291
#define OPC$_CLU_GAINDISK 361299
#define OPC$_CLU_DISKRDERR 361307
#define OPC$_CLU_DISKWRERR 361315
#define OPC$_CLU_DISKINVDAT 361323
#define OPC$_CLU_DISKTIMEOUT 361331
#define OPC$_CLU_LOSTMSG 361339
#define OPC$_CLU_NOQUORUM 361347
#define OPC$_CLU_FORNDISK 361355
#define OPC$_CLU_COMPLETE 361363
#define OPC$_CLU_QUORUM 361371
#define OPC$_CLU_ECNX 361379
#define OPC$_CLU_HAVEDISK 361387
#define OPC$_CLU_REMOTE 361395
#define OPC$_CLU_LOCAL 361403
#define OPC$_CLU_WTCHTIMEOUT 361411
#define OPC$_CLU_NOTRUST 361419         /*                                  */
/* FOLLOWING ARE DEVICE MESSAGE FOR SHADOWING.                              */
/*                                                                          */
#define OPC$_SHACHASTA 361427
#define OPC$_SHAMEMFAL 361435
#define OPC$_SHARDUCED 361443
#define OPC$_SHACOPCOM 361451
#define OPC$_SHACOPBEG 361459
#define OPC$_SHAALLCOM 361467
#define OPC$_SHAWROMEM 361475
#define OPC$_SHAREDZER 361483
#define OPC$_SHAPOSMEM 361491
#define OPC$_SHAORGMEM 361499

struct OPC {
    unsigned char opc$b_ms_type;        /* MESSAGE TYPE                     */
#pragma nostandard
    variant_union  {
        unsigned char opc$b_ms_target;  /* MESSAGE TARGET                   */
        unsigned char opc$b_ms_enab;    /* MESSAGE ENABLES                  */
        } opc$r_ms_target_overlay;
    unsigned short int opc$w_ms_status; /* MESSAGE STATUS                   */
    variant_union  {
        unsigned long int opc$l_ms_rplyid; /* REPLY ID                      */
        variant_union  {
            unsigned long int opc$l_ms_mask; /* MESSAGE MASK                */
            unsigned long int opc$l_ms_rqstid; /* REQUEST ID                */
            } opc$r_ms_mask_overlay;
        } opc$r_ms_rplyid_overlay;
    variant_union  {
        unsigned long int opc$l_ms_text; /* MESSAGE TEXT                    */
        variant_struct  {
            unsigned short int opc$w_ms_ounit; /* OPERATOR UNIT NUMBER      */
            char opc$t_ms_oname;        /* OPERATOR NAME                    */
            } opc$r_ms_text_fields;
        } opc$r_ms_text_overlay;
    short int opcdef$$_fill_1 [7];      /* SPACE FOR NAME                   */
    unsigned long int opc$l_ms_otext [32]; /* OPERATOR TEXT                 */
    variant_union  {
        unsigned long int opc$l_ms_maxsz; /* MESSAGE MAX SIZE               */
/* OPERATOR MESSAGE TYPES                                                   */
        variant_struct  {
            unsigned opc$v_nm_centrl : 1; /*                                */
            unsigned opc$v_nm_print : 1;
            unsigned opc$v_nm_tapes : 1;
            unsigned opc$v_nm_disks : 1;
            unsigned opc$v_nm_device : 1;
            unsigned opc$v_nm_cards : 1;
            unsigned opc$v_nm_ntwork : 1;
            unsigned opc$v_nm_cluster : 1;
            unsigned opc$v_nm_security : 1;
            unsigned opc$v_nm_reply : 1;
            unsigned opc$v_nm_software : 1;
            unsigned opc$v_nm_license : 1;
            unsigned opc$v_nm_oper1 : 1;
            unsigned opc$v_nm_oper2 : 1;
            unsigned opc$v_nm_oper3 : 1;
            unsigned opc$v_nm_oper4 : 1;
            unsigned opc$v_nm_oper5 : 1;
            unsigned opc$v_nm_oper6 : 1;
            unsigned opc$v_nm_oper7 : 1;
            unsigned opc$v_nm_oper8 : 1;
            unsigned opc$v_nm_oper9 : 1;
            unsigned opc$v_nm_oper10 : 1;
            unsigned opc$v_nm_oper11 : 1;
            unsigned opc$v_nm_oper12 : 1;
            } opc$r_ms_maxsz_bits;
        } opc$r_ms_maxsz_overlay;
    } ;
#pragma standard

#endif					/* __OPCDEF_LOADED */
#ifndef __OPDEF_LOADED
#define __OPDEF_LOADED	1

/*** MODULE $opdef ***/
#define OP$_HALT 0
#define OP$_NOP 1
#define OP$_REI 2
#define OP$_BPT 3
#define OP$_RET 4
#define OP$_RSB 5
#define OP$_LDPCTX 6
#define OP$_SVPCTX 7
#define OP$_CVTPS 8
#define OP$_CVTSP 9
#define OP$_INDEX 10
#define OP$_CRC 11
#define OP$_PROBER 12
#define OP$_PROBEW 13
#define OP$_INSQUE 14
#define OP$_REMQUE 15
#define OP$_BSBB 16
#define OP$_BSB 16
#define OP$_BRB 17
#define OP$_BNEQ 18
#define OP$_BNEQU 18
#define OP$_BEQL 19
#define OP$_BEQLU 19
#define OP$_BGTR 20
#define OP$_BLEQ 21
#define OP$_JSB 22
#define OP$_JMP 23
#define OP$_BGEQ 24
#define OP$_BLSS 25
#define OP$_BGTRU 26
#define OP$_BLEQU 27
#define OP$_BVC 28
#define OP$_BVS 29
#define OP$_BGEQU 30
#define OP$_BCC 30
#define OP$_BLSSU 31
#define OP$_BCS 31
#define OP$_ADDP4 32
#define OP$_ADDP 32
#define OP$_ADDP6 33
#define OP$_SUBP4 34
#define OP$_SUBP 34
#define OP$_SUBP6 35
#define OP$_CVTPT 36
#define OP$_MULP 37
#define OP$_CVTTP 38
#define OP$_DIVP 39
#define OP$_MOVC3 40
#define OP$_MOVC 40
#define OP$_CMPC3 41
#define OP$_CMPC 41
#define OP$_SCANC 42
#define OP$_SPANC 43
#define OP$_MOVC5 44
#define OP$_CMPC5 45
#define OP$_MOVTC 46
#define OP$_MOVTUC 47
#define OP$_BSBW 48
#define OP$_BRW 49
/*                BR,^X31                                                 */
#define OP$_CVTWL 50
#define OP$_CVTWB 51
#define OP$_MOVP 52
#define OP$_CMPP3 53
#define OP$_CMPP 53
#define OP$_CVTPL 54
#define OP$_CMPP4 55
#define OP$_EDITPC 56
#define OP$_MATCHC 57
#define OP$_LOCC 58
#define OP$_SKPC 59
#define OP$_MOVZWL 60
#define OP$_ACBW 61
#define OP$_MOVAW 62
#define OP$_PUSHAW 63
#define OP$_ADDF2 64
#define OP$_ADDF 64
#define OP$_ADDF3 65
#define OP$_SUBF2 66
#define OP$_SUBF 66
#define OP$_SUBF3 67
#define OP$_MULF2 68
#define OP$_MULF 68
#define OP$_MULF3 69
#define OP$_DIVF2 70
#define OP$_DIVF 70
#define OP$_DIVF3 71
#define OP$_CVTFB 72
#define OP$_CVTFW 73
#define OP$_CVTFL 74
#define OP$_CVTRFL 75
#define OP$_CVTBF 76
#define OP$_CVTWF 77
#define OP$_CVTLF 78
#define OP$_ACBF 79
#define OP$_MOVF 80
#define OP$_CMPF 81
#define OP$_MNEGF 82
#define OP$_TSTF 83
#define OP$_EMODF 84
#define OP$_POLYF 85
#define OP$_CVTFD 86
/*        RESERVED 57                                                       */
#define OP$_ADAWI 88
/*        RESERVED 59                                                       */
/*        RESERVED 5A                                                       */
/*        RESERVED 5B                                                       */
#define OP$_INSQHI 92
#define OP$_INSQTI 93
#define OP$_REMQHI 94
#define OP$_REMQTI 95
#define OP$_ADDD2 96
#define OP$_ADDD 96
#define OP$_ADDD3 97
#define OP$_SUBD2 98
#define OP$_SUBD 98
#define OP$_SUBD3 99
#define OP$_MULD2 100
#define OP$_MULD 100
#define OP$_MULD3 101
#define OP$_DIVD2 102
#define OP$_DIVD 102
#define OP$_DIVD3 103
#define OP$_CVTDB 104
#define OP$_CVTDW 105
#define OP$_CVTDL 106
#define OP$_CVTRDL 107
#define OP$_CVTBD 108
#define OP$_CVTWD 109
#define OP$_CVTLD 110
#define OP$_ACBD 111
#define OP$_MOVD 112
#define OP$_CMPD 113
#define OP$_MNEGD 114
#define OP$_TSTD 115
#define OP$_EMODD 116
#define OP$_POLYD 117
#define OP$_CVTDF 118
/*        RESERVED 77                                                       */
#define OP$_ASHL 120
#define OP$_ASHQ 121
#define OP$_EMUL 122
#define OP$_EDIV 123
#define OP$_CLRQ 124
#define OP$_CLRD 124
#define OP$_CLRG 124
#define OP$_MOVQ 125
#define OP$_MOVAQ 126
#define OP$_MOVAD 126
#define OP$_MOVAG 126
#define OP$_PUSHAQ 127
#define OP$_PUSHAD 127
#define OP$_PUSHAG 127
#define OP$_ADDB2 128
#define OP$_ADDB 128
#define OP$_ADDB3 129
#define OP$_SUBB2 130
#define OP$_SUBB 130
#define OP$_SUBB3 131
#define OP$_MULB2 132
#define OP$_MULB 132
#define OP$_MULB3 133
#define OP$_DIVB2 134
#define OP$_DIVB 134
#define OP$_DIVB3 135
#define OP$_BISB2 136
#define OP$_BISB 136
#define OP$_BISB3 137
#define OP$_BICB2 138
#define OP$_BICB 138
#define OP$_BICB3 139
#define OP$_XORB2 140
#define OP$_XORB 140
#define OP$_XORB3 141
#define OP$_MNEGB 142
#define OP$_CASEB 143
#define OP$_MOVB 144
#define OP$_CMPB 145
#define OP$_MCOMB 146
#define OP$_BITB 147
#define OP$_CLRB 148
#define OP$_TSTB 149
#define OP$_INCB 150
#define OP$_DECB 151
#define OP$_CVTBL 152
#define OP$_CVTBW 153
#define OP$_MOVZBL 154
#define OP$_MOVZBW 155
#define OP$_ROTL 156
#define OP$_ACBB 157
#define OP$_MOVAB 158
#define OP$_PUSHAB 159
#define OP$_ADDW2 160
#define OP$_ADDW 160
#define OP$_ADDW3 161
#define OP$_SUBW2 162
#define OP$_SUBW 162
#define OP$_SUBW3 163
#define OP$_MULW2 164
#define OP$_MULW 164
#define OP$_MULW3 165
#define OP$_DIVW2 166
#define OP$_DIVW 166
#define OP$_DIVW3 167
#define OP$_BISW2 168
#define OP$_BISW 168
#define OP$_BISW3 169
#define OP$_BICW2 170
#define OP$_BICW 170
#define OP$_BICW3 171
#define OP$_XORW2 172
#define OP$_XORW 172
#define OP$_XORW3 173
#define OP$_MNEGW 174
#define OP$_CASEW 175
#define OP$_MOVW 176
#define OP$_CMPW 177
#define OP$_MCOMW 178
#define OP$_BITW 179
#define OP$_CLRW 180
#define OP$_TSTW 181
#define OP$_INCW 182
#define OP$_DECW 183
#define OP$_BISPSW 184
#define OP$_BICPSW 185
#define OP$_POPR 186
#define OP$_PUSHR 187
#define OP$_CHMK 188
#define OP$_CHME 189
#define OP$_CHMS 190
#define OP$_CHMU 191
#define OP$_ADDL2 192
#define OP$_ADDL 192
#define OP$_ADDL3 193
#define OP$_SUBL2 194
#define OP$_SUBL 194
#define OP$_SUBL3 195
#define OP$_MULL2 196
#define OP$_MULL 196
#define OP$_MULL3 197
#define OP$_DIVL2 198
#define OP$_DIVL 198
#define OP$_DIVL3 199
#define OP$_BISL2 200
#define OP$_BISL 200
#define OP$_BISL3 201
#define OP$_BICL2 202
#define OP$_BICL 202
#define OP$_BICL3 203
#define OP$_XORL2 204
#define OP$_XORL 204
#define OP$_XORL3 205
#define OP$_MNEGL 206
#define OP$_CASEL 207
#define OP$_MOVL 208
#define OP$_CMPL 209
#define OP$_MCOML 210
#define OP$_BITL 211
#define OP$_CLRL 212
#define OP$_CLRF 212
#define OP$_TSTL 213
#define OP$_INCL 214
#define OP$_DECL 215
#define OP$_ADWC 216
#define OP$_SBWC 217
#define OP$_MTPR 218
#define OP$_MFPR 219
#define OP$_MOVPSL 220
#define OP$_PUSHL 221
#define OP$_POPL 36560
#define OP$_MOVAL 222
#define OP$_MOVAF 222
#define OP$_PUSHAL 223
#define OP$_PUSHAF 223
#define OP$_BBS 224
#define OP$_BBC 225
#define OP$_BBSS 226
#define OP$_BBCS 227
#define OP$_BBSC 228
#define OP$_BBCC 229
#define OP$_BBSSI 230
#define OP$_BBCCI 231
#define OP$_BLBS 232
#define OP$_BLBC 233
#define OP$_FFS 234
#define OP$_FFC 235
#define OP$_CMPV 236
#define OP$_CMPZV 237
#define OP$_EXTV 238
#define OP$_EXTZV 239
#define OP$_INSV 240
#define OP$_ACBL 241
#define OP$_AOBLSS 242
#define OP$_AOBLEQ 243
#define OP$_SOBGEQ 244
#define OP$_SOBGTR 245
#define OP$_CVTLB 246
#define OP$_CVTLW 247
#define OP$_ASHP 248
#define OP$_CVTLP 249
#define OP$_CALLG 250
#define OP$_CALLS 251
#define OP$_XFC 252
#define OP$_ESCD 253
#define OP$_ESCE 254
#define OP$_ESCF 255
#define OP$_BUGW 65279
#define OP$_BUGL 65023
#define OP$_CVTDH 13053
#define OP$_CVTGF 13309
#define OP$_ADDG2 16637
#define OP$_ADDG3 16893
#define OP$_SUBG2 17149
#define OP$_SUBG3 17405
#define OP$_MULG2 17661
#define OP$_MULG3 17917
#define OP$_DIVG2 18173
#define OP$_DIVG3 18429
#define OP$_ADDH2 24829
#define OP$_ADDH3 25085
#define OP$_SUBH2 25341
#define OP$_SUBH3 25597
#define OP$_MULH2 25853
#define OP$_MULH3 26109
#define OP$_DIVH2 26365
#define OP$_DIVH3 26621
#define OP$_CVTGB 18685
#define OP$_CVTGW 18941
#define OP$_CVTGL 19197
#define OP$_CVTRGL 19453
#define OP$_CVTBG 19709
#define OP$_CVTWG 19965
#define OP$_CVTLG 20221
#define OP$_ACBG 20477
#define OP$_CVTHB 26877
#define OP$_CVTHW 27133
#define OP$_CVTHL 27389
#define OP$_CVTRHL 27645
#define OP$_CVTBH 27901
#define OP$_CVTWH 28157
#define OP$_CVTLH 28413
#define OP$_ACBH 28669
#define OP$_MOVG 20733
#define OP$_CMPG 20989
#define OP$_MNEGG 21245
#define OP$_TSTG 21501
#define OP$_EMODG 21757
#define OP$_POLYG 22013
#define OP$_CVTGH 22269
#define OP$_MOVH 28925
#define OP$_CMPH 29181
#define OP$_MNEGH 29437
#define OP$_TSTH 29693
#define OP$_EMODH 29949
#define OP$_POLYH 30205
#define OP$_CVTHG 30461
/*                CLRG,^X7C                                                 */
#define OP$_CLRH 31997
#define OP$_CLRO 31997
#define OP$_MOVO 32253
#define OP$_MOVAH 32509
#define OP$_MOVAO 32509
#define OP$_PUSHAH 32765
#define OP$_PUSHAO 32765
#define OP$_CVTFH 39165
#define OP$_CVTFG 39421
#define OP$_CVTHF 63229
#define OP$_CVTHD 63485

#endif					/* __OPDEF_LOADED */
#ifndef __OPRDEF_LOADED
#define __OPRDEF_LOADED	1

/*** MODULE $oprdef ***/
/*+                                                                         */
/* OPERATOR COMMUNICATIONS MESSAGE TYPES AND VALUES                         */
/*-                                                                         */
/* OPERATOR MESSAGE TYPES                                                   */
#define OPR$_TERMENABL 1                /* ENABLE TERMINAL                  */
#define OPR$_LOGINIT 2                  /* INITIALIZE THE LOG               */
#define OPR$_OPRQST 3                   /* OPERATOR REQUEST                 */
#define OPR$_OPREPLY 4                  /* OPERATOR REPLY                   */
#define OPR$M_CENTRAL 1
#define OPR$M_PRINTER 2
#define OPR$M_TAPES 4
#define OPR$M_DISKS 8
#define OPR$M_DEVICES 16
#define OPR$M_USER1 131040
#define OPR$M_USER2 131072
#define OPR$M_USER3 262144
#define OPR$M_USER4 524288
#define OPR$M_USER5 1048576
#define OPR$M_USER6 2097152
#define OPR$M_USER7 4194304
#define OPR$M_USER8 8388608
#define OPR$M_USER9 16777216
#define OPR$M_USER10 33554432
#define OPR$M_USER11 67108864
#define OPR$M_USER12 134217728
union oprdef {
#pragma nostandard
    variant_struct  {
        unsigned opr$v_central : 1;     /*                                  */
        unsigned opr$v_printer : 1;
        unsigned opr$v_tapes : 1;
        unsigned opr$v_disks : 1;
        unsigned opr$v_devices : 1;
        unsigned opr$v_user1 : 12;
        unsigned opr$v_user2 : 1;
        unsigned opr$v_user3 : 1;
        unsigned opr$v_user4 : 1;
        unsigned opr$v_user5 : 1;
        unsigned opr$v_user6 : 1;
        unsigned opr$v_user7 : 1;
        unsigned opr$v_user8 : 1;
        unsigned opr$v_user9 : 1;
        unsigned opr$v_user10 : 1;
        unsigned opr$v_user11 : 1;
        unsigned opr$v_user12 : 1;
        unsigned opr$v_fill_10 : 4;
        } opr$r_oprdef_bits;
    } ;
 
#pragma standard

#endif					/* __OPRDEF_LOADED */
#ifndef __OTS$ROUTINES_LOADED
#define __OTS$ROUTINES_LOADED	1

/*** MODULE ots$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    OTS$CVT_T_D                                                           */
/*                                                                          */
/*    Convert Numeric Text to D- or F-Floating Value                        */
/*                                                                          */
/*    The Convert Numeric Text to D- or F-Floating routines                 */
/*    convert an ASCII text string representation of a                      */
/*    numeric value to a D_floating or F_floating value.                    */
/*                                                                          */
unsigned long int ots$cvt_t_d() ;
/*    OTS$CVT_T_F                                                           */
/*                                                                          */
/*    Convert Numeric Text to D- or F-Floating Value                        */
/*                                                                          */
/*    The Convert Numeric Text to D- or F-Floating routines                 */
/*    convert an ASCII text string representation of a                      */
/*    numeric value to a D_floating or F_floating value.                    */
/*                                                                          */
unsigned long int ots$cvt_t_f() ;
/*    OTS$CVT_T_G                                                           */
/*                                                                          */
/*    Convert Numeric Text to G- or H-Floating Value                        */
/*                                                                          */
/*    The Convert Numeric Text to G- or H-Floating routines                 */
/*    convert an ASCII text string representation of a                      */
/*    numeric value to a G_floating or H_floating value.                    */
/*                                                                          */
unsigned long int ots$cvt_t_g() ;
/*    OTS$CVT_T_H                                                           */
/*                                                                          */
/*    Convert Numeric Text to G- or H-Floating Value                        */
/*                                                                          */
/*    The Convert Numeric Text to G- or H-Floating routines                 */
/*    convert an ASCII text string representation of a                      */
/*    numeric value to a G_floating or H_floating value.                    */
/*                                                                          */
unsigned long int ots$cvt_t_h() ;
/*    OTS$DIVC                                                              */
/*                                                                          */
/*    Complex Division                                                      */
/*                                                                          */
/*    The Complex Division routines                                         */
/*    return a complex result of a division on complex                      */
/*    numbers.                                                              */
/*                                                                          */
/*ENTRY ots$divc ALIAS $ots_divc PARAMETER (                                */
/*    F_FLOATING COMPLEX NAMED complex_dividend IN                          */
/*        TYPENAME f_floating_complex VALUE,                                */
/*    F_FLOATING COMPLEX NAMED complex_divisor IN                           */
/*        TYPENAME f_floating_complex VALUE )                               */
/*  RETURNS F_FLOATING COMPLEX NAMED RESULT TYPENAME f_floating_complex;    */
/*    OTS$DIVCD_R3                                                          */
/*                                                                          */
/*    Complex Division                                                      */
/*                                                                          */
/*    The Complex Division routines                                         */
/*    return a complex result of a division on complex                      */
/*    numbers.                                                              */
/*                                                                          */
/*ENTRY ots$divcd_r3 ALIAS $ots_divcd_r3 PARAMETER (                        */
/*    D_FLOATING COMPLEX NAMED complex_dividend IN                          */
/*        TYPENAME d_floating_complex VALUE,                                */
/*    D_FLOATING COMPLEX NAMED complex_divisor IN                           */
/*        TYPENAME d_floating_complex VALUE )                               */
/*  RETURNS D_FLOATING COMPLEX NAMED RESULT TYPENAME d_floating_complex;    */
/*    OTS$DIVCG_R3                                                          */
/*                                                                          */
/*    Complex Division                                                      */
/*                                                                          */
/*    The Complex Division routines                                         */
/*    return a complex result of a division on complex                      */
/*    numbers.                                                              */
/*                                                                          */
/*ENTRY ots$divcg_r3 ALIAS $ots_divcg_r3 PARAMETER (                        */
/*    G_FLOATING COMPLEX NAMED complex_dividend IN                          */
/*        TYPENAME g_floating_complex VALUE,                                */
/*    G_FLOATING COMPLEX NAMED complex_divisor IN                           */
/*        TYPENAME g_floatin_complex VALUE )                                */
/*  RETURNS G_FLOATING COMPLEX NAMED RESULT TYPENAME g_floating_complex;    */
/*    OTS$DIV_PK_LONG                                                       */
/*                                                                          */
/*    Packed Decimal Division with Long Divisor                             */
/*                                                                          */
/*    The Packed Decimal Division with Long Divisor routine                 */
/*    divides fixed-point decimal data, which is stored in packed           */
/*    decimal form, when precision and scale requirements for the quotient call  */
/*    for multiple precision division. The divisor must have a precision of */
/*    thirty or thirty-one digits.                                          */
/*                                                                          */
int ots$div_pk_long() ;
/*    OTS$DIV_PK_SHORT                                                      */
/*                                                                          */
/*    Packed Decimal Division with Short Divisor                            */
/*                                                                          */
/*    The Packed Decimal Division with Short Divisor routine                */
/*    divides fixed-point decimal data                                      */
/*    when precision and scale requirements for the quotient call for       */
/*    multiple-precision division.                                          */
/*                                                                          */
int ots$div_pk_short() ;
/*    OTS$MOVE3                                                             */
/*                                                                          */
/*    Move Data Without Fill                                                */
/*                                                                          */
/*    The Move Data Without Fill routine                                    */
/*    moves up to 231-1 bytes, (2,147,483,647 bytes) from a                 */
/*    specified source address to a specified destination address.          */
/*                                                                          */
int ots$move3() ;
/*    OTS$MOVE5                                                             */
/*                                                                          */
/*    Move Data with Fill                                                   */
/*                                                                          */
/*    The Move Data with Fill routine                                       */
/*    moves up to 231-1 bytes, (2,147,483,647 bytes) from a                 */
/*    specified source address to a specified destination address,          */
/*    with separate source and destination lengths,                         */
/*    and with fill.  Overlap of the source and destination arrays          */
/*    does not affect the result.                                           */
/*                                                                          */
int ots$move5() ;
/*    OTS$MULCD_R3                                                          */
/*                                                                          */
/*    Complex Multiplication                                                */
/*                                                                          */
/*    The Complex Multiplication routines                                   */
/*    calculate the complex product of two complex                          */
/*    values.                                                               */
/*                                                                          */
/*ENTRY ots$mulcd_r3 ALIAS $ots_mulcd_r3 PARAMETER (                        */
/*    D_FLOATING COMPLEX NAMED complex_multiplier IN                        */
/*        TYPENAME d_floating_complex VALUE,                                */
/*    D_FLOATING COMPLEX NAMED complex_multiplicand IN                      */
/*        TYPENAME d_floating_complex VALUE )                               */
/*  RETURNS D_FLOATING COMPLEX NAMED RESULT TYPENAME d_floating_complex;    */
/*    OTS$MULCG_R3                                                          */
/*                                                                          */
/*    Complex Multiplication                                                */
/*                                                                          */
/*    The Complex Multiplication routines                                   */
/*    calculate the complex product of two complex                          */
/*    values.                                                               */
/*                                                                          */
/*ENTRY ots$mulcg_r3 ALIAS $ots_mulcg_r3 PARAMETER (                        */
/*    G_FLOATING COMPLEX NAMED complex_multiplier IN                        */
/*        TYPENAME g_floating_complex VALUE,                                */
/*    G_FLOATING COMPLEX NAMED complex_multiplicand IN                      */
/*        TYPENAME g_floating_complex VALUE )                               */
/*  RETURNS G_FLOATING COMPLEX NAMED RESULT TYPENAME g_floating_complex;    */
/*    OTS$CNVOUT                                                            */
/*                                                                          */
/*    Convert D_floating, G_floating or H_floating Number to Character String */
/*                                                                          */
/*    The Convert Floating to Character String routines convert             */
/*    a D_floating, G_floating or H_floating number                         */
/*    to a character string in                                              */
/*    the FORTRAN E format.                                                 */
/*                                                                          */
unsigned long int ots$cnvout() ;
/*    OTS$CNVOUT_G                                                          */
/*                                                                          */
/*    Convert D_floating, G_floating or H_floating Number to Character String */
/*                                                                          */
/*    The Convert Floating to Character String routines convert             */
/*    a D_floating, G_floating or H_floating number                         */
/*    to a character string in                                              */
/*    the FORTRAN E format.                                                 */
/*                                                                          */
unsigned long int ots$cnvout_g() ;
/*    OTS$CNVOUT_H                                                          */
/*                                                                          */
/*    Convert D_floating, G_floating or H_floating Number to Character String */
/*                                                                          */
/*    The Convert Floating to Character String routines convert             */
/*    a D_floating, G_floating or H_floating number                         */
/*    to a character string in                                              */
/*    the FORTRAN E format.                                                 */
/*                                                                          */
unsigned long int ots$cnvout_h() ;
/*    OTS$POWCC                                                             */
/*                                                                          */
/*    Raise a Complex Base to a Complex Floating-Point Exponent             */
/*                                                                          */
/*    The Raise a Complex Base to a Complex Floating-Point Exponent routines */
/*    return the result of raising                                          */
/*    a complex base to a complex exponent.                                 */
/*                                                                          */
/*ENTRY ots$powcc ALIAS $ots_powcc PARAMETER (                              */
/*    F_FLOATING COMPLEX NAMED complex_base IN                              */
/*        TYPENAME f_floating_complex VALUE,                                */
/*    F_FLOATING COMPLEX NAMED complex_exponent_value IN                    */
/*        TYPENAME f_floating_complex VALUE )                               */
/*  RETURNS F_FLOATING COMPLEX NAMED RESULT TYPENAME f_floating_complex;    */
/*    OTS$POWCDCD_R3                                                        */
/*                                                                          */
/*    Raise a Complex Base to a Complex Floating-Point Exponent             */
/*                                                                          */
/*    The Raise a Complex Base to a Complex Floating-Point Exponent routines */
/*    raise                                                                 */
/*    a complex base to a complex exponent.                                 */
/*                                                                          */
/*ENTRY ots$powcdcd_r3 ALIAS $ots_powcdcd_r3 PARAMETER (                    */
/*    D_FLOATING COMPLEX NAMED complex_base IN                              */
/*        TYPENAME d_floating_complex VALUE,                                */
/*    D_FLOATING COMPLEX NAMED complex_exponent_value IN                    */
/*        TYPENAME d_floating_complex VALUE )                               */
/*  RETURNS D_FLOATING COMPLEX NAMED RESULT TYPENAME d_floating_complex;    */
/*    OTS$POWCGCG_R3                                                        */
/*                                                                          */
/*    Raise a Complex Base to a Complex Floating-Point Exponent             */
/*                                                                          */
/*    The Raise a Complex Base to a Complex Floating-Point Exponent routines */
/*    raise                                                                 */
/*    a complex base to a complex exponent.                                 */
/*                                                                          */
/*ENTRY ots$powcgcg_r3 ALIAS $ots_powcgcg_r3 PARAMETER (                    */
/*    G_FLOATING COMPLEX NAMED complex_base IN                              */
/*        TYPENAME g_floating_complex VALUE,                                */
/*    G_FLOATING COMPLEX NAMED complex_exponent_value IN                    */
/*        TYPENAME g_floating_complex VALUE )                               */
/*  RETURNS G_FLOATING COMPLEX NAMED RESULT TYPENAME g_floating_complex;    */
/*    OTS$POWCJ                                                             */
/*                                                                          */
/*    Raise a Complex Base to a Signed Longword Integer Exponent            */
/*                                                                          */
/*    The Raise a Complex Base to a Signed Longword Integer Exponent        */
/*    routines return the complex result of raising a complex base to an    */
/*    integer exponent.                                                     */
/*                                                                          */
/*ENTRY ots$powcj ALIAS $ots_powcj PARAMETER (                              */
/*    F_FLOATING COMPLEX NAMED complex_base IN                              */
/*        TYPENAME f_floating_complex VALUE,                                */
/*    LONGWORD NAMED longword_integer_exponent IN                           */
/*        TYPENAME longword_signed VALUE )                                  */
/*  RETURNS F_FLOATING COMPLEX NAMED RESULT TYPENAME f_floating_complex;    */
/*    OTS$POWCDJ_R3                                                         */
/*                                                                          */
/*    Raise a Complex Base to a Signed Longword Integer Exponent            */
/*                                                                          */
/*    The Raise a Complex Base to a Signed Longword Integer Exponent        */
/*    routines return the complex result of raising a complex base to an    */
/*    integer exponent.                                                     */
/*                                                                          */
/*ENTRY ots$powcdj_r3 ALIAS $ots_powcdj_r3 PARAMETER (                      */
/*    D_FLOATING COMPLEX NAMED complex_base IN                              */
/*        TYPENAME D_floating_complex VALUE,                                */
/*    LONGWORD NAMED longword_integer_exponent IN                           */
/*        TYPENAME longword_signed VALUE )                                  */
/*  RETURNS D_FLOATING COMPLEX NAMED RESULT TYPENAME d_floating_complex;    */
/*    OTS$POWCGJ_R3                                                         */
/*                                                                          */
/*    Raise a Complex Base to a Signed Longword Integer Exponent            */
/*                                                                          */
/*    The Raise a Complex Base to a Signed Longword Integer Exponent        */
/*    routines return the complex result of raising a complex base to an    */
/*    integer exponent.                                                     */
/*                                                                          */
/*ENTRY ots$powcgj_r3 ALIAS $ots_powcgj_r3 PARAMETER (                      */
/*    G_FLOATING COMPLEX NAMED complex_base IN                              */
/*        TYPENAME g_floating_complex VALUE,                                */
/*    LONGWORD NAMED longword_integer_exponent IN                           */
/*        TYPENAME longword_signed VALUE )                                  */
/*  RETURNS G_FLOATING COMPLEX NAMED RESULT TYPENAME g_floating_complex;    */
/*    OTS$POWDD                                                             */
/*                                                                          */
/*    Raise a D_floating Base to D_floating Exponent                        */
/*                                                                          */
/*    The Raise a D_floating Base to a D_floating Exponent routine          */
/*    raises a D_floating base to a D_floating                              */
/*    exponent.                                                             */
/*                                                                          */
/*ENTRY ots$powdd ALIAS $ots_powdd PARAMETER (                              */
/*    D_FLOATING NAMED D_floating_point_base IN                             */
/*        TYPENAME d_floating VALUE,                                        */
/*    D_FLOATING NAMED D_floating_point_exponent IN                         */
/*        TYPENAME d_floating VALUE )                                       */
/*  RETURNS D_FLOATING NAMED RESULT TYPENAME d_floating;                    */
/*    OTS$POWDJ                                                             */
/*                                                                          */
/*    Raise a D_floating Base to a Longword Exponent                        */
/*                                                                          */
/*    The Raise a D_floating Base to a Longword Exponent routine            */
/*    raises a D_floating base to a longword exponent.                      */
/*                                                                          */
/*ENTRY ots$powdj ALIAS $ots_powdj PARAMETER (                              */
/*    D_FLOATING NAMED D_floating_point_base IN                             */
/*        TYPENAME d_floating VALUE,                                        */
/*    LONGWORD NAMED longword_integer_exponent IN                           */
/*        TYPENAME longword_signed VALUE )                                  */
/*  RETURNS D_FLOATING NAMED RESULT TYPENAME d_floating;                    */
/*    OTS$POWDR                                                             */
/*                                                                          */
/*    Raise a D_floating Base to an F_floating Exponent                     */
/*                                                                          */
/*    The Raise a D_floating Base to an F_floating Exponent routines        */
/*    raise a D_floating base to an                                         */
/*    F_floating exponent.                                                  */
/*                                                                          */
/*ENTRY ots$powdr ALIAS $ots_powdr PARAMETER (                              */
/*    D_FLOATING NAMED D_floating_point_base IN                             */
/*        TYPENAME d_floating VALUE,                                        */
/*    F_FLOATING NAMED F_floating_point_exponent IN                         */
/*        TYPENAME f_floating VALUE )                                       */
/*  RETURNS D_FLOATING NAMED RESULT TYPENAME d_floating;                    */
/*    OTS$POWGG                                                             */
/*                                                                          */
/*    Raise a G_floating Base to a G_floating Exponent                      */
/*                                                                          */
/*    The Raise a G_floating Base to a G_floating Exponent routine          */
/*    raises a G_floating base to a G_floating exponent.                    */
/*                                                                          */
/*ENTRY ots$powgg ALIAS $ots_powgg PARAMETER (                              */
/*    G_FLOATING NAMED G_floating_point_base IN                             */
/*        TYPENAME g_floating VALUE,                                        */
/*    G_FLOATING NAMED G_floating_point_exponent IN                         */
/*        TYPENAME g_floating VALUE )                                       */
/*  RETURNS G_FLOATING NAMED RESULT TYPENAME g_floating;                    */
/*    OTS$POWGJ                                                             */
/*                                                                          */
/*    Raise a G_floating Base to a Longword Exponent                        */
/*                                                                          */
/*    The Raise a G_floating Base to a Longword Exponent routine            */
/*    raises a G_floating base to a longword exponent.                      */
/*                                                                          */
/*ENTRY ots$powgj ALIAS $ots_powgj PARAMETER (                              */
/*    G_FLOATING NAMED G_floating_point_base IN                             */
/*        TYPENAME g_floating VALUE,                                        */
/*    LONGWORD NAMED longword_integer_exponent IN                           */
/*        TYPENAME longword_signed VALUE )                                  */
/*  RETURNS G_FLOATING NAMED RESULT TYPENAME g_floating;                    */
/*    OTS$POWHH_R3                                                          */
/*                                                                          */
/*    Raise an H_floating Base to an H_floating Exponent                    */
/*                                                                          */
/*    The Raise an H_floating Base to an H_floating Exponent                */
/*    routine raises an H_floating base to an H_floating exponent.          */
/*                                                                          */
/*ENTRY ots$powhh_r3 ALIAS $ots_powhh_r3 PARAMETER (                        */
/*    H_FLOATING NAMED H_floating_point_base IN                             */
/*        TYPENAME h_floating VALUE,                                        */
/*    H_FLOATING NAMED H_floating_point_exponent IN                         */
/*        TYPENAME h_floating VALUE )                                       */
/*  RETURNS H_FLOATING NAMED RESULT TYPENAME h_floating;                    */
/*    OTS$POWHJ_R3                                                          */
/*                                                                          */
/*    Raise an H_floating Base to an Longword Exponent                      */
/*                                                                          */
/*    The Raise an H_floating Base to a Longword Exponent                   */
/*    routine raises an H_floating base to a longword exponent.             */
/*                                                                          */
/*ENTRY ots$powhj_r3 ALIAS $ots_powhj_r3 PARAMETER (                        */
/*    H_FLOATING NAMED H_floating_point_base IN                             */
/*        TYPENAME h_floating VALUE,                                        */
/*    LONGWORD NAMED longword_integer_exponent IN                           */
/*        TYPENAME longword_signed VALUE )                                  */
/*  RETURNS H_FLOATING NAMED RESULT TYPENAME h_floating;                    */
/*    OTS$POWII                                                             */
/*                                                                          */
/*    Raise a Word Base to a Word Exponent                                  */
/*                                                                          */
/*    The Raise a Word Base to a Word Exponent routine                      */
/*    raises a word base to a word exponent.                                */
/*                                                                          */
short int ots$powii() ;
/*    OTS$POWJJ                                                             */
/*                                                                          */
/*    Raise a Longword Base to a Longword Exponent                          */
/*                                                                          */
/*    The Raise a Longword Base to a Longword Exponent routine              */
/*    raises a signed longword base to a signed longword exponent.          */
/*                                                                          */
long int ots$powjj() ;
/*    OTS$POWLULU                                                           */
/*                                                                          */
/*    Raise an Unsigned Longword Base to an Unsigned Longword Exponent      */
/*                                                                          */
/*    The Raise an Unsigned Longword Base to an Unsigned Longword           */
/*    Exponent routine                                                      */
/*    raises an unsigned longword integer base to                           */
/*    an unsigned longword integer exponent.                                */
/*                                                                          */
unsigned long int ots$powlulu() ;
/*    OTS$POWRD                                                             */
/*                                                                          */
/*    Raise an F_floating Base to D_floating Exponent                       */
/*                                                                          */
/*    The Raise an F_floating Base to a D_floating Exponent                 */
/*    routine raises an F_floating base to a D_floating                     */
/*    exponent.                                                             */
/*                                                                          */
/*ENTRY ots$powrd ALIAS $ots_powrd PARAMETER (                              */
/*    F_FLOATING NAMED F_floating_point_base IN                             */
/*        TYPENAME f_floating VALUE,                                        */
/*    D_FLOATING NAMED D_floating_point_exponent IN                         */
/*        TYPENAME d_floating VALUE )                                       */
/*  RETURNS D_FLOATING NAMED RESULT TYPENAME d_floating;                    */
/*    OTS$POWRJ                                                             */
/*                                                                          */
/*    Raise an F_floating Base to a Longword Exponent                       */
/*                                                                          */
/*    The Raise an F_floating Base to a Longword Exponent                   */
/*    routine raises an F_floating base to a longword exponent.             */
/*                                                                          */
float ots$powrj() ;
/*    OTS$POWRR                                                             */
/*                                                                          */
/*    Raise an F_floating Base to F_floating Exponent                       */
/*                                                                          */
/*    The Raise an F_floating Base to an F_floating Exponent                */
/*    routine raises an F_floating base to an F_floating                    */
/*    exponent.                                                             */
/*                                                                          */
float ots$powrr() ;
/*    OTS$POWRLU                                                            */
/*                                                                          */
/*    Raise a Floating-Point Base to an Unsigned Longword Integer Exponent  */
/*                                                                          */
/*    The Raise a Floating-Point Base to an Unsigned Longword Integer       */
/*    Exponent routines raises                                              */
/*    a floating-point base to an unsigned longword integer exponent.       */
/*                                                                          */
float ots$powrlu() ;
/*    OTS$POWDLU                                                            */
/*                                                                          */
/*    Raise a Floating-Point Base to an Unsigned Longword Integer Exponent  */
/*                                                                          */
/*    The Raise a Floating-Point Base to an Unsigned Longword Integer       */
/*    Exponent routines raises                                              */
/*    a floating-point base to an unsigned longword integer exponent.       */
/*                                                                          */
/*ENTRY ots$powdlu ALIAS $ots_powdlu PARAMETER (                            */
/*    D_FLOATING NAMED floating_point_base IN                               */
/*        TYPENAME d_floating VALUE,                                        */
/*    LONGWORD UNSIGNED NAMED unsigned_lword_int_exponent IN                */
/*        TYPENAME longword_unsigned VALUE )                                */
/*  RETURNS D_FLOATING NAMED RESULT TYPENAME d_floating;                    */
/*    OTS$POWGLU                                                            */
/*                                                                          */
/*    Raise a Floating-Point Base to an Unsigned Longword Integer Exponent  */
/*                                                                          */
/*    The Raise a Floating-Point Base to an Unsigned Longword Integer       */
/*    Exponent routines raises                                              */
/*    a floating-point base to an unsigned longword integer exponent.       */
/*                                                                          */
/*ENTRY ots$powglu ALIAS $ots_powglu PARAMETER (                            */
/*    G_FLOATING NAMED floating_point_base IN                               */
/*        TYPENAME g_floating VALUE,                                        */
/*    LONGWORD UNSIGNED NAMED unsigned_lword_int_exponent IN                */
/*        TYPENAME longword_unsigned VALUE )                                */
/*  RETURNS G_FLOATING NAMED RESULT TYPENAME g_floating;                    */
/*    OTS$POWHLU_R3                                                         */
/*                                                                          */
/*    Raise a Floating-Point Base to an Unsigned Longword Integer Exponent  */
/*                                                                          */
/*    The Raise a Floating-Point Base to an Unsigned Longword Integer       */
/*    Exponent routines raises                                              */
/*    a floating-point base to an unsigned longword integer exponent.       */
/*                                                                          */
/*ENTRY ots$powhlu_r3 ALIAS $ots_powhlu_r3 PARAMETER (                      */
/*    H_FLOATING NAMED floating_point_base IN                               */
/*        TYPENAME h_floating VALUE,                                        */
/*    LONGWORD UNSIGNED NAMED unsigned_lword_int_exponent IN                */
/*        TYPENAME longword_unsigned VALUE )                                */
/*  RETURNS H_FLOATING NAMED RESULT TYPENAME h_floating;                    */
/*    OTS$SCOPY_DXDX                                                        */
/*                                                                          */
/*    Copy a Source String Passed by Descriptor to a Destination String     */
/*                                                                          */
/*    The Copy a Source String Passed by Descriptor to a Destination String  */
/*    routine                                                               */
/*    copies a source string to a destination string. Both strings are      */
/*    passed by descriptor.                                                 */
/*                                                                          */
unsigned short int ots$scopy_dxdx() ;
/*    OTS$SCOPY_R_DX                                                        */
/*                                                                          */
/*    Copy a Source String Passed by Reference to a Destination String      */
/*                                                                          */
/*    The Copy a Source String Passed by Reference to a Destination String  */
/*    routine copies a source string passed by reference to a destination   */
/*    string.                                                               */
/*                                                                          */
unsigned short int ots$scopy_r_dx() ;
/*    OTS$SFREE1_DD                                                         */
/*                                                                          */
/*    Strings, Free One Dynamic                                             */
/*                                                                          */
/*    The Free One Dynamic String routine                                   */
/*    returns one dynamic string area to free storage.                      */
/*                                                                          */
int ots$sfree1_dd() ;
/*    OTS$SFREEN_DD                                                         */
/*                                                                          */
/*    Strings, Free n Dynamic                                               */
/*                                                                          */
/*    The Free n Dynamic Strings routine                                    */
/*    takes as input a vector of one or more dynamic string areas and       */
/*    returns them to free storage.                                         */
/*                                                                          */
int ots$sfreen_dd() ;
/*    OTS$SGET1_DD                                                          */
/*                                                                          */
/*    Strings, Get One Dynamic                                              */
/*                                                                          */
/*    The Get One Dynamic String routine                                    */
/*    allocates a specified number of bytes of dynamic virtual              */
/*    memory to a specified string descriptor.                              */
/*                                                                          */
int ots$sget1_dd() ;
/*    OTS$CVT_L_TB                                                          */
/*                                                                          */
/*    Convert an Unsigned Integer to Binary Text                            */
/*                                                                          */
/*    The Convert an Unsigned Integer to Binary Text routine                */
/*    converts an unsigned integer value of arbitrary length to             */
/*    binary representation in an ASCII text string. By default, a longword is */
/*    converted.                                                            */
/*                                                                          */
unsigned long int ots$cvt_l_tb() ;
/*    OTS$CVT_L_TI                                                          */
/*                                                                          */
/*    Convert Signed Integer to Decimal Text                                */
/*                                                                          */
/*    The Convert Signed Integer to Decimal Text routine                    */
/*    converts a signed integer to a decimal ASCII text string. This        */
/*    routine supports FORTRAN Iw and Iw.m output and BASIC output conversion.  */
/*                                                                          */
unsigned long int ots$cvt_l_ti() ;
/*    OTS$CVT_L_TL                                                          */
/*                                                                          */
/*    Convert Integer to Logical Text                                       */
/*                                                                          */
/*    The Convert Integer to Logical Text routine                           */
/*    converts an integer to an ASCII text string representation            */
/*    using FORTRAN L (logical) format.                                     */
/*                                                                          */
unsigned long int ots$cvt_l_tl() ;
/*    OTS$CVT_L_TO                                                          */
/*                                                                          */
/*    Convert Unsigned Integer to Octal Text                                */
/*                                                                          */
/*    The Convert Unsigned Integer to Octal Text routine                    */
/*    converts an unsigned integer to an octal ASCII text string.           */
/*    OTS$CVT_L_TO supports FORTRAN Ow and Ow.m output conversion formats.  */
/*                                                                          */
unsigned long int ots$cvt_l_to() ;
/*    OTS$CVT_L_TU                                                          */
/*                                                                          */
/*    Convert Unsigned Integer to Decimal Text                              */
/*                                                                          */
/*    The Convert Unsigned Integer to Decimal Text routine                  */
/*    converts a byte, word or longword value to unsigned decimal           */
/*    representation in an ASCII text string. By default, a longword is     */
/*    converted.                                                            */
/*                                                                          */
unsigned long int ots$cvt_l_tu() ;
/*    OTS$CVT_L_TZ                                                          */
/*                                                                          */
/*    Convert Integer to Hexadecimal Text                                   */
/*                                                                          */
/*    The Convert Integer to Hexadecimal Text routine                       */
/*    converts an unsigned integer to a hexadecimal ASCII text              */
/*    string. OTS$CVT_L_TZ supports FORTRAN Zw and Zw.m output conversion   */
/*    formats.                                                              */
/*                                                                          */
unsigned long int ots$cvt_l_tz() ;
/*    OTS$CVT_TB_L                                                          */
/*                                                                          */
/*    Convert Binary Text to Unsigned Integer                               */
/*                                                                          */
/*    The Convert Binary Text to Unsigned Integer routine                   */
/*    converts an ASCII text string representation of an unsigned           */
/*    binary value to an unsigned integer value of arbitrary length. By default, */
/*    the result is a longword. Valid input characters are the blank and the */
/*    digits 0 and 1. No sign is permitted.                                 */
/*                                                                          */
unsigned long int ots$cvt_tb_l() ;
/*    OTS$CVT_TI_L                                                          */
/*                                                                          */
/*    Convert Signed Integer Text to Integer                                */
/*                                                                          */
/*    The Convert Signed Integer Text to Integer routine                    */
/*    converts an ASCII text string representation of a decimal             */
/*    number to a signed byte, word, or longword integer value.             */
/*    The result is a longword by                                           */
/*    default, but the calling program can specify a byte or a word value   */
/*    instead.                                                              */
/*                                                                          */
unsigned long int ots$cvt_ti_l() ;
/*    OTS$CVT_TL_L                                                          */
/*                                                                          */
/*    Convert Logical Text to Integer                                       */
/*                                                                          */
/*    The Convert Logical Text to Integer routine                           */
/*    converts an ASCII text string representation of a FORTRAN-77 L        */
/*    format to a byte, word, or longword integer value. The result is a longword by */
/*    default, but the calling program can specify a byte or a word value   */
/*    instead.                                                              */
/*                                                                          */
unsigned long int ots$cvt_tl_l() ;
/*    OTS$CVT_TO_L                                                          */
/*                                                                          */
/*    Convert Octal Text to Signed Integer                                  */
/*                                                                          */
/*    The Convert Octal Text to Signed Integer routine                      */
/*    converts an ASCII text string representation of an                    */
/*    octal value to an signed integer of an arbitrary length. The result is a */
/*    longword by default, but the calling program can specify a byte, word, */
/*    or longword.                                                          */
/*                                                                          */
unsigned long int ots$cvt_to_l() ;
/*    OTS$CVT_TU_L                                                          */
/*                                                                          */
/*    Convert Unsigned Decimal Text to Integer                              */
/*                                                                          */
/*    The Convert Unsigned Decimal Text to Integer routine                  */
/*    converts an ASCII text string representation of an unsigned           */
/*    decimal value to an unsigned byte, word, or longword value. By default, the */
/*    result is a longword. Valid input characters are the space and the digits 0 */
/*    through 9. No sign is permitted.                                      */
/*                                                                          */
unsigned long int ots$cvt_tu_l() ;
/*    OTS$CVT_TZ_L                                                          */
/*                                                                          */
/*    Convert Hexadecimal Text to Unsigned Integer                          */
/*                                                                          */
/*    The Convert Hexadecimal Text to Unsigned Integer routine              */
/*    converts an ASCII text string representation of an unsigned           */
/*    hexadecimal value to an unsigned integer of an arbitrary length.      */
/*    The result is a longword by default, but the calling program can specify */
/*    a byte, word, or longword                                             */
/*    value.                                                                */
/*                                                                          */
unsigned long int ots$cvt_tz_l() ;

#endif					/* __OTS$ROUTINES_LOADED */
#ifndef __OTSDEF_LOADED
#define __OTSDEF_LOADED	1

/*** MODULE $otsdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:42.39 */
/*                                                                          */
/* FILE: OTSMSG.MSG  EDIT: SBL2003                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 2-001 - CONVERT TO MESSAGE UTILITY SOURCE FORMAT.  ADAPTED FROM OTSMSG.MDL */
/*	  VERSION 1-009.  SBL 22-APR-1981                                   */
/* 2-002 - ADD OTS$_WRONUMARG.   RKR 4-SEP-1981                             */
/* 2-003 - ADD .TITLE AND .IDENT.  SBL 28-AUG-1982                          */
/*--                                                                        */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	OTS$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$OTSDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS EXTERNAL;                    */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*-                                                                         */
/*+                                                                         */
/* DEFINE OTS$ SEVERE ERROR MESSAGES                                        */
/*-                                                                         */
/*			; DO NOT HAVE CONCEPT OF ERROR NUMBER (SEE FOR$ MTH$) */
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE SEVERE       */
/*			; SET LH TO 23 (DECIMAL) OTS$ PREFIX                */
#define OTS$_FACILITY 23
#define OTS$_INVSTRDES 1540108
#define OTS$_FATINTERR 1540116
#define OTS$_INTDATCOR 1540124
#define OTS$_IO_CONCLO 1540132
#define OTS$_INPCONERR 1540140
#define OTS$_OUTCONERR 1540148
#define OTS$_STRIS_INT 1540156
#define OTS$_INSVIRMEM 1540164
#define OTS$_WRONUMARG 1540172
/*			; OTS$SCOPY                                         */
/*+                                                                         */
/* DEFINE OTS$ WARNING MESSAGES:                                            */
/*-                                                                         */
/*			; DO NOT HAVE CONCEPT OF ERROR NUMBER (SEE FOR$ MTH$) */
/*			; SET SUB-SYSTEM SPECIFIC BIT AND MAKE WARNING      */
/*			; SET LH TO 23 (DECIMAL) OTS$ PREFIX                */
#define OTS$_USEFLORES 1541120

#endif					/* __OTSDEF_LOADED */
#ifndef __PCCDEF_LOADED
#define __PCCDEF_LOADED	1

/*** MODULE $pccdef ***/
/*+                                                                         */
/* PRINTER/TERMINAL CARRIAGE CONTROL SPECIFIERS                             */
/*--                                                                        */
#define PCC$M_CHAR 31
#define PCC$M_EIGHTBIT 64
#define PCC$M_SINGLE 128
#define PCC$M_LINECNT 127
#define PCC$_FTN_SINGLE 32              /* SINGLE SPACE                     */
#define PCC$_FTN_DOUBLE 48              /* DOUBLE SPACE                     */
#define PCC$_FTN_PAGE 49                /* PAGE SPACE                       */
#define PCC$_FTN_OVRPRT 43              /* OVER PRINT                       */
#define PCC$_FTN_PROMPT 36              /* PROMPT                           */
struct pccdef {
    unsigned short int pcc$w_fortran;   /* FORTRAN FIELD                    */
#pragma nostandard
    variant_union  {                    /* PREFIX FIELD                     */
        unsigned char pcc$b_prefix;
        variant_struct  {
            unsigned pccdef$$_bits0 : 1;
            unsigned pcc$v_fill_11 : 7;
            } pcc$r_prefix_bits0;
        variant_struct  {
            unsigned pccdef$$_bits1 : 1;
            unsigned pcc$v_fill_12 : 7;
            } pcc$r_prefix_bits1;
        } pcc$r_prefix_overlay;
    variant_union  {
        unsigned char pcc$b_postfix;    /* POSTFIX FIELD                    */
        variant_struct  {
            unsigned pcc$v_char : 5;    /* CHARACTER FIELD                  */
            unsigned pccdef$$_fill_1 : 1;
            unsigned pcc$v_eightbit : 1; /* EIGHTBIT CHARACTER SET          */
            unsigned pcc$v_single : 1;  /* SINGLE CHARACTER                 */
            } pcc$r_postfix_bits0;
        variant_struct  {
            unsigned pcc$v_linecnt : 7; /* LINE COUNT FOR NEWLINES          */
            unsigned pcc$v_fill_13 : 1;
            } pcc$r_postfix_bits1;
/* FORTRAN CONSTANTS                                                        */
        } pcc$r_postfix_overlay;
    } ;
 
#pragma standard

#endif					/* __PCCDEF_LOADED */
#ifndef __PERROR_LOADED
#define __PERROR_LOADED	1

/*	PERROR - V3.0 - VAX C RTL variables used by the PERROR routine	*/

#pragma nostandard

extern noshare char *sys_errlist[];
extern noshare int sys_nerr;
#pragma standard

#endif					/* __PERROR_LOADED */
#ifndef __PLVDEF_LOADED
#define __PLVDEF_LOADED	1

/*** MODULE $plvdef ***/
/*+                                                                         */
/* PRIVILEGED LIBRARY VECTOR DEFINITION                                     */
/*-                                                                         */
#define PLV$C_TYP_CMOD 1                /*CHANGE MODE VECTOR TYPE           */
#define PLV$C_TYP_MSG 2                 /*MESSAGE VECTOR TYPE               */
struct plvdef {
    unsigned long int plv$l_type;       /*TYPE CODE FOR VECTOR FORMAT       */
/*TYPE CODES FOR PRIVILEGE VECTORS                                          */
    unsigned long int plv$l_version;    /*SYSTEM VERSION NUMBER             */
#pragma nostandard
    variant_union  {
        unsigned long int plv$l_kernel; /*SELF-REL PTR TO KERNEL MODE DISPATCHER  */
        unsigned long int plv$l_msgdsp; /*SELF-REL PTR TO MESSAGE DISPATCHER  */
        } plv$r_kernel_overlay;
    unsigned long int plv$l_exec;       /*SELF-REL PTR TO EXEC MODE DISPATCHER  */
    unsigned long int plv$l_usrundwn;   /*SELF-REL PTR TO USER RUNDOWN SERVICE  */
    long int plvdef$$_fill_1;           /*UNUSED, RESERVED FOR FUTURE USE   */
    unsigned long int plv$l_rms;        /*SELF-REL PTR TO RMS SERVICES DISPATCHER  */
    unsigned long int plv$l_check;      /*LONGWORD USED TO CHECK VIRTUAL ADDRESS  */
/*LOCATION OF VECTOR                                                        */
    } ;
 
#pragma standard

#endif					/* __PLVDEF_LOADED */
#ifndef __PPL$DEF_LOADED
#define __PPL$DEF_LOADED	1

/*** MODULE ppl$def ***/
/* Definitions for RTL Parallel Processing Facility - PPL                   */
/*                                                                          */
/* Pre-defined event ids.                                                   */
/*                                                                          */
#define PPL$K_ABNORMAL_EXIT -2          /* abnormal participant termination */
#define PPL$K_NORMAL_EXIT -1            /* normal participant termination   */
/*                                                                          */
/* Shared memory options flags.                                             */
/*                                                                          */
#define PPL$M_NOZERO 1
#define PPL$M_NOWRT 2
#define PPL$M_FLUSH 4
#define PPL$M_NOUNI 8
#define PPL$M_MOPT_SPARE -16
struct mem_options {
    unsigned ppl$v_nozero : 1;          /* not demand-zero                  */
    unsigned ppl$v_nowrt : 1;           /* read-only                        */
    unsigned ppl$v_flush : 1;           /* write to disk                    */
    unsigned ppl$v_nouni : 1;           /* non-unique name not requested    */
    unsigned ppl$v_mopt_spare : 28;     /* extra bits                       */
    } ;
/*                                                                          */
/* Processing options flags.                                                */
/*                                                                          */
#define PPL$M_INIT_SYNCH 1
#define PPL$M_NODEBUG 2
#define PPL$M_STOP_CHILDREN 4
#define PPL$M_NON_BLOCKING 8
#define PPL$M_NOTIFY_ONE 16
#define PPL$M_SPIN_WAIT 32
#define PPL$M_POPT_SPARE -64
struct proc_options {
    unsigned ppl$v_init_synch : 1;      /* parent blocks until children init */
    unsigned ppl$v_nodebug : 1;         /* disable DEBUG                    */
    unsigned ppl$v_stop_children : 1;   /* stop children of terminating process */
    unsigned ppl$v_non_blocking : 1;    /* don't block if semaphore unavailable */
    unsigned ppl$v_notify_one : 1;      /* notify only one enabler for event */
    unsigned ppl$v_spin_wait : 1;       /* spin rather than $HIBER          */
    unsigned ppl$v_popt_spare : 26;     /* extra bits                       */
    } ;

#endif					/* __PPL$DEF_LOADED */
#ifndef __PPL$ROUTINES_LOADED
#define __PPL$ROUTINES_LOADED	1

/*** MODULE ppl$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    PPL$ADJUST_QUORUM                                                     */
/*                                                                          */
/*    Adjust Barrier Quorum                                                 */
/*                                                                          */
/*    The Adjust Barrier Quorum routine increments or decrements the quorum */
/*    associated with the specified barrier, thus allowing a barrier to     */
/*    dynamically alter the number of participants required to conclude a   */
/*    wait on that barrier.  The barrier must have been created by          */
/*    PPL$CREATE_BARRIER. (See PPL$CREATE_BARRIER for more information      */
/*    about quorums.)                                                       */
/*                                                                          */
unsigned long int ppl$adjust_quorum() ;
/*    PPL$AWAIT_EVENT                                                       */
/*                                                                          */
/*    Await Event Occurrence                                                */
/*                                                                          */
/*    The Await Event Occurrence routine blocks the caller until an event   */
/*    occurs.                                                               */
/*                                                                          */
unsigned long int ppl$await_event() ;
/*    PPL$CREATE_BARRIER                                                    */
/*                                                                          */
/*    Create a Barrier                                                      */
/*                                                                          */
/*    The Create a Barrier routine creates and initializes a                */
/*    barrier, and returns the barrier identifier.                          */
/*    You use the barrier identifier to perform all operations on that      */
/*    barrier.                                                              */
/*                                                                          */
unsigned long int ppl$create_barrier() ;
/*    PPL$CREATE_EVENT                                                      */
/*                                                                          */
/*    Create an Event                                                       */
/*                                                                          */
/*    The Create an Event routine creates an arbitrary user-defined event   */
/*    and returns the event identifier. You use the event identifier to     */
/*    perform all operations on that event.                                 */
/*                                                                          */
unsigned long int ppl$create_event() ;
/*    PPL$CREATE_SPIN_LOCK                                                  */
/*                                                                          */
/*    Create Spin Lock                                                      */
/*                                                                          */
/*    The Create Spin Lock routine creates and initializes a simple (spin)  */
/*    lock, and returns the lock identifier. You use that lock identifier to  */
/*    get and free the lock.                                                */
/*                                                                          */
unsigned long int ppl$create_spin_lock() ;
/*    PPL$CREATE_SHARED_MEMORY                                              */
/*                                                                          */
/*    Create Shared Memory                                                  */
/*                                                                          */
/*    The Create Shared Memory routine creates (if necessary) and maps a    */
/*    section of memory that can be shared by multiple processes.           */
/*                                                                          */
unsigned long int ppl$create_shared_memory() ;
/*    PPL$CREATE_SEMAPHORE                                                  */
/*                                                                          */
/*    Create a Semaphore                                                    */
/*                                                                          */
/*    The Create a Semaphore routine creates and initializes a              */
/*    semaphore with a waiting queue, and returns the semaphore identifier. */
/*    You use the semaphore identifier to perform all operations on that    */
/*    semaphore.                                                            */
/*                                                                          */
unsigned long int ppl$create_semaphore() ;
/*    PPL$CREATE_VM_ZONE                                                    */
/*                                                                          */
/*    Create a New Virtual Memory Zone                                      */
/*                                                                          */
/*    The Create a New Virtual Memory Zone routine creates a new storage    */
/*    zone, according to specified arguments, which is available to all     */
/*    participants in the application.                                      */
/*                                                                          */
unsigned long int ppl$create_vm_zone() ;
/*    PPL$DECREMENT_SEMAPHORE                                               */
/*                                                                          */
/*    Decrement a Semaphore                                                 */
/*                                                                          */
/*    The Decrement a Semaphore routine waits for a semaphore to have a     */
/*    value greater than 0, then decrements the value                       */
/*    by 1 to indicate the allocation of a resource.                        */
/*    If the value of the semaphore is 0 at the time of the call,           */
/*    the caller is put in the associated queue and is suspended.           */
/*    The semaphore must have been created by PPL$CREATE_SEMAPHORE.         */
/*                                                                          */
unsigned long int ppl$decrement_semaphore() ;
/*    PPL$DELETE_SHARED_MEMORY                                              */
/*                                                                          */
/*    Delete Shared Memory                                                  */
/*                                                                          */
/*    The Delete Shared Memory routine deletes or unmaps from a global      */
/*    section that you created using the PPL$CREATE_SHARED_MEMORY routine.  */
/*    Optionally, this routine writes the contents of the global section to */
/*    disk before deleting the section.                                     */
/*                                                                          */
unsigned long int ppl$delete_shared_memory() ;
/*    PPL$ENABLE_EVENT_AST                                                  */
/*                                                                          */
/*    Enable AST Notification of an Event                                   */
/*                                                                          */
/*    The Enable AST Notification of an Event routine specifies the address of */
/*    an AST routine (and optionally an argument to that routine) to be delivered */
/*    when an event occurs.                                                 */
/*                                                                          */
unsigned long int ppl$enable_event_ast() ;
/*    PPL$ENABLE_EVENT_SIGNAL                                               */
/*                                                                          */
/*    Enable Signal Notification of an Event                                */
/*                                                                          */
/*    The Enable Signal Notification of an Event routine specifies a        */
/*    condition value to be signaled when the event occurs.                 */
/*                                                                          */
unsigned long int ppl$enable_event_signal() ;
/*    PPL$FLUSH_SHARED_MEMORY                                               */
/*                                                                          */
/*    Flush Shared Memory                                                   */
/*                                                                          */
/*    The Flush Shared Memory routine writes (flushes) to disk the contents */
/*    of a global section that you created using the PPL$CREATE_SHARED_MEMORY */
/*    routine. Only pages that have been modified are flushed to disk.      */
/*                                                                          */
unsigned long int ppl$flush_shared_memory() ;
/*    PPL$FIND_SYNCH_ELEMENT_ID                                             */
/*                                                                          */
/*    Find                                                                  */
/*                                                                          */
/*    Given the name of a spin lock, semaphore, barrier, or event, the      */
/*    Find Synchronization Element Identification routine returns the       */
/*    identifier of the associated synchronization element.                 */
/*                                                                          */
unsigned long int ppl$find_synch_element_id() ;
/*    PPL$GET_INDEX                                                         */
/*                                                                          */
/*    Get Index of a Participant                                            */
/*                                                                          */
/*    The Get Index of a Participant routine returns an index that is unique */
/*    within the application. A value of zero signifies the main or         */
/*    main participant. The other participants in the application           */
/*    always return an index greater than zero.                             */
/*                                                                          */
unsigned long int ppl$get_index() ;
/*    PPL$INCREMENT_SEMAPHORE                                               */
/*                                                                          */
/*    Increment a Semaphore                                                 */
/*                                                                          */
/*    The Increment a Semaphore routine increments the value of the semaphore */
/*    by 1, analogous to the signal protocol.  If any other participants    */
/*    are blocked on a call to PPL$DECREMENT_SEMAPHORE for this semaphore,  */
/*    one is removed from the queue and awakened.                           */
/*    The semaphore must have been created by PPL$CREATE_SEMAPHORE.         */
/*                                                                          */
unsigned long int ppl$increment_semaphore() ;
/*    PPL$INDEX_TO_PID                                                      */
/*                                                                          */
/*    Convert Participant-Index to VMS PID                                  */
/*                                                                          */
/*    The Convert Participant-Index to VMS PID routine returns the VMS PID  */
/*    of the process or subprocess associated with the specified index.     */
/*                                                                          */
unsigned long int ppl$index_to_pid() ;
/*    PPL$INITIALIZE                                                        */
/*                                                                          */
/*    Initialize the PPL$ Facility                                          */
/*                                                                          */
/*    The Initialize the PPL$ Facility routine informs the PPL$ facility that the */
/*    caller is forming or joining the parallel application.  Calling this  */
/*    routine is optional, because PPL$ initializes itself at the           */
/*    first call to a PPL$ routine.                                         */
/*                                                                          */
unsigned long int ppl$initialize() ;
/*    PPL$PID_TO_INDEX                                                      */
/*                                                                          */
/*    Convert VMS PID to Participant-Index                                  */
/*                                                                          */
/*    The Convert VMS PID to Participant-Index routine returns the PPL$-defined */
/*    participant index of the process or subprocess associated with the    */
/*    specified VMS PID.                                                    */
/*                                                                          */
unsigned long int ppl$pid_to_index() ;
/*    PPL$READ_BARRIER                                                      */
/*                                                                          */
/*    Read a Barrier                                                        */
/*                                                                          */
/*    The Read a Barrier routine returns the specified barrier's current quorum and */
/*    the number of participants currently waiting (blocked) at the barrier.  The */
/*    barrier must have been created by PPL$CREATE_BARRIER.                 */
/*                                                                          */
unsigned long int ppl$read_barrier() ;
/*    PPL$READ_EVENT                                                        */
/*                                                                          */
/*    Read an Event State                                                   */
/*                                                                          */
/*    The Read an Event State routine returns the current state of the specified  */
/*    event.                                                                */
/*    The state can be not_occurred  or not_occurred.                       */
/*                                                                          */
unsigned long int ppl$read_event() ;
/*    PPL$READ_SEMAPHORE                                                    */
/*                                                                          */
/*    Read Semaphore Values                                                 */
/*                                                                          */
/*    The Read Semaphore Values routine returns the current or              */
/*    maximum values, or both, of the specified counting semaphore.         */
/*    The semaphore must have been created by                               */
/*    PPL$CREATE_SEMAPHORE.                                                 */
/*                                                                          */
unsigned long int ppl$read_semaphore() ;
/*    PPL$RELEASE_SPIN_LOCK                                                 */
/*                                                                          */
/*    Release Spin Lock                                                     */
/*                                                                          */
/*    The Release Spin Lock routine relinquishes the spin lock by clearing the */
/*    bit representing the lock. The lock must have been created by         */
/*    PPL$CREATE_SPIN_LOCK.                                                 */
/*                                                                          */
unsigned long int ppl$release_spin_lock() ;
/*    PPL$SPAWN                                                             */
/*                                                                          */
/*    Initiate Parallel Execution                                           */
/*                                                                          */
/*    The Initiate Parallel Execution routine executes code in parallel     */
/*    with the caller by creating one or more subordinate threads of execution */
/*    (VMS subprocesses).                                                   */
/*                                                                          */
unsigned long int ppl$spawn() ;
/*    PPL$SET_QUORUM                                                        */
/*                                                                          */
/*    Set Barrier Quorum                                                    */
/*                                                                          */
/*    The Set Barrier Quorum routine dynamically sets a value for the       */
/*    specified barrier's quorum.  This allows you to easily reuse a barrier */
/*    for different work items with various numbers of participants.        */
/*    The barrier must have been created by PPL$CREATE_BARRIER.             */
/*                                                                          */
unsigned long int ppl$set_quorum() ;
/*    PPL$STOP                                                              */
/*                                                                          */
/*    Stop a Participant                                                    */
/*                                                                          */
/*    The Stop a Participant routine terminates the execution of the specified */
/*    participant in this application.                                      */
/*                                                                          */
unsigned long int ppl$stop() ;
/*    PPL$SEIZE_SPIN_LOCK                                                   */
/*                                                                          */
/*    Seize Spin Lock                                                       */
/*                                                                          */
/*    The Seize Spin Lock routine retrieves a simple (spin) lock by waiting in a */
/*    spin loop until the lock is free. The lock must have been created by  */
/*    PPL$CREATE_SPIN_LOCK.                                                 */
/*                                                                          */
unsigned long int ppl$seize_spin_lock() ;
/*    PPL$TERMINATE                                                         */
/*                                                                          */
/*    Abort PPL$ Participation                                              */
/*                                                                          */
/*    The Abort PPL$ Participation routine ends the caller's                */
/*    participation in the application prematurely --- that is, at some time */
/*    before the caller actually completes its execution.                   */
/*                                                                          */
unsigned long int ppl$terminate() ;
/*    PPL$TRIGGER_EVENT                                                     */
/*                                                                          */
/*    Trigger an Event                                                      */
/*                                                                          */
/*    The Trigger an Event routine causes the event's state to become       */
/*    occurred.  You control whether all pending actions for                */
/*    the event are processed (made to occur), or just one is processed.    */
/*    A pending action can be an AST, a signal (condition), or a wakeup.    */
/*                                                                          */
unsigned long int ppl$trigger_event() ;
/*    PPL$UNIQUE_NAME                                                       */
/*                                                                          */
/*    Produce a Unique Name                                                 */
/*                                                                          */
/*    The Produce a Unique Name routine returns an application-unique name. */
/*    A system-unique string specific to the calling application is appended */
/*    to the string specified by the user.                                  */
/*    The resulting name is identical for all participants in               */
/*    the application, but different from those for all other applications on that */
/*    system.                                                               */
/*                                                                          */
unsigned long int ppl$unique_name() ;
/*    PPL$WAIT_AT_BARRIER                                                   */
/*                                                                          */
/*    Synchronize at a Barrier                                              */
/*                                                                          */
/*    The Synchronize at a Barrier routine causes the caller to             */
/*    wait at the specified barrier.                                        */
/*    The barrier is in effect from the time the first participant calls    */
/*    PPL$WAIT_AT_BARRIER until each member of the                          */
/*    quorum has issued the call.  At that time, the wait concludes and     */
/*    all are released for further execution.                               */
/*                                                                          */
unsigned long int ppl$wait_at_barrier() ;

#endif					/* __PPL$ROUTINES_LOADED */
#ifndef __PPLDEF_LOADED
#define __PPLDEF_LOADED	1

/*** MODULE $ppldef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:54.54 */
/*                                                                          */
/* FILE: PPLMSG.MSG EDIT: CMF1004                                           */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1987 BY						    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/*                                                                          */
/* FACILITY:	VAX PPL                                                     */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS FILE CONTAINS THE DEFINITION FOR THE PPL FACILITY SPECIFIC     */
/*	ERROR MESSAGES.  THE FACILITY CODE FOR PPL IS 481.                  */
/*                                                                          */
/* ENVIRONMENT:	VAX/VMS USER MODE                                           */
/*                                                                          */
/* AUTHOR: P. GILBERT, CREATION DATE: 30-SEP-1986                           */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	E01-001		ORIGINAL                                            */
/*                                                                          */
/*	E01-002		TO ADD THE FACILITY CODE.	CMF	23-JAN-1987 */
/*                                                                          */
/*	E01-003		TO CORRECT THE IDENT TO MATCH	CMF	26-JAN-1987 */
/*			THE CMS GENERATION NUMBER.                          */
/*                                                                          */
/*	E01-004		REVAMP THE FILE TO CONFORM TO	CMF	28-JAN-1987 */
/*			RTL STANDARDS. ( PATTERNED AFTER                    */
/*			LIBMSG.MSG )                                        */
/*                                                                          */
/*	E01-005		TO CHANGE THE MODULE NAME FROM  CMF	16-FEB-1987 */
/*			PPL$MSG TO PPL$MSGDEF TO BE                         */
/*			CONSISTENT WITH THE OTHER RTLS                      */
/*                                                                          */
/*	E01-006		TO ADD PPL$_ATTUSETWO TO INDICATE CMF	16-FEB-1987 */
/*			THAT AN ATTEMPT HAS BEEN MADE TO                    */
/*			USE TWO BARRIERS THUS RESULTING IN                  */
/*			DEAD LOCK.                                          */
/*                                                                          */
/*	E01-007		ADD MSGS FOR BARRIERS AND EVENTS,	DLR 24-JUL-87 */
/*			PLUS OTHER MISC UPDATES.                            */
/*			REMOVE OLD DEAD ONES BY ! *** NOTATION.             */
/*                                                                          */
/*	E01-008		CONFORM TO DOCUMENTATION STANDARDS.	DLR 19-AUG-1987 */
/*                                                                          */
/*--                                                                        */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	PPL$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE IBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE    */
/* ERROR MESSAGE, NOT COUNTING ARTICLES AND PREPSITIONS.                    */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* MACRO-32PROGRAMMING:                                                     */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$PPLDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS AS EXTERNAL;                 */
/* THE MACROS ARE PROVIDED ONLY FOR THE COVENIENCE OF THE USER.             */
/*-                                                                         */
/*+                                                                         */
/* SPECIAL NOTE:                                                            */
/*                                                                          */
/* THE MESSAGES HERE SHOULD BE RESOLVED FROM STARLET.OLB.  INORDER          */
/* FOR THIS TO HAPPEN, SEVERAL VMS BUILD FILES NEED TO BE EDITED.           */
/* THIS WILL BE DONE FOR SYS 11.  NOTE THAT SEVERAL OF OUT BUILD            */
/* PROCEDURES MAY NEED TO BE EDITED.  PPLRTLBLD.COM TO COPY                 */
/* AND DELETE APPROPRIATE FILE IN APPROPRIATE PLACES.                       */
/*                                                                          */
/* ALSO, THE FILE PPLDEF WILL NEED TO BE CHANGED TO BE NAME PPLMSGDEF       */
/* TO FOLLOW THE STANDARDS OF THE OTHER ROUTINES.                           */
/*                                                                          */
/* PPLRTLLNK.OPT MAY NEED TO BE EDITED TO GET RID OF UNIVERSAL SYMBOLD      */
/* SO THAT THERE WON'T BE EXTRA BAGAGE IN THE SHAREABLE IMAGE.              */
/*                                                                          */
/*-                                                                         */
/*			; SET LH TO 481 (DECIMAL).                          */
#define PPL$_FACILITY 481
#define PPL$_NORMAL 31555585
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  ALL IS WELL.                                              */
/*  USER ACTION:  ENJOY YOUR SUCCESS.  ALL THINGS MUST PASS.                */
/*--                                                                        */
#define PPL$_CREATED 31555601
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  ITEM WAS CREATED, AN ALTERNATE SUCCESS STATUS             */
/*		 INDICATING THE ITEM WAS NOT JUST SUCCESSFULLY FOUND.       */
/*  USER ACTION:  CONTINUE NORMALLY.                                        */
/*--                                                                        */
#define PPL$_NOONE_ENABLED 31555609
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  EVENT TRIGGER IS SUCCESSFULLY QUEUED, AND NO ONE IS       */
/*		 PRESENTLY ENABLED TO RECEIVE IT.  THE FIRST CALLER TO      */
/*		 ENABLE IT WILL RECEIVE IT.                                 */
/*  USER ACTION:  CONTINUE NORMALLY.                                        */
/*--                                                                        */
#define PPL$_NOT_AVAILABLE 31555617
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  ALTERNATE SUCCESS STATUS RETURNED WHEN USER REQUESTS      */
/*		 IMMEDIATE NON-BLOCKING ACCESS TO A RESOURCE WHICH          */
/*		 WAS NOT AVAILABLE.                                         */
/*  USER ACTION:  CONTINUE NORMALLY.                                        */
/*--                                                                        */
#define PPL$_CREATED_SOME 31555625
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  SOME OF THE REQUESTED ITEMS WERE CREATED, BUT NOT ALL.    */
/*  USER ACTION:  IF PROCESSING CAN CONTINUE WITH FEWER ITEMS THAN THOSE    */
/*		 REQUESTED, THEN CONTINUE NORMALLY.                         */
/*--                                                                        */
/*			; NOTE:  ERROR CODES MUST NOT OVERLAP SUCCESS CODES!!! */
/*			; SET SUB-SYSTEM SPECIFIC BIT FOR NOW.              */
/*			; SET LH TO 481 (DECIMAL)                           */
/****	EXCQUESIZ	<exceeded queue size, number of waiting processes at limit> */
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  TOO MANY CALLERS REQUIRED QUEUING.                        */
/*  USER ACTION:  RECODE TO REDUCE NUMBER OF CALLERS ACCESSING RESOURCE.    */
/*--                                                                        */
#define PPL$_INCOMPEXI 31556100
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  ALL PPL OBJECTS MUST HAVE UNIQUE NAMES.                   */
/*  USER ACTION:  RECODE THE CALL TO SPECIFY A DIFFERENT NAME.              */
/*--                                                                        */
#define PPL$_INSVIRMEM 31556108
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  CALLER DOES NOT HAVE SUFFICIENT AVAILABLE SPACE TO        */
/*		 COMPLETE REQUEST.                                          */
/*  USER ACTION:  IF YOU USE EXTENSIVE PPL SERVICES, TRY SPECIFYING A       */
/*		 LARGER VALUE TO PPL$INITIALIZE.  OTHERWISE, CHECK          */
/*		 YOUR SYSTEM QUOTAS TO SEE IF AN INCREASE IS NEEDED.        */
/*--                                                                        */
#define PPL$_INVDESC 31556116
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  DESCRIPTOR IS INVALID.                                    */
/*  USER ACTION:  RECODE TO CORRECT THE DESCRIPTOR.                         */
/*--                                                                        */
#define PPL$_INVELEID 31556124
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  SPECIFIED ELEMENT ID IS NOT A LEGITIMATE ID.              */
/*  USER ACTION:  EXAMINE PROGRAM CODE - SOME MODIFICATION OF THE           */
/*		 ELEMENT ID HAS OCCURRED.                                   */
/*--                                                                        */
#define PPL$_INVELENAM 31556132
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  ILLEGAL CHARACTER STRING.                                 */
/*  USER ACTION:  FIX THE CHARACTER STRING.                                 */
/*--                                                                        */
#define PPL$_INVELETYP 31556140
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  USER SPECIFIED AN ELEMENT WHICH CANNOT BE OPERATED        */
/*		 BY THE CALLED ROUTINE.                                     */
/*  USER ACTION:  RECODE TO PASS THE PROPER ELEMENT TYPE.                   */
/*--                                                                        */
#define PPL$_INVNUMCHI 31556148
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  USER REQUESTED CREATION OF A NUMBER < 1.                  */
/*  USER ACTION:  RECODE REQUEST TO USE THE PROPER VALUE.                   */
/*--                                                                        */
/****	INVQUESIZ	<invalid queue size, must be positive>              */
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  INVALID QUEUE SIZE.                                       */
/*  USER ACTION:  SPECIFY A POSITIVE NUMBER.                                */
/*--                                                                        */
#define PPL$_INVSEMINI 31556156
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  A SEMAPHORE INITIAL VALUE MUST BE <= ITS MAXIMUM.         */
/*  USER ACTION:  CHANGE THE SPECIFIED INITIAL VALUE.                       */
/*--                                                                        */
#define PPL$_INVSEMMAX 31556164
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  A SEMAPHORE'S MAXIMUM VALUE MUST BE POSITIVE.             */
/*  USER ACTION:  CHANGE THE SPECIFIED MAXIMUM VALUE.                       */
/*--                                                                        */
#define PPL$_LOCNOTEST 31556172
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  YOU CANNOT RELEASE A LOCK YOU HAVE NOT BEEN GRANTED.      */
/*  USER ACTION:  RECODE TO ASSURE THAT THE LOCK IS HELD BY THE             */
/*		 CALLER ATTEMPTING TO RELEASE IT.                           */
/*--                                                                        */
#define PPL$_NOSECEX 31556180
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  SECTION SPECIFIED FOR FLUSH OR DELETE DOES NOT EXIST.     */
/*  USER ACTION:  RECODE TO ASSURE THAT SECTION TO DELETE/FLUSH HAS BEEN    */
/*		 CREATED.                                                   */
/*--                                                                        */
/****	NOSHRM		<no shared memory exists>                           */
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  NO SHARED MEMORY EXISTS.                                  */
/*  USER ACTION:  DITTO.                                                    */
/*--                                                                        */
#define PPL$_NOSUCHELE 31556188
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  NO ELEMENT IS SPECIFIED BY THE INPUT ID.                  */
/*  USER ACTION:  RECODE TO ASSURE THAT THE INPUT ID IS FOR A               */
/*		 LEGITIMATELY CREATED ELEMENT.                              */
/*--                                                                        */
#define PPL$_NOSUCHLOC 31556196
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  NO LOCK ELEMENT IS SPECIFIED BY THE INPUT ID.             */
/*  USER ACTION:  RECODE TO ASSURE THAT THE INPUT ID IS FOR A               */
/*		 LEGITIMATELY CREATED LOCK ELEMENT.                         */
/*--                                                                        */
#define PPL$_NOSUCHNAM 31556204
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  INPUT NAME DOES NOT SPECIFY AN EXISTING ELEMENT.          */
/*  USER ACTION:  RECODE TO ASSURE THAT THE NAME MATCHES A CREATED          */
/*		 ELEMENT.                                                   */
/*--                                                                        */
#define PPL$_WRONUMARG 31556212
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  TOO MANY OR TOO FEW ARGUMENTS SPECIFIED IN THE CALL.      */
/*  USER ACTION:  RECODE USING PROPER NUMBER OF ARGUMENTS.                  */
/*--                                                                        */
#define PPL$_ABNTERMIN 31556220
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  ABNORMAL TERMINATION.                                     */
/*  USER ACTION:  AN APPLICATION PARTICIPANT HAS ENDED ABNORMALLY.          */
/*		 SOME APPLICATION-SPECIFIC RECOVERY MAY BE DESIRED.         */
/*--                                                                        */
#define PPL$_EXHNEVCAL 31556228
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  AN APPLICATION PARTICIPANT TERMINATED WITHOUT             */
/*		 EXECUTING ITS PPL EXIT HANDLER.                            */
/*  USER ACTION:  APPLICATION HAS BEEN ABNORMALLY TERMINATED.  SOME         */
/*		 APPLICATION-SPECIFIC RECOVERY MAY BE DESIRED.              */
/*--                                                                        */
#define PPL$_INVARG 31556236
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  A SPECIFIED ARGUMENT IS INVALID.                          */
/*  USER ACTION:  RECODE TO PASS THE PROPER ARGUMENT.                       */
/*--                                                                        */
#define PPL$_NOINIT 31556244
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  PPL$INITIALIZE MUST BE CALLED BEFORE THIS ROUTINE.        */
/*  USER ACTION:  RECODE TO ASSURE THAT CALLS ARE ISSUED IN PROPER ORDER.   */
/*		 PPL$INITIALIZE IS PERFORMED AUTOMATICALLY FOR MOST         */
/*		 CALLS, BUT NOT FOR THOSE WHICH REQUIRE THE PRIOR           */
/*		 CREATION OF AN ELEMENT.                                    */
/*--                                                                        */
#define PPL$_NONPIC 31556252
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  PPL CANNOT MAP REQUESTED ADDRESS SPACE TO THE SAME        */
/*		 ADDRESSES IN ALL PROCESSES.                                */
/*  USER ACTION:  IF IT IS CRITICAL TO THE APPLICATION THAT THE REQUESTED   */
/*		 SPACE APPEAR AT THE SAME ADDRESSES IN ALL PROCESSES,       */
/*		 THE USER MUST TAKE STEPS TO ASSURE THAT ENOUGH SPACE       */
/*		 IS MADE AVAILABLE.  THIS MAY REQUIRE INCREASING SYSTEM     */
/*		 QUOTAS OR RESERVING THE REQUIRED ADDRESSES THROUGH         */
/*		 LINKTIME OPERATIONS.                                       */
/*--                                                                        */
#define PPL$_SEMININON 31556260
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  IMPROPER INITIAL VALUE SPECIFIED.                         */
/*  USER ACTION:  RECODE TO ASSURE THAT PROPER VALUE IS PASSED.             */
/*--                                                                        */
#define PPL$_NOTIMP 31556268
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  A CALL HAS BEEN ISSUED TO AN UNIMPLEMENTED SERVICE.       */
/*  USER ACTION:  RECODE TO ELIMINATE THIS CALL.                            */
/*--                                                                        */
#define PPL$_ATTUSETWO 31556276
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  USER HAS ATTEMPTED TO WAIT ON 2 APPLICATION-WIDE          */
/*		 BARRIERS AT THE SAME TIME.                                 */
/*  USER ACTION:  RECODE TO ASSURE THAT DEADLOCK IS AVOIDED BY WAITING      */
/*		 ON ONLY ONE APPLICATION-WIDE BARRIER AT A TIME.            */
/*--                                                                        */
#define PPL$_IN_BARRIER_WAIT 31556284
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  THE BARRIER WAS ALREADY IN EFFECT AT THE TIME OF          */
/*		 THIS CALL.                                                 */
/*  USER ACTION:  RECODE TO ASSURE THAT THE BARRIER QUORUM IS ESTABLISHED   */
/*		 BEFORE ANYONE ATTEMPTS TO WAIT ON THE BARRIER.             */
/*--                                                                        */
#define PPL$_NO_SUCH_PARTY 31556292
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  SPECIFIED PARTICIPANT DOES NOT EXIST IN THIS              */
/*		 APPLICATION.                                               */
/*  USER ACTION:  RECODE TO ASSURE THAT PROPER PARTICIPANT IS SPECIFIED     */
/*		 IN THE CALL TO THIS ROUTINE.                               */
/*--                                                                        */
#define PPL$_BUFOVFL 31559680
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  BUFFER COULD NOT CONTAIN THE COMPLETE OUTPUT STRING.      */
/*  USER ACTION:  RECODE TO PASS A LARGER BUFFER.                           */
/*--                                                                        */
#define PPL$_ELEALREXI 31571971
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  AN ELEMENT BY THIS NAME ALREADY EXISTS, AND ITS           */
/*		 ID HAS BEEN RETURNED.                                      */
/*  USER ACTION:  CONTINUE NORMALLY IF THE NAME IS EXPECTED TO EXIST.       */
/*--                                                                        */
#define PPL$_SEMALRMAX 31571979
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  SEMAPHORE CANNOT BE INCREMENTED FURTHER.                  */
/*  USER ACTION:  RECODE TO ASSURE THAT ONLY THE PROPER MAXIMUM NUMBER      */
/*		 OF PPL$INCREMENT_SEMAPHORE REQUESTS ARE ISSUED.            */
/*--                                                                        */
/****	SEMALRZER	<semaphore value is already zero>                   */
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  SEMAPHORE VALUE ALREADY AT ZERO.                          */
/*  USER ACTION:  BOGUS MESSAGE.                                            */
/*--                                                                        */
#define PPL$_INTDELPRC 31571987
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  AN APPLICATION CALL TO PPL$STOP FORCED THE TEMINATION     */
/*		 OF THIS PARTICIPANT.                                       */
/*  USER ACTION:  SINCE THE APPLICATION ITSELF TERMINATED THIS PARTY,       */
/*		 ANY ACTIONS ARE APPLICATION-DEPENDENT.                     */
/*--                                                                        */
#define PPL$_INTTERMIN 31571995
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  AN APPLICATION CALL TO PPL$TERMINATE FORCED THE           */
/*		 TEMINATION OF THIS PARTICIPANT.                            */
/*  USER ACTION:  SINCE THE APPLICATION ITSELF TERMINATED THIS PARTY,       */
/*		 ANY ACTIONS ARE APPLICATION-DEPENDENT.                     */
/*--                                                                        */
#define PPL$_EXITSTATUS 31572003
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  AN APPLICATION PARTICIPANT EXITED WITH THIS STATUS.       */
/*  USER ACTION:  DETERMINE THE CAUSE OF THE TERMINATION BY EXAMINING       */
/*		 THE STATUS CODE.                                           */
/*--                                                                        */
#define PPL$_EVENT_OCCURRED 31572011
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  THIS CODE INDICATES THE OCCURRENCE OF AN EVENT FOR        */
/*		 WHICH NOTIFICATION HAS BEEN REQUESTED BY THE USER.         */
/*  USER ACTION:  SINCE THE APPLICATION REQUESTED THIS NOTIFICATION,        */
/*		 RESPONSE IS APPLICATION-DEPENDENT.                         */
/*--                                                                        */
/****	EXIT		<participant termination: ppl index: !UL status: !XL>/FAO=2 */
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  THIS CODE INDICATES THE OCCURRENCE OF THE PARTICIPANT     */
/*		 TERMINATION EVENT.  TERMINATION MAY BE EITHER MORAL        */
/*		 OR ABNORMAL.                                               */
/*  USER ACTION:  SINCE THE APPLICATION REQUESTED THIS NOTIFICATION,        */
/*		 RESPONSE IS APPLICATION-DEPENDENT.                         */
/*--                                                                        */
#define PPL$_NORMAL_EXIT 31572019
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  THIS CODE INDICATES THE OCCURRENCE OF THE NORMAL          */
/*		 PARTICIPANT TERMINATION EVENT.                             */
/*  USER ACTION:  SINCE THE APPLICATION REQUESTED THIS NOTIFICATION,        */
/*		 RESPONSE IS APPLICATION-DEPENDENT.                         */
/*--                                                                        */
#define PPL$_ABNORMAL_EXIT 31572027
/*++                                                                        */
/*  FACILITY:     PPL, RUN-TIME LIBRARY                                     */
/*  EXPLANATION:  THIS CODE INDICATES THE OCCURRENCE OF THE ABNORMAL        */
/*		 PARTICIPANT TERMINATION EVENT.                             */
/*  USER ACTION:  SINCE THE APPLICATION REQUESTED THIS NOTIFICATION,        */
/*		 RESPONSE IS APPLICATION-DEPENDENT.                         */
/*--                                                                        */

#endif					/* __PPLDEF_LOADED */
#ifndef __PQLDEF_LOADED
#define __PQLDEF_LOADED	1

/*** MODULE $pqldef ***/
/*+                                                                         */
/* PROCESS QUOTA LIST CODES                                                 */
/*-                                                                         */
#define PQL$_LISTEND 0                  /*LIST END CODE (MUST BE FIRST)     */
#define PQL$_ASTLM 1                    /*AST LIMIT                         */
#define PQL$_BIOLM 2                    /*BUFFERED I/O LIMIT                */
#define PQL$_BYTLM 3                    /*BYTE LIMIT FOR BUFFERED I/O       */
#define PQL$_CPULM 4                    /*CPU TIME LIMIT                    */
#define PQL$_DIOLM 5                    /*DIRECT I/O LIMIT                  */
#define PQL$_FILLM 6                    /*OPEN FILE LIMIT                   */
#define PQL$_PGFLQUOTA 7                /*PAGING FILE QUOTA                 */
#define PQL$_PRCLM 8                    /*SUB-PROCESS LIMIT                 */
#define PQL$_TQELM 9                    /*TIMER QUEUE ENTRY LIMIT           */
#define PQL$_WSQUOTA 10                 /*WORKING SET QUOTA                 */
#define PQL$_WSDEFAULT 11               /*WORKING SET DEFAULT               */
#define PQL$_ENQLM 12                   /*ENQUEUE LIMIT                     */
#define PQL$_WSEXTENT 13                /*WORKING SET EXTENT LIMIT          */
#define PQL$_JTQUOTA 14                 /*JOB-WIDE LOGICAL NAME TABLE CREATION QUOTA */
#define PQL$_LENGTH 15                  /*NUMBER OF QUOTAS (MUST BE LAST)   */
 

#endif					/* __PQLDEF_LOADED */
#ifndef __PRCDEF_LOADED
#define __PRCDEF_LOADED	1

/*** MODULE $prcdef ***/
/*+                                                                         */
/* $CREPRC STATUS FLAGS AND ITEM CODES                                      */
/*-                                                                         */
#define PRC$M_SSRWAIT 1
#define PRC$M_SSFEXCU 2
#define PRC$M_PSWAPM 4
#define PRC$M_NOACNT 8
#define PRC$M_BATCH 16
#define PRC$M_HIBER 32
#define PRC$M_NOUAF 64
#define PRC$M_NETWRK 128
#define PRC$M_DISAWS 256
#define PRC$M_DETACH 512
#define PRC$M_INTER 1024
#define PRC$M_IMGDMP 2048
#define PRC$M_CLISPEC 4096
#define PRC$M_NOPASSWORD 8192
#define PRC$M_DEBUG 16384
#define PRC$M_DBGTRU 32768
#define PRC$M_LOGIN 64
union prcdef {
    struct  {
        unsigned prc$v_ssrwait : 1;     /* RESOURCE WAIT DISABLE            */
        unsigned prc$v_ssfexcu : 1;     /* SYSTEM SERVICE FAIL EXCEPTION MODE  */
        unsigned prc$v_pswapm : 1;      /* PROCESS SWAP MODE                */
        unsigned prc$v_noacnt : 1;      /* ACCOUNTING MESSAGE DISABLE       */
        unsigned prc$v_batch : 1;       /* BATCH INDICATOR                  */
        unsigned prc$v_hiber : 1;       /* HIBERNATE BEFORE CALLING INITIAL IMAGE  */
        unsigned prc$v_nouaf : 1;       /* BYPASS LOGIN VERIFICATION FOR DETACHED PROC.  */
        unsigned prc$v_netwrk : 1;      /* NETWORK INDICATOR                */
        unsigned prc$v_disaws : 1;      /* DISABLE WORKING SET ADJUST       */
        unsigned prc$v_detach : 1;      /* DETACHED PROCESS                 */
        unsigned prc$v_inter : 1;       /* INTERACTIVE INDICATOR            */
        unsigned prc$v_imgdmp : 1;      /* IMAGE DUMP REQUESTED             */
        unsigned prc$v_clispec : 1;     /* PASS CLI SPECIFICATIONS          */
        unsigned prc$v_nopassword : 1;  /* DON'T PROMPT FOR USERNAME AND PASSWORD */
        unsigned prc$v_debug : 1;       /* /DEBUG desired                   */
        unsigned prc$v_dbgtru : 1;      /* debugger present                 */
        } prc$r_prcdef_bits;
    struct  {
        unsigned prc$v_fill_0 : 6;
        unsigned prc$v_login : 1;       /* BYPASS LOGIN VERIFICATION FOR DETACHED PROC.  */
        unsigned prc$v_fill_14 : 1;
        } prc$r_prcdef_obsolete;
    } ;
/*+                                                                         */
/*                                                                          */
/* Create Process Item List Data Identifier Definitions                     */
/*                                                                          */
/* **** NOTE ****                                                           */
/*                                                                          */
/*        New items must always be added at the END of the list so that     */
/*        users will not have to relink or reassemble.                      */
/*                                                                          */
/*-                                                                         */
#define PRC$_LISTEND 0                  /* End of list (must be first code) */
#define PRC$_PGFLCHAR 1                 /* Page file characteristics        */
#define PRC$_PGFLINDEX 2                /* Page file index                  */
#define PRC$_INPUT_ATT 3                /* SYS$INPUT attributes             */
#define PRC$_OUTPUT_ATT 4               /* SYS$OUTPUT attributes            */
#define PRC$_ERROR_ATT 5                /* SYS$ERROR attributes             */
 

#endif					/* __PRCDEF_LOADED */
#ifndef __PRDEF_LOADED
#define __PRDEF_LOADED	1

/*** MODULE $prdef ***/
/*+                                                                         */
/*  PROCESSOR REGISTER DEFINITIONS                                          */
/*-                                                                         */
#define PR$_KSP 0                       /*KERNEL STACK POINTER              */
#define PR$_ESP 1                       /*EXECUTIVE STACK POINTER           */
#define PR$_SSP 2                       /*SUPERVISOR STACK POINTER          */
#define PR$_USP 3                       /*USER STACK POINTER                */
#define PR$_ISP 4                       /*INTERRUPT STACK POINTER           */
#define PR$_P0BR 8                      /*P0 BASE REGISTER                  */
#define PR$_P0LR 9                      /*P0 LIMIT REGISTER                 */
#define PR$_P1BR 10                     /*P1 BASE REGISTER                  */
#define PR$_P1LR 11                     /*P1 LIMIT REGISTER                 */
#define PR$_SBR 12                      /*SYSTEM BASE REGISTER              */
#define PR$_SLR 13                      /*SYSTEM LIMIT REGISTER             */
#define PR$_PCBB 16                     /*PROCESS CONTROL BLOCK BASE        */
#define PR$_SCBB 17                     /*SYSTEM CONTROL BLOCK BASE         */
#define PR$_IPL 18                      /*INTERRUPT PRIORITY LEVEL REGISTER  */
#define PR$_ASTLVL 19                   /*AST LEVEL REGISTER                */
#define PR$_SIRR 20                     /*SOFTWARE INTERRUPT REQUEST REGISTER  */
#define PR$_SISR 21                     /*SOFTWARE INTERRUPT SUMMARY REGISTER  */
#define PR$_ICCS 24                     /* INTERVAL CLOCK CONTROL STATUS REGISTER  */
#define PR$_RXCS 32                     /* CONSOLE RECIEVER CONTROL STATUS REGISTER  */
#define PR$_RXDB 33                     /* CONSOLE RECEIVER DATA BUFFER REGISTER  */
#define PR$_TXCS 34                     /* CONSOLE TRANSMIT CONTROL STATUS REGISTER  */
#define PR$_TXDB 35                     /* CONSOLE TRANSMIT DATA BUFFER REGISTER  */
#define PR$_MAPEN 56                    /* MAPPING ENABLE REGISTER          */
#define PR$_TBIA 57                     /* TRANSLATION BUFFER INVALIDATE ALL  */
#define PR$_TBIS 58                     /* TRANSLATION BUFFER INVALIDATE SINGLE  */
#define PR$_SID 62                      /* SYSTEM IDENTIFICATION REGISTER   */
#define PR$_TBCHK 63                    /* TRANSLATION BUFFER VALID CHECK   */
#define PR$_SID_TYP780 1                /* VAX 11/780                       */
#define PR$_SID_TYP750 2                /* VAX 11/750                       */
#define PR$_SID_TYP730 3                /* VAX 11/730                       */
#define PR$_SID_TYP790 4                /* VAX 11/790                       */
#define PR$_SID_TYP8SS 5                /* Scorpio for now                  */
#define PR$_SID_TYP8NN 6                /* Nautilus for now                 */
#define PR$_SID_TYPUV1 7                /* MicroVAX I                       */
#define PR$_SID_TYPUV2 8                /* MicroVAX II                      */
#define PR$_SID_TYP410 8                /* VAXstar                          */
#define PR$_SID_TYP009 9                /* Virtual VAX                      */
#define PR$_SID_TYP650 10               /* Mayfair                          */
#define PR$_SID_TYP9CC 10               /* Calypso/XCP                      */
#define PR$_SID_TYP60 10                /* Firefox                          */
#define PR$_SID_TYP9RR 11               /* XRP                              */
#define PR$_SID_TYP8PS 17               /* Polarstar                        */
#define PR$_SID_TYPMAX 17               /* MAX LEGAL CPU TYPE               */
/*Chip CPU types                                                            */
#define PR$_SID_TYPUV 8                 /* MicroVAX chip                    */
/*MicroVAX chip CPU Subtypes                                                */
#define PR$_XSID_UV_UV 0                /* Generic MicroVAX (unused subtype) */
#define PR$_XSID_UV_UV2 1               /* MicroVAX II                      */
#define PR$_XSID_UV_410 4               /* VAXstar                          */
#define PR$_SID_TYPCV 10                /* CVAX chip                        */
/*CVAX chip CPU Subtypes                                                    */
#define PR$_XSID_CV_CV 0                /* Generic CVAX (unused subtype)    */
#define PR$_XSID_CV_650 1               /* Mayfair                          */
#define PR$_XSID_CV_9CC 2               /* Calypso/XCP                      */
#define PR$_XSID_CV_60 3                /* Firefox                          */
#define PR$_SID_TYPRV 11                /* XRP chip                         */
/*XRP chip CPU Subtypes                                                     */
#define PR$_XSID_RV_9RR 2               /* Calypso/XRP                      */
/*Nautilus CPU Subtypes                                                     */
#define PR$_XSID_N8800 0                /* VAX 8800                         */
#define PR$_XSID_N8700 1                /* VAX 8700                         */
#define PR$_XSID_N2 2                   /* Undefined Nautilus CPU           */
#define PR$_XSID_N3 3                   /* Undefined Nautilus CPU           */
#define PR$_XSID_N4 4                   /* Undefined Nautilus CPU           */
#define PR$_XSID_N5 5                   /* Undefined Nautilus CPU           */
#define PR$_XSID_N8550 6                /* VAX 8550                         */
#define PR$_XSID_N8500 7                /* VAX 8500                         */
#define PR$_XSID_N8NNN -1               /* Unknown Nautilus CPU             */
/*VAX 11/780 IPR'S:                                                         */
#define PR$_WCSA 44                     /* WCS ADDRESS REGISTER             */
#define PR$_WCSD 45                     /* WCS DATA REGISTER                */
#define PR$_SBIFS 48                    /* SBI FAULT STATUS REGISTER        */
#define PR$_SBIS 49                     /* SBI SILO REGISTER                */
#define PR$_SBISC 50                    /* SBI COMPARATOR REGISTER          */
#define PR$_SBIMT 51                    /* SBI MAINTENANCE REGISTER         */
#define PR$_SBIER 52                    /* SBI ERROR REGISTER               */
#define PR$_SBITA 53                    /* SBI TIMEOUT ADDRESS REGISTER     */
#define PR$_SBIQC 54                    /* SBI QUADWORD CLEAR REGISTER      */
/*END OF VAX 11/780-SPECIFIC IPR'S                                          */
#define PR$_CMIERR 23                   /* CMI ERROR SUMMARY REGISTER       */
#define PR$_CSRS 28                     /* CONSOLE BLK STORE RCV STATUS     */
#define PR$_CSRD 29                     /* CONSOLE BLK STORE RCV DATA       */
#define PR$_CSTS 30                     /* CONSOLE BLK STORE XMIT STATUS    */
#define PR$_CSTD 31                     /* CONSOLE BLK STORE XMIT DATA      */
#define PR$_TBDR 36                     /* TB DISABLE REGISTER              */
#define PR$_CADR 37                     /* CACHE DISABLE REGISTER           */
#define PR$_MCESR 38                    /* MACHINE CHECK ERROR SUMMARY REG  */
#define PR$_CAER 39                     /* CACHE ERROR REGISTER             */
#define PR$_UBRESET 55                  /* UNIBUS I/O RESET REGISTER        */
/*END OF 11/750 AND 11/730 IPR'S                                            */
#define PR$_PAMACC 64                   /* PAMM ACCESS                      */
#define PR$_PAMLOC 65                   /* PAMM LOCATION                    */
#define PR$_CSWP 66                     /* CACHE SWEEP REGISTER             */
#define PR$_MDECC 67                    /* MBOX DATA ECC REGISTER           */
#define PR$_MENA 68                     /* MBOX ERROR ENABLE REGISTER       */
#define PR$_MDCTL 69                    /* MBOX DATA CONTROL REGISTER       */
#define PR$_MCCTL 70                    /* MBOX MCC CONTROL REGISTER        */
#define PR$_MERG 71                     /* MBOX ERROR GENERATOR REGISTER    */
#define PR$_CRBT 72                     /* CONSOLE REBOOT                   */
#define PR$_DFI 73                      /* DIAGNOSTIC FAULT INSERTION       */
#define PR$_EHSR 74                     /* ERROR HANDLING STATUS REGISTER   */
#define PR$_ACCS790 75                  /* ACCELERATOR STATUS REGISTER      */
#define PR$_STXCS 76                    /* CONSOLE STORAGE CONTROL REG      */
#define PR$_STXDB 77                    /* CONSOLE STORAGE DATA REGISTER    */
#define PR$_LSPA 78                     /* SCRATCHPAD ADDRESS               */
#define PR$_RSPD 79                     /* SCRATCHPAD DATA                  */
/*END OF 11/790 PROCESSOR-SPECIFIC IPRS                                     */
union prdef {
#pragma nostandard
    variant_struct  {
        unsigned pr$v_sid_sn : 12;      /* SERIAL NUMBER FIELD              */
        unsigned pr$v_sid_pl : 3;       /* PLANT ID                         */
        unsigned pr$v_sid_eco : 9;      /* ECO LEVEL                        */
        unsigned pr$v_sid_type : 8;     /* CPU TYPE CODE                    */
        } pr$r_prdef_bits;
    variant_struct  {
        unsigned pr$v_fill_xsid_bits : 24; /* CPU-SPECIFIC XSID BITS        */
        unsigned pr$v_xsid_type : 8;    /* CPU SUBTYPE CODE                 */
        } pr$r_prdef_xbits;
/* SYSTEM ID REGISTER CPU TYPES                                             */
/* Number assignments are                                                   */
/* based upon the jumpers                                                   */
/* read by the console from                                                 */
/* the MPS backplane                                                        */
/*VAX 11/750 AND 11/730 IPR'S:                                              */
/*VAX 11/790 PROCESSOR-SPECIFIC IPRS                                        */
    } ;
 
#pragma standard

#endif					/* __PRDEF_LOADED */
#ifndef __PROCESSES_LOADED
#define __PROCESSES_LOADED	1

/*	PROCESSES - V3.0 - Prototypes for sub-process functions	*/

int	vfork	(void);
int	execl	(char *name, ...);
int	execlp	(char *name, ...);
int	execv	(char *name, char *argv[]);
int	execvp	(char *name, char *argv[]);
int	execle	(char *name, ...);
int	execve	(char *name, char *argv[], char *envp[]);
int	pipe	(int array_fdscptr[2], ...);
int	system	(const char *string);
int	wait	(int *status);

#endif					/* __PROCESSES_LOADED */
#ifndef __PRODEF_LOADED
#define __PRODEF_LOADED	1

/*** MODULE $prodef ***/
/*                                                                          */
/* GSD entry - Procedure definition, normal symbols                         */
/*                                                                          */
#define PRO$K_NAME 12
#define PRO$C_NAME 12
struct prodef {
#pragma nostandard
    variant_union  {
        unsigned char pro$b_gsdtyp;     /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char pro$t_start [];
            char prodef$$_fill_1;
            } pro$r_gsdtyp_fields;
        } pro$r_gsdtyp_overlay;
    unsigned char pro$b_datyp;          /*Maps over GSY$B_DATYP             */
    unsigned short int pro$w_flags;     /*Maps over GSY$W_FLAGS             */
    unsigned char pro$b_psindx;         /*Maps over SDF$B_PSINDX            */
    unsigned long int pro$l_addrs;      /*Entry point address, maps over SDF$L_VALUE  */
    unsigned short int pro$w_mask;      /*Entry point mask                  */
    unsigned char pro$b_namlng;         /*Length of name                    */
    char pro$t_name [31];               /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __PRODEF_LOADED */
#ifndef __PROMDEF_LOADED
#define __PROMDEF_LOADED	1

/*** MODULE $promdef ***/
/*                                                                          */
/* GSD entry - Procedure definition, version mask symbols                   */
/*                                                                          */
#define PROM$K_NAME 16
#define PROM$C_NAME 16
struct promdef {
#pragma nostandard
    variant_union  {
        unsigned char prom$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char prom$t_start [];
            char promdef$$_fill_1;
            } prom$r_gsdtyp_fields;
        } prom$r_gsdtyp_overlay;
    unsigned char prom$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int prom$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned char prom$b_psindx;        /*Maps over SDF$B_PSINDX            */
    unsigned long int prom$l_addrs;     /*Entry point address, maps over SDF$L_VALUE  */
    unsigned long int prom$l_version_mask; /*Mask value for symbol          */
    unsigned short int prom$w_mask;     /*Entry point mask                  */
    unsigned char prom$b_namlng;        /*Length of name                    */
    char prom$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __PROMDEF_LOADED */
#ifndef __PROVDEF_LOADED
#define __PROVDEF_LOADED	1

/*** MODULE $provdef ***/
/*                                                                          */
/* GSD entry - Procedure definition, vectored symbols                       */
/*                                                                          */
#define PROV$K_NAME 16
#define PROV$C_NAME 16
struct provdef {
#pragma nostandard
    variant_union  {
        unsigned char prov$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char prov$t_start [];
            char provdef$$_fill_1;
            } prov$r_gsdtyp_fields;
        } prov$r_gsdtyp_overlay;
    unsigned char prov$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int prov$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned char prov$b_psindx;        /*Maps over SDF$B_PSINDX            */
    unsigned long int prov$l_addrs;     /*Entry point address, maps over SDF$L_VALUE  */
    unsigned long int prov$l_vector;    /*Vectored entry point address      */
    unsigned short int prov$w_mask;     /*Entry point mask                  */
    unsigned char prov$b_namlng;        /*Length of name                    */
    char prov$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __PROVDEF_LOADED */
#ifndef __PROWDEF_LOADED
#define __PROWDEF_LOADED	1

/*** MODULE $prowdef ***/
/*                                                                          */
/* GSD entry - Procedure definition with word of psect value                */
/*                                                                          */
#define PROW$K_NAME 13
#define PROW$C_NAME 13
struct prowdef {
#pragma nostandard
    variant_union  {
        unsigned char prow$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char prow$t_start [];
            char prowdef$$_fill_1;
            } prow$r_gsdtyp_fields;
        } prow$r_gsdtyp_overlay;
    unsigned char prow$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int prow$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned short int prow$w_psindx;   /*Maps over SDFW$W_PSINDX           */
    unsigned long int prow$l_addrs;     /*Entry point address, maps over SDFW$L_VALUE  */
    unsigned short int prow$w_mask;     /*Entry point mask                  */
    unsigned char prow$b_namlng;        /*Length of name                    */
    char prow$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __PROWDEF_LOADED */
#ifndef __PRTDEF_LOADED
#define __PRTDEF_LOADED	1

/*** MODULE $prtdef ***/
/*+                                                                         */
/* PROTECTION FIELD DEFINITIONS                                             */
/*-                                                                         */
#define PRT$C_NA 0                      /* NO ACCESS                        */
#define PRT$C_KR 3                      /* KERNEL READ ONLY                 */
#define PRT$C_KW 2                      /* KERNEL WRITE                     */
#define PRT$C_ER 7                      /* EXEC READ ONLY                   */
#define PRT$C_EW 5                      /* EXEC WRITE                       */
#define PRT$C_SR 11                     /* SUPER READ ONLY                  */
#define PRT$C_SW 8                      /* SUPER WRITE                      */
#define PRT$C_UR 15                     /* USER READ ONLY                   */
#define PRT$C_UW 4                      /* USER WRITE                       */
#define PRT$C_ERKW 6                    /* EXEC READ KERNEL WRITE           */
#define PRT$C_SRKW 10                   /* SUPER READ KERNEL WRITE          */
#define PRT$C_SREW 9                    /* SUPER READ EXEC WRITE            */
#define PRT$C_URKW 14                   /* USER READ KERNEL WRITE           */
#define PRT$C_UREW 13                   /* USER READ EXEC WRITE             */
#define PRT$C_URSW 12                   /* USER READ SUPER WRITE            */
#define PRT$C_RESERVED 1                /* RESERVED                         */
 

#endif					/* __PRTDEF_LOADED */
#ifndef __PRVDEF_LOADED
#define __PRVDEF_LOADED	1

/*** MODULE $prvdef ***/
/*+                                                                         */
/* PRIVILEGE BIT DEFINITIONS                                                */
/*                                                                          */
/*	Note that any privileges added here must also be reflected in the   */
/*	modules [VMSLIB.SRC]SETPRIV.MAR, [CLIUTL.SRC]SHOWPROC.B32,          */
/*	[RTL.SRC]LIBLEXICA.B32, and                                         */
/*	[CLD.SRC]DCLINT.CLD, MCRINT.CLD, MCRSET.CLD, RUN.CLD, and SET.CLD   */
/*	to completely add the new privilege.                                */
/*                                                                          */
/*-                                                                         */
#define PRV$M_CMKRNL 1
#define PRV$M_CMEXEC 2
#define PRV$M_SYSNAM 4
#define PRV$M_GRPNAM 8
#define PRV$M_ALLSPOOL 16
#define PRV$M_DETACH 32
#define PRV$M_DIAGNOSE 64
#define PRV$M_LOG_IO 128
#define PRV$M_GROUP 256
#define PRV$M_NOACNT 512
#define PRV$M_PRMCEB 1024
#define PRV$M_PRMMBX 2048
#define PRV$M_PSWAPM 4096
#define PRV$M_SETPRI 8192
#define PRV$M_SETPRV 16384
#define PRV$M_TMPMBX 32768
#define PRV$M_WORLD 65536
#define PRV$M_MOUNT 131072
#define PRV$M_OPER 262144
#define PRV$M_EXQUOTA 524288
#define PRV$M_NETMBX 1048576
#define PRV$M_VOLPRO 2097152
#define PRV$M_PHY_IO 4194304
#define PRV$M_BUGCHK 8388608
#define PRV$M_PRMGBL 16777216
#define PRV$M_SYSGBL 33554432
#define PRV$M_PFNMAP 67108864
#define PRV$M_SHMEM 134217728
#define PRV$M_SYSPRV 268435456
#define PRV$M_BYPASS 536870912
#define PRV$M_SYSLCK 1073741824
#define PRV$M_SHARE -2147483648
#define PRV$M_ACNT 512
#define PRV$M_ALTPRI 8192
union prvdef {
#pragma nostandard
    variant_struct  {
        unsigned prv$v_cmkrnl : 1;      /* MAY CHANGE MODE TO KERNEL        */
        unsigned prv$v_cmexec : 1;      /* MAY CHANGE MODE TO EXEC          */
/* ***** THE PRECEEDING TWO BITS MUST BE ADJACENT                           */
/* ***** THE FOLLOWING TWO BITS MUST BE ADJACENT                            */
        unsigned prv$v_sysnam : 1;      /* MAY INSERT IN SYSTEM LOGICAL NAME TABLE  */
        unsigned prv$v_grpnam : 1;      /* MAY INSERT IN GROUP LOGICAL NAME TABLE  */
/* ***** THE PRECEEDING TWO BITS MUST BE ADJACENT                           */
        unsigned prv$v_allspool : 1;    /*MAY ALLOCATE SPOOLED DEVICE       */
        unsigned prv$v_detach : 1;      /* MAY CREATE DETACHED PROCESSES    */
        unsigned prv$v_diagnose : 1;    /* MAY DIAGNOSE DEVICES             */
        unsigned prv$v_log_io : 1;      /* MAY DO LOGICAL I/O               */
        unsigned prv$v_group : 1;       /* MAY AFFECT OTHER PROCESSES IN SAME GROUP  */
        unsigned prv$v_noacnt : 1;      /* MAY SUPPRESS ACCOUNTING MESSAGE  */
        unsigned prv$v_prmceb : 1;      /* MAY CREATE PERMANENT COMMON EVENT CLUSTERS  */
        unsigned prv$v_prmmbx : 1;      /* MAY CREATE PERMANENT MAILBOX     */
        unsigned prv$v_pswapm : 1;      /* MAY CHANGE PROCESS SWAP MODE     */
        unsigned prv$v_setpri : 1;      /* MAY SET ANY PRIORITY VALUE       */
        unsigned prv$v_setprv : 1;      /* MAY SET ANY PRIVILEGE BITS       */
        unsigned prv$v_tmpmbx : 1;      /* MAY CREATE TEMPORARY MAILBOX     */
        unsigned prv$v_world : 1;       /* MAY AFFECT OTHER PROCESSES IN THE WORLD  */
        unsigned prv$v_mount : 1;       /* MAY EXECUTE MOUNT ACP FUNCTIONS  */
        unsigned prv$v_oper : 1;        /* OPERATOR PRIVILEGE               */
        unsigned prv$v_exquota : 1;     /* MAY EXCEED QUOTAS                */
        unsigned prv$v_netmbx : 1;      /* MAY CREATE NETWORK DEVICE        */
        unsigned prv$v_volpro : 1;      /* MAY OVERRIDE VOLUME PROTECTION   */
        unsigned prv$v_phy_io : 1;      /* MAY DO PHYSICAL I/O              */
        unsigned prv$v_bugchk : 1;      /* MAY MAKE BUG CHECK ERROR LOG ENTRIES  */
        unsigned prv$v_prmgbl : 1;      /* MAY CREATE PERMANENT GLOBAL SECTIONS  */
        unsigned prv$v_sysgbl : 1;      /* MAY CREATE SYSTEM WIDE GLOBAL SECTIONS  */
        unsigned prv$v_pfnmap : 1;      /* MAY MAP TO SECTION BY PFN        */
        unsigned prv$v_shmem : 1;       /* MAY ALLOCATE STRUCTURES IN SHARED MEMORY  */
        unsigned prv$v_sysprv : 1;      /* ELIGIBLE FOR SYSTEM PROTECTION FIELD  */
        unsigned prv$v_bypass : 1;      /* MAY BYPASS UIC BASED PROTECTION  */
        unsigned prv$v_syslck : 1;      /* MAY CREATE SYSTEM WIDE LOCKS     */
        unsigned prv$v_share : 1;       /* MAY ASSIGN CHANNEL TO NON-SHARED DEVICE */
        unsigned prv$v_upgrade : 1;     /* May upgrade classification       */
        unsigned prv$v_downgrade : 1;   /* May downgrade classification     */
        unsigned prv$v_grpprv : 1;      /* Group access via system protection field */
        unsigned prv$v_readall : 1;     /* Read access to everything        */
        unsigned prvdef$$_fill_3 : 2;   /* spare 2 bits (used to be TMPJNL/PRMJNL) */
        unsigned prv$v_security : 1;    /* May perform security functions   */
        unsigned prv$v_fill_15 : 1;
        } prv$r_prvdef_bits0;
/* ***** THE FOLLOWING TWO BITS MUST BE ADJACENT                            */
    variant_struct  {
        unsigned prvdef$$_fill_1 : 9;   /* SKIP 9                           */
        unsigned prv$v_acnt : 1;        /* MAY SUPPRESS ACCOUNTING MESSAGES (NOACNT)  */
        unsigned prvdef$$_fill_2 : 3;   /* SKIP 3                           */
        unsigned prv$v_altpri : 1;      /* MAY SET ANY PRIORITY VALE (SETPRI)  */
        unsigned prv$v_fill_16 : 2;
        } prv$r_prvdef_bits1;
    } ;
 
#pragma standard

#endif					/* __PRVDEF_LOADED */
#ifndef __PSLDEF_LOADED
#define __PSLDEF_LOADED	1

/*** MODULE $psldef ***/
/*+                                                                         */
/* PROCESSOR STATUS LONGWORD MASK AND FIELD DEFINITIONS                     */
/*-                                                                         */
#define PSL$M_C 1
#define PSL$M_V 2
#define PSL$M_Z 4
#define PSL$M_N 8
#define PSL$M_TBIT 16
#define PSL$M_IV 32
#define PSL$M_FU 64
#define PSL$M_DV 128
#define PSL$M_IPL 2031616
#define PSL$M_PRVMOD 12582912
#define PSL$M_CURMOD 50331648
#define PSL$M_IS 67108864
#define PSL$M_FPD 134217728
#define PSL$M_TP 1073741824
#define PSL$M_CM -2147483648
#define PSL$C_KERNEL 0                  /* KERNEL MODE                      */
#define PSL$C_EXEC 1                    /* EXEC MODE                        */
#define PSL$C_SUPER 2                   /* SUPERVISOR MODE                  */
#define PSL$C_USER 3                    /* USER MODE                        */
#define PSL$M_SAFBITS 14335
union psldef {
#pragma nostandard
    variant_struct  {
        unsigned psl$v_c : 1;           /* Carry                            */
        unsigned psl$v_v : 1;           /* oVerflow                         */
        unsigned psl$v_z : 1;           /* Zero                             */
        unsigned psl$v_n : 1;           /* Negative                         */
        unsigned psl$v_tbit : 1;        /* TBIT ENABLE                      */
        unsigned psl$v_iv : 1;          /* INTEGER OVERFLOW                 */
        unsigned psl$v_fu : 1;          /* FLOATING UNDEFINED               */
        unsigned psl$v_dv : 1;          /* DIVIDE BY ZERO                   */
        unsigned psldef$$_fill_1 : 8;   /*                                  */
        unsigned psl$v_ipl : 5;         /* INTERRUPT PRIORITY LEVEL         */
        unsigned psldef$$_fill_2 : 1;   /*                                  */
        unsigned psl$v_prvmod : 2;      /* PREVIOUS PROCESSOR MODE          */
        unsigned psl$v_curmod : 2;      /* CURRENT PROCESSOR MODE           */
        unsigned psl$v_is : 1;          /* INTERRUPT STACK BIT              */
        unsigned psl$v_fpd : 1;         /* FIRST PART DONE                  */
        unsigned psldef$$_fill_3 : 2;   /* MUST BE ZERO                     */
        unsigned psl$v_tp : 1;          /* TRACE TRAP PENDING               */
        unsigned psl$v_cm : 1;          /* COMPATIBILITY MODE BIT AND MASK  */
        } psl$r_psldef_bits;
/*                                                                          */
/* MODE SYMBOL DEFINITIONS                                                  */
/*                                                                          */
    } ;
#pragma standard

#endif					/* __PSLDEF_LOADED */
#ifndef __PSMMSGDEF_LOADED
#define __PSMMSGDEF_LOADED	1

/*** MODULE $psmmsgdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:18:58.85 */
/*                                                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/* FACILITY:                                                                */
/*	PRINT SYMBIONT.                                                     */
/*                                                                          */
/* ABSTRACT:                                                                */
/*	SYMBIONT MESSAGES.                                                  */
/*                                                                          */
/* ENVIRONMENT:                                                             */
/*	VAX/VMS USER AND KERNEL MODE.                                       */
/*                                                                          */
/* AUTHOR: G. ROBERT, CREATION DATE: 31-AUG-1982                            */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	3B-010	BLS0336		BENN SCHREIBER		 5-AUG-1984         */
/*		ADD MISSING .END STATEMENT.                                 */
/*                                                                          */
/*	3B-009	RRB3009		ROWLAND R. BRADLEY	24-JUL-1984         */
/*		SEPARATE THE PSM MESSAGES AND THE SMB MESSAGES.             */
/*		                                                            */
/*	3B-008	GRR3008		GREGORY R. ROBERT	29-APR-1984         */
/*		ADDED PSM$_FLUSH                                            */
/*                                                                          */
/*	3B-007	GRR3007		GREGORY R. ROBERT	23-AUG-1983         */
/*		BUGFIXES, PAGE_SETUP_MODULES, FORM_SETUP_MODULES,           */
/*		SHEET_FEED, SYMBIONT INITIATED PAUSE_TASK AND STOP_STREAM,  */
/*		HANGUP CODE, READ AND WRITE ITEM SERVICES                   */
/*                                                                          */
/*	3B-006	GRR3006		GREGORY R. ROBERT	03-AUG-1983         */
/*		CHANGED FUNNOTSUP TO SUCCESS.                               */
/*                                                                          */
/*	3B-005	GRR3005		GREGORY R. ROBERT	29-JUL-1983         */
/*		ADDED MESSAGES FOR FT1.                                     */
/*                                                                          */
/*	3B-004	GRR3004		GREGORY R. ROBERT	23-JUN-1983         */
/*		ADDED "module not found" AND "too many levels" MESSAGES.    */
/*                                                                          */
/*	3B-003	GRR3003		GREGORY R. ROBERT	27-MAY-1983         */
/*		REMOVED UNUSED MESSAGES.  ADDED NOMOREITEMS AND INVSTMNBR.  */
/*                                                                          */
/*	3B-002	GRR3002		GREGORY R. ROBERT	04-APR-1983         */
/*		ADDED PSM$_NOMOREITEMS.                                     */
/*                                                                          */
/***                                                                        */
/*                                                                          */
/* THESE ARE THE MESSAGES COMMON TO VAX/VMS SYMBIONTS.  MESSAGE TYPES FOR   */
/* MESSAGES SENT FROM THE SYMBIONTS TO THE JOB CONTROLLER ARE DEFINED BY    */
/* THE $MSGDEF MACRO.                                                       */
/*                                                                          */
#define PSM$_FACILITY 262
#define PSM$_FUNNOTSUP 17203201
#define PSM$_PENDING 17203209
#define PSM$_FLUSH 17203217
#define PSM$_BUFFEROVF 17203224
#define PSM$_NEWPAGE 17203232
#define PSM$_SUSPEND 17203240
#define PSM$_ESCAPE 17203248
#define PSM$_EOF 17203258
#define PSM$_INVVMSOSC 17203266
#define PSM$_MODNOTFND 17203274
#define PSM$_NOFILEID 17203282
#define PSM$_OSCTOOLON 17203290
#define PSM$_TOOMANYLEV 17203298
#define PSM$_INVITMCOD 17203308
/*** MODULE $psmmsgdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:02.61 */
/*                                                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/* FACILITY:                                                                */
/*	SYMBIONT.                                                           */
/*                                                                          */
/* ABSTRACT:                                                                */
/*	SYMBIONT  MESSAGES.                                                 */
/*                                                                          */
/*	THESE ARE THE MESSAGES COMMON TO VAX/VMS SYMBIONTS.  MESSAGE TYPES FOR */
/*	MESSAGES SENT FROM THE SYMBIONTS TO THE JOB CONTROLLER ARE DEFINED BY */
/*	THE $MSGDEF MACRO.                                                  */
/*                                                                          */
/* ENVIRONMENT:                                                             */
/*	VAX/VMS USER AND KERNEL MODE.                                       */
/*                                                                          */
/* AUTHOR: ROWLAND R. BRADLEY, CREATION DATE: 20-JULY-1984                  */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	3B-010	BLS0336		BENN SCHREIBER		 5-AUG-1984         */
/*		ADD .END.                                                   */
/*                                                                          */
/*	3B-009	RRB0009		ROWLAND R. BRADLEY	20-JUL-184          */
/*		REMOVED THESE DEFINITIONS FOR SMB AND PLACED IN A SEPARATE  */
/*		FILE SMBMSG.MSG.  THIS ACCOMPLISHES THE RENAMING OF MESSAGES  */
/*		WITH A SEPARATE FACILITY CODE.  NOW TWO TYPES OF MESSAGES   */
/*		SMB$... AND PSM$... DEPENDING ON THE CONTEXT OF THE         */
/*		ERROR.  AUDIT TRAIL BEGINS AT HIGHER NUMBER SINCE THIS IS   */
/*		A CONTINUATION OF PSMMSG.MSG.                               */
/*                                                                          */
/***                                                                        */
/*                                                                          */
#define SMB$_FACILITY 272
#define SMB$_NOMOREITEMS 17858562
#define SMB$_INVSTMNBR 17858572
#define SMB$_INVSTRLEV 17858580

#endif					/* __PSMMSGDEF_LOADED */
#ifndef __PSWDEF_LOADED
#define __PSWDEF_LOADED	1

/*** MODULE $pswdef ***/
/*+                                                                         */
/* Define PSW bits (STARDEF.MDL has PSL bits)                               */
/*-                                                                         */
#define PSW$M_C 1
#define PSW$M_V 2
#define PSW$M_Z 4
#define PSW$M_N 8
#define PSW$M_TBIT 16
#define PSW$M_IV 32
#define PSW$M_FU 64
#define PSW$M_DV 128
union pswdef {
#pragma nostandard
    variant_struct  {
        unsigned psw$v_c : 1;           /* carry                            */
        unsigned psw$v_v : 1;           /* overflow                         */
        unsigned psw$v_z : 1;           /* zero                             */
        unsigned psw$v_n : 1;           /* negative                         */
        unsigned psw$v_tbit : 1;        /* trace trap enable                */
        unsigned psw$v_iv : 1;          /* integer overflow enable          */
        unsigned psw$v_fu : 1;          /* floating underflow enable        */
        unsigned psw$v_dv : 1;          /* decimal overflow enable          */
        } psw$r_pswdef_bits;
    } ;
 
#pragma standard

#endif					/* __PSWDEF_LOADED */
/*
 *      %W%     (DEC OSF/1)    %G%
 */
/*
 *  Copyright (c) 1990, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	Common Multithread Architecture (CMA) services; POSIX 1003.4 interface
 *
 *  ABSTRACT:
 *
 *	External definitions for CMA's pthreads services
 *
 *  AUTHORS:
 *
 *	Dave Butenhof
 *
 *  CREATION DATE:
 * 
 *	20 February 1990
 *
 *  MODIFICATION HISTORY:
 *
 *	001	Dave Butenhof	6 March 1990
 *		Some PTHREAD constants are defined in terms of CMA enums;
 *		they need to be cast to (int) to prevent complaints by some
 *		compilers.
 *	002	Dave Butenhof	2 May 1990
 *		Implement cancel and push/pop handlers (on top of CMA
 *		exception handling and alerts).
 *	003	Dave Butenhof	18 May 1990
 *		Change pthread_cond_timedwait to use struct timespec.
 *	004	Dave Butenhof	12 June 1990
 *		Add pthread_delay_np and pthread_get_expiration_np.
 *	005	Dave Butenhof	22 June 1990
 *		Update interface to 1003.4a/D3 (May 11, 1990).  This includes
 *		changing synchronization variable parameters from "value" to
 *		"reference", but does not include degenerating attributes
 *		objects to public structures.  It also does not include the
 *		new event operations.
 *	006	Dave Butenhof	27 June 1990
 *		Clean up some, and implement "pthread_equal_np" macro.
 *	007	Dave Butenhof	29 June 1990
 *		Change interface to pthread_get_expiration_np (an in and an
 *		out instead of just one modify).
 *	008	Dave Butenhof	2 July 1990
 *		Add constants and functions for controlling whether mutex
 *		locks can nest within a thread ("friendly mutexes").
 *	009	Dave Butenhof	27 July 1990
 *		Fix pthread_equal
 *	010	Dave Butenhof	5 October 1990
 *		Implement pthread_lock_global_np and
 *		pthread_unlock_global_np.
 *	011	Dave Butenhof	9 October 1990
 *		Use new _CMA_IMPORT_ symbol to import the pthread
 *		distinguished handled.
 *	012	Paul Curtin	20 November 1990
 *		Removed p from pthread in posix_pthread_attr_stacksize.
 *		Added two new defines for; realtime scheduling, and signals.
 *	013	Paul Curtin	21 November 1990
 *		Switch order of arguments to pthread_keycreate
 *	014	Dave Butenhof	12 February 1991
 *		Change "friendly" mutex to "recursive", add "nonrecursive"
 *	015	Webb Scales	19 February 1991
 *		Add CMA scheduling symbols for Pthreads.
 *	016	Dave Butenhof	20 March 1991
 *		Remove _POSIX_PROCESS_SCHEDULING option, since we don't
 *		support it.
 *	017	Dave Butenhof	29 May 1991
 *		Remove the realtime scheduling option under OSF/1 when
 *		using kernel threads, since it doesn't (yet) support POSIX
 *		scheduling for Mach threads.
 *	018	Dave Butenhof	05 June 1991
 *		Remove include of cma_px.h, which is already included by
 *		cma.h.
 *	019	Dave Butenhof	10 June 1991
 *		Create pthread_getunique_np
 *	020	Webb Scales	 2 July 1991
 *		Add typedefs for OSF/1 compatibility.
 *	021	Dave Butenhof	07 October 1991
 *		Add pthread_attr_setguardsize_np &
 *		pthread_attr_getguardsize_np functions.
 *	022	Dave Butenhof	29 October 1991
 *		OSF/1 unistd.h defines _POSIX_THREADS and
 *		_POSIX_THREAD_ATTR_STACKSIZE, and cc (with -std1) is
 *		complaining about the redefinition here. Don't redefine if
 *		they're already defined.
 *	023	Dave Butenhof	15 November 1991
 *		Add omitted prototype for pthread_signal_to_cancel_np().
 *	024	Dave Butenhof	02 December 1991
 *		Add pthread_cond_signal_int_np().
 */

#ifndef PTHREAD
#define PTHREAD

#ifdef vms
# include <cma.h>
#else
# include <dce/cma.h>
# include <signal.h>
#endif

/*
 * The implementation makes these basic decisions
 */

#ifndef _POSIX_THREADS
# define _POSIX_THREADS				1
#endif
#ifndef _POSIX_THREAD_ATTR_STACKSIZE
# define _POSIX_THREAD_ATTR_STACKSIZE		1
#endif
#if _CMA_KTHREADS_ != _CMA__MACH
# define _POSIX_THREADS_REALTIME_SCHEDULING	1
#elif defined (_POSIX_THREADS_REALTIME_SCHEDULING)
# undef _POSIX_THREADS_REALTIME_SCHEDULING
#endif
#ifndef _POSIX_THREADS_PER_PROCESS_SIGNALS_1
# define _POSIX_THREADS_PER_PROCESS_SIGNALS_1	1
#endif

/*
 * Implement push and pop for cancellation handlers, using TRY and ENDTRY
 */

#define pthread_cleanup_push(routine,arg)	\
    { \
    pthread_cleanup_t _XXX_proc = (pthread_cleanup_t)(routine); \
    pthread_addr_t _XXX_arg = (pthread_addr_t)(arg); \
    int _XXX_completed = 0; \
    TRY {

#define pthread_cleanup_pop(execute)	\
    _XXX_completed = 1;} \
    FINALLY { \
	if ((! _XXX_completed) || (execute)) _XXX_proc (_XXX_arg);} \
    ENDTRY}

#define pthread_equal_np(thread1,thread2) \
    (((thread1).field1 == (thread2).field1) \
    && ((thread1).field2 == (thread2).field2))

#define pthread_equal(thread1,thread2) \
    (((thread1).field1 == (thread2).field1) \
    && ((thread1).field2 == (thread2).field2))

#define pthread_getunique_np(handle) \
    (((unsigned int)((pthread_t *)handle)->field2) & 0xffff)

/*
 * Sample decisions for the environment types
 */

typedef	cma_t_key		pthread_key_t;

typedef cma_t_address		pthread_addr_t;
/*
 * For compatibility with OSF/1 pthreads
 */
typedef pthread_addr_t		any_t;

typedef void (*pthread_cleanup_t) _CMA_PROTOTYPE_ ((pthread_addr_t arg));

/*
 * Sample decision for a one-time initialization control block and its
 * initialization macro.
 *
 * Declare a one time initialization control block as:
 *
 *	static pthread_once_t	block = pthread_once_init;
 */
typedef cma_t_once	pthread_once_t;

#define pthread_once_init	cma_once_init

#define CANCEL_ON	1
#define CANCEL_OFF	0

/*
 * The following are the portable pthread definitions
 */

/*
 * Operations on Handles
 */

/*
 * Operations on attributes objects
 */

typedef cma_t_attr	pthread_attr_t;

/*
 * An attributes object is created to specify the attributes of other CMA
 * objects that will be created.
 */

int
pthread_attr_create _CMA_PROTOTYPE_ ((
	pthread_attr_t		*attr));

/*
 * An attributes object can be deleted when it is no longer needed.
 */

int
pthread_attr_delete _CMA_PROTOTYPE_ ((
	pthread_attr_t		*attr));

/*
 * Operations on threads
 */

typedef cma_t_thread		pthread_t;
typedef cma_t_start_routine	pthread_startroutine_t;
/*
 * For compatibility with OSF/1 pthreads
 */
typedef pthread_startroutine_t	pthread_func_t;

#define PTHREAD_INHERIT_SCHED	((int)cma_c_sched_inherit)
#define PTHREAD_DEFAULT_SCHED	((int)cma_c_sched_use_default)

#define SCHED_FIFO		((int)cma_c_sched_fifo)
#define SCHED_RR		((int)cma_c_sched_rr)
#define SCHED_FG_NP		((int)cma_c_sched_throughput)
#define SCHED_BG_NP		((int)cma_c_sched_background)
#define SCHED_OTHER		((int)cma_c_sched_throughput)

#define PRI_FIFO_MIN		((int)cma_c_prio_fifo_min)
#define PRI_FIFO_MAX		((int)cma_c_prio_fifo_max)
#define PRI_RR_MIN		((int)cma_c_prio_rr_min)
#define PRI_RR_MAX		((int)cma_c_prio_rr_max)
#define PRI_FG_MIN_NP		((int)cma_c_prio_through_min)
#define PRI_FG_MAX_NP		((int)cma_c_prio_through_max)
#define PRI_BG_MIN_NP		((int)cma_c_prio_back_min)
#define PRI_BG_MAX_NP		((int)cma_c_prio_back_max)
#define PRI_OTHER_MIN		((int)cma_c_prio_through_min)
#define PRI_OTHER_MAX		((int)cma_c_prio_through_max)

/*
 * Operations to define thread creation attributes
 */

/*
 * Set or obtain the default thread priority.
 */
int
pthread_attr_setprio _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	int		priority));

int
pthread_attr_getprio _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * Set or obtain the default scheduling algorithm
 */
int
pthread_attr_setsched _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	int		scheduler));

int
pthread_attr_getsched _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * Set or obtain whether a thread will use the default scheduling attributes,
 * or inherit them from the creating thread.
 */
int
pthread_attr_setinheritsched _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	int		inherit));

int
pthread_attr_getinheritsched _CMA_PROTOTYPE_ ((
	pthread_attr_t		attr));

/*
 * Set or obtain the default stack size
 */
int
pthread_attr_setstacksize _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	long		stacksize));

long
pthread_attr_getstacksize _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * Set or obtain the default guard size
 */
int
pthread_attr_setguardsize_np _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	long		guardsize));

long
pthread_attr_getguardsize_np _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * The following procedures can be used to control thread creation,
 * termination and deletion.
 */

/*
 * To create a thread object and runnable thread, a routine must be specified
 * as the new thread's start routine.  An argument may be passed to this
 * routine, as an untyped address; an untyped address may also be returned as
 * the routine's value.  An attributes object may be used to specify details
 * about the kind of thread being created.
 */
int
pthread_create _CMA_PROTOTYPE_ ((
	pthread_t		*thread,
	pthread_attr_t		attr,
	pthread_startroutine_t	start_routine,
	pthread_addr_t		arg));

/*
 * A thread object may be "detached" to specify that the return value and
 * completion status will not be requested.
 */
int
pthread_detach _CMA_PROTOTYPE_ ((
	pthread_t		*thread));

/* 
 * A thread may terminate it's own execution.
 */
void
pthread_exit _CMA_PROTOTYPE_ ((
	pthread_addr_t 		status));

/* 
 * A thread can await termination of another thread and retrieve the return
 * value of the thread.
 */
int
pthread_join _CMA_PROTOTYPE_ ((
	pthread_t		thread,
	pthread_addr_t		*status));

/*
 * Thread Scheduling Operations
 */

/*
 * The current user_assigned priority of a thread can be changed.
 */
int
pthread_setprio _CMA_PROTOTYPE_ ((
	pthread_t	thread,
	int		priority));

/*
 * The current user_assigned scheduler algorithm of a thread can be changed.
 */
int
pthread_setscheduler _CMA_PROTOTYPE_ ((
	pthread_t	thread,
	int		scheduler,
	int		priority));

/*
 * A thread may tell the scheduler that its processor can be made available.
 */
void
pthread_yield _CMA_PROTOTYPE_ ((void));

/*
 * Thread Information Operations
 */

/*
 * A thread may obtain a copy of its own thread handle.
 */
pthread_t
pthread_self _CMA_PROTOTYPE_ ((void));

/*
 * The current user_assigned priority of a thread can be read.
 */
int
pthread_getprio _CMA_PROTOTYPE_ ((
	pthread_t	thread));

/*
 * The current user_assigned scheduler algorithm of a thread can be read.
 */
int
pthread_getscheduler _CMA_PROTOTYPE_ ((
	pthread_t	thread));

/*
 * Operations on Mutexes
 */

#define MUTEX_FAST_NP		0
#define MUTEX_RECURSIVE_NP	1
#define MUTEX_NONRECURSIVE_NP	2

typedef cma_t_attr	pthread_mutexattr_t;
typedef	cma_t_mutex	pthread_mutex_t;

int
pthread_mutexattr_create _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	*attr));

int
pthread_mutexattr_delete _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	*attr));

int
pthread_mutexattr_setkind_np _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	*attr,
	int			kind));

int
pthread_mutexattr_getkind_np _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	attr));

/* 
 * The following routines create, delete, lock and unlock mutexes.
 */
int
pthread_mutex_init _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex,
	pthread_mutexattr_t	attr));

int
pthread_mutex_destroy _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

int
pthread_mutex_lock _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

int
pthread_mutex_trylock _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

int
pthread_mutex_unlock _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

/*
 * Operations on condition variables
 */

typedef cma_t_attr	pthread_condattr_t;
typedef cma_t_cond	pthread_cond_t;

int
pthread_condattr_create _CMA_PROTOTYPE_ ((
	pthread_condattr_t	*attr));

int
pthread_condattr_delete _CMA_PROTOTYPE_ ((
	pthread_condattr_t	*attr));

/*
 * A thread can create and delete condition variables.
 */
int
pthread_cond_init _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond,
	pthread_condattr_t	attr));

int
pthread_cond_destroy _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

/*
 * A thread can signal to and broadcast on a condition variable.
 */
int
pthread_cond_broadcast _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

int
pthread_cond_signal _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

int
pthread_cond_signal_int_np _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

/*
 * A thread can wait for a condition variable to be signalled or broadcast.
 */
int
pthread_cond_wait _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond,
	pthread_mutex_t		*mutex));

/*
 * Operations for timed waiting
 */

/*
 * A thread can perform a timed wait on a condition variable.
 */
int
pthread_cond_timedwait _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond,
	pthread_mutex_t		*mutex,
	struct timespec		*abstime));

/*
 * Operations for client initialization.
 */

typedef void (*pthread_initroutine_t) _CMA_PROTOTYPE_ ((void));

int
pthread_once _CMA_PROTOTYPE_ ((
	pthread_once_t		*once_block,
	pthread_initroutine_t	init_routine));

/*
 * Operations for per-thread context
 */

typedef cma_t_destructor	pthread_destructor_t;

/*
 * A unique per-thread context key can be obtained for the process
 */
int
pthread_keycreate _CMA_PROTOTYPE_ ((
	pthread_key_t		*key,
	pthread_destructor_t	destructor));

/*
 * A thread can set a per-thread context value identified by a key.
 */
int
pthread_setspecific _CMA_PROTOTYPE_ ((
	pthread_key_t	key,
	pthread_addr_t	value));

/*
 * A thread can retrieve a per-thread context value identified by a key.
 */
int
pthread_getspecific _CMA_PROTOTYPE_ ((
	pthread_key_t	key,
	pthread_addr_t	*value));

/*
 * Operations for alerts.
 */

/*
 * The current thread can request that a thread terminate it's execution.
 */

int
pthread_cancel _CMA_PROTOTYPE_ ((
	pthread_t	thread));

/*
 * The current thread can poll for alert delivery.
 */
void
pthread_testcancel _CMA_PROTOTYPE_ ((void));

/*
 * The current thread can enable or disable alert delivery (PTHREAD
 * "cancels"); it can control "general cancelability" (CMA "defer") or
 * just "asynchronous cancelability" (CMA "asynch disable").
 */
int
pthread_setasynccancel _CMA_PROTOTYPE_ ((
	int	state));

int
pthread_setcancel _CMA_PROTOTYPE_ ((
	int	state));

_CMA_IMPORT_ pthread_attr_t		pthread_attr_default;
_CMA_IMPORT_ pthread_mutexattr_t	pthread_mutexattr_default;
_CMA_IMPORT_ pthread_condattr_t		pthread_condattr_default;

/*
 * Define nonportable extensions
 */

extern int
pthread_get_expiration_np _CMA_PROTOTYPE_ ((
	struct timespec	*delta,
	struct timespec	*abstime));

extern int
pthread_delay_np _CMA_PROTOTYPE_ ((
	struct timespec	*interval));

extern void
pthread_lock_global_np _CMA_PROTOTYPE_ ((void));

extern void
pthread_unlock_global_np _CMA_PROTOTYPE_ ((void));

# if _CMA_OS_ != _CMA__VMS
extern int
pthread_signal_to_cancel_np _CMA_PROTOTYPE_ ((
	sigset_t	*sigset,
	pthread_t	*thread));
# endif

#endif
/*  DEC/CMS REPLACEMENT HISTORY, Element PTHREAD.H */
/*  *17    2-DEC-1991 12:37:24 BUTENHOF "pthread_cond_signal_int_np" */
/*  *16   18-NOV-1991 11:22:51 BUTENHOF "Add prototype for signal_to_cancel_np" */
/*  *15   31-OCT-1991 12:40:46 BUTENHOF "Fix errors where OSF/1 has already defined POSIX feature macros" */
/*  *14   14-OCT-1991 13:43:00 BUTENHOF "Fix header file locations" */
/*  *13    2-JUL-1991 21:02:04 SCALES "Add typedefs to for OSF/1 compatibility" */
/*  *12   10-JUN-1991 19:59:15 SCALES "Convert to stream format for ULTRIX build" */
/*  *11   10-JUN-1991 19:22:44 BUTENHOF "Fix the sccs headers" */
/*  *10   10-JUN-1991 18:25:45 SCALES "Add sccs headers for Ultrix" */
/*  *9    10-JUN-1991 14:13:03 BUTENHOF "Add macro to extract thread sequence #" */
/*  *8     5-JUN-1991 17:32:16 BUTENHOF "On UNIX platforms, most headers are in dce/" */
/*  *7    29-MAY-1991 17:02:25 BUTENHOF "Currently on OSF/1 based system, no priority" */
/*  *6     1-APR-1991 18:10:30 BUTENHOF "Add pthread_signal_to_cancel_np()" */
/*  *5    21-MAR-1991 09:26:59 BUTENHOF "" */
/*  *4    19-FEB-1991 22:11:29 SCALES "Add scheduling symbols" */
/*  *3    13-FEB-1991 17:54:56 BUTENHOF "Change mutex attribute name symbols" */
/*  *2    12-FEB-1991 23:10:02 BUTENHOF "Recursive/nonrecursive mutexes" */
/*  *1    12-DEC-1990 21:48:44 BUTENHOF "P1003.4a support" */
/*  DEC/CMS REPLACEMENT HISTORY, Element PTHREAD.H */
/*
 *	%W%	(DEC OSF/1)	%G%
 */
/*
 *  Copyright (c) 1990, 1991 by
 *  Digital Equipment Corporation, Maynard Massachusetts.
 *  All rights reserved.
 *
 *  This software is furnished under a license and may be used and  copied
 *  only  in  accordance  with  the  terms  of  such  license and with the
 *  inclusion of the above copyright notice.  This software or  any  other
 *  copies  thereof may not be provided or otherwise made available to any
 *  other person.  No title to and ownership of  the  software  is  hereby
 *  transferred.
 *
 *  The information in this software is subject to change  without  notice
 *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment
 *  Corporation.
 *
 *  DIGITAL assumes no responsibility for the use or  reliability  of  its
 *  software on equipment which is not supplied by DIGITAL.
 */

/*
 *  FACILITY:
 *
 *	Common Multithread Architecture (CMA) services; POSIX 1003.4 interface
 *	
 *	Exception Generating Pthreads Interface (ptdexc)
 *
 *  ABSTRACT:
 *
 *	External definitions for CMA's pthreads exception (ptdexc) services
 *
 *  AUTHORS:
 *
 *	Paul Curtin
 *
 *  CREATION DATE:
 * 
 *	27 August 1990
 *
 *  MODIFICATION HISTORY:
 *
 *	001	Dave Butenhof	10 October 1990
 *		Use _CMA_IMPORT_ config symbol for distinguished handles
 *	002	Paul Curtin	9 November 1990
 *		Removed _e from pthread_equal routines 
 *	003	Paul Curtin	20 November 1990
 *		Removed p from pthread in posix_pthread_attr_stacksize
 *		Added two new defines for; realtime scheduling, and signals.
 *	004	Paul Curtin	21 November 1990
 *		Swithed order of arguments to pthread_keycreate
 *	005	Paul Curtin	21 January 1991
 *		Changed *_illinst to *_illinstr to match cma.h
 *	006	Dave Butenhof	22 January 1991
 *		Fix exception names
 *	007	Paul Curtin	04 February 1991
 *		Adjusted a couple of names.
 *	008	Dave Butenhof	4 February 1991
 *		New function names
 *	009	Dave Butenhof	7 February 1991
 *		Fix name of delay function (for some reason, it was defined
 *		as "pthread_e_delay_e_np").
 *	010	Dave Butenhof	12 February 1991
 *		Change "friendly" mutex to "recursive", add "nonrecursive"
 *	011	Webb Scales	19 February 1991
 *		Add CMA scheduling symbols for Pthreads.
 *	012	Dave Butenhof	20 March 1991
 *		Remove _POSIX_PROCESS_SCHEDULING option, since we don't
 *		support it.
 *	013	Dave Butenhof	26 March 1991
 *		Move exception definitions to exc_handling.h
 *	014	Paul Curtin	24 April 1991
 *		Adding missing def for pthread_cond_wait
 *	015	Webb Scales	24 April 1991
 *		Corrected typedef for initroutine_t
 *	016	Dave Butenhof	29 May 1991
 *		Remove the realtime scheduling option under OSF/1 when
 *		using kernel threads, since it doesn't (yet) support POSIX
 *		scheduling for Mach threads.
 *	017	Dave Butenhof	05 June 1991
 *		Remove include of cma_px.h, which is already included by
 *		cma.h.
 *	018	Dave Butenhof	10 June 1991
 *		Create pthread_getunique_np
 *	019	Webb Scales	 2 July 1991
 *		Add typedefs for OSF/1 compatibility.
 *	020	Paul Curtin	22 August 1991
 *		Added define for pthread_get_expiration_np.
 *	021	Dave Butenhof	07 October 1991
 *		Add pthread_attr_setguardsize_np &
 *		pthread_attr_getguardsize_np functions.
 *	022	Dave Butenhof	29 October 1991
 *		OSF/1 unistd.h defines _POSIX_THREADS and
 *		_POSIX_THREAD_ATTR_STACKSIZE, and cc (with -std1) is
 *		complaining about the redefinition here. Don't redefine if
 *		they're already defined.
 *	023	Dave Butenhof	15 November 1991
 *		Add omitted prototype for pthread_signal_to_cancel_np().
 *	024	Dave Butenhof	02 December 1991
 *		Add pthread_cond_signal_int_np().
 */

#ifndef PTHREAD_EXC
#define PTHREAD_EXC

#ifdef vms
# include <cma.h>
#else
# include <dce/cma.h>
# include <signal.h>
#endif

/*
 * The implementation makes these basic decisions
 */

#ifndef _POSIX_THREADS
# define _POSIX_THREADS				1
#endif
#ifndef _POSIX_THREAD_ATTR_STACKSIZE
# define _POSIX_THREAD_ATTR_STACKSIZE		1
#endif
#if _CMA_KTHREADS_ != _CMA__MACH
# define _POSIX_THREADS_REALTIME_SCHEDULING	1
#elif defined (_POSIX_THREADS_REALTIME_SCHEDULING)
# undef _POSIX_THREADS_REALTIME_SCHEDULING
#endif
#ifndef _POSIX_THREADS_PER_PROCESS_SIGNALS_1
# define _POSIX_THREADS_PER_PROCESS_SIGNALS_1	1
#endif

/*
 * Implement push and pop for cancellation handlers, using TRY and ENDTRY
 */

#define pthread_cleanup_push(routine,arg)	\
    { \
    pthread_cleanup_t _XXX_proc = (pthread_cleanup_t)(routine); \
    pthread_addr_t _XXX_arg = (pthread_addr_t)(arg); \
    int _XXX_completed = 0; \
    TRY {

#define pthread_cleanup_pop(execute)	\
    _XXX_completed = 1;} \
    FINALLY { \
	if ((! _XXX_completed) || (execute)) _XXX_proc (_XXX_arg);} \
    ENDTRY}


/*
 *  Macros used to convert normal pthread routine calls to exception 
 *  returning routines.  This is done by including this file, pthread_exc.h,
 *  in the place of pthread.h .
 */


#define pthread_equal_np(thread1,thread2) \
    (((thread1).field1 == (thread2).field1) \
    && ((thread1).field2 == (thread2).field2))

#define pthread_equal(thread1,thread2) \
    (((thread1).field1 == (thread2).field1) \
    && ((thread1).field2 == (thread2).field2))

#define pthread_getunique_np(handle) \
    (((unsigned int)((pthread_t *)handle)->field2) & 0xffff)

#define pthread_attr_create(attr) \
    ptdexc_attr_create(attr)

#define pthread_attr_delete(attr) \
    ptdexc_attr_delete(attr)

#define pthread_attr_setprio(attr,priority) \
    ptdexc_attr_setprio(attr,priority)

#define pthread_attr_getprio(attr) \
    ptdexc_attr_getprio(attr)

#define pthread_attr_setsched(attr,scheduler) \
    ptdexc_attr_setsched(attr,scheduler)

#define pthread_attr_getsched(attr) \
    ptdexc_attr_getsched(attr)

#define pthread_attr_setinheritsched(attr,inherit) \
    ptdexc_attr_setinheritsched(attr,inherit)

#define pthread_attr_getinheritsched(attr) \
    ptdexc_attr_getinheritsched(attr)

#define pthread_attr_setstacksize(attr,stacksize) \
    ptdexc_attr_setstacksize(attr,stacksize)

#define pthread_attr_getstacksize(attr) \
    ptdexc_attr_getstacksize(attr)

#define pthread_attr_setguardsize_np(attr,guardsize) \
    ptdexc_attr_setguardsize_np(attr,guardsize)

#define pthread_attr_getguardsize_np(attr) \
    ptdexc_attr_getguardsize_np(attr)

#define pthread_create(thread,attr,start_routine,arg) \
    ptdexc_create(thread,attr,start_routine,arg)

#define pthread_detach(thread) \
    ptdexc_detach(thread)

#define pthread_exit(status) \
    ptdexc_exit(status)

#define pthread_get_expiration_np(delta,abstime) \
    ptdexc_get_expiration_np(delta,abstime)

#define pthread_join(thread,status) \
    ptdexc_join(thread,status)

#define pthread_setprio(thread,priority) \
    ptdexc_setprio(thread,priority)

#define pthread_setscheduler(thread,scheduler,priority) \
    ptdexc_setscheduler(thread,scheduler,priority)

#define pthread_yield() \
    ptdexc_yield()

#define pthread_self() \
    ptdexc_self()

#define pthread_getprio(thread) \
    ptdexc_getprio(thread)

#define pthread_getscheduler(thread) \
    ptdexc_getscheduler(thread)

#define pthread_mutexattr_create(attr) \
    ptdexc_mutexattr_create(attr)

#define pthread_mutexattr_delete(attr) \
    ptdexc_mutexattr_delete(attr)

#define pthread_mutexattr_setkind_np(attr,kind) \
    ptdexc_mutexattr_setkind_np(attr,kind)

#define pthread_mutexattr_getkind_np(attr) \
    ptdexc_mutexattr_getkind_np(attr)

#define pthread_mutex_init(mutex,attr) \
    ptdexc_mutex_init(mutex,attr)

#define pthread_mutex_destroy(mutex) \
    ptdexc_mutex_destroy(mutex)

#define pthread_mutex_lock(mutex) \
    ptdexc_mutex_lock(mutex)

#define pthread_mutex_trylock(mutex) \
    ptdexc_mutex_trylock(mutex)

#define pthread_mutex_unlock(mutex) \
    ptdexc_mutex_unlock(mutex)

#define pthread_condattr_create(attr) \
    ptdexc_condattr_create(attr)

#define pthread_condattr_delete(attr) \
    ptdexc_condattr_delete(attr)

#define pthread_cond_init(cond,attr) \
    ptdexc_cond_init(cond,attr)

#define pthread_cond_destroy(cond) \
    ptdexc_cond_destroy(cond)

#define pthread_cond_broadcast(cond) \
    ptdexc_cond_broadcast(cond)

#define pthread_cond_signal(cond) \
    ptdexc_cond_signal(cond)

#define pthread_cond_signal_int_np(cond) \
    ptdexc_cond_signal_int_np(cond)

#define pthread_cond_wait(cond,mutex) \
    ptdexc_cond_wait(cond,mutex)

#define pthread_cond_timedwait(cond,mutex,abstime) \
    ptdexc_cond_timedwait(cond,mutex,abstime)

#define pthread_once(once_block,init_routine) \
    ptdexc_once(once_block,init_routine)

#define pthread_keycreate(key,destructor) \
    ptdexc_keycreate(key,destructor)

#define pthread_setspecific(key,value) \
    ptdexc_setspecific(key,value)

#define pthread_getspecific(key,value) \
    ptdexc_getspecific(key,value)

#define pthread_mutexattr_setkind(attr,kind) \
    ptdexc_mutexattr_setkind_np(attr,kind)

#define pthread_mutexattr_getkind(attr) \
    ptdexc_mutexattr_getkind_np(attr)

#define pthread_cancel(thread) \
    ptdexc_cancel(thread)

#define pthread_testcancel() \
    ptdexc_testcancel()

#define pthread_setasynccancel(state) \
    ptdexc_setasynccancel(state)

#define pthread_setcancel(state) \
    ptdexc_setcancel(state)

#define pthread_delay_np(interval) \
    ptdexc_delay_np(interval)

#define pthread_lock_global_np() \
    ptdexc_lock_global_np()

#define pthread_unlock_global_np() \
    ptdexc_unlock_global_np()

#define pthread_signal_to_cancel_np(sigset,thread) \
    ptdexc_signal_to_cancel_np(sigset,thread)

/*
 * Sample decisions for the environment types
 */

typedef	cma_t_key		pthread_key_t;

typedef cma_t_address		pthread_addr_t;
/*
 * For compatibility with OSF/1 pthreads
 */
typedef pthread_addr_t		any_t;

typedef void (*pthread_cleanup_t) _CMA_PROTOTYPE_ ((pthread_addr_t arg));

/*
 * Sample decision for a one-time initialization control block and its
 * initialization macro.
 *
 * Declare a one time initialization control block as:
 *
 *	static pthread_once_t	block = pthread_once_init;
 */
typedef cma_t_once	pthread_once_t;

#define pthread_once_init	cma_once_init

#define CANCEL_ON	1
#define CANCEL_OFF	0

/*
 * The following are the portable pthread definitions
 */

/*
 * Operations on Handles
 */

/*
 * Operations on attributes objects
 */

typedef cma_t_attr	pthread_attr_t;

/*
 * An attributes object is created to specify the attributes of other CMA
 * objects that will be created.
 */

void
ptdexc_attr_create _CMA_PROTOTYPE_ ((
	pthread_attr_t		*attr));

/*
 * An attributes object can be deleted when it is no longer needed.
 */

void
ptdexc_attr_delete _CMA_PROTOTYPE_ ((
	pthread_attr_t		*attr));

/*
 * Operations on threads
 */

typedef cma_t_thread		pthread_t;
typedef cma_t_start_routine	pthread_startroutine_t;
/*
 * For compatibility with OSF/1 pthreads
 */
typedef pthread_startroutine_t	pthread_func_t;

#define PTHREAD_INHERIT_SCHED	((int)cma_c_sched_inherit)
#define PTHREAD_DEFAULT_SCHED	((int)cma_c_sched_use_default)

#define SCHED_FIFO		((int)cma_c_sched_fifo)
#define SCHED_RR		((int)cma_c_sched_rr)
#define SCHED_FG_NP		((int)cma_c_sched_throughput)
#define SCHED_BG_NP		((int)cma_c_sched_background)
#define SCHED_OTHER		((int)cma_c_sched_throughput)

#define PRI_FIFO_MIN		((int)cma_c_prio_fifo_min)
#define PRI_FIFO_MAX		((int)cma_c_prio_fifo_max)
#define PRI_RR_MIN		((int)cma_c_prio_rr_min)
#define PRI_RR_MAX		((int)cma_c_prio_rr_max)
#define PRI_FG_MIN_NP		((int)cma_c_prio_through_min)
#define PRI_FG_MAX_NP		((int)cma_c_prio_through_max)
#define PRI_BG_MIN_NP		((int)cma_c_prio_back_min)
#define PRI_BG_MAX_NP		((int)cma_c_prio_back_max)
#define PRI_OTHER_MIN		((int)cma_c_prio_through_min)
#define PRI_OTHER_MAX		((int)cma_c_prio_through_max)

/*
 * Operations to define thread creation attributes
 */

/*
 * Set or obtain the default thread priority.
 */
void
ptdexc_attr_setprio _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	int		priority));

int
ptdexc_attr_getprio _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * Set or obtain the default scheduling algorithm
 */
void
ptdexc_attr_setsched _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	int		scheduler));

int
ptdexc_attr_getsched _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * Set or obtain whether a thread will use the default scheduling attributes,
 * or inherit them from the creating thread.
 */
void
ptdexc_attr_setinheritsched _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	int		inherit));

int
ptdexc_attr_getinheritsched _CMA_PROTOTYPE_ ((
	pthread_attr_t		attr));

/*
 * Set or obtain the default stack size
 */
void
ptdexc_attr_setstacksize _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	long		stacksize));

long
ptdexc_attr_getstacksize _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * Set or obtain the default guard size
 */
void
ptdexc_attr_setguardsize_np _CMA_PROTOTYPE_ ((
	pthread_attr_t	*attr,
	long		guardsize));

long
ptdexc_attr_getguardsize_np _CMA_PROTOTYPE_ ((
	pthread_attr_t	attr));

/*
 * The following procedures can be used to control thread creation,
 * termination and deletion.
 */

/*
 * To create a thread object and runnable thread, a routine must be specified
 * as the new thread's start routine.  An argument may be passed to this
 * routine, as an untyped address; an untyped address may also be returned as
 * the routine's value.  An attributes object may be used to specify details
 * about the kind of thread being created.
 */
void
ptdexc_create _CMA_PROTOTYPE_ ((
	pthread_t		*thread,
	pthread_attr_t		attr,
	pthread_startroutine_t	start_routine,
	pthread_addr_t		arg));

/*
 * A thread object may be "detached" to specify that the return value and
 * completion status will not be requested.
 */
void
ptdexc_detach _CMA_PROTOTYPE_ ((
	pthread_t		*thread));

/* 
 * A thread may terminate it's own execution.
 */
void
ptdexc_exit _CMA_PROTOTYPE_ ((
	pthread_addr_t 		status));

/* 
 * A thread can await termination of another thread and retrieve the return
 * value of the thread.
 */
void
ptdexc_join _CMA_PROTOTYPE_ ((
	pthread_t		thread,
	pthread_addr_t		*status));

/*
 * Thread Scheduling Operations
 */

/*
 * The current user_assigned priority of a thread can be changed.
 */
int
ptdexc_setprio _CMA_PROTOTYPE_ ((
	pthread_t	thread,
	int		priority));

/*
 * The current user_assigned scheduler algorithm of a thread can be changed.
 */
int
ptdexc_setscheduler _CMA_PROTOTYPE_ ((
	pthread_t	thread,
	int		scheduler,
	int		priority));

/*
 * A thread may tell the scheduler that its processor can be made available.
 */
void
ptdexc_yield _CMA_PROTOTYPE_ ((void));

/*
 * Thread Information Operations
 */

/*
 * A thread may obtain a copy of its own thread handle.
 */
pthread_t
ptdexc_self _CMA_PROTOTYPE_ ((void));

/*
 * The current user_assigned priority of a thread can be read.
 */
int
ptdexc_getprio _CMA_PROTOTYPE_ ((
	pthread_t	thread));

/*
 * The current user_assigned scheduler algorithm of a thread can be read.
 */
int
ptdexc_getscheduler _CMA_PROTOTYPE_ ((
	pthread_t	thread));

/*
 * Operations on Mutexes
 */

#define MUTEX_FAST_NP		0
#define MUTEX_RECURSIVE_NP	1
#define MUTEX_NONRECURSIVE_NP	2

typedef cma_t_attr	pthread_mutexattr_t;
typedef	cma_t_mutex	pthread_mutex_t;

void
ptdexc_mutexattr_create _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	*attr));

void
ptdexc_mutexattr_delete _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	*attr));

void
ptdexc_mutexattr_setkind_np _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	*attr,
	int			kind));

int
ptdexc_mutexattr_getkind_np _CMA_PROTOTYPE_ ((
	pthread_mutexattr_t	attr));

/* 
 * The following routines create, delete, lock and unlock mutexes.
 */
void
ptdexc_mutex_init _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex,
	pthread_mutexattr_t	attr));

void
ptdexc_mutex_destroy _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

void
ptdexc_mutex_lock _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

int
ptdexc_mutex_trylock _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

void
ptdexc_mutex_unlock _CMA_PROTOTYPE_ ((
	pthread_mutex_t		*mutex));

/*
 * Operations on condition variables
 */

typedef cma_t_attr	pthread_condattr_t;
typedef cma_t_cond	pthread_cond_t;

void
ptdexc_condattr_create _CMA_PROTOTYPE_ ((
	pthread_condattr_t	*attr));

void
ptdexc_condattr_delete _CMA_PROTOTYPE_ ((
	pthread_condattr_t	*attr));

/*
 * A thread can create and delete condition variables.
 */
void
ptdexc_cond_init _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond,
	pthread_condattr_t	attr));

void
ptdexc_cond_destroy _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

/*
 * A thread can signal to and broadcast on a condition variable.
 */
void
ptdexc_cond_broadcast _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

void
ptdexc_cond_signal _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

void
ptdexc_cond_signal_int_np _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond));

/*
 * A thread can wait for a condition variable to be signalled or broadcast.
 */
void
ptdexc_cond_wait _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond,
	pthread_mutex_t		*mutex));

/*
 * Operations for timed waiting
 */

/*
 * A thread can perform a timed wait on a condition variable.
 */
int
ptdexc_cond_timedwait _CMA_PROTOTYPE_ ((
	pthread_cond_t		*cond,
	pthread_mutex_t		*mutex,
	struct timespec		*abstime));

/*
 * Operations for client initialization.
 */

typedef void (*pthread_initroutine_t) _CMA_PROTOTYPE_ ((void));

void
ptdexc_once _CMA_PROTOTYPE_ ((
	pthread_once_t		*once_block,
	pthread_initroutine_t	init_routine));

/*
 * Operations for per-thread context
 */

typedef cma_t_destructor	pthread_destructor_t;

/*
 * A unique per-thread context key can be obtained for the process
 */
void
ptdexc_keycreate _CMA_PROTOTYPE_ ((
	pthread_key_t		*key,
	pthread_destructor_t	destructor));

/*
 * A thread can set a per-thread context value identified by a key.
 */
void
ptdexc_setspecific _CMA_PROTOTYPE_ ((
	pthread_key_t	key,
	pthread_addr_t	value));

/*
 * A thread can retrieve a per-thread context value identified by a key.
 */
void
ptdexc_getspecific _CMA_PROTOTYPE_ ((
	pthread_key_t	key,
	pthread_addr_t	*value));

/*
 * Operations for alerts.
 */

/*
 * The current thread can request that a thread terminate it's execution.
 */

void
ptdexc_cancel _CMA_PROTOTYPE_ ((
	pthread_t	thread));

/*
 * The current thread can poll for alert delivery.
 */
void
ptdexc_testcancel _CMA_PROTOTYPE_ ((void));

/*
 * The current thread can enable or disable alert delivery (PTHREAD
 * "cancels"); it can control "general cancelability" (CMA "defer") or
 * just "asynchronous cancelability" (CMA "asynch disable").
 */
int
ptdexc_setasynccancel _CMA_PROTOTYPE_ ((
	int	state));

int
ptdexc_setcancel _CMA_PROTOTYPE_ ((
	int	state));

_CMA_IMPORT_ pthread_attr_t		pthread_attr_default;
_CMA_IMPORT_ pthread_mutexattr_t	pthread_mutexattr_default;
_CMA_IMPORT_ pthread_condattr_t		pthread_condattr_default;

/*
 * Define nonportable extensions
 */

extern int
ptdexc_get_expiration_np _CMA_PROTOTYPE_ ((
	struct timespec	*delta,
	struct timespec	*abstime));

extern void
ptdexc_delay_np _CMA_PROTOTYPE_ ((
	struct timespec	*interval));

extern void
ptdexc_lock_global_np _CMA_PROTOTYPE_ ((void));

extern void
ptdexc_unlock_global_np _CMA_PROTOTYPE_ ((void));

# if _CMA_OS_ != _CMA__VMS
extern void
ptdexc_signal_to_cancel_np _CMA_PROTOTYPE_ ((
	sigset_t	*sigset,
	pthread_t	*thread));
# endif

#endif
/*  DEC/CMS REPLACEMENT HISTORY, Element PTHREAD_EXC.H */
/*  *27    2-DEC-1991 12:37:31 BUTENHOF "pthread_cond_signal_int_np" */
/*  *26   18-NOV-1991 14:39:01 BUTENHOF "Fix an oops" */
/*  *25   18-NOV-1991 11:22:59 BUTENHOF "Add prototype for signal_to_cancel_np" */
/*  *24   31-OCT-1991 12:40:54 BUTENHOF "Fix errors where OSF/1 has already defined POSIX feature macros" */
/*  *23   14-OCT-1991 13:43:06 BUTENHOF "Fix header file locations" */
/*  *22   22-AUG-1991 13:11:05 CURTIN "adding a definition for pthread_get_expiration_np" */
/*  *21    2-JUL-1991 21:02:08 SCALES "Add typedefs for OSF/1 compatibility" */
/*  *20   10-JUN-1991 19:59:27 SCALES "Convert to stream format for ULTRIX build" */
/*  *19   10-JUN-1991 19:22:48 BUTENHOF "Fix the sccs headers" */
/*  *18   10-JUN-1991 18:25:49 SCALES "Add sccs headers for Ultrix" */
/*  *17   10-JUN-1991 14:13:08 BUTENHOF "Add macro to extract thread sequence #" */
/*  *16    5-JUN-1991 17:32:23 BUTENHOF "On UNIX platforms, most headers are in dce/" */
/*  *15   29-MAY-1991 17:02:30 BUTENHOF "Currently on OSF/1 based system, no priority" */
/*  *14   24-APR-1991 18:43:52 SCALES "Correct definition of pthread_initroutine_t" */
/*  *13   24-APR-1991 12:21:53 CURTIN "added a missing definition" */
/*  *12    1-APR-1991 18:10:37 BUTENHOF "Fix up exceptions" */
/*  *11   21-MAR-1991 09:27:04 BUTENHOF "" */
/*  *10   19-FEB-1991 22:11:40 SCALES "Add scheduling symbols" */
/*  *9    13-FEB-1991 17:55:01 BUTENHOF "Change mutex attribute name symbols" */
/*  *8    12-FEB-1991 23:10:06 BUTENHOF "Recursive/nonrecursive mutexes" */
/*  *7    12-FEB-1991 01:29:47 BUTENHOF "Fix name of delay function" */
/*  *6     5-FEB-1991 01:00:13 BUTENHOF "Change pthread exc interface names" */
/*  *5     4-FEB-1991 13:56:15 CURTIN "Changed a couple of names" */
/*  *4    24-JAN-1991 00:35:44 BUTENHOF "Exception changes" */
/*  *3    21-JAN-1991 13:26:59 CURTIN "changed *_illinst to *_illinstr" */
/*  *2    28-DEC-1990 00:04:55 BUTENHOF "Change exception names" */
/*  *1    12-DEC-1990 21:48:47 BUTENHOF "P1003.4a support" */
/*  DEC/CMS REPLACEMENT HISTORY, Element PTHREAD_EXC.H */
#ifndef __QUIDEF_LOADED
#define __QUIDEF_LOADED	1

/*** MODULE $quidef ***/
/*                                                                          */
/* Get Queue Information Service ($GETQUI) definitions.                     */
/*                                                                          */
/* NOTE:  New items must always be added at the end so users will not have to relink. */
/*                                                                          */
/* NOTE:  Update [VMSLIB.SRC]QUITABLE.MAR to reflect changes in $QUIDEF.    */
/*                                                                          */
/*                                                                          */
/* Function codes                                                           */
/*                                                                          */
#define QUI$_CANCEL_OPERATION 1         /* Cancel a wildcard operation      */
#define QUI$_DISPLAY_CHARACTERISTIC 2   /* Return characteristic attributes */
#define QUI$_DISPLAY_FILE 3             /* Return file attributes           */
#define QUI$_DISPLAY_FORM 4             /* Return form attributes           */
#define QUI$_DISPLAY_JOB 5              /* Return job attributes            */
#define QUI$_DISPLAY_QUEUE 6            /* Return queue attributes          */
#define QUI$_TRANSLATE_QUEUE 7          /* Validate and translate queue name */
#define QUI$_DISPLAY_ENTRY 8            /* Return entry (job) attributes (without first having to establish queue context) */
#define QUI$_RESERVED_FUNC_9 9          /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_FUNC_10 10        /* Reserved for Digital use (name may change) */
/*                                                                          */
/* Item codes                                                               */
/*                                                                          */
#define QUI$_ACCOUNT_NAME 1             /* Job: Submitter's account name    */
#define QUI$_AFTER_TIME 2               /* Job: /AFTER=time                 */
#define QUI$_ASSIGNED_QUEUE_NAME 3      /* Queue: ASSIGN/QUEUE target       */
#define QUI$_BASE_PRIORITY 4            /* Queue: /BASE_PRIORITY=n          */
#define QUI$_CHARACTERISTIC_NAME 5      /* Characteristic: Name             */
#define QUI$_CHARACTERISTIC_NUMBER 6    /* Characteristic: Number           */
#define QUI$_CHARACTERISTICS 7          /* Job, queue: /CHARACTERISTICS=(c,...) */
#define QUI$_CHECKPOINT_DATA 8          /* Job: Checkpoint data             */
#define QUI$_CLI 9                      /* Job: /CLI=filename               */
#define QUI$_COMPLETED_BLOCKS 10        /* Job: Completed blocks including checkpoint */
#define QUI$_CONDITION_VECTOR 11        /* Job: Completion status           */
#define QUI$_CPU_DEFAULT 12             /* Queue: /CPUDEFAULT=t             */
#define QUI$_CPU_LIMIT 13               /* Job, queue: /CPUMAXIMUM=t        */
#define QUI$_DEVICE_NAME 14             /* Queue: /ON=device                */
#define QUI$_ENTRY_NUMBER 15            /* Job: Entry number                */
#define QUI$_FILE_COPIES 16             /* File: /COPIES=n                  */
#define QUI$_FILE_COPIES_CHKPT 17       /* File: File copies checkpoint (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_FILE_COPIES_DONE 18        /* File: File copies completed      */
#define QUI$_FILE_FLAGS 19              /* File: Boolean information        */
#define QUI$_FILE_SETUP_MODULES 20      /* File: /SETUP=(module,...)        */
#define QUI$_FILE_SPECIFICATION 21      /* File: Full file specification    */
#define QUI$_FILE_STATUS 22             /* File: Status information         */
#define QUI$_FIRST_PAGE 23              /* File: /PAGES=(n,"")              */
#define QUI$_FORM_DESCRIPTION 24        /* Form: /DESCRIPTION=string        */
#define QUI$_FORM_FLAGS 25              /* Form: Boolean information        */
#define QUI$_FORM_LENGTH 26             /* Form: /LENGTH=n                  */
#define QUI$_FORM_MARGIN_BOTTOM 27      /* Form: /MARGIN=BOTTOM=n           */
#define QUI$_FORM_MARGIN_LEFT 28        /* Form: /MARGIN=LEFT=n             */
#define QUI$_FORM_MARGIN_RIGHT 29       /* Form: /MARGIN=RIGHT=n            */
#define QUI$_FORM_MARGIN_TOP 30         /* Form: /MARGIN=TOP=n              */
#define QUI$_FORM_NAME 31               /* Form, job, queue: Form name      */
#define QUI$_FORM_NUMBER 32             /* Form: Number                     */
#define QUI$_FORM_SETUP_MODULES 33      /* Form: /SETUP=(module,...)        */
#define QUI$_FORM_STOCK 34              /* Form: /STOCK=stock-name          */
#define QUI$_FORM_WIDTH 35              /* Form: /WIDTH=n                   */
#define QUI$_GENERIC_TARGET 36          /* Queue: /GENERIC=(queue-name,...) */
#define QUI$_INTERVENING_BLOCKS 37      /* Job: Intervening pending blocks  */
#define QUI$_INTERVENING_JOBS 38        /* Job: Intervening pending jobs    */
#define QUI$_JOB_COPIES 39              /* Job: /JOB_COUNT=n                */
#define QUI$_JOB_COPIES_CHKPT 40        /* Job: Job copies checkpoint (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_JOB_COPIES_DONE 41         /* Job: Job copies completed        */
#define QUI$_JOB_FLAGS 42               /* Job: Boolean information         */
#define QUI$_JOB_LIMIT 43               /* Queue: /JOB_LIMIT=n              */
#define QUI$_JOB_NAME 44                /* Job: Name                        */
#define QUI$_JOB_RESET_MODULES 45       /* Queue: /SEPARATE=RESET=(module,...) */
#define QUI$_JOB_SIZE 46                /* Job: Total blocks in job         */
#define QUI$_JOB_SIZE_MAXIMUM 47        /* Queue: /BLOCK_LIMIT=n            */
#define QUI$_JOB_SIZE_MINIMUM 48        /* Queue: /BLOCK_LIMIT=(n,"")       */
#define QUI$_JOB_STATUS 49              /* Job: Status information          */
#define QUI$_LAST_PAGE 50               /* File: /PAGES=n                   */
#define QUI$_LIBRARY_SPECIFICATION 51   /* Queue: /LIBRARY=file-specification */
#define QUI$_LOG_QUEUE 52               /* Job: /PRINTER=queue-name         */
#define QUI$_LOG_SPECIFICATION 53       /* Job: /LOG_FILE=file-specification */
#define QUI$_NOTE 54                    /* Job: /NOTE=string                */
#define QUI$_OPERATOR_REQUEST 55        /* Job: /OPERATOR=string            */
#define QUI$_OWNER_UIC 56               /* Queue: /OWNER=uic                */
#define QUI$_PAGE_SETUP_MODULES 57      /* Form: /PAGE_SETUP=(module,...)   */
#define QUI$_PARAMETER_1 58             /* Job: /PARAMETER=string           */
#define QUI$_PARAMETER_2 59
#define QUI$_PARAMETER_3 60
#define QUI$_PARAMETER_4 61
#define QUI$_PARAMETER_5 62
#define QUI$_PARAMETER_6 63
#define QUI$_PARAMETER_7 64
#define QUI$_PARAMETER_8 65
#define QUI$_PRIORITY 66                /* Job: /PRIORITY=n                 */
#define QUI$_PROCESSOR 67               /* Queue: /PROCESSOR=filename       */
#define QUI$_PROTECTION 68              /* Queue: /PROTECTION=mask          */
#define QUI$_QUEUE_FLAGS 69             /* Queue: Boolean information       */
#define QUI$_QUEUE_NAME 70              /* Job, queue: Queue name           */
#define QUI$_QUEUE_STATUS 71            /* Queue: Status information        */
#define QUI$_REFUSAL_REASON 72          /* Job: Reason symbiont refused job (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_REQUEUE_PRIORITY 73        /* Job: Priority after requeue (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_REQUEUE_QUEUE_NAME 74      /* Job: Queue after requeue         */
#define QUI$_SCSNODE_NAME 75            /* Queue: /ON=node::                */
#define QUI$_SEARCH_FLAGS 76            /* Flags to control search          */
#define QUI$_SEARCH_NAME 77             /* Object name to search for	    */
#define QUI$_SEARCH_NUMBER 78           /* Object number to search for      */
#define QUI$_SUBMISSION_TIME 79         /* Job: Submission time             */
#define QUI$_UIC 80                     /* Job: Submitter's UIC             */
#define QUI$_USERNAME 81                /* Job: Submitter's username        */
#define QUI$_WSDEFAULT 82               /* Job, queue: /WSDEFAULT=n         */
#define QUI$_WSEXTENT 83                /* Job, queue: /WSEXTENT=n          */
#define QUI$_WSQUOTA 84                 /* Job, queue: /WSQUOTA=n           */
#define QUI$_RESERVED_BOOLEAN_85 85     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_86 86     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_INPUT_87 87       /* Reserved for Digital use (name may change) */
#define QUI$_SEARCH_USERNAME 88         /* Username of owner of job to modify search */
#define QUI$_DEFAULT_FORM_NAME 89       /* Default form name on queue       */
#define QUI$_DEFAULT_FORM_NUMBER 90     /* Default form number on queue     */
#define QUI$_DEFAULT_FORM_STOCK 91      /* Stock name for default form      */
#define QUI$_JOB_PID 92                 /* Pid of batch job                 */
#define QUI$_FILE_IDENTIFICATION 93     /* File identification (From RMS NAM block) */
#define QUI$_PENDING_JOB_BLOCK_COUNT 94 /* Total number of blocks for all pending jobs */
#define QUI$_RESERVED_BOOLEAN_95 95     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_96 96     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_97 97     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_98 98     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_99 99     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_100 100   /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_101 101   /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_BOOLEAN_102 102   /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_INPUT_103 103     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_INPUT_104 104     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_INPUT_105 105     /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_INPUT_106 106     /* Reserved for Digital use (name may change) */
#define QUI$_EXECUTING_JOB_COUNT 107    /* Number of jobs that are executing */
#define QUI$_HOLDING_JOB_COUNT 108      /* Number of holding jobs           */
#define QUI$_TIMED_RELEASE_JOB_COUNT 109 /* Number of jobs specified with /AFTER_TIME */
#define QUI$_PENDING_JOB_REASON 110     /* Secondary status describing why job is pending */
#define QUI$_ORB_ADDRESS 111            /* Address of in-memory ORB data structure (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_QUEUE_DESCRIPTION 112      /* Queue: /DESCRIPTION              */
#define QUI$_SYMBIONT_FLAGS 113         /* Symbiont options (requests) passed to job controller */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_JOB_ACCESS_CLASS 114       /* Job access class information (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_ORB_LOCK_KEY 115           /* Key value for locking of in-memory ORB data structure (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define QUI$_RESERVED_OUTPUT_116 116    /* Reserved for Digital use (name may change) */
#define QUI$_PENDING_JOB_COUNT 117      /* Number of pending jobs           */
#define QUI$_RETAINED_JOB_COUNT 118     /* Number of retained jobs          */
#define QUI$_RESTART_QUEUE_NAME 119     /* Name of queue into which a job would be restarted, if appropriate */
#define QUI$_RESERVED_OUTPUT_120 120    /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_OUTPUT_121 121    /* Reserved for Digital use (name may change) */
#define QUI$_RESERVED_OUTPUT_122 122    /* Reserved for Digital use (name may change) */
/*                                                                          */
/* Subfields of FILE_FLAGS item code.                                       */
/*                                                                          */
#define QUI$M_FILE_BURST 1
#define QUI$M_FILE_BURST_EXP 2
#define QUI$M_FILE_DELETE 4
#define QUI$M_FILE_DOUBLE_SPACE 8
#define QUI$M_FILE_FLAG 16
#define QUI$M_FILE_FLAG_EXP 32
#define QUI$M_FILE_TRAILER 64
#define QUI$M_FILE_TRAILER_EXP 128
#define QUI$M_FILE_PAGE_HEADER 256
#define QUI$M_FILE_PAGINATE 512
#define QUI$M_FILE_PASSALL 1024
#define QUI$M_FILE_PAGINATE_EXP 2048
struct file_flags {
    unsigned qui$v_file_burst : 1;      /* /BURST                           */
    unsigned qui$v_file_burst_exp : 1;  /* /[NO]BURST explicit (intentionally not documented) */
    unsigned qui$v_file_delete : 1;     /* /DELETE                          */
    unsigned qui$v_file_double_space : 1; /* /SPACE                         */
    unsigned qui$v_file_flag : 1;       /* /FLAG                            */
    unsigned qui$v_file_flag_exp : 1;   /* /[NO]FLAG explicit (intentionally not documented) */
    unsigned qui$v_file_trailer : 1;    /* /TRAILER                         */
    unsigned qui$v_file_trailer_exp : 1; /* /[NO]TRAILER explicit (intentionally not documented) */
    unsigned qui$v_file_page_header : 1; /* /HEADER                         */
    unsigned qui$v_file_paginate : 1;   /* /FEED                            */
    unsigned qui$v_file_passall : 1;    /* /PASSALL                         */
    unsigned qui$v_file_paginate_exp : 1; /* /[NO]FEED explicit (intentionally not documented) */
    unsigned qui$v_filler : 20;
    } ;
/*                                                                          */
/* Subfields of FILE_STATUS item code.                                      */
/*                                                                          */
#define QUI$M_FILE_CHECKPOINTED 1
#define QUI$M_FILE_EXECUTING 2
struct file_status {
    unsigned qui$v_file_checkpointed : 1; /* File checkpointed              */
    unsigned qui$v_file_executing : 1;  /* File currently executing         */
    unsigned qui$v_filler : 30;
    } ;
/*                                                                          */
/* Subfields of FORM_FLAGS item code.                                       */
/*                                                                          */
#define QUI$M_FORM_SHEET_FEED 1
#define QUI$M_FORM_TRUNCATE 2
#define QUI$M_FORM_WRAP 4
struct form_flags {
    unsigned qui$v_form_sheet_feed : 1; /* /SHEET_FEED                      */
    unsigned qui$v_form_truncate : 1;   /* /TRUNCATE                        */
    unsigned qui$v_form_wrap : 1;       /* /WRAP                            */
    unsigned qui$v_filler : 29;
    } ;
/*                                                                          */
/* Subfields of JOB_FLAGS item code.                                        */
/*                                                                          */
#define QUI$M_JOB_CPU_LIMIT 1
#define QUI$M_JOB_FILE_BURST 2
#define QUI$M_JOB_FILE_BURST_ONE 4
#define QUI$M_JOB_FILE_BURST_EXP 8
#define QUI$M_JOB_FILE_FLAG 16
#define QUI$M_JOB_FILE_FLAG_ONE 32
#define QUI$M_JOB_FILE_FLAG_EXP 64
#define QUI$M_JOB_FILE_TRAILER 128
#define QUI$M_JOB_FILE_TRAILER_ONE 256
#define QUI$M_JOB_FILE_TRAILER_EXP 512
#define QUI$M_JOB_LOG_DELETE 1024
#define QUI$M_JOB_LOG_NULL 2048
#define QUI$M_JOB_LOG_SPOOL 4096
#define QUI$M_JOB_LOWERCASE 8192
#define QUI$M_JOB_NOTIFY 16384
#define QUI$M_JOB_RESTART 32768
#define QUI$M_JOB_WSDEFAULT 65536
#define QUI$M_JOB_WSEXTENT 131072
#define QUI$M_JOB_WSQUOTA 262144
#define QUI$M_JOB_FILE_PAGINATE 524288
#define QUI$M_JOB_FILE_PAGINATE_EXP 1048576
struct job_flags {
    unsigned qui$v_job_cpu_limit : 1;   /* /CPUTIME explicit                */
    unsigned qui$v_job_file_burst : 1;  /* /BURST=ALL                       */
    unsigned qui$v_job_file_burst_one : 1; /* /BURST=ONE                    */
    unsigned qui$v_job_file_burst_exp : 1; /* /[NO]BURST explicit (intentionally not documented) */
    unsigned qui$v_job_file_flag : 1;   /* /FLAG=ALL                        */
    unsigned qui$v_job_file_flag_one : 1; /* /FLAG=ONE                      */
    unsigned qui$v_job_file_flag_exp : 1; /* /[NO]FLAG explicit (intentionally not documented) */
    unsigned qui$v_job_file_trailer : 1; /* /TRAILER=ALL                    */
    unsigned qui$v_job_file_trailer_one : 1; /* /TRAILER=ONE                */
    unsigned qui$v_job_file_trailer_exp : 1; /* /[NO]TRAILER explicit (intentionally not documented) */
    unsigned qui$v_job_log_delete : 1;  /* /NOKEEP                          */
    unsigned qui$v_job_log_null : 1;    /* /NOLOG_FILE                      */
    unsigned qui$v_job_log_spool : 1;   /* /PRINTER                         */
    unsigned qui$v_job_lowercase : 1;   /* /LOWERCASE                       */
    unsigned qui$v_job_notify : 1;      /* /NOTIFY                          */
    unsigned qui$v_job_restart : 1;     /* /RESTART                         */
    unsigned qui$v_job_wsdefault : 1;   /* /WSDEFAULT explicit              */
    unsigned qui$v_job_wsextent : 1;    /* /WSEXTENT explicit               */
    unsigned qui$v_job_wsquota : 1;     /* /WSQUOTA explicit                */
    unsigned qui$v_job_file_paginate : 1; /* /FEED                          */
    unsigned qui$v_job_file_paginate_exp : 1; /* /[NO]FEED explicit (intentionally not documented) */
    unsigned qui$v_filler : 11;
    } ;
/*                                                                          */
/* Subfields of JOB_STATUS item code.                                       */
/*                                                                          */
#define QUI$M_JOB_ABORTING 1
#define QUI$M_JOB_EXECUTING 2
#define QUI$M_JOB_HOLDING 4
#define QUI$M_JOB_INACCESSIBLE 8
#define QUI$M_JOB_REFUSED 16
#define QUI$M_JOB_REQUEUE 32
#define QUI$M_JOB_RESTARTING 64
#define QUI$M_JOB_RETAINED 128
#define QUI$M_JOB_STARTING 256
#define QUI$M_JOB_TIMED_RELEASE 512
#define QUI$M_JOB_SUSPENDED 1024
#define QUI$M_JOB_PENDING 2048
struct job_status {
    unsigned qui$v_job_aborting : 1;    /* Job is aborting                  */
    unsigned qui$v_job_executing : 1;   /* Job is executing                 */
    unsigned qui$v_job_holding : 1;     /* Job is holding for /HOLD         */
    unsigned qui$v_job_inaccessible : 1; /* Job is inaccessible             */
    unsigned qui$v_job_refused : 1;     /* Job was refused by symbiont      */
    unsigned qui$v_job_requeue : 1;     /* Job will requeue after abort (intentionally not documented) */
    unsigned qui$v_job_restarting : 1;  /* Job started execution at least once (intentionally not documented) */
    unsigned qui$v_job_retained : 1;    /* Job was retained by /RETAIN      */
    unsigned qui$v_job_starting : 1;    /* Job is starting                  */
    unsigned qui$v_job_timed_release : 1; /* Job is holding for /AFTER      */
    unsigned qui$v_job_suspended : 1;   /* Job is suspended by STOP/QUEUE command */
    unsigned qui$v_job_pending : 1;     /* Job is pending (see QUI$_JOB_PENDING_REASON for more information) */
    unsigned qui$v_filler : 20;
    } ;
#define QUI$V_JOB_TIMED 9               /* Synonym for QUI$V_JOB_TIMED_RELEASE for V4 compatibility */
#define QUI$M_JOB_TIMED 512             /* Synonym for QUI$M_JOB_TIMED_RELEASE for V4 compatibility */
/*                                                                          */
/* Subfields of PENDING_JOB_REASON.                                         */
/*                                                                          */
/* Note that in the descriptions below "queue" refers to the execution queue in which a job resides, or to the set of execution */
/* queues that is the target of the generic queue in which a job resides.   */
/*                                                                          */
#define QUI$M_PEND_CHAR_MISMATCH 1
#define QUI$M_PEND_JOB_SIZE_MAX 2
#define QUI$M_PEND_JOB_SIZE_MIN 4
#define QUI$M_PEND_LOWERCASE_MISMATCH 8
#define QUI$M_PEND_NO_ACCESS 16
#define QUI$M_PEND_QUEUE_BUSY 32
#define QUI$M_PEND_QUEUE_STATE 64
#define QUI$M_PEND_STOCK_MISMATCH 128
struct pending_job_reason {
    unsigned qui$v_pend_char_mismatch : 1; /* Queue's characteristics do not match job's requirements */
    unsigned qui$v_pend_job_size_max : 1; /* Print job's block size is too large to execute on queue (print job only) */
    unsigned qui$v_pend_job_size_min : 1; /* Print job's block size is too small to execute on queue (print job only) */
    unsigned qui$v_pend_lowercase_mismatch : 1; /* Queue's lowercase attribute does not match job's requirements (print job only) */
    unsigned qui$v_pend_no_access : 1;  /* User does not have access to queue */
    unsigned qui$v_pend_queue_busy : 1; /* Job is ready to execute but must wait until other jobs ahead of it in the queue */
/* complete execution (this is a normal state that requires no user intervention) */
    unsigned qui$v_pend_queue_state : 1; /* Queue state prevents job from executing (see QUI$_QUEUE_STATUS for more info) */
    unsigned qui$v_pend_stock_mismatch : 1; /* Stock type of mounted form on output execution queue does not match */
/* stock stock type required by form associated with job (print job only)   */
    unsigned qui$v_filler : 24;
    } ;
/*                                                                          */
/* Subfields of QUEUE_FLAGS item code.                                      */
/*                                                                          */
#define QUI$M_QUEUE_BATCH 1
#define QUI$M_QUEUE_CPU_DEFAULT 2
#define QUI$M_QUEUE_CPU_LIMIT 4
#define QUI$M_QUEUE_FILE_BURST 8
#define QUI$M_QUEUE_FILE_BURST_ONE 16
#define QUI$M_QUEUE_FILE_FLAG 32
#define QUI$M_QUEUE_FILE_FLAG_ONE 64
#define QUI$M_QUEUE_FILE_TRAILER 128
#define QUI$M_QUEUE_FILE_TRAILER_ONE 256
#define QUI$M_QUEUE_GENERIC 512
#define QUI$M_QUEUE_GENERIC_SELECTION 1024
#define QUI$M_QUEUE_JOB_BURST 2048
#define QUI$M_QUEUE_JOB_FLAG 4096
#define QUI$M_QUEUE_JOB_SIZE_SCHED 8192
#define QUI$M_QUEUE_JOB_TRAILER 16384
#define QUI$M_QUEUE_RETAIN_ALL 32768
#define QUI$M_QUEUE_RETAIN_ERROR 65536
#define QUI$M_QUEUE_SWAP 131072
#define QUI$M_QUEUE_TERMINAL 262144
#define QUI$M_QUEUE_WSDEFAULT 524288
#define QUI$M_QUEUE_WSEXTENT 1048576
#define QUI$M_QUEUE_WSQUOTA 2097152
#define QUI$M_QUEUE_FILE_PAGINATE 4194304
#define QUI$M_QUEUE_RECORD_BLOCKING 8388608
#define QUI$M_QUEUE_PRINTER 16777216
#define QUI$M_QUEUE_ACL_SPECIFIED 33554432
struct queue_flags {
    unsigned qui$v_queue_batch : 1;     /* /BATCH                           */
    unsigned qui$v_queue_cpu_default : 1; /* /CPUDEFAULT specified          */
    unsigned qui$v_queue_cpu_limit : 1; /* /CPUMAXIMUM specified            */
    unsigned qui$v_queue_file_burst : 1; /* /DEFAULT=BURST=ALL              */
    unsigned qui$v_queue_file_burst_one : 1; /* /DEFAULT=BURST=ONE          */
    unsigned qui$v_queue_file_flag : 1; /* /DEFAULT=FLAG=ALL                */
    unsigned qui$v_queue_file_flag_one : 1; /* /DEFAULT=FLAG=ONE            */
    unsigned qui$v_queue_file_trailer : 1; /* /DEFAULT=TRAILER=ALL          */
    unsigned qui$v_queue_file_trailer_one : 1; /* /DEFAULT=TRAILER=ONE      */
    unsigned qui$v_queue_generic : 1;   /* /GENERIC                         */
    unsigned qui$v_queue_generic_selection : 1; /* /ENABLE_GENERIC          */
    unsigned qui$v_queue_job_burst : 1; /* /SEPARATE=BURST                  */
    unsigned qui$v_queue_job_flag : 1;  /* /SEPARATE=FLAG	            */
    unsigned qui$v_queue_job_size_sched : 1; /* /SCHEDULE=SIZE              */
    unsigned qui$v_queue_job_trailer : 1; /* /SEPARATE=TRAILER              */
    unsigned qui$v_queue_retain_all : 1; /* /RETAIN=ALL                     */
    unsigned qui$v_queue_retain_error : 1; /* /RETAIN=ERROR                 */
    unsigned qui$v_queue_swap : 1;      /* /NODISABLE_SWAPPING              */
    unsigned qui$v_queue_terminal : 1;  /* /DEVICE=TERMINAL or terminal device type reported by symbiont */
    unsigned qui$v_queue_wsdefault : 1; /* /WSDEFAULT specified             */
    unsigned qui$v_queue_wsextent : 1;  /* /WSEXTENT specified              */
    unsigned qui$v_queue_wsquota : 1;   /* /WSQUOTA specified               */
    unsigned qui$v_queue_file_paginate : 1; /* /DEFAULT=FEED                */
    unsigned qui$v_queue_record_blocking : 1; /* /RECORD_BLOCKING           */
    unsigned qui$v_queue_printer : 1;   /* /DEVICE=PRINTER or printer device type reported by symbiont */
    unsigned qui$v_queue_acl_specified : 1; /* ACL has been specified for queue */
    unsigned qui$v_filler : 6;
    } ;
/*                                                                          */
/* Subfields of QUEUE_STATUS item code.                                     */
/*                                                                          */
#define QUI$M_QUEUE_ALIGNING 1
#define QUI$M_QUEUE_IDLE 2
#define QUI$M_QUEUE_LOWERCASE 4
#define QUI$M_QUEUE_OPERATOR_REQUEST 8
#define QUI$M_QUEUE_PAUSED 16
#define QUI$M_QUEUE_PAUSING 32
#define QUI$M_QUEUE_REMOTE 64
#define QUI$M_QUEUE_RESETTING 128
#define QUI$M_QUEUE_RESUMING 256
#define QUI$M_QUEUE_SERVER 512
#define QUI$M_QUEUE_STALLED 1024
#define QUI$M_QUEUE_STARTING 2048
#define QUI$M_QUEUE_STOPPED 4096
#define QUI$M_QUEUE_STOPPING 8192
#define QUI$M_QUEUE_UNAVAILABLE 16384
#define QUI$M_QUEUE_CLOSED 32768
struct queue_status {
    unsigned qui$v_queue_aligning : 1;  /* Queue is aligning                */
    unsigned qui$v_queue_idle : 1;      /* Queue is idle                    */
    unsigned qui$v_queue_lowercase : 1; /* Lowercase device                 */
    unsigned qui$v_queue_operator_request : 1; /* Queue is doing /OPERATOR (intentionally not documented) */
    unsigned qui$v_queue_paused : 1;    /* Queue is paused                  */
    unsigned qui$v_queue_pausing : 1;   /* Queue is pausing                 */
    unsigned qui$v_queue_remote : 1;    /* Remote device                    */
    unsigned qui$v_queue_resetting : 1; /* Incomplete remote request to reset */
    unsigned qui$v_queue_resuming : 1;  /* Queue is resuming                */
    unsigned qui$v_queue_server : 1;    /* /DEVICE=SERVER or reported to be a served queue by the symbiont */
    unsigned qui$v_queue_stalled : 1;   /* Device is stalled                */
    unsigned qui$v_queue_starting : 1;  /* Queue is starting                */
    unsigned qui$v_queue_stopped : 1;   /* Queue is stopped                 */
    unsigned qui$v_queue_stopping : 1;  /* Queue is stopping                */
    unsigned qui$v_queue_unavailable : 1; /* Device is unavailable          */
    unsigned qui$v_queue_closed : 1;    /* Queue is closed                  */
    unsigned qui$v_filler : 16;
    } ;
/*                                                                          */
/* Subfields of SEARCH_FLAGS item code.                                     */
/*                                                                          */
#define QUI$M_SEARCH_ALL_JOBS 1
#define QUI$M_SEARCH_WILDCARD 2
#define QUI$M_SEARCH_BATCH 4
#define QUI$M_SEARCH_SYMBIONT 8
#define QUI$M_SEARCH_THIS_JOB 16
#define QUI$M_SEARCH_PRINTER 32
#define QUI$M_SEARCH_SERVER 64
#define QUI$M_SEARCH_TERMINAL 128
#define QUI$M_SEARCH_GENERIC 256
#define QUI$M_SEARCH_GENERIC_TARGET 512
#define QUI$M_SEARCH_PENDING_JOBS 1024
#define QUI$M_SEARCH_EXECUTING_JOBS 2048
#define QUI$M_SEARCH_TIMED_RELEASE_JOBS 4096
#define QUI$M_SEARCH_HOLDING_JOBS 8192
#define QUI$M_SEARCH_RETAINED_JOBS 16384
#define QUI$M_SEARCH_FREEZE_CONTEXT 32768
struct search_flags {
    unsigned qui$v_search_all_jobs : 1; /* Select all jobs (else only those with same username as caller) */
    unsigned qui$v_search_wildcard : 1; /* Force a wildcard operation       */
    unsigned qui$v_search_batch : 1;    /* Select batch queues              */
    unsigned qui$v_search_symbiont : 1; /* Select symbiont (output) queues (note that QUI$V_SEARCH_SYMBIONT is equivalent */
/* to setting QUI$V_SEARCH_PRINTER, QUI$V_SEARCH_SERVER, and QUI$V_SEARCH_TERMINAL) */
    unsigned qui$v_search_this_job : 1; /* Select only caller's batch job (forcing new context) */
    unsigned qui$v_search_printer : 1;  /* Select printer queues            */
    unsigned qui$v_search_server : 1;   /* Select server queues             */
    unsigned qui$v_search_terminal : 1; /* Select terminal queues           */
    unsigned qui$v_search_generic : 1;  /* Select generic queues            */
    unsigned qui$v_search_generic_target : 1; /* Select generic target queues after selecting generic queue (for internal use) */
/* (note this option is NOT supported; it is intentionally not documented and */
/* reserved for Digital use)                                                */
    unsigned qui$v_search_pending_jobs : 1; /* Select only pending jobs     */
    unsigned qui$v_search_executing_jobs : 1; /* Select only executing jobs */
    unsigned qui$v_search_timed_release_jobs : 1; /* Select only timed release jobs */
    unsigned qui$v_search_holding_jobs : 1; /* Select only holding jobs     */
    unsigned qui$v_search_retained_jobs : 1; /* Select only retained jobs   */
    unsigned qui$v_search_freeze_context : 1; /* Do not advance wildcard context to next object in list at end of operation */
    unsigned qui$v_filler : 16;
    } ;
/*                                                                          */
/* Subfields of SYMBIONT_FLAGS item code.                                   */
/*                                                                          */
/* Note: this item code is intentionally not documented and reserved for Digital use. */
/*                                                                          */
#define QUI$M_SYM_NOTIFIES 1
#define QUI$M_SYM_REQUESTS_OPER 2
#define QUI$M_SYM_COPIES_FILE 4
#define QUI$M_SYM_COPIES_JOB 8
#define QUI$M_SYM_ACCEPTS_ALL_FORMS 16
#define QUI$M_SYM_NO_JOB_CHECKPOINT 32
struct symbiont_flags {
    unsigned qui$v_sym_notifies : 1;    /* Symbiont notifies for job completions */
    unsigned qui$v_sym_requests_oper : 1; /* Symbiont generates operator messages */
    unsigned qui$v_sym_copies_file : 1; /* Symbiont generates multiple file copies */
    unsigned qui$v_sym_copies_job : 1;  /* Symbiont generates multiple job copies */
    unsigned qui$v_sym_accepts_all_forms : 1; /* Symbiont processes all form types */
    unsigned qui$v_sym_no_job_checkpoint : 1; /* Always reprocess full job on a restart */
    unsigned qui$v_filler : 26;
    } ;
 

#endif					/* __QUIDEF_LOADED */
#ifndef __RAB_LOADED
#define __RAB_LOADED	1
#pragma nostandard

/*** MODULE $rabdef ***/
/*                                                                          */
/*         record access block (rab) definitions                            */
/*                                                                          */
/*  there is one rab per connected stream                                   */
/*  it is used for all communications between the user                      */
/*  and rms concerning operations on the stream                             */
/*                                                                          */
/*+++++*****                                                                */
/*  the fields thru ctx cannot be changed due to commonality                */
/*  with the fab                                                            */
/*                                                                          */
#define RAB$C_BID 1                     /* code for rab                     */
#define RAB$M_PPF_RAT 16320
#define RAB$M_PPF_IND 16384
#define RAB$M_ASY 1
#define RAB$M_TPT 2
#define RAB$M_REA 4
#define RAB$M_RRL 8
#define RAB$M_UIF 16
#define RAB$M_MAS 32
#define RAB$M_FDL 64
#define RAB$M_HSH 128
#define RAB$M_EOF 256
#define RAB$M_RAH 512
#define RAB$M_WBH 1024
#define RAB$M_BIO 2048
#define RAB$M_CDK 4096
#define RAB$M_LOA 8192
#define RAB$M_LIM 16384
#define RAB$M_SYNCSTS 32768
#define RAB$M_LOC 65536
#define RAB$M_WAT 131072
#define RAB$M_ULK 262144
#define RAB$M_RLK 524288
#define RAB$M_NLK 1048576
#define RAB$M_KGE 2097152
#define RAB$M_KGT 4194304
#define RAB$M_NXR 8388608
#define RAB$M_RNE 16777216
#define RAB$M_TMO 33554432
#define RAB$M_CVT 67108864
#define RAB$M_RNF 134217728
#define RAB$M_ETO 268435456
#define RAB$M_PTA 536870912
#define RAB$M_PMT 1073741824
#define RAB$M_CCO -2147483648
#define RAB$M_EQNXT 2097152
#define RAB$M_NXT 4194304
#define RAB$C_SEQ 0                     /* sequential access                */
#define RAB$C_KEY 1                     /* keyed access                     */
#define RAB$C_RFA 2                     /* rfa access                       */
#define RAB$C_STM 3                     /* stream access (valid only for sequential org)  */
#define RAB$C_MAXRAC 2                  /* Maximum RAC value currently supported by RMS */
#define RAB$K_BLN 68                    /* length of rab                    */
#define RAB$C_BLN 68                    /* length of rab                    */

struct RAB {
    unsigned char rab$b_bid;            /* block id                         */
    unsigned char rab$b_bln;            /* block length                     */
    variant_union  {
        unsigned short int rab$w_isi;   /* internal stream index            */
/* (ifi in fab)                                                             */
        variant_struct  {
            unsigned rabdef$$_fill_1 : 6; /* move to bit 6                  */
            unsigned rab$v_ppf_rat : 8; /* rat value for process-permanent files  */
            unsigned rab$v_ppf_ind : 1; /* indirect access to process-permanent file  */
/* (i.e., restricted operations)                                            */
            unsigned rab$v_fill_5 : 1;
            } rab$r_isi_bits;
        } rab$r_isi_overlay;
    variant_union  {
        unsigned long int rab$l_rop;    /* record options                   */
        variant_struct  {
            unsigned rab$v_asy : 1;     /* asynchronous operations          */
            unsigned rab$v_tpt : 1;     /* truncate put - allow sequential put not at  */
/*   eof, thus truncating file (seq. org only)                              */
/*                                                                          */
/* these next two should be in the byte for bits                            */
/* input to $find or $get, but there is no room there                       */
/*                                                                          */
            unsigned rab$v_rea : 1;     /* lock record for read only, allow other readers  */
            unsigned rab$v_rrl : 1;     /* read record regardless of lock   */
/*                                                                          */
            unsigned rab$v_uif : 1;     /* update if existent               */
            unsigned rab$v_mas : 1;     /* mass-insert mode                 */
            unsigned rab$v_fdl : 1;     /* fast record deletion             */
            unsigned rab$v_hsh : 1;     /* use hash code in bkt             */
/*                                                                          */
            unsigned rab$v_eof : 1;     /* connect to eof                   */
            unsigned rab$v_rah : 1;     /* read ahead                       */
            unsigned rab$v_wbh : 1;     /* write behind                     */
            unsigned rab$v_bio : 1;     /* connect for bio only             */
            unsigned rab$v_cdk : 1;     /* check for duplicate keys on $GET */
            unsigned rab$v_loa : 1;     /* use bucket fill percentage       */
            unsigned rab$v_lim : 1;     /* compare for key limit reached on $get/$find seq. (idx only)  */
            unsigned rab$v_syncsts : 1; /* Synchronous status notification for asynchronous routines. */
/*                                                                          */
/* the following bits are input to                                          */
/* $find or $get, (see above also REA and RRL)                              */
/* (separate byte)                                                          */
/*                                                                          */
            unsigned rab$v_loc : 1;     /* use locate mode                  */
            unsigned rab$v_wat : 1;     /* wait if record not available     */
            unsigned rab$v_ulk : 1;     /* manual unlocking                 */
            unsigned rab$v_rlk : 1;     /* allow readers for this locked record  */
            unsigned rab$v_nlk : 1;     /* do not lock record               */
            unsigned rab$v_kge : 1;     /* key > or =                       */
            unsigned rab$v_kgt : 1;     /* key greater than                 */
            unsigned rab$v_nxr : 1;     /* get non-existent record          */
/*                                                                          */
/*  the following bits are terminal qualifiers only                         */
/*  (separate byte)                                                         */
/*                                                                          */
            unsigned rab$v_rne : 1;     /* read no echo                     */
            unsigned rab$v_tmo : 1;     /* use time-out period              */
            unsigned rab$v_cvt : 1;     /* convert to upper case            */
            unsigned rab$v_rnf : 1;     /* read no filter                   */
            unsigned rab$v_eto : 1;     /* extended terminal operation      */
            unsigned rab$v_pta : 1;     /* purge type ahead                 */
            unsigned rab$v_pmt : 1;     /* use prompt buffer                */
            unsigned rab$v_cco : 1;     /* cancel control o on output       */
            } rab$r_rop_bits0;
        variant_struct  {
            unsigned rabdef$$_fill_6 : 21;
            unsigned rab$v_eqnxt : 1;   /* Synonyms for KGE and             */
            unsigned rab$v_nxt : 1;     /*   KGT                            */
            unsigned rab$v_fill_6 : 1;
            } rab$r_rop_bits1;
/* the following bits may be                                                */
/* input to various rab-related                                             */
/* operations                                                               */
/*                                                                          */
        variant_struct  {
            char rabdef$$_fill_3;
            unsigned char rab$b_rop1;   /* various options                  */
            unsigned char rab$b_rop2;   /* get/find options (use of this field discouraged  */
/* due to REA and RRL being in a different byte)                            */
            unsigned char rab$b_rop3;   /* terminal read options            */
/*                                                                          */
            } rab$r_rop_fields;
        } rab$r_rop_overlay;
    unsigned long int rab$l_sts;        /* status                           */
    variant_union  {
        unsigned long int rab$l_stv;    /* status value                     */
        variant_struct  {
            unsigned short int rab$w_stv0; /* low word of stv               */
            unsigned short int rab$w_stv2; /* high word of stv              */
            } rab$r_stv_fields;
        } rab$r_stv_overlay;
    variant_union  {
        unsigned short int rab$w_rfa [3]; /* record's file address          */
        variant_struct  {
            unsigned long int rab$l_rfa0;
            unsigned short int rab$w_rfa4;
            } rab$r_rfa_fields;
        } rab$r_rfa_overlay;
    short int rabdef$$_fill_4;          /* (reserved - rms release 1 optimizes stores  */
/*  to the rfa field to be a move quad, overwriting                         */
/*  this reserved word)                                                     */
    unsigned long int rab$l_ctx;        /* user context                     */
/*-----*****                                                                */
    short int rabdef$$_fill_5;          /* (spare)                          */
    unsigned char rab$b_rac;            /* record access                    */
    unsigned char rab$b_tmo;            /* time-out period                  */
    unsigned short int rab$w_usz;       /* user buffer size                 */
    unsigned short int rab$w_rsz;       /* record buffer size               */
    char *rab$l_ubf;			/* user buffer address              */
    char *rab$l_rbf;			/* record buffer address            */
    char *rab$l_rhb;			/* record header buffer addr        */
    variant_union  {
        char *rab$l_kbf;		/* key buffer address               */
        char *rab$l_pbf;		/* prompt buffer addr               */
        } rab$r_kbf_overlay;
    variant_union  {
        unsigned char rab$b_ksz;        /* key buffer size                  */
        unsigned char rab$b_psz;        /* prompt buffer size               */
        } rab$r_ksz_overlay;
    unsigned char rab$b_krf;            /* key of reference                 */
    char rab$b_mbf;                     /* multi-buffer count               */
    unsigned char rab$b_mbc;            /* multi-block count                */
    variant_union  {
        unsigned long int rab$l_bkt;    /* bucket hash code, vbn, or rrn    */
        unsigned long int rab$l_dct;    /* duplicates count on key accessed on alternate key  */
        } rab$r_bkt_overlay;
    struct FAB *rab$l_fab;		/* related fab for connect          */
    char *rab$l_xab;			/* XAB address                      */
    } ;
 
/* These are tradtional macros that should be hand-maintained for compatibility */
#define RAB$V_PPF_RAT	6		/* rat value for process-permanent files */
#define RAB$S_PPF_RAT	8
#define RAB$V_PPF_IND	14		/* indirect access to process-permanent file */
#define RAB$V_ASY	0		/* asynchronous operations */
#define RAB$V_TPT	1		/* truncate-on-put - allow sequential put not at eof */
#define RAB$V_REA	2		/* lock record for read only, allow other readers */
#define RAB$V_RRL	3		/* read record regardless of lock */
#define RAB$V_UIF	4		/* update if existent */
#define RAB$V_MAS	5		/* mass-insert mode */
#define RAB$V_FDL	6		/* fast record deletion */
#define RAB$V_HSH	7		/* use hash code in bkt */
#define RAB$V_EOF	8		/* connect to end-of-file */
#define RAB$V_RAH	9		/* read ahead */
#define RAB$V_WBH	10		/* write behind */
#define RAB$V_BIO	11		/* connect for block I/O only */
#define RAB$V_LV2	12		/* level 2 RU lock consistency */
#define RAB$M_LV2	(1 << RAB$V_LV2)
#define RAB$V_LOA	13		/* load buckets according to the file size */
#define RAB$V_LIM	14		/* compare for key limit reached on $get/$find seq.(idx only) */
#define RAB$V_LOC	16		/* use locate mode */
#define RAB$V_WAT	17		/* wait if record not available */
#define RAB$V_ULK	18		/* manual unlocking */
#define RAB$V_RLK	19		/* allow readers for this locked record */
#define RAB$V_NLK	20		/* do not lock record */
#define RAB$V_KGE	21		/* key is greater than or equal to */
#define RAB$V_KGT	22		/* key is greater than */
#define RAB$V_NXR	23		/* non-existent record processing */
#define RAB$V_RNE	24		/* read no echo */
#define RAB$V_TMO	25		/* use time-out period */
#define RAB$V_CVT	26		/* convert to upper case */
#define RAB$V_RNF	27		/* read no filter */
#define RAB$V_ETO	28		/* extended terminal operation */
#define RAB$V_PTA	29		/* purge type ahead */
#define RAB$V_PMT	30		/* use prompt buffer */
#define RAB$V_CCO	31		/* cancel control O on output */
#define RAB$V_EQNXT 	21		/*  Synonym for KGE */
#define RAB$V_NXT  	22		/*  Synonym for KGT */

globalref struct RAB cc$rms_rab;	/* Declare initialized prototype data structure */

#pragma standard
#endif					/* __RAB_LOADED */
#ifndef __RMEDEF_LOADED
#define __RMEDEF_LOADED	1

/*** MODULE $rmedef ***/
/*                                                                          */
/*                rms escape definitions                                    */
/*                                                                          */
/*  the following values identify various requests for non-standard rms     */
/*  functions.  they are currently input to the $modify function in the     */
/*  ctx field of the fab only if the esc bit is set in fop.  incorrect      */
/*  use of these capabilties could cause rms to fail, hence great caution   */
/*  should be exercised in their use.                                       */
/*                                                                          */
#define RME$C_SETRFM 1                  /* change rfm, mrs, and fsz (if vfc) in ifab only  */
#define RME$C_PPFECHO 2                 /* enable echo of SYS$INPUT to SYS$OUTPUT */
#define RME$C_SETRCF 3                  /* change recovery mode             */
#define RME$C_KEEP_LOCK_ON 4            /* Turn on Keep Lock behavior       */
#define RME$C_KEEP_LOCK_OFF 5           /* Turn off Keep Lock behavior      */

#endif					/* __RMEDEF_LOADED */
#ifndef __RMS_LOADED
#define __RMS_LOADED	1

/*	RMS - V3.0 - Include all RMS data structure definitions	*/

#pragma nostandard

# include nam
# include fab
# include rab
# include xab
# include rmsdef
#pragma standard

#endif					/* __RMS_LOADED */
#ifndef __RMSDEF_LOADED
#define __RMSDEF_LOADED	1

/*** MODULE $rmsdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 00:19:07.75 */
/*                                                                          */
/*	.TITLE	RMSDEF -RMS COMPLETION CODES                                */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 		     							    * */
/**									    * */
/***************************************************************************** */
/*++                                                                        */
/* FACILITY: RMS                                                            */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS MODULE DEFINES ALL RMS COMPLETION CODES.                       */
/*                                                                          */
/* ENVIRONMENT:                                                             */
/*                                                                          */
/*	THE MESSAGE TRANSLATOR MUST BE USED TO CONVERT RMSDEF.MSG INTO      */
/*	RMSDEF.SDL.  THE SDL TRANSLATOR MUST THEN BE USED TO CONVERT        */
/*	RMSDEF.SDL INTO RMSDEF.MAR (AND RMSDEF.B32).                        */
/*                                                                          */
/* AUTHOR: LEO F. LAVERDURE,	CREATION DATE:  10-DEC-1976                 */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	X-27	PMV0072		PETER M. VATNE		08-OCT-1987         */
/*		CHANGE RMS$_NOJNLLIC TO RMS$_JNLNOTAUTH.                    */
/*                                                                          */
/* 	X-26	LSS0057		LEONARD S. SZUBOWICZ	15-SEP-1987         */
/*		CHANGE TEXT FOR THE RMS$_OK_DUP STATUS SUCH THAT THE MESSAGE */
/*		IS APPLICABLE TO $GET AS WELL AS $PUT.                      */
/*                                                                          */
/*	X-25	PMV0068		PETER M. VATNE		11-SEP-1987         */
/*		ADD RMS$_NOJNLLIC, NO RMS JOURNALING LICENSE, FOR LMF.      */
/*                                                                          */
/*	X-24	RNM0026		RUSSELL N. MURRAY	15-AUG-1987         */
/*		ADD RMS$_SYNCH MESSAGE FOR NOTIFICATION OF SYNCHRONOUS      */
/*		COMPLETION.                                                 */
/*                                                                          */
/*	X-23	JEJ0479		JAMES E JOHNSON		13-AUG-1987         */
/*		ADD RMS$_IVATRACE MESSAGE.                                  */
/*                                                                          */
/*	X-22	PMV0061		PETER M. VATNE		03-AUG-1987         */
/*		CHANGE RESERVED MESSAGE RMS$_BUG_XX5 TO RMS$_BUG_RU_COMMIT_FAIL */
/*		TO CORRESPOND TO POSITIVE RMS BUGCHECK FTL$_RU_COMMIT_FAIL. */
/*                                                                          */
/* 	X-21	LSS0042		LEONARD S. SZUBOWICZ	13-MAY-1987         */
/*		CHANGE RESERVED MESSAGE RMS$_BUG_XX4 TO RMS$_BUG_RU_ABORT_FAIL */
/*		TO CORRESPOND TO POSITIVE RMS BUGCHECK FTL$_RU_ABORT_FAIL   */
/*	                                                                    */
/*	X-20	SAD0034		STUART A. DAVIDSON	12-MAR-1987         */
/*		DROP QUOTES FROM SNADTF MESSAGE TEXT.                       */
/*                                                                          */
/*	X-19	PJH		PAUL J. HOULIHAN	19-JAN-1987         */
/*		MERGE IN 17J1.                                              */
/*                                                                          */
/*		X-17J1	PJH		PAUL J. HOULIHAN	15-JAN-1987 */
/*			FIX SEVERAL SMALL JNL PROBLEMS.                     */
/*			ADD RMS$_BUG_FLUSH_JNL_FAILED CODE.                 */
/*                                                                          */
/*	X-18	KPS0148		KENNETH P. SIEGEL	04-DEC-1986         */
/*		ADDED SNPPF (STATISTICS MONITORING NOT SUPPORTED FOR        */
/*		PROCESS PERMANENT FILES) ERROR MESSAGE.                     */
/*                                                                          */
/*	X-17	PMV0025		PETER M. VATNE		24-NOV-1986         */
/*		ADD NEW MESSAGE, RMS$_NOTSAMEJNL.  THIS STATUS IS           */
/*		USED TO RESTRICT AI/BI WITH RU JOURNALING TO A              */
/*		SINGLE LONG-TERM JOURNAL FILE.                              */
/*                                                                          */
/*	X-16	DAS		DAVID A. SOLOMON	18-NOV-1986         */
/*		ADD NEW MESSAGE, RMS$_DELJNS. REMOVE RMS$_XCR (BY REPLACING IT */
/*		WITH A PLACEHOLDER), AS JOURNALING BITS ARE NO LONGER       */
/*		SPECIFIED IN THE $XABJNL. SLIGHT WORDING CHANGE ON DETACHED */
/*		RU RECOVERY ERROR MESSAGES.                                 */
/*                                                                          */
/*	X-15	DAS		DAVID A. SOLOMON	12-NOV-1986         */
/*		FIX ERROR IN X-5/X-6: JOURNALING VARIANT NOT MERGED         */
/*		CORRECTLY, RESULTING IN SEVERAL JOURNALING MESSAGES NUMBERS */
/*		BEING DIFFERENT IN THE MAININE THAN WHAT THEY WERE ON THE   */
/*		JOURNALING VARIANT. ALSO, MOVE NEW SNADTF MESSAGES TO RE-USE */
/*		AVAILABLE UNUSED MESSAGE NUMBERS, INSTEAD OF GENERATING NEW */
/*		ONES. FINALLY, CHANGE RMS$_BUG_ABORT TO RMS$_BUG_RU_ACTIVE. */
/*                                                                          */
/*	X-14	SAD0014		STUART A. DAVIDSON	 4-NOV-1986         */
/*		SNADTF - FIX TYPO IN DTFACC, DTFCRE                         */
/*                                                                          */
/*	X-13	SAD0014		STUART A. DAVIDSON	 3-NOV-1986         */
/*		SNADTF - FIX TYPO, ADD 2 ADDITIONAL MESSAGES.               */
/*                                                                          */
/*	X-12	JEJ0377		JAMES E JOHNSON		29-OCT-1986         */
/*		ADD NOEXTEND ERROR CODE TO FLAG FAILED RELATIVE FILE        */
/*		EXTENDS DUE TO PREVIOUS FAILURES.                           */
/*                                                                          */
/*	X-11	KPS0131		KENNETH P. SIEGEL	25-OCT-1986         */
/*		ADDED SNS ERROR CODE FOR STATISTICS NOT SUPPORT ON          */
/*		NON-DISK DEVICES.                                           */
/*                                                                          */
/*	X-10	SAD009		STUART A. DAVIDSON	06-OCT-1986         */
/*		ADD COMPLETION CODES FOR SNADTF (IBM DATA XFER)             */
/*                                                                          */
/*	X-9	GJA0003		GARY J. ALLISON		29-SEP-1986         */
/*		ADD DETACHED RECOVERY ERROR MESSAGES                        */
/*                                                                          */
/*	X-8	PMV0008		PETER M. VATNE		24-SEP-1986         */
/*		MODIFY RMS$_ACC_AIJ, RMS$_ACC_BIJ, AND RMS$_ACC_ATJ         */
/*		TO ALSO OUTPUT THE STV.                                     */
/*                                                                          */
/*	X-7	JWT0243		JIM TEAGUE		 2-SEP-1986         */
/*		ADD NEW ERRORS FOR COLLATED KEYS.                           */
/*                                                                          */
/*	X-6	GJA		GARY J. ALLISON		29-JUL-1986         */
/*		REMOVE DUPS FROM JNL MERGE.                                 */
/*                                                                          */
/*	X-5	GJA		GARY J. ALLISON		29-JUL-1986         */
/*		MERGE JOURNALING INTO MAINLINE                              */
/*                                                                          */
/*		X-3J6	DAS		DAVID A. SOLOMON	14-APR-1986 */
/*			REMOVE RMS$_RUH_FILE (USING A GENERAL RUF MESSAGE INSTEAD). */
/*			CHANGE RMS$_RUH TEXT TO NOT HAVE FAO PARAMETERS. ADD */
/*			RMS$_BUG_RURECERR.                                  */
/*	                                                                    */
/*		X-3J5	JEJ0302		JAMES E JOHNSON		 4-APR-1986 */
/*			ADD RMS$_RRF (ERROR DURING RU RECOVERY) AND         */
/*			RMS$_RUH/RMS$_RUH_FILE (USED TO FORM TEXT OF RU HANDLER ERRORS */
/*			SENT TO OPCOM).                                     */
/*	                                                                    */
/*		X-3J4	JEJ0272		JAMES E JOHNSON		11-FEB-1986 */
/*			ADD RMS$_RUF, RMS$_BUG_ABORT CODES.                 */
/*	                                                                    */
/*		X-3J3	JEJ0237		JAMES E JOHNSON		16-DEC-1985 */
/*			ADD RMS$_RUNDOWN CODE                               */
/*	                                                                    */
/*		X-3J2	JEJ0205		JAMES E JOHNSON		25-OCT-1985 */
/*			ADD JOURNAL SPECIFIC WRTJNL_XXJ ERROR CODES TO REPLACE */
/*			THE GENERIC ERRWRTJNL CODE.                         */
/*                                                                          */
/*	X-4	JEJ0216		JAMES E JOHNSON		18-NOV-1985         */
/*		MERGE X-3J2 INTO MAIN LINE FOR V4.4.                        */
/*                                                                          */
/*		X-3J2	JEJ0205		JAMES E JOHNSON		25-OCT-1985 */
/*			ADD JOURNAL SPECIFIC WRTJNL_XXJ ERROR CODES TO REPLACE */
/*			THE GENERIC ERRWRTJNL CODE.                         */
/*                                                                          */
/*	X-3	JEJ0161		JAMES E JOHNSON		 9-SEP-1985         */
/*		UPDATE RMS JOURNALING MESSAGES.                             */
/*                                                                          */
/*	X-2	JWT0212		JIM TEAGUE		 4-SEP-1985         */
/*		ADD (WHAT IS FOR NOW) AN INTERNAL STATUS CODE TO            */
/*		DIFFERENTIATE BETWEEN FINDING A DELETED RECORD (DEL)        */
/*		AND FINDING IT BUT WITH A DIFFERENT KEY (KEY_MISMATCH).     */
/*		                                                            */
/*	V03-024	RAS0314		RON SCHAEFER		21-JUN-1984         */
/*		WORK OVER THE MESSAGES ONE MORE TIME:  FIX TYPO IN OK_RNF,  */
/*		DELETE ACPEOF ERROR, DELETE WSF ERROR.                      */
/*                                                                          */
/*	V03-023	RAS0282		RON SCHAEFER		28-MAR-1984         */
/*		MINOR TEXT CHANGES AND COMMENTS ADDED.                      */
/*		DELETE RMS$_COP ERROR.                                      */
/*                                                                          */
/*	V03-022	DAS0005		DAVID SOLOMON		19-MAR-1984         */
/*		REMOVE RMS$_ECHO (NO LONGER NEEDED AS A RESULT OF NEW       */
/*		IMPLEMENTATION FOR ECHO SYS$INPUT -> SYS$OUTPUT).           */
/*                                                                          */
/*	V03-021	JWT0150		JIM TEAGUE		01-FEB-1984         */
/*		ADD RMS$_IFF FOR TRYING TO WRITE-ACCESS A FILE ON           */
/*		MAGTAPE THAT HAS NON-0 VALUE FOR ANSI BUFFER OFFSET.        */
/*                                                                          */
/*	V03-020	RAS0233		RON SCHAEFER		 9-JAN-1984         */
/*		ADD RMS$_NOVALPRS ERROR FOR $SEARCH NOT PRECEDED BY         */
/*		VALID $PARSE.                                               */
/*                                                                          */
/*	V03-019	JWT0148		JIM TEAGUE		20-DEC-1983         */
/*		ADD A JNL XAB ERROR FOR CONFLICTING RU ATTRIBUTES           */
/*		ON $CREATE: RMS$_XCR.                                       */
/*                                                                          */
/*	V03-018	RAS0171		RON SCHAEFER		28-JUL-1983         */
/*		ADD RMS$_BUSY; A STRUCTURE-LESS ERROR (R0-ONLY STATUS)      */
/*		REPLACING TEMP3.                                            */
/*                                                                          */
/*	V03-017	DAS0004		DAVID SOLOMON		28-JUN-1983         */
/*		ADD RMS$_FILEPURGED; ADD RMS$_ACPEOF FOR ZALEWSKI.          */
/*                                                                          */
/*	V03-016	KPL0007		PETER LIEBERWIRTH	 8-JUN-1983         */
/*		FIX SPELLING IN JNL ERROR MESSAGES, ADD CJF ERROR WHICH     */
/*		WILL SOON SUBSUME COP AND CQE.                              */
/*                                                                          */
/*	V03-015	DAS0003		DAVID SOLOMON		18-FEB-1983         */
/*		ADD XNF (REPLACING TEMP9), TMR (NEW), LWC (NEW).            */
/*                                                                          */
/*	V03-014	KBT0497		KEITH B. THOMPSON	18-FEB-1983         */
/*		ADD INCOMPSHR ERROR (REUSE OF TEMP1 SLOT)                   */
/*                                                                          */
/*	V03-013	RAS0120		RON SCHAEFER		 2-FEB-1983         */
/*		ADD ECHO PSEUDO-STATUS TO SUPPORT ECHO OF SYS$INPUT         */
/*		TO SYS$OUTPUT.                                              */
/*                                                                          */
/*	V03-012	JWH0174		JEFFRY W. HORN		24-JAN-1983         */
/*		ADD CQE AND COP ERRORS.                                     */
/*                                                                          */
/*	V03-011	KPL0006		PETER LIEBERWIRTH	 7-JAN-1983         */
/*		ADD OK_RULK FOR RECOVERY UNIT SUPPORT.                      */
/*                                                                          */
/*		ADD REENT ERROR FOR $RENAME.                                */
/*		                                                            */
/*	V03-009	JWH0153		JEFFREY W. HORN		 8-DEC-1982         */
/*		ADD NRU ERROR.                                              */
/*                                                                          */
/*	V03-008	JWH0152		JEFFREY W. HORN		 8-DEC-1982         */
/*		ADD JNS ERROR.                                              */
/*                                                                          */
/*	V03-007 MCN0002		MARIA DEL C. NASR	15-NOV-1982         */
/*		REPLACE ORD ERROR CODE ELIMINATED BY MCN0001, SINCE         */
/*		THE NETWORK CODE REFERENCES IT.                             */
/*                                                                          */
/*	V03-006 MCN0001		MARIA DEL C. NASR	26-OCT-1982         */
/*		PRINT KEY OF REFERENCE OR AREA IDENTIFICATION NUMBER        */
/*		INSTEAD OF XAB ADDRESS FOR ERRORS RETURNED DURING           */
/*		INDEXED FILE CREATION.  ALSO RENAME ALL UNUSED ERROR        */
/*		CODES TO TEMP.                                              */
/*                                                                          */
/*	V03-005	JWH0102		JEFFREY W. HORN		24-SEP-1982         */
/*		ADD RUP ERROR.                                              */
/*                                                                          */
/*	V03-004	RAS0095		RON SCHAEFER		 7-SEP-1982         */
/*		ADD OVRDSKQUOTA ERROR.                                      */
/*                                                                          */
/*	V03-002	JWH0002		JEFFREY W. HORN		26-JUL-1982         */
/*		CONVERT TO .MSG FORMAT.   ADD RUM ERROR.                    */
/*                                                                          */
/*	V03-001	JWH0001		JEFFREY W. HORN		20-JUL-1982         */
/*		ADD JNF, JOP, AND NOJ ERRORS.                               */
/*                                                                          */
/*	V02-042	KPL0005		PETER LIEBERWIRTH	 4-FEB-1982         */
/*		ADD ERROR MESSAGES RMS$_EXENQLM AND RMS$_DEADLOCK           */
/*		CORRECTLY.                                                  */
/*                                                                          */
/*	V02-041	CDS0001		C D SAETHER	24-JAN-1982                 */
/*		ADD GBC AND CRMP ERRORS.                                    */
/*                                                                          */
/*	V02-040	JAK0069		J A KRYCKA	15-JAN-1982                 */
/*		ADD SUPPORT AND NETFAIL ERROR CODES.                        */
/*                                                                          */
/*	V02-039	JAK0068		J A KRYCKA	31-DEC-1981                 */
/*		MODIFY TEXT FOR SUP, NET, BUG_DAP, AND ENV ERROR MESSAGES.  */
/*                                                                          */
/*	V02-038 LJA0001		LAURIE ANDERSON 20-DEC-1981                 */
/*		MODIFIED SOME MESSAGES TO READ BETTER.                      */
/*                                                                          */
/*	V02-037	JAK0063		J A KRYCKA	31-AUG-1981                 */
/*		ADD CRE_STM SUCCESS CODE.                                   */
/*                                                                          */
/*	V02-036	KPL0004		PETER LIEBERWIRTH	13-JAN-1981         */
/*		ADD ENQ SEVERE ERROR MESSAGE, TO INDICATE $ENQ/$DEQ FAILURE. */
/*		ALSO ADD SUCCESS CODES OK_RRL, AND OK_WAT.                  */
/*                                                                          */
/*	V02-035	REFORMAT	J A KRYCKA	30-JUL-1980                 */
/*                                                                          */
/*--                                                                        */
#define RMS$_FACILITY 1
#define RMS$V_STVSTATUS 14              /* MOVE TO BIT 14 OF THE            */
/* STATUS CODE IT INDICATES                                                 */
/* THAT STV CONTAINS A SECONDARY                                            */
/* STATUS CODE.                                                             */
#define RMS$_SUC 65537
#define RMS$_NORMAL 65537
/*+                                                                         */
/*                                                                          */
/*	SUCCESS CODES                                                       */
/*                                                                          */
/*-                                                                         */
/* BIT 16 = BIT 15 = 1                                                      */
#define RMS$_STALL 98305
/* (NOTE: USER NEVER RECEIVES THIS CODE)                                    */
#define RMS$_PENDING 98313
#define RMS$_OK_DUP 98321
#define RMS$_OK_IDX 98329
/*  (RECORD HAS BEEN INSERTED, BUT INDEX STRUCTURE IS NO LONGER             */
/*  OPTIMAL.)                                                               */
#define RMS$_OK_RLK 98337
/* (BECAUSE LOCKER SET RLK IN ROP FIELD WHEN RECORD WAS LOCKED.)            */
#define RMS$_OK_RRL 98345
/* (BECAUSE READER SET RRL IN ROP FIELD WHEN ACCESSING RECORD.)             */
/* (THIS CODE USED TO BE OK_RRV)                                            */
/*OK_RRV	;MSG <record was inserted successfully in primary>          */
/*  (BUT IT MAY NOT BE ACCESSIBLE VIA ONE-OR-MORE SECONDARY KEYS,           */
/*  AND NOT BY RFA ADDRESSING. FILE RE-ORGANIZATION RECOMMENDED!)           */
#define RMS$_KFF 98353
#define RMS$_OK_ALK 98361
#define RMS$_OK_DEL 98369
#define RMS$_OK_RNF 98377
#define RMS$_OK_LIM 98385
#define RMS$_OK_NOP 98393
#define RMS$_OK_WAT 98401
/* (BECAUSE WAT BIT IN ROP WAS SET AND RECORD WAS ALREADY                   */
/* LOCKED.)                                                                 */
#define RMS$_CRE_STM 98409
#define RMS$_OK_RULK 98417
#define RMS$_SYNCH 98425
/*+                                                                         */
/*                                                                          */
/*	SUCCESS CODES PASSED THRU FROM DRIVERS AND ACP -	BIT 15 = 0  */
/*                                                                          */
/*-                                                                         */
#define RMS$_CONTROLC 67153             /* TERMINAL I/O ABORTED DUE TO CTRL/C */
#define RMS$_CONTROLO 67081
/* TERMINAL I/O ABORTED DUE TO CTRL/O                                       */
#define RMS$_CONTROLY 67089
/* TERMINAL I/O ABORTED DUE TO CTRL/Y                                       */
#define RMS$_CREATED 67097
/* FILE WAS CREATED, NOT OPENED                                             */
#define RMS$_SUPERSEDE 67121
/* CREATED FILE SUPERSEDED EXISTING VERSION                                 */
#define RMS$_OVRDSKQUOTA 67177
/* DISK USAGE EXCEEDS DISK QUOTA                                            */
#define RMS$_FILEPURGED 67193
/* CREATE FILE CAUSED OLDEST FILE                                           */
/* VERSION TO BE PURGED                                                     */
/*+                                                                         */
/*                                                                          */
/*	WARNING CODES                                                       */
/*                                                                          */
/*-                                                                         */
/* BIT 16 = BIT 15 = 1, BIT 14 = 0                                          */
#define RMS$_BOF 98712
#define RMS$_RNL 98720
#define RMS$_RTB 98728
#define RMS$_TMO 98736
#define RMS$_TNS 98744
#define RMS$_BES 98752
#define RMS$_PES 98760
/*+                                                                         */
/*                                                                          */
/*	ERROR CODES - WITHOUT STV                                           */
/*                                                                          */
/*-                                                                         */
/* BIT 16 = BIT 15 = 1, BIT 14 = 0                                          */
#define RMS$_ACT 98906
#define RMS$_DEL 98914
#define RMS$_INCOMPSHR 98922
#define RMS$_DNR 98930
#define RMS$_EOF 98938
#define RMS$_FEX 98946
#define RMS$_FLK 98954
#define RMS$_FNF 98962
#define RMS$_PRV 98970
#define RMS$_REX 98978
#define RMS$_RLK 98986
#define RMS$_RNF 98994
/*  (RECORD NEVER WAS IN FILE, OR HAS BEEN DELETED.)                        */
#define RMS$_WLK 99002
#define RMS$_EXP 99010
#define RMS$_NMF 99018
#define RMS$_SUP 99026
/* (NOTE THAT SUPPORT HAS REPLACED SUP EXCEPT WHEN RMS CANNOT               */
/* MAP THE DAP STATUS CODE INTO A FAL STATUS CODE.)                         */
/* (NOTE ALSO THAT SUP SHOULD HAVE BEEN DEFINED AS A SEVERE                 */
/* ERROR CODE. HOWEVER, SUPPORT IS A SEVERE ERROR CODE.)                    */
#define RMS$_RSA 99034
#define RMS$_CRC 99042
#define RMS$_WCC 99050
#define RMS$_IDR 99058
#define RMS$_LWC 99066
#define RMS$_UNUSED1 99074
#define RMS$_NOVALPRS 99082
#define RMS$_KEY_MISMATCH 99090
#define RMS$_RUH 99098
#define RMS$_JND 99106
#define RMS$_BADPHASE 99114
#define RMS$_TOWDR 99122
#define RMS$_NEXDR 99130
#define RMS$_INVDRMSG 99138
#define RMS$_RU_ACTIVE 99146
#define RMS$_UNKRUFAC 99154
#define RMS$_LIMBO 99162
#define RMS$_IVATRACE 99170
/*+                                                                         */
/*                                                                          */
/*	ERROR CODES - WITH STV ERROR CODE                                   */
/*                                                                          */
/*-                                                                         */
/* BIT 16 = BIT 15 = BIT 14 = 1                                             */
#define RMS$_ACC 114690
#define RMS$_CRE 114698
#define RMS$_DAC 114706
#define RMS$_ENT 114714
#define RMS$_EXT 114722
#define RMS$_FND 114730
#define RMS$_MKD 114738
#define RMS$_DPE 114746
#define RMS$_SPL 114754
#define RMS$_DNF 114762
#define RMS$_RUF 114770
#define RMS$_WRTJNL_AIJ 114778
#define RMS$_WRTJNL_BIJ 114786
#define RMS$_WRTJNL_ATJ 114794
#define RMS$_WRTJNL_RUJ 114802
#define RMS$_RRF 114810
/*+                                                                         */
/*                                                                          */
/*	SEVERE ERROR CODES - WITHOUT STV                                    */
/*                                                                          */
/*-                                                                         */
/* BIT 16 = BIT 15 = 1, BIT 14 = 0                                          */
#define RMS$_DTFCDDREC 99308
#define RMS$_AID 99316
#define RMS$_ALN 99324
#define RMS$_ALQ 99332
#define RMS$_ANI 99340
#define RMS$_AOP 99348
#define RMS$_BKS 99356
#define RMS$_BKZ 99364
#define RMS$_BLN 99372
#define RMS$_BUG 99380
#define RMS$_BUG_DDI 99388
#define RMS$_BUG_DAP 99396
#define RMS$_BUG_RU_ACTIVE 99404
#define RMS$_BUG_RURECERR 99412
#define RMS$_BUG_FLUSH_JNL_FAILED 99420
#define RMS$_BUG_RU_ABORT_FAIL 99428
#define RMS$_BUG_RU_COMMIT_FAIL 99436
#define RMS$_BUG_XX6 99444
#define RMS$_BUG_XX7 99452
#define RMS$_BUG_XX8 99460
#define RMS$_BUSY 99468
#define RMS$_CCR 99476
#define RMS$_CHG 99484
#define RMS$_CHK 99492
#define RMS$_COD 99500
#define RMS$_CUR 99508
#define RMS$_DAN 99516
#define RMS$_DEV 99524
#define RMS$_DIR 99532
#define RMS$_DME 99540
#define RMS$_DNA 99548
#define RMS$_DTP 99556
#define RMS$_DUP 99564
#define RMS$_DVI 99572
#define RMS$_ESA 99580
#define RMS$_ESS 99588
#define RMS$_FAB 99596
#define RMS$_FAC 99604
#define RMS$_FLG 99612
#define RMS$_FNA 99620
#define RMS$_FNM 99628
#define RMS$_FSZ 99636
#define RMS$_FOP 99644
#define RMS$_FUL 99652
#define RMS$_IAL 99660
#define RMS$_IAN 99668
#define RMS$_IDX 99676
#define RMS$_IFI 99684
#define RMS$_IMX 99692
#define RMS$_IOP 99700
#define RMS$_IRC 99708
#define RMS$_ISI 99716
#define RMS$_KBF 99724
#define RMS$_KEY 99732
#define RMS$_KRF 99740
#define RMS$_KSZ 99748
#define RMS$_LAN 99756
#define RMS$_RUNDOWN 99764
#define RMS$_LNE 99772
#define RMS$_DTFCVT 99780
#define RMS$_MRN 99788
#define RMS$_MRS 99796
#define RMS$_NAM 99804
#define RMS$_NEF 99812
#define RMS$_DTFQUASYN 99820
#define RMS$_NOD 99828
#define RMS$_NPK 99836
#define RMS$_ORD 99844                  /*! NOT USED AS OF V4               */
#define RMS$_ORG 99852
#define RMS$_PBF 99860
#define RMS$_PLG 99868
#define RMS$_POS 99876
#define RMS$_DTFQUAVAL 99884
#define RMS$_QUO 99892
#define RMS$_RAB 99900
#define RMS$_RAC 99908
#define RMS$_RAT 99916
#define RMS$_RBF 99924
#define RMS$_RFA 99932
#define RMS$_RFM 99940
#define RMS$_RHB 99948
#define RMS$_RLF 99956
#define RMS$_ROP 99964
#define RMS$_RRV 99972
#define RMS$_RVU 99980
#define RMS$_RSS 99988
#define RMS$_RST 99996
#define RMS$_RSZ 100004
#define RMS$_SEQ 100012
#define RMS$_SHR 100020
#define RMS$_SIZ 100028
#define RMS$_SQO 100036
#define RMS$_DTFSESEST 100044
#define RMS$_SYN 100052
#define RMS$_TRE 100060
#define RMS$_TYP 100068
#define RMS$_UBF 100076
#define RMS$_USZ 100084
#define RMS$_VER 100092
#define RMS$_XNF 100100
#define RMS$_XAB 100108
#define RMS$_ESL 100116
#define RMS$_DTFSESTER 100124
#define RMS$_ENV 100132
#define RMS$_PLV 100140
#define RMS$_MBC 100148
#define RMS$_RSL 100156
#define RMS$_WLD 100164
#define RMS$_NET 100172                 /* (NOTE THAT NETFAIL HAS REPLACED NET EXCEPT WHEN RMS CANNOT */
/* MAP THE DAP STATUS CODE INTO A FAL STATUS CODE.)                         */
#define RMS$_IBF 100180
#define RMS$_REF 100188
#define RMS$_IFL 100196
#define RMS$_DFL 100204
#define RMS$_KNM 100212
#define RMS$_IBK 100220
#define RMS$_KSI 100228
#define RMS$_LEX 100236
#define RMS$_SEG 100244
#define RMS$_SNE 100252                 /*! NOT USED AS OF V4               */
#define RMS$_SPE 100260                 /*! NOT USED AS OF V4               */
#define RMS$_UPI 100268
#define RMS$_ACS 100276
#define RMS$_STR 100284
#define RMS$_FTM 100292
#define RMS$_GBC 100300
#define RMS$_DEADLOCK 100308
#define RMS$_EXENQLM 100316
#define RMS$_JOP 100324
#define RMS$_RUM 100332
#define RMS$_JNS 100340
#define RMS$_NRU 100348
#define RMS$_IFF 100356
#define RMS$_DTFTRATBL 100364
#define RMS$_DTFUNSTYP 100372
#define RMS$_DTFVERMIS 100380
#define RMS$_DTFACC 100388
#define RMS$_BOGUSCOL 100396
#define RMS$_ERRREADCOL 100404
#define RMS$_ERRWRITECOL 100412
#define RMS$_SNS 100420
#define RMS$_NOEXTEND 100428
#define RMS$_DTFCRE 100436
#define RMS$_DELJNS 100444
#define RMS$_NOTSAMEJNL 100452
#define RMS$_SNPPF 100460               /*+                                 */
/*                                                                          */
/*	SEVERE ERRORS - WITH STV ERROR CODE                                 */
/*                                                                          */
/*-                                                                         */
/* BIT 16 = BIT 15 = BIT 14 = 1                                             */
#define RMS$_ATR 114892
#define RMS$_ATW 114900
#define RMS$_CCF 114908
#define RMS$_CDA 114916
#define RMS$_CHN 114924
#define RMS$_RER 114932
#define RMS$_RMV 114940
#define RMS$_RPL 114948
#define RMS$_SYS 114956
#define RMS$_WER 114964
#define RMS$_WPL 114972
#define RMS$_IFA 114980
#define RMS$_WBE 114988
#define RMS$_ENQ 114996
#define RMS$_NETFAIL 115004
#define RMS$_SUPPORT 115012
#define RMS$_CRMP 115020
#define RMS$_DTFCFGFIL 115028
#define RMS$_REENT 115036
#define RMS$_ACC_RUJ 115044
#define RMS$_TMR 115052
#define RMS$_ACC_AIJ 115060
#define RMS$_ACC_BIJ 115068
#define RMS$_ACC_ATJ 115076
#define RMS$_DTFDEFFIL 115084
#define RMS$_DTFREGFIL 115092
#define RMS$_JNLNOTAUTH 115100

#endif					/* __RMSDEF_LOADED */
#ifndef __SBKDEF_LOADED
#define __SBKDEF_LOADED	1

/*** MODULE $sbkdef ***/
/*+                                                                         */
/*                                                                          */
/* Statistics block. This block is used to report various data regarding    */
/* an open file to the requesting program.                                  */
/*                                                                          */
/*-                                                                         */
/*                                                                          */
/* The first two longwords are presented in inverted form for compatibility */
/* with the old RSX-11 statistics block.                                    */
/*                                                                          */
#define SBK$K_LENGTH 32
#define SBK$C_LENGTH 32
struct sbkdef {
#pragma nostandard
    variant_union  {
        unsigned long int sbk$l_stlbn;  /* starting LBN if contiguous       */
        variant_struct  {
            unsigned short int sbk$w_stlbnh; /* high order word             */
            unsigned short int sbk$w_stlbnl; /* low order word              */
            } sbk$r_stlbn_fields;
        } sbk$r_stlbn_overlay;
    variant_union  {
        unsigned long int sbk$l_filesize; /* file size                      */
        variant_struct  {
            unsigned short int sbk$w_filesizh; /* high order word           */
            unsigned short int sbk$w_filesizl; /* low order word            */
/*                                                                          */
/* The following two fields are for RSX-11 compatibility                    */
/*                                                                          */
            } sbk$r_filesize_fields;
        } sbk$r_filesize_overlay;
    unsigned char sbk$b_acnt;           /* low byte of access count         */
    unsigned char sbk$b_lcnt;           /* low byte of lock count           */
    unsigned long int sbk$l_fcb;        /* address of file control block    */
    short int sbkdef$$_fill_1;          /* spare                            */
    unsigned short int sbk$w_acnt;      /* access count                     */
    unsigned short int sbk$w_lcnt;      /* lock count (against writers)     */
    unsigned short int sbk$w_wcnt;      /* writer count                     */
    unsigned short int sbk$w_tcnt;      /* truncate lock count              */
    unsigned long int sbk$l_reads;      /* count of reads executed on channel  */
    unsigned long int sbk$l_writes;     /* count of writes executed on channel  */
    } ;
 
#pragma standard

#endif					/* __SBKDEF_LOADED */
#ifndef __SCRDEF_LOADED
#define __SCRDEF_LOADED	1

/*** MODULE $scrdef ***/
/* SCREEN PACKAGE REQUEST TYPES                                             */
#define SCR$C_PUT_SCREEN 0              /* SCR$PUT_SCREEN                   */
#define SCR$C_GET_SCREEN 1              /* SCR$GET_SCREEN                   */
#define SCR$C_ERASE_PAGE 2              /* SCR$ERASE_PAGE                   */
#define SCR$C_ERASE_LINE 3              /* SCR$ERASE_LINE                   */
#define SCR$C_SET_CURSOR 4              /* SCR$SET_CURSOR                   */
#define SCR$C_DOWN_SCROLL 5             /* SCR$DOWN_SCROLL                  */
#define SCR$C_SCREEN_INFO 6             /* SCR$SCREEN_INFO                  */
#define SCR$C_PUT_LINE 7                /* SCR$PUT_LINE                     */
#define SCR$C_MOVE_CURSOR 8             /* SCR$MOVE_CURSOR                  */
#define SCR$C_SET_SCROLL 9              /* SCR$SET_SCROLL                   */
#define SCR$C_UP_SCROLL 10              /* SCR$UP_SCROLL                    */
/*                                                                          */
/*        DEFINE BIT MASKS AND VALUES FOR SCREEN ATTRIBUTES                 */
/*                                                                          */
#define SCR$M_BOLD 1
#define SCR$M_REVERSE 2
#define SCR$M_BLINK 4
#define SCR$M_UNDERLINE 8
#define SCR$M_NORMAL 0                  /*no bits set                       */
union scrdef {
#pragma nostandard
    variant_struct  {
        unsigned scr$v_bold : 1;
        unsigned scr$v_reverse : 1;
        unsigned scr$v_blink : 1;
        unsigned scr$v_underline : 1;
        unsigned scr$v_fill_0 : 4;
        } scr$r_scrdef_bits;
    } ;
/*                                                                          */
/*        DEFINE FORMAT OF SCR$SCREEN_INFO RETURN BUFFER                    */
/*                                                                          */
#define SCR$M_SCREEN 1
#define SCR$M_ANSICRT 2
#define SCR$M_REGIS 4
#define SCR$M_BLOCK 8
#define SCR$M_AVO 16
#define SCR$M_EDIT 32
#define SCR$M_DECCRT 64
#define SCR$K_LENGTH 20                 /* LENGTH OF INFO RETURN BUFFER     */
#define SCR$C_LENGTH 20                 /* LENGTH OF INFO RETURN BUFFER     */
struct scrdef1 {
    variant_union  {
        unsigned long int scr$l_flags;  /* FLAGS LONGWORD                   */
        variant_struct  {
            unsigned scr$v_screen : 1;  /* 1 = SCREEN ORIENTED, 0 = SCROLLING  */
            unsigned scr$v_ansicrt : 1; /* ANSI TERMINAL                    */
            unsigned scr$v_regis : 1;   /* REGIS TERMINAL                   */
            unsigned scr$v_block : 1;   /* BLOCK MODE TERMINAL              */
            unsigned scr$v_avo : 1;     /* ADVANCED VIDEO TERMINAL          */
            unsigned scr$v_edit : 1;    /* TERMINAL HAS EDIT CAPABILITY     */
            unsigned scr$v_deccrt : 1;  /* TERMINAL IS A DEC CRT            */
            unsigned scr$v_fill_1 : 1;
            } scr$r_flags_bits;
        } scr$r_flags_overlay;
    unsigned short int scr$w_width;     /* WIDTH OF EACH LINE               */
    unsigned short int scr$w_pagesize;  /* LINES IN SCREEN                  */
    unsigned char scr$b_devtype;        /* DEVICE TYPE (SEE $DCDEF)         */
    char scrdef$$_fill_1 [11];          /* (RESERVED)                       */
    } ;
#pragma standard

#endif					/* __SCRDEF_LOADED */
#ifndef __SDFDEF_LOADED
#define __SDFDEF_LOADED	1

/*** MODULE $sdfdef ***/
/*                                                                          */
/* Symbol definition                                                        */
/*                                                                          */
#define SDF$K_NAME 10
#define SDF$C_NAME 10
struct sdfdef {
#pragma nostandard
    variant_union  {
        unsigned char sdf$b_gsdtyp;     /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char sdf$t_start [];
            char sdfdef$$_fill_1;
            } sdf$r_gsdtyp_fields;
        } sdf$r_gsdtyp_overlay;
    unsigned char sdf$b_datyp;          /*Maps over GSY$B_DATYP             */
    unsigned short int sdf$w_flags;     /*Maps over GSY$W_FLAGS             */
    unsigned char sdf$b_psindx;         /*Owning psect number               */
    unsigned long int sdf$l_value;      /*Value of symbol                   */
    unsigned char sdf$b_namlng;         /*Length of name                    */
    char sdf$t_name [31];               /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __SDFDEF_LOADED */
#ifndef __SDFMDEF_LOADED
#define __SDFMDEF_LOADED	1

/*** MODULE $sdfmdef ***/
/*                                                                          */
/* Symbol definition for version mask symbols                               */
/*                                                                          */
#define SDFM$K_NAME 14
#define SDFM$C_NAME 14
struct sdfmdef {
#pragma nostandard
    variant_union  {
        unsigned char sdfm$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char sdfm$t_start [];
            char sdfmdef$$_fill_1;
            } sdfm$r_gsdtyp_fields;
        } sdfm$r_gsdtyp_overlay;
    unsigned char sdfm$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int sdfm$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned char sdfm$b_psindx;        /*Owning psect number               */
    unsigned long int sdfm$l_value;     /*Value of symbol                   */
    unsigned long int sdfm$l_version_mask; /*Mask for symbol                */
    unsigned char sdfm$b_namlng;        /*Length of name                    */
    char sdfm$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __SDFMDEF_LOADED */
#ifndef __SDFVDEF_LOADED
#define __SDFVDEF_LOADED	1

/*** MODULE $sdfvdef ***/
/*                                                                          */
/* Symbol definition for vectored symbols                                   */
/*                                                                          */
#define SDFV$K_NAME 14
#define SDFV$C_NAME 14
struct sdfvdef {
#pragma nostandard
    variant_union  {
        unsigned char sdfv$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char sdfv$t_start [];
            char sdfvdef$$_fill_1;
            } sdfv$r_gsdtyp_fields;
        } sdfv$r_gsdtyp_overlay;
    unsigned char sdfv$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int sdfv$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned char sdfv$b_psindx;        /*Owning psect number               */
    unsigned long int sdfv$l_value;     /*Value of symbol                   */
    unsigned long int sdfv$l_vector;    /*Vectored value of symbol          */
    unsigned char sdfv$b_namlng;        /*Length of name                    */
    char sdfv$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __SDFVDEF_LOADED */
#ifndef __SDFWDEF_LOADED
#define __SDFWDEF_LOADED	1

/*** MODULE $sdfwdef ***/
/*                                                                          */
/* Symbol definition with word of psect value                               */
/*                                                                          */
#define SDFW$K_NAME 11
#define SDFW$C_NAME 11
struct sdfwdef {
#pragma nostandard
    variant_union  {
        unsigned char sdfw$b_gsdtyp;    /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char sdfw$t_start [];
            char sdfwdef$$_fill_1;
            } sdfw$r_gsdtyp_fields;
        } sdfw$r_gsdtyp_overlay;
    unsigned char sdfw$b_datyp;         /*Maps over GSY$B_DATYP             */
    unsigned short int sdfw$w_flags;    /*Maps over GSY$W_FLAGS             */
    unsigned short int sdfw$w_psindx;   /*Owning psect number               */
    unsigned long int sdfw$l_value;     /*Value of symbol                   */
    unsigned char sdfw$b_namlng;        /*Length of name                    */
    char sdfw$t_name [31];              /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __SDFWDEF_LOADED */
#ifndef __SECDEF_LOADED
#define __SECDEF_LOADED	1

/*** MODULE $secdef ***/
/*+                                                                         */
/* PROCESS OR GLOBAL SECTION DEFINITIONS                                    */
/*-                                                                         */
/*                                                                          */
/* ***** L_VBN, L_WINDOW, AND B_PFC MUST BE THE SAME OFFSET VALUES AS THE   */
/* ***** EQUIVALENTLY NAMED OFFSETS IN $PFLDEF                              */
/*                                                                          */
#define SEC$M_VPX 4194303
#define SEC$M_PFC -16777216
#define SEC$M_GBL 1
#define SEC$M_CRF 2
#define SEC$M_DZRO 4
#define SEC$M_WRT 8
#define SEC$M_SHMGS 16
#define SEC$M_WRTMOD 192
#define SEC$M_AMOD 768
#define SEC$M_RESIDENT 8192
#define SEC$M_PERM 16384
#define SEC$M_SYSGBL 32768
#define SEC$M_PFNMAP 65536
#define SEC$M_EXPREG 131072
#define SEC$M_PROTECT 262144
#define SEC$M_PAGFIL 524288
#define SEC$M_EXECUTE 1048576
#define SEC$M_NOPROTCHK 2097152
#define SEC$M_NO_OVERMAP 4194304
#pragma nostandard
struct SEC {
    variant_union  {
        unsigned long int sec$l_gsd;    /*GLOBAL SECTION DESCRIPTOR ADDRESS  */
        unsigned long int sec$l_ccb;    /*CHANNEL CONTROL BLOCK ADDRESS IF PROCESS SECTION  */
        } sec$r_gsd_overlay;
    unsigned short int sec$w_secxfl;    /*SECTION INDEX FORWARD LINK        */
    unsigned short int sec$w_secxbl;    /*SECTION INDEX BACKWARD LINK       */
    variant_union  {
        unsigned long int sec$l_vpxpfc; /*START VIRT PAGE INDEX & PFC       */
        variant_struct  {
            unsigned sec$v_vpx : 22;    /* STARTING VIRTUAL PAGE INDEX      */
            unsigned secdef$$_fill_1 : 2; /* UNUSED                         */
            unsigned sec$v_pfc : 8;     /* PAGE FAULT CLUSTER               */
            } sec$r_vpxpfc_bits;
        variant_struct  {
            char secdef$$_fill_5 [3];
            unsigned char sec$b_pfc;    /*PAGE FAULT CLUSTER                */
            } sec$r_vpxpfc_fields;
        } sec$r_vpxpfc_overlay;
    unsigned long int sec$l_window;     /*WINDOW CONTROL BLOCK              */
    unsigned long int sec$l_vbn;        /*BASE VIRTUAL BLOCK NUMBER         */
    variant_union  {
        unsigned short int sec$w_flags; /*VARIOUS CONTROL FLAGS             */
        variant_struct  {
            unsigned sec$v_gbl : 1;     /* GLOBAL SECTION                   */
            unsigned sec$v_crf : 1;     /* COPY ON REFERENCE                */
            unsigned sec$v_dzro : 1;    /* DEMAND ZERO                      */
            unsigned sec$v_wrt : 1;     /* WRITABLE                         */
            unsigned sec$v_shmgs : 1;   /* SHARED MEMORY GLOBAL SECTION     */
            unsigned secdef$$_fill_2 : 1; /* SPARE                          */
            unsigned sec$v_wrtmod : 2;  /* WRITE ACCESS MODE FOR SECTION    */
            unsigned sec$v_amod : 2;    /* ACCESS MODE OF SECTION           */
            unsigned secdef$$_fill_3 : 3; /* SPARE                          */
            unsigned sec$v_resident : 1; /* RESIDENT GLOBAL                 */
            unsigned sec$v_perm : 1;    /* PERMANENT SECTION                */
            unsigned sec$v_sysgbl : 1;  /* 1 = SYSTEM GLOBAL, 0 = GROUP GLOBAL  */
/*                                                                          */
/* *****  THE FOLLOWING FLAGS ARE INDICATORS FOR $MGBLSC AND $CRMPSC SYSTEM */
/* *****  SERVICE REQUESTS AND ARE NOT STORED IN THE FLAGS WORD FIELD.      */
/*                                                                          */
            unsigned sec$v_pfnmap : 1;  /* MAP TO SPECIFIC PFN'S            */
            unsigned sec$v_expreg : 1;  /* MAP INTO FIRST FREE ADDRESS SPACE  */
            unsigned sec$v_protect : 1; /* CHECK WRITE ACCESS MODE (WRTMOD)  */
            unsigned sec$v_pagfil : 1;  /* GLOBAL SECTION HAS PAGE FILE BACKING STORE  */
            unsigned sec$v_execute : 1; /* CHECK FOR EXECUTE ACCESS         */
            unsigned sec$v_noprotchk : 1; /* INHIBIT PROTECTION CHECK       */
            unsigned sec$v_no_overmap : 1; /* DON'T OVERMAP ADDRESS SPACE   */
            unsigned sec$v_fill_0 : 1;
            } sec$r_flags_bits;
        } sec$r_flags_overlay;
    } ;
#define SEC$K_LENGTH 32                 /*SIZE OF PSTE/GSTE                 */
#define SEC$C_LENGTH 32                 /*SIZE OF PSTE/GSTE                 */
/*+                                                                         */
#define SEC$K_MATALL 0                  /* MATCH ALWAYS, USE GLOBAL SECTION  */
#define SEC$K_MATEQU 1                  /* MATCH IF ISD$L_IDENT EQU GBL ID  */
#define SEC$K_MATLEQ 2                  /* MATCH IF ISD$L_IDENT LEQ GBL ID  */
struct secdef1 {
    char secdef$$_fill_6 [21];
    unsigned char sec$b_amod;           /*ACCESS MODE OF SECTION            */
    short int secdef$$_fill_4;          /*SPARE                             */
    unsigned long int sec$l_refcnt;     /*COUNT OF PTE'S REFERENCING THIS SECTION  */
    unsigned long int sec$l_pagcnt;     /*NO. OF PAGES IN THE SECTION       */
/*                                                                          */
/* ***** NOTE THAT NUMBER OF LONG WORDS MUST BE EVEN                        */
/*                                                                          */
/* MATCH CONTROL VIELD VALUES                                               */
/*-                                                                         */
/* BASE OF ZERO , INCR 1                                                    */
    } ;
#pragma standard
/*                                                                          */
/* Definitions for $GETSECI service                                         */
/*                                                                          */
#define SECI$_CHAIN 1                   /* Chained item block               */
#define SECI$_GSMODE 2                  /* Access mode of section           */
#define SECI$_GSFLAGS 3                 /* Flags                            */
#define SECI$_GSNAME 4                  /* Global section name              */
#define SECI$_GSIDENT 5                 /* Global section ident             */
#define SECI$_GSRELPAG 6                /* Relative page number             */
 

#endif					/* __SECDEF_LOADED */
#ifndef __SETJMP_LOADED
#define __SETJMP_LOADED	1

/*	SETJMP - V3.0 - Setjmp and Longjmp Environment Buffer Definition	*/

/*
 * jmp_buf expanded to 15 entries on 28 May 1984 in connection with 
 * new set/long-jmp mechanism to handle signals and ASTs correctly
 */

typedef int jmp_buf[15];
#define	JMP_BUF_TYPE int *

int setjmp (jmp_buf env);

void longjmp (jmp_buf env, int val);

#endif					/* __SETJMP_LOADED */
#ifndef __SFDEF_LOADED
#define __SFDEF_LOADED	1

/*** MODULE $sfdef ***/
/*+                                                                         */
/* Define stack frame offsets as a separate structure SF$                   */
/*-                                                                         */
#define SF$V_C		0		   	/* carry condition code */
#define SF$V_V		1		   	/* overflow condition code */
#define SF$V_Z		2		   	/* zero condition code */
#define SF$V_N		3		   	/* negative condition code */
#define SF$V_TBIT	4		   	/* trace trap enable bit */
#define SF$V_IV		5		   	/* integer overflow trap enable bit */
#define SF$V_FU		6		   	/* floating underflow trap enable bit */
#define SF$V_DV		7		   	/* decimal overflow trap enable bit */

#define SF$M_C 1
#define SF$M_V 2
#define SF$M_Z 4
#define SF$M_N 8
#define SF$M_TBIT 16
#define SF$M_IV 32
#define SF$M_FU 64
#define SF$M_DV 128
#pragma nostandard
struct sf$frame {
    int *sf$a_handler;                  /* Adr. of handler or 0 if no handler  */
    variant_union  {
        unsigned short int sf$w_save_psw; /* saved PSW                      */
        variant_struct  {
            unsigned sf$v_c : 1;        /* carry                            */
            unsigned sf$v_v : 1;        /* overflow                         */
            unsigned sf$v_z : 1;        /* zero                             */
            unsigned sf$v_n : 1;        /* negative                         */
            unsigned sf$v_tbit : 1;     /* trace trap enable                */
            unsigned sf$v_iv : 1;       /* integer overflow enable          */
            unsigned sf$v_fu : 1;       /* floating underflow enable        */
            unsigned sf$v_dv : 1;       /* decimal overflow enable          */
            } sf$r_save_psw_bits;
        } sf$r_save_psw_overlay;
    variant_union  {
        unsigned short int sf$w_save_mask; /* saved register mask plus flags  */
        variant_struct  {
            unsigned sf$v_save_mask : 12; /* register save mask             */
            unsigned sfdef$$_fill_1 : 1; /* MBZ                             */
            unsigned sf$v_calls : 1;    /* 1 if CALLS                       */
            unsigned sf$v_stackoffs : 2; /* SP offset                       */
            } sf$r_save_mask_bits;
        } sf$r_save_mask_overlay;
    unsigned long int sf$l_save_ap;     /* saved AP                         */
    unsigned long int sf$l_save_fp;     /* saved FP                         */
    unsigned long int sf$l_save_pc;     /* saved PC                         */
    unsigned long int sf$l_save_regs;   /* first register saved is saved here  */
    } ;
#pragma standard

#endif					/* __SFDEF_LOADED */
#ifndef __SGPSDEF_LOADED
#define __SGPSDEF_LOADED	1

/*** MODULE $sgpsdef ***/
/*                                                                          */
/* GSD entry - P-section definition in shareable image                      */
/*                                                                          */
#define SGPS$M_PIC 1
#define SGPS$M_LIB 2
#define SGPS$M_OVR 4
#define SGPS$M_REL 8
#define SGPS$M_GBL 16
#define SGPS$M_SHR 32
#define SGPS$M_EXE 64
#define SGPS$M_RD 128
#define SGPS$M_WRT 256
#define SGPS$M_VEC 512
#define SGPS$K_NAME 13
#define SGPS$C_NAME 13
struct sgpsdef {
#pragma nostandard
    variant_union  {
        unsigned char sgps$b_gsdtyp;    /*Typ field                         */
        variant_struct  {
            char sgps$t_start [];
            char sgpsdef$$_fill_1;
            } sgps$r_gsdtyp_fields;
        } sgps$r_gsdtyp_overlay;
    unsigned char sgps$b_align;         /*P-sect alignment                  */
    variant_union  {
        unsigned short int sgps$w_flags; /*P-sect flags                     */
        variant_struct  {
            unsigned sgps$v_pic : 1;    /*Position independent              */
            unsigned sgps$v_lib : 1;    /*From a shareable image            */
            unsigned sgps$v_ovr : 1;    /*Overlaid memory allocation        */
            unsigned sgps$v_rel : 1;    /*Relocatable                       */
            unsigned sgps$v_gbl : 1;    /*Global scope                      */
            unsigned sgps$v_shr : 1;    /*Shareable                         */
            unsigned sgps$v_exe : 1;    /*Executable                        */
            unsigned sgps$v_rd : 1;     /*Readable                          */
            unsigned sgps$v_wrt : 1;    /*Writeable                         */
            unsigned sgps$v_vec : 1;    /*Vector psect                      */
            unsigned sgps$v_fill_16 : 6;
            } sgps$r_flags_bits;
        } sgps$r_flags_overlay;
    unsigned long int sgps$l_alloc;     /*Length of this psect in shr image  */
    unsigned long int sgps$l_base;      /*Base of this psect in shr image   */
    unsigned char sgps$b_namlng;        /*Length of p-sect name             */
    char sgps$t_name [31];              /*Name field                        */
    } ;
 
#pragma standard

#endif					/* __SGPSDEF_LOADED */
#ifndef __SHRDEF_LOADED
#define __SHRDEF_LOADED	1

/*** MODULE $shrdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 00:50:16.57 */
/*                                                                          */
/* SHRMSG.MSG - SYSTEM DEFINITION FILE FOR SHARED MESSAGES                  */
/*                                                                          */
/* VERSION:	'X-4'                                                       */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*++                                                                        */
/*                                                                          */
/* FACILITY:  VAX/VMS SYSTEM MACRO LIBRARIES                                */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS FILE CONTAINS THE MDL SOURCE FOR THE SHARED MESSAGES.          */
/*                                                                          */
/* ENVIRONMENT:                                                             */
/*                                                                          */
/*	N/A                                                                 */
/*                                                                          */
/*--                                                                        */
/*                                                                          */
/*                                                                          */
/* AUTHOR:  THE VMS GROUP	 CREATION DATE:  1-AUG-1976                 */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	X-4	RJS		RON SOMMER		12-OCT_1987         */
/*		ADD MESSAGE PRDCONT. COMMON LMF MESSAGE TO BE USED BY       */
/*		SYSTEM LAYERED PRODUCTS WHEN LICENSE CHECK HAS FAILED       */
/*		BUT PRODUCT EXECUTION IS CONTINUING.                        */
/*                                                                          */
/*	X-3	AEW0002		ANNE E. WARNER		08-DEC-1986         */
/*		ADD MESSAGES ANBIGANS AND INVALANS USED FOR /CONFIRM        */
/*		IN COMMON QUALIFIER PACKAGE (LIBCQUAL).                     */
/*                                                                          */
/*	X-2	CWH5002		CW HOBBS		30-MAY-1986         */
/*		CORRECT SPELLING IN NOSUCHID.                               */
/*                                                                          */
/*	V03-011	TSK0002		TAMAR KRICHEVSKY	 28-MAR-1984        */
/*		ADD NOSUCHID.                                               */
/*                                                                          */
/*       V03-010 AEW0001         ANNE E. WARNER           6-MAR-1984        */
/*               ADD FILSPCSRCH AND NOSRCHLIST.                             */
/*                 FILSPCSRCH - FILE SPECIFICATION CONTAINS A SEARCH LIST.  */
/*                 NOSRCHLST  - COMMAND DOES NOT SUPPORT SEARCH LISTS.      */
/*               BOTH MESSAGES ORIGINALLY IN [CLIUTL.SRC]SETDIR.B32.        */
/*                                                                          */
/*	V03-009	TSK0001		TAMAR KRICHEVSKY	 8-FEB-1984         */
/*		ADD QUALMISS.                                               */
/*                                                                          */
/*	V03-008	SHZ0004		STEPHEN H. ZALEWSKI,	28-FEB-1983         */
/*		CHANGED TEXT OF NOFILPURG.                                  */
/*                                                                          */
/*	V03-007	SHZ0003		STEPHEN H. ZALEWSKI,	11-JAN-1983         */
/*		ADD FILNOTACC.  MAKE DELINTERR AND DIRTOBUSY OBSOLETE.      */
/*                                                                          */
/*	V03-006	SBL3006		STEVEN B. LIONEL, 19-NOV-1982               */
/*		ADD NOFILES.                                                */
/*                                                                          */
/*	V03-005	MLJ0094		MARTIN L. JACK,	31-JUL-1982  23:18          */
/*		ADD INVQUAVAL.                                              */
/*                                                                          */
/*	V03-004	SHZ0002		STEPHEN H. ZALEWSKI,	23-JUL-1982  16:40  */
/*		ADDED TOTAL, PURGED, AND FILDELETED MESSAGES.               */
/*                                                                          */
/*	V03-003	BLS0152		BENN SCHREIBER	25-MAY-1982                 */
/*		ADD PRODNOTINS MESSAGE                                      */
/*                                                                          */
/*	V03-002	GAS0068		GERRY SMITH	31-MAR-1982                 */
/*		ADD NOTRUNC MESSAGE.                                        */
/*                                                                          */
/*	V03-001	MLJ0084		MARTIN L. JACK,	28-MAR-1982  14:48          */
/*		CLEAN UP INITIAL CAPITALIZATION ERRORS.                     */
/*                                                                          */
/* THESE MESSAGE CODES SHOULD NOT BE USED DIRECTLY BY A FACILITY SINCE      */
/* THEY DO NOT CONTAIN A SUBSYSTEM (I.E., FACILITY) IDENTIFIER OR A         */
/* SEVERITY CODE.  USE THE FOLLOWING FORMULA TO CALCULATE ACTUAL FACILITY   */
/* MESSAGE CODES.                                                           */
/*	FACILITY MESSAGE CODE = COMMON MESSAGE CODE +                       */
/*				FACILITY ID * 65536 +                       */
/*				SEVERITY CODE                               */
#define SHR$_FACILITY 0
#define SHR$_APPENDEDB 4096
#define SHR$_APPENDEDR 4104
#define SHR$_BADBYTE 4112
#define SHR$_BADFIELD 4120
#define SHR$_BADLONG 4128
#define SHR$_BADWORD 4136
#define SHR$_BEGIN 4144
#define SHR$_BEGIND 4152
#define SHR$_BEGINT 4160
#define SHR$_CLICB 4168
#define SHR$_CLOSEIN 4176
#define SHR$_CLOSEOUT 4184
#define SHR$_COPIEDB 4192
#define SHR$_COPIEDR 4200
#define SHR$_CREATED 4208
#define SHR$_ENDED 4216
#define SHR$_ENDEDD 4224
#define SHR$_ENDEDT 4232
#define SHR$_NEWFILES 4240
#define SHR$_OPENIN 4248
#define SHR$_OPENOUT 4256
#define SHR$_OVERLAY 4264
#define SHR$_READERR 4272
#define SHR$_REPLACED 4280
#define SHR$_WILDCONCAT 4288
#define SHR$_WILDOUTVER 4296
#define SHR$_WRITEERR 4304
#define SHR$_ABEND 4312
#define SHR$_ABENDD 4320
#define SHR$_ABENDT 4328
#define SHR$_SYSERRORPC 4336
#define SHR$_SYNTAX 4344
#define SHR$_NOVALUE 4352
#define SHR$_BADKEY 4360
#define SHR$_BADVALUE 4368
#define SHR$_BADDELIM 4376
#define SHR$_BADLOGIC 4384
#define SHR$_NOWILD 4392
#define SHR$_TEXT 4400
#define SHR$_IDXCONCAT 4408
#define SHR$_RELCONCAT 4416
#define SHR$_HIGHVER 4424
#define SHR$_BADLOGICPC 4432
#define SHR$_ATPC 4440
#define SHR$_BADCOPIES 4448
#define SHR$_BADFORM 4456
#define SHR$_BADJOBID 4464
#define SHR$_BADJOBNAME 4472
#define SHR$_BADPRTY 4480
#define SHR$_BADQNAME 4488
#define SHR$_BADTIME 4496
#define SHR$_NOQUEUE 4504
#define SHR$_NOJOBID 4512
#define SHR$_NOJOBNAME 4520
#define SHR$_SYSERROR 4528
#define SHR$_NOTCOPIED 4536
#define SHR$_NOTCMPLT 4544
#define SHR$_RMSERROR 4552
#define SHR$_UNXPCTSTS 4560
#define SHR$_HASHCONCAT 4568
#define SHR$_INCOMPAT 4576
#define SHR$_VALERR 4584
#define SHR$_FILNOTDEL 4592
#define SHR$_CONFDEL 4600
#define SHR$_DELETED 4608
#define SHR$_DELVER 4616
#define SHR$_PURGEVER 4624
#define SHR$_CLOSEDEL 4632
#define SHR$_DIRTOOBUS 4640
#define SHR$_NOFILPURG 4648
#define SHR$_FILNOTPUR 4656
#define SHR$_SEARCHFAIL 4664
#define SHR$_DELINTERR 4672
#define SHR$_PARSEFAIL 4680
#define SHR$_FILPURGED 4688
#define SHR$_ENDABORT 4696
#define SHR$_ENDDIAGS 4704
#define SHR$_ENDNOOBJ 4712
#define SHR$_HALTED 4720
#define SHR$_NOCMDMEM 4728
#define SHR$_QEMPTY 4736
#define SHR$_CBT 4744
#define SHR$_EXISTS 4752
#define SHR$_UNLOCKED 4760
#define SHR$_RENAMED 4768
#define SHR$_PROTECTED 4776
#define SHR$_NOTLOCKED 4784
#define SHR$_ACTIMAGE 4792
#define SHR$_DIRNOTCRE 4800
#define SHR$_NODESTQUE 4808
#define SHR$_ILLDESQUE 4816
#define SHR$_NOTTERM 4824
#define SHR$_CONFQUAL 4832
#define SHR$_ILLDIRCOPY 4840
#define SHR$_INSVIRMEM 4848
#define SHR$_CREATEDSTM 4856
#define SHR$_NOTRUNC 4864
#define SHR$_PRODNOTINS 4872
#define SHR$_TOTAL 4880
#define SHR$_FILPURG 4888
#define SHR$_FILDEL 4896
#define SHR$_INVQUAVAL 4904
#define SHR$_NOFILES 4912
#define SHR$_FILNOTACC 4920
#define SHR$_QUALMISS 4928
#define SHR$_FILSPCSRCH 4936
#define SHR$_NOSRCHLST 4944
#define SHR$_NOSUCHID 4952
#define SHR$_AMBIGANS 4960
#define SHR$_INVALANS 4968
#define SHR$_PRDCONT 4976

#endif					/* __SHRDEF_LOADED */
#ifndef __SIGNAL_LOADED
#define __SIGNAL_LOADED	1

/*	SIGNAL - V3.0 - UNIX Signal Value Definitions	*/

#define NSIG	17		/* number of signals */

#define	SIGHUP	1		/* hangup */
#define	SIGINT	2		/* interrupt */
#define	SIGQUIT	3		/* quit */
#define	SIGILL	4		/* illegal instruction (not reset when caught) */
#define	SIGTRAP	5		/* trace trap (not reset when caught) */
#define	SIGIOT	6		/* IOT instruction */
#define	SIGEMT	7		/* EMT instruction */
#define	SIGFPE	8		/* floating point exception */
#define	SIGKILL	9		/* kill (cannot be caught or ignored) */
#define	SIGBUS	10		/* bus error */
#define	SIGSEGV	11		/* segmentation violation */
#define SIGSYS	12		/* bad argument to system call */
#define SIGPIPE	13		/* write to a pipe with no one to read it */
#define SIGALRM	14		/* alarm clock */
#define SIGTERM	15		/* software termination signal from kill */

#define	ILL_RESAD_FAULT	0x0	/* reserved addressing mode fault */
#define	ILL_PRIVIN_FAULT 0x1	/* privilidged instruction fault */
#define	ILL_RESOP_FAULT	0x2	/* reserved operand fault */

#define	FPE_INTOVF_TRAP 0X1
#define	FPE_INTDIV_TRAP 0X2
#define	FPE_FLTOVF_TRAP 0X3
#define	FPE_FLTDIV_TRAP 0X4
#define	FPE_FLTUND_TRAP 0X5
#define	FPE_DECOVF_TRAP 0X6
#define	FPE_SUBRNG_TRAP 0X7
#define FPE_FLTOVF_FAULT 0X8
#define FPE_FLTDIV_FAULT 0X9
#define FPE_FLTUND_FAULT 0XA

struct	sigvec
{
	int	(*sv_handler)();	/* handler address */
	int	sv_mask;		/* mask of signals to be blocked */
	int	sv_onstack;		/* flag to indicate signal stack */
};

struct	sigcontext
{
	int	sc_onstack;		/* signal stack flag to restore */
	int	sc_mask;		/* signal mask to restore */
	int	sc_sp;			/* stack pointerto restore */
	int	sc_pc;			/* pc to return to */
	int	sc_ps;			/* psl to restore */
};

struct	sigstack
{
	char	*ss_sp;			/* signal stack pointer */
	int	ss_onstack;		/* current status */
};

typedef int sig_atomic_t;

#define	BADSIG	(int (*)())-1
#define	SIG_DFL	(int (*)())0	/* default */
#define SIG_IGN	(int (*)())1	/* ignore */


void (*signal (int sig, void (*func)(int, ...)) ) (int, ...);

void (*ssignal (int sig, void (*action)(int, ...)) ) (int, ...);

int raise (int sig, ...);

int gsignal (int sig, ...);

int kill (int pid, int sig);

int alarm (unsigned int seconds);

int pause (void);

int sleep (unsigned seconds);

int sigvec     (int sigveca, struct sigvec *sv, struct sigvec *osv);

int sigblock   (int mask);

int sigsetmask (int mask);

int sigstack   (struct sigstack *ss, struct sigstack *oss);

int sigpause  (int mask);

void VAXC$ESTABLISH (int (*exception_handler)( void *sigarr, void *mecharr));

#endif					/* __SIGNAL_LOADED */
#ifndef __SJCDEF_LOADED
#define __SJCDEF_LOADED	1

/*** MODULE $sjcdef ***/
/*                                                                          */
/* Send to Job Controller Service ($SNDJBC) definitions.                    */
/*                                                                          */
/* NOTE:  New items must always be added at the end so users will not have to relink. */
/*                                                                          */
/*                                                                          */
/* Function codes                                                           */
/*                                                                          */
#define SJC$_ABORT_JOB 1                /* Abort current job in a queue     */
#define SJC$_ADD_FILE 2                 /* Add a file to an open job        */
#define SJC$_ALTER_JOB 3                /* Alter parameters of a job        */
#define SJC$_ALTER_QUEUE 4              /* Alter parameters of a queue      */
#define SJC$_ASSIGN_QUEUE 5             /* Assign a logical queue to an execution queue */
#define SJC$_BATCH_CHECKPOINT 6         /* Establish a checkpoint in a batch job */
#define SJC$_BATCH_SERVICE 7            /* LOGINOUT communication           */
#define SJC$_CLOSE_DELETE 8             /* Close and delete an open job     */
#define SJC$_CLOSE_JOB 9                /* Close and enqueue an open job    */
#define SJC$_CREATE_JOB 10              /* Create an open job               */
#define SJC$_CREATE_QUEUE 11            /* Create a queue                   */
#define SJC$_DEASSIGN_QUEUE 12          /* Deassign a logical queue         */
#define SJC$_DEFINE_CHARACTERISTIC 13   /* Create a characteristic definition */
#define SJC$_DEFINE_FORM 14             /* Create a form definition         */
#define SJC$_DELETE_CHARACTERISTIC 15   /* Delete a characteristic definition */
#define SJC$_DELETE_FORM 16             /* Delete a form definition         */
#define SJC$_DELETE_JOB 17              /* Delete a job                     */
#define SJC$_DELETE_QUEUE 18            /* Delete a queue                   */
#define SJC$_ENTER_FILE 19              /* Enter a single file job in a queue */
#define SJC$_MERGE_QUEUE 20             /* Requeue all jobs in one queue to another */
#define SJC$_PAUSE_QUEUE 21             /* Suspend processing from a queue  */
#define SJC$_RESET_QUEUE 22             /* Reset a queue                    */
#define SJC$_START_ACCOUNTING 23        /* Start accounting manager         */
#define SJC$_START_QUEUE 24             /* Start processing from a queue	 */
#define SJC$_START_QUEUE_MANAGER 25     /* Start system job queue manager   */
#define SJC$_STOP_ACCOUNTING 26         /* Stop accounting manager          */
#define SJC$_STOP_QUEUE 27              /* Stop processing from a queue     */
#define SJC$_STOP_QUEUE_MANAGER 28      /* Stop system job queue manager    */
#define SJC$_SYNCHRONIZE_JOB 29         /* Synchronize with job completion  */
#define SJC$_WRITE_ACCOUNTING 30        /* Write user accounting record     */
#define SJC$_CONTROL_DIAGNOSTICS 31     /* Control diagnostic functions (for internal use only) */
/* (note this function code is intentionally not documented and reserved for Digital use) */
#define SJC$_RESERVED_FUNC_32 32        /* Reserved for Digital use (name may change) */
/*                                                                          */
/* Item codes                                                               */
/*                                                                          */
#define SJC$_ACCOUNTING_MESSAGE 1       /* User accounting message          */
#define SJC$_ACCOUNTING_TYPES 2         /* Mask of accounting record types  */
#define SJC$_AFTER_TIME 3               /* Hold until time                  */
#define SJC$_NO_AFTER_TIME 4
#define SJC$_ALIGNMENT_MASK 5           /* Mask alignment data              */
#define SJC$_ALIGNMENT_PAGES 6          /* Number of alignment pages        */
#define SJC$_BASE_PRIORITY 7            /* Batch process base priority      */
#define SJC$_BATCH 8                    /* Batch queue                      */
#define SJC$_NO_BATCH 9
#define SJC$_BATCH_INPUT 10             /* LOGINOUT communication           */
#define SJC$_BATCH_OUTPUT 11            /* For use by LOGINOUT (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define SJC$_CHARACTERISTIC_NAME 12     /* Printer characteristic           */
#define SJC$_CHARACTERISTIC_NUMBER 13
#define SJC$_NO_CHARACTERISTICS 14
#define SJC$_CHECKPOINT_DATA 15         /* Batch checkpoint string          */
#define SJC$_NO_CHECKPOINT_DATA 16
#define SJC$_CLI 17                     /* Batch process CLI                */
#define SJC$_NO_CLI 18
#define SJC$_CPU_DEFAULT 19             /* Default CPU time limit           */
#define SJC$_NO_CPU_DEFAULT 20
#define SJC$_CPU_LIMIT 21               /* Maximum CPU time limit           */
#define SJC$_NO_CPU_LIMIT 22
#define SJC$_CREATE_START 23            /* Start queue after creation       */
#define SJC$_DELETE_FILE 24             /* Delete file after processing     */
#define SJC$_NO_DELETE_FILE 25
#define SJC$_DESTINATION_QUEUE 26       /* Destination queue name           */
#define SJC$_DEVICE_NAME 27             /* Output device name               */
#define SJC$_DOUBLE_SPACE 28            /* Double space output              */
#define SJC$_NO_DOUBLE_SPACE 29
#define SJC$_ENTRY_NUMBER 30            /* Job entry number                 */
#define SJC$_ENTRY_NUMBER_OUTPUT 31
#define SJC$_FILE_BURST 32              /* Print file burst page            */
#define SJC$_FILE_BURST_ONE 33
#define SJC$_NO_FILE_BURST 34
#define SJC$_FILE_COPIES 35             /* Print n copies of file           */
#define SJC$_FILE_FLAG 36               /* Print file flag page             */
#define SJC$_FILE_FLAG_ONE 37
#define SJC$_NO_FILE_FLAG 38
#define SJC$_FILE_IDENTIFICATION 39     /* DVI, FID, DID of file            */
#define SJC$_FILE_SETUP_MODULES 40      /* Device control modules for file  */
#define SJC$_NO_FILE_SETUP_MODULES 41
#define SJC$_FILE_SPECIFICATION 42      /* File specification of file       */
#define SJC$_FILE_TRAILER 43            /* Print file trailer page          */
#define SJC$_FILE_TRAILER_ONE 44
#define SJC$_NO_FILE_TRAILER 45
#define SJC$_FIRST_PAGE 46              /* Starting page number             */
#define SJC$_NO_FIRST_PAGE 47
#define SJC$_FORM_DESCRIPTION 48        /* Textual description of form      */
#define SJC$_FORM_LENGTH 49             /* Form length in lines             */
#define SJC$_FORM_MARGIN_BOTTOM 50      /* Form bottom margin in lines      */
#define SJC$_FORM_MARGIN_LEFT 51        /* Form left margin in characters   */
#define SJC$_FORM_MARGIN_RIGHT 52       /* Form right margin in characters  */
#define SJC$_FORM_MARGIN_TOP 53         /* Form top margin in lines         */
#define SJC$_FORM_NAME 54               /* Printer form                     */
#define SJC$_FORM_NUMBER 55
#define SJC$_FORM_SETUP_MODULES 56      /* Device control modules for form  */
#define SJC$_NO_FORM_SETUP_MODULES 57
#define SJC$_FORM_SHEET_FEED 58         /* Form is sheet fed                */
#define SJC$_NO_FORM_SHEET_FEED 59
#define SJC$_FORM_STOCK 60              /* Stock name for form              */
#define SJC$_FORM_TRUNCATE 61           /* Truncate long lines              */
#define SJC$_NO_FORM_TRUNCATE 62
#define SJC$_FORM_WIDTH 63              /* Form width in characters         */
#define SJC$_FORM_WRAP 64               /* Wrap long lines                  */
#define SJC$_NO_FORM_WRAP 65
#define SJC$_GENERIC_QUEUE 66           /* Queue is a generic queue         */
#define SJC$_NO_GENERIC_QUEUE 67
#define SJC$_GENERIC_SELECTION 68       /* Queue can take work from generic queue */
#define SJC$_NO_GENERIC_SELECTION 69
#define SJC$_GENERIC_TARGET 70          /* Possible execution queue for generic queue */
#define SJC$_HOLD 71                    /* Place job on hold                */
#define SJC$_NO_HOLD 72
#define SJC$_JOB_BURST 73               /* Print job burst page             */
#define SJC$_NO_JOB_BURST 74
#define SJC$_JOB_COPIES 75              /* Print n copies of entire job     */
#define SJC$_JOB_FLAG 76                /* Print job flag page              */
#define SJC$_NO_JOB_FLAG 77
#define SJC$_JOB_LIMIT 78               /* Number of concurrent jobs        */
#define SJC$_JOB_NAME 79                /* Identifying name of job          */
#define SJC$_JOB_RESET_MODULES 80       /* Device control modules between jobs */
#define SJC$_NO_JOB_RESET_MODULES 81
#define SJC$_JOB_SIZE_MAXIMUM 82        /* Largest job accepted by printer  */
#define SJC$_NO_JOB_SIZE_MAXIMUM 83
#define SJC$_JOB_SIZE_MINIMUM 84        /* Smallest job accepted by printer */
#define SJC$_NO_JOB_SIZE_MINIMUM 85
#define SJC$_JOB_SIZE_SCHEDULING 86     /* Schedule printer queues by size  */
#define SJC$_NO_JOB_SIZE_SCHEDULING 87
#define SJC$_JOB_STATUS_OUTPUT 88       /* Status message for submitted job */
#define SJC$_JOB_TRAILER 89             /* Print job trailer page           */
#define SJC$_NO_JOB_TRAILER 90
#define SJC$_LAST_PAGE 91               /* Ending page number               */
#define SJC$_NO_LAST_PAGE 92
#define SJC$_LIBRARY_SPECIFICATION 93   /* Filename of device control library */
#define SJC$_NO_LIBRARY_SPECIFICATION 94
#define SJC$_LOG_DELETE 95              /* Delete log file                  */
#define SJC$_NO_LOG_DELETE 96
#define SJC$_LOG_QUEUE 97               /* Log file's print queue           */
#define SJC$_LOG_SPECIFICATION 98       /* File specification of log file   */
#define SJC$_NO_LOG_SPECIFICATION 99
#define SJC$_LOG_SPOOL 100              /* Print log file                   */
#define SJC$_NO_LOG_SPOOL 101
#define SJC$_LOWERCASE 102              /* Print on lowercase printer       */
#define SJC$_NO_LOWERCASE 103
#define SJC$_NEW_VERSION 104            /* Create new version of file       */
#define SJC$_NEXT_JOB 105               /* Resume at next job               */
#define SJC$_NOTE 106                   /* Flag page note text              */
#define SJC$_NO_NOTE 107
#define SJC$_NOTIFY 108                 /* Notify user on completion        */
#define SJC$_NO_NOTIFY 109
#define SJC$_OPERATOR_REQUEST 110       /* Operator service text            */
#define SJC$_NO_OPERATOR_REQUEST 111
#define SJC$_OWNER_UIC 112              /* Queue owner UIC                  */
#define SJC$_PAGE_HEADER 113            /* Print page headers               */
#define SJC$_NO_PAGE_HEADER 114
#define SJC$_PAGE_SETUP_MODULES 115     /* Device control modules for form page */
#define SJC$_NO_PAGE_SETUP_MODULES 116
#define SJC$_PAGINATE 117               /* Paginate output with free form feeds */
#define SJC$_NO_PAGINATE 118
#define SJC$_PARAMETER_1 119            /* Batch job parameters             */
#define SJC$_PARAMETER_2 120
#define SJC$_PARAMETER_3 121
#define SJC$_PARAMETER_4 122
#define SJC$_PARAMETER_5 123
#define SJC$_PARAMETER_6 124
#define SJC$_PARAMETER_7 125
#define SJC$_PARAMETER_8 126
#define SJC$_NO_PARAMETERS 127
#define SJC$_PASSALL 128                /* Print file passall               */
#define SJC$_NO_PASSALL 129
#define SJC$_PRIORITY 130               /* Job scheduling priority          */
#define SJC$_PROCESSOR 131              /* Filename of symbiont image       */
#define SJC$_NO_PROCESSOR 132
#define SJC$_PROTECTION 133             /* Queue protection mask            */
#define SJC$_QUEUE 134                  /* Queue on which to operate        */
#define SJC$_QUEUE_FILE_SPECIFICATION 135 /* File specification of queue file */
#define SJC$_RELATIVE_PAGE 136          /* Resume after forward or back space */
#define SJC$_REQUEUE 137                /* Requeue job                      */
#define SJC$_RESTART 138                /* Job can restart                  */
#define SJC$_NO_RESTART 139
#define SJC$_RETAIN_ALL_JOBS 140        /* Retain completed jobs            */
#define SJC$_RETAIN_ERROR_JOBS 141
#define SJC$_NO_RETAIN_JOBS 142
#define SJC$_SCSNODE_NAME 143           /* Node name of execution node      */
#define SJC$_SEARCH_STRING 144          /* Resume after finding string      */
#define SJC$_SWAP 145                   /* Swap batch processes             */
#define SJC$_NO_SWAP 146
#define SJC$_TERMINAL 147               /* Queue is a (generic) terminal queue */
#define SJC$_NO_TERMINAL 148
#define SJC$_TOP_OF_FILE 149            /* Resume at top of file            */
#define SJC$_USER_IDENTIFICATION 150    /* Proxy user identification (not supported and is obsolete) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define SJC$_WSDEFAULT 151              /* Working set default              */
#define SJC$_NO_WSDEFAULT 152
#define SJC$_WSEXTENT 153               /* Working set extent               */
#define SJC$_NO_WSEXTENT 154
#define SJC$_WSQUOTA 155                /* Working set quota                */
#define SJC$_NO_WSQUOTA 156
#define SJC$_ACCOUNT_NAME 157           /* Proxy account name (requires CMKRNL privilege) */
#define SJC$_UIC 158                    /* Proxy UIC (requires CMKRNL privilege) */
#define SJC$_USERNAME 159               /* Proxy username (requires CMKRNL privilege) */
#define SJC$_BUFFER_COUNT 160           /* Multibuffer count for queue file */
#define SJC$_EXTEND_QUANTITY 161        /* Allocation and extend quantity for queue file */
#define SJC$_RECORD_BLOCKING 162        /* Symbiont record blocking of output stream */
#define SJC$_NO_RECORD_BLOCKING 163
#define SJC$_QUEMAN_RESTART 164         /* qualifier on SJC$_START_QUEUE_MANAGER, restart queue manager after an abort */
#define SJC$_NO_QUEMAN_RESTART 165
#define SJC$_DEFAULT_FORM_NAME 166      /* Default queue form name          */
#define SJC$_DEFAULT_FORM_NUMBER 167    /* Default queue form number        */
#define SJC$_RESERVED_INPUT_168 168     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_169 169     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_OUTPUT_170 170    /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_OUTPUT_171 171    /* Reserved for Digital use (name may change) */
#define SJC$_OPEN_QUEUE 172             /* Open queue - allow job submission */
#define SJC$_CLOSE_QUEUE 173            /* Close queue - do not allow job submission */
#define SJC$_SERVER 174                 /* Server queue                     */
#define SJC$_PRINTER 175                /* Printer queue                    */
#define SJC$_UPDATE_ORB 176             /* Update ORB information in queue file (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define SJC$_NO_QUEUE_DESCRIPTION 177   /* No queue description supplied    */
#define SJC$_RESERVED_BOOLEAN_178 178   /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_BOOLEAN_179 179   /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_BOOLEAN_180 180   /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_BOOLEAN_181 181   /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_BOOLEAN_182 182   /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_BOOLEAN_183 183   /* Reserved for Digital use (name may change) */
#define SJC$_DIAGNOSTIC_FLAGS 184       /* Diagnostic flags (for internal use only) */
/* (note this item code is intentionally not documented and reserved for Digital use) */
#define SJC$_QUEUE_DESCRIPTION 185      /* Queue description                */
#define SJC$_RESERVED_INPUT_186 186     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_187 187     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_188 188     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_189 189     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_190 190     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_191 191     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_192 192     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_193 193     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_194 194     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_INPUT_195 195     /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_OUTPUT_196 196    /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_OUTPUT_197 197    /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_OUTPUT_198 198    /* Reserved for Digital use (name may change) */
#define SJC$_RESERVED_OUTPUT_199 199    /* Reserved for Digital use (name may change) */
/*                                                                          */
/* Subfields of ACCOUNTING_TYPES item code.  These definitions must track EXE$GL_ACMFLAGS. */
/*                                                                          */
#define SJC$M_ACCT_PROCESS 1
#define SJC$M_ACCT_IMAGE 2
#define SJC$M_ACCT_INTERACTIVE 4
#define SJC$M_ACCT_LOGIN_FAILURE 8
#define SJC$M_ACCT_SUBPROCESS 16
#define SJC$M_ACCT_DETACHED 32
#define SJC$M_ACCT_BATCH 64
#define SJC$M_ACCT_NETWORK 128
#define SJC$M_ACCT_PRINT 256
#define SJC$M_ACCT_MESSAGE 512
struct accounting_types {
    unsigned sjc$v_acct_process : 1;    /* Process termination              */
    unsigned sjc$v_acct_image : 1;      /* Image termination                */
    unsigned sjc$v_acct_interactive : 1; /* Interactive processes           */
    unsigned sjc$v_acct_login_failure : 1; /* Login failures                */
    unsigned sjc$v_acct_subprocess : 1; /* Subprocesses                     */
    unsigned sjc$v_acct_detached : 1;   /* Detached processes               */
    unsigned sjc$v_acct_batch : 1;      /* Batch processes                  */
    unsigned sjc$v_acct_network : 1;    /* Network processes                */
    unsigned sjc$v_acct_print : 1;      /* Print job termination            */
    unsigned sjc$v_acct_message : 1;    /* User messages                    */
    unsigned sjc$v_acct_unused : 22;
    } ;
 

#endif					/* __SJCDEF_LOADED */
#ifndef __SMG$ROUTINES_LOADED
#define __SMG$ROUTINES_LOADED	1

/*** MODULE smg$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    SMG$ADD_KEY_DEF                                                       */
/*                                                                          */
/*    Add Key Definition                                                    */
/*                                                                          */
/*    The Add Key Definition routine adds a keypad key definition to a table */
/*    of key definitions.                                                   */
/*                                                                          */
unsigned long int smg$add_key_def() ;
/*    SMG$ALLOW_ESCAPE                                                      */
/*                                                                          */
/*    Allow Escape Sequences                                                */
/*                                                                          */
/*    SMG$ALLOW_ESCAPE enables or disables SMG parsing of escape sequences which are */
/*    output to a virtual display.                                          */
/*                                                                          */
unsigned long int smg$allow_escape() ;
/*    SMG$BEGIN_DISPLAY_UPDATE                                              */
/*                                                                          */
/*    Begin Batching of Display Updates                                     */
/*                                                                          */
/*    The Begin Batching of Display Updates routine saves, or batches, all  */
/*    output to a virtual display until a matching call to                  */
/*    SMG$END_DISPLAY_UPDATE is encountered.                                */
/*                                                                          */
unsigned long int smg$begin_display_update() ;
/*    SMG$BEGIN_PASTEBOARD_UPDATE                                           */
/*                                                                          */
/*    Begin Batching of Pasteboard Updates                                  */
/*                                                                          */
/*    The Begin Batching of Pasteboard Updates routine saves, or batches,   */
/*    all output to a pasteboard until a matching call to                   */
/*    SMG$END_PASTEBOARD_UPDATE is encountered.                             */
/*                                                                          */
unsigned long int smg$begin_pasteboard_update() ;
/*    SMG$CANCEL_INPUT                                                      */
/*                                                                          */
/*    Cancel Input Request                                                  */
/*                                                                          */
/*    The Cancel Input Request routine immediately cancels any              */
/*    read-in-progress that was issued by SMG$READ_COMPOSED_LINE,           */
/*    SMG$READ_KEYSTROKE, SMG$READ_STRING or SMG$READ_VERIFY.               */
/*                                                                          */
unsigned long int smg$cancel_input() ;
/*    SMG$CURSOR_COLUMN                                                     */
/*                                                                          */
/*    Return Cursor Column Position                                         */
/*                                                                          */
/*    The Return Cursor Column Position routine returns the virtual cursor's */
/*    current column position in a specified virtual display.               */
/*                                                                          */
unsigned long int smg$cursor_column() ;
/*    SMG$CHECK_FOR_OCCLUSION                                               */
/*                                                                          */
/*    Check For Occlusion                                                   */
/*                                                                          */
/*    The Check for Occlusion routine checks to see whether a virtual       */
/*    display is covered (occluded) by another virtual display.             */
/*                                                                          */
unsigned long int smg$check_for_occlusion() ;
/*    SMG$CHANGE_VIEWPORT                                                   */
/*                                                                          */
/*    Change the Viewport                                                   */
/*                                                                          */
/*    The Change the Viewport Associated with a Virtual Display routine     */
/*    changes the size of an existing viewport in a virtual display. The    */
/*    text that is currently in the viewport is remapped to fit the new     */
/*    dimensions.                                                           */
/*                                                                          */
unsigned long int smg$change_viewport() ;
/*    SMG$CREATE_KEY_TABLE                                                  */
/*                                                                          */
/*    Create Key Table                                                      */
/*                                                                          */
/*    The Create Key Table routine creates a table for key definitions.     */
/*                                                                          */
unsigned long int smg$create_key_table() ;
/*    SMG$CREATE_MENU                                                       */
/*                                                                          */
/*    Fill the Virtual Display With a Menu                                  */
/*                                                                          */
/*    The Fill the Virtual Display with a Menu routine displays menu choices */
/*    in the virtual display indicated, starting at the specified row.      */
/*                                                                          */
unsigned long int smg$create_menu() ;
/*    SMG$CONTROL_MODE                                                      */
/*                                                                          */
/*    Control Mode                                                          */
/*                                                                          */
/*    The Control Mode routine controls the mode of the pasteboard. This    */
/*    includes buffering, minimal updating, whether the screen is cleared   */
/*    when the pasteboard is deleted, and whether tab characters are used   */
/*    for screen formatting.                                                */
/*                                                                          */
unsigned long int smg$control_mode() ;
/*    SMG$COPY_VIRTUAL_DISPLAY                                              */
/*                                                                          */
/*    Copy a Virtual Display                                                */
/*                                                                          */
/*    The Copy a Virtual Display routine creates a copy of an existing      */
/*    virtual display and assigns to it a new virtual display identifier.   */
/*                                                                          */
unsigned long int smg$copy_virtual_display() ;
/*    SMG$CREATE_PASTEBOARD                                                 */
/*                                                                          */
/*    Create a Pasteboard                                                   */
/*                                                                          */
/*    The Create Pasteboard routine creates a pasteboard and returns its assigned */
/*    pasteboard identifier.                                                */
/*                                                                          */
unsigned long int smg$create_pasteboard() ;
/*    SMG$CHANGE_PBD_CHARACTERISTICS                                        */
/*                                                                          */
/*    Change Pasteboard Characteristics                                     */
/*                                                                          */
/*    The Change Pasteboad Characteristics routine lets you change the characteristics */
/*    associated with a pasteboard.                                         */
/*                                                                          */
unsigned long int smg$change_pbd_characteristics() ;
/*    SMG$CHANGE_RENDITION                                                  */
/*                                                                          */
/*    Change Default Rendition                                              */
/*                                                                          */
/*    The Change Default Rendition routine changes the video attributes for all or part of a */
/*    virtual display.                                                      */
/*                                                                          */
unsigned long int smg$change_rendition() ;
/*    SMG$CURSOR_ROW                                                        */
/*                                                                          */
/*    Return Cursor Row Position                                            */
/*                                                                          */
/*    The Return Cursor Row Position routine returns the virtual cursor's   */
/*    current row position in a specified virtual display.                  */
/*                                                                          */
unsigned long int smg$cursor_row() ;
/*    SMG$CREATE_SUBPROCESS                                                 */
/*                                                                          */
/*    Create and Initialize a Subprocess                                    */
/*                                                                          */
/*    The Create and Initialize a Subprocess routine creates a DCL          */
/*    subprocess and associates it with a virtual display.                  */
/*                                                                          */
unsigned long int smg$create_subprocess() ;
/*    SMG$CREATE_VIRTUAL_DISPLAY                                            */
/*                                                                          */
/*    Create a Virtual Display                                              */
/*                                                                          */
/*    The Create Virtual Display routine creates a virtual display and returns its */
/*    assigned display identifier                                           */
/*                                                                          */
unsigned long int smg$create_virtual_display() ;
/*    SMG$CHANGE_VIRTUAL_DISPLAY                                            */
/*                                                                          */
/*    Change Virtual Display                                                */
/*                                                                          */
/*    The Change Virtual Display routine lets you change the dimensions, border, and video */
/*    attributes of a virtual display.                                      */
/*                                                                          */
unsigned long int smg$change_virtual_display() ;
/*    SMG$CREATE_VIRTUAL_KEYBOARD                                           */
/*                                                                          */
/*    Create a Virtual Keyboard                                             */
/*                                                                          */
/*    The Create Virtual Keyboard routine creates a virtual keyboard and returns its assigned */
/*    keyboard identifier.                                                  */
/*                                                                          */
unsigned long int smg$create_virtual_keyboard() ;
/*    SMG$CREATE_VIEWPORT                                                   */
/*                                                                          */
/*    Create a Virtual Viewport                                             */
/*                                                                          */
/*    The Create a Virtual Viewport routine creates a viewport and          */
/*    associates it with a virtual display. The location and size of the    */
/*    viewport are specified by the caller.                                 */
/*                                                                          */
unsigned long int smg$create_viewport() ;
/*    SMG$DELETE_CHARS                                                      */
/*                                                                          */
/*    Delete Characters                                                     */
/*                                                                          */
/*    The Delete Characters routine deletes characters in a virtual display. */
/*                                                                          */
unsigned long int smg$delete_chars() ;
/*    SMG$DEFINE_KEY                                                        */
/*                                                                          */
/*    Perform a DEFINE/KEY Command                                          */
/*                                                                          */
/*    The Perform a DEFINE/KEY Command routine performs the DEFINE/KEY      */
/*    command you provide.                                                  */
/*                                                                          */
unsigned long int smg$define_key() ;
/*    SMG$DISABLE_BROADCAST_TRAPPING                                        */
/*                                                                          */
/*    Disable Broadcast Trapping                                            */
/*                                                                          */
/*    The Disable Broadcast Trapping routine disables trapping of broadcast */
/*    messages for the specified terminal.                                  */
/*                                                                          */
unsigned long int smg$disable_broadcast_trapping() ;
/*    SMG$DISABLE_UNSOLICITED_INPUT                                         */
/*                                                                          */
/*    Disable Unsolicited Input                                             */
/*                                                                          */
/*    The Disable Unsolicited Input routine disables the trapping of        */
/*    unsolicited input.                                                    */
/*                                                                          */
unsigned long int smg$disable_unsolicited_input() ;
/*    SMG$DELETE_KEY_DEF                                                    */
/*                                                                          */
/*    Delete Key Definition                                                 */
/*                                                                          */
/*    The Delete Key Definition routine deletes a key definition from the   */
/*    specified table of key definitions.                                   */
/*                                                                          */
unsigned long int smg$delete_key_def() ;
/*    SMG$DELETE_LINE                                                       */
/*                                                                          */
/*    Delete Line                                                           */
/*                                                                          */
/*    The Delete Line routine deletes lines from a virtual display.         */
/*                                                                          */
unsigned long int smg$delete_line() ;
/*    SMG$DELETE_MENU                                                       */
/*                                                                          */
/*    End Access to a Menu in the Virtual Display                           */
/*                                                                          */
/*    The End Access to a Menu in the Virtual Display routine ends access to */
/*    the menu choices in the specified virtual display.                    */
/*                                                                          */
unsigned long int smg$delete_menu() ;
/*    SMG$DELETE_PASTEBOARD                                                 */
/*                                                                          */
/*    Delete Pasteboard                                                     */
/*                                                                          */
/*    The Delete Pasteboard routine deletes a pasteboard.                   */
/*                                                                          */
unsigned long int smg$delete_pasteboard() ;
/*    SMG$DRAW_CHAR                                                         */
/*                                                                          */
/*    Draw a Character in a Virtual Display                                 */
/*                                                                          */
/*    The Draw a Character in a Virtual Display routine draws a character at */
/*    the specified position in a virtual display.                          */
/*                                                                          */
unsigned long int smg$draw_char() ;
/*    SMG$DRAW_LINE                                                         */
/*                                                                          */
/*    Draw A Line                                                           */
/*                                                                          */
/*    The Draw a Line routine draws a horizontal or vertical line.          */
/*                                                                          */
unsigned long int smg$draw_line() ;
/*    SMG$DRAW_RECTANGLE                                                    */
/*                                                                          */
/*    Draw a Rectangle                                                      */
/*                                                                          */
/*    The Draw a Rectangle routine draws a rectangle.                       */
/*                                                                          */
unsigned long int smg$draw_rectangle() ;
/*    SMG$DELETE_SUBPROCESS                                                 */
/*                                                                          */
/*    Terminate a Subprocess                                                */
/*                                                                          */
/*    The Terminate a Subprocess routine deletes a subprocess that was      */
/*    created with the SMG$CREATE_SUBPROCESS routine.                       */
/*                                                                          */
unsigned long int smg$delete_subprocess() ;
/*    SMG$DEL_TERM_TABLE                                                    */
/*                                                                          */
/*    Delete Terminal Table                                                 */
/*                                                                          */
/*    The Delete Terminal Table routine terminates access to a private TERMTABLE.EXE */
/*    and frees the associated virtual address space.                       */
/*                                                                          */
unsigned long int smg$del_term_table() ;
/*    SMG$DELETE_VIRTUAL_DISPLAY                                            */
/*                                                                          */
/*    Delete Virtual Display                                                */
/*                                                                          */
/*    The Delete Virtual Display routine deletes a virtual display.         */
/*                                                                          */
unsigned long int smg$delete_virtual_display() ;
/*    SMG$DELETE_VIRTUAL_KEYBOARD                                           */
/*                                                                          */
/*    Delete Virtual Keyboard                                               */
/*                                                                          */
/*    The Delete Virtual Keyboard routine deletes a virtual keyboard.       */
/*                                                                          */
unsigned long int smg$delete_virtual_keyboard() ;
/*    SMG$DELETE_VIEWPORT                                                   */
/*                                                                          */
/*    Delete a Viewport                                                     */
/*                                                                          */
/*    The Delete a Viewport routine deletes the specified viewport from any */
/*    pasteboards to which it is pasted.                                    */
/*                                                                          */
unsigned long int smg$delete_viewport() ;
/*    SMG$ERASE_CHARS                                                       */
/*                                                                          */
/*    Erase Characters                                                      */
/*                                                                          */
/*    The Erase Characters routine erases characters in a virtual display by */
/*    replacing them with blanks.                                           */
/*                                                                          */
unsigned long int smg$erase_chars() ;
/*    SMG$END_DISPLAY_UPDATE                                                */
/*                                                                          */
/*    End Display Update                                                    */
/*                                                                          */
/*    The End Display Update routine ends update batching for a virtual display. */
/*                                                                          */
unsigned long int smg$end_display_update() ;
/*    SMG$END_PASTEBOARD_UPDATE                                             */
/*                                                                          */
/*    End Pasteboard Update                                                 */
/*                                                                          */
/*    The End Pasteboard Update routine ends update batching for a pasteboard. */
/*                                                                          */
unsigned long int smg$end_pasteboard_update() ;
/*    SMG$ENABLE_UNSOLICITED_INPUT                                          */
/*                                                                          */
/*    Enable Unsolicited Input                                              */
/*                                                                          */
/*    The Enable Unsolicited Input routine detects unsolicited input and    */
/*    calls an AST routine in response.                                     */
/*                                                                          */
unsigned long int smg$enable_unsolicited_input() ;
/*    SMG$ERASE_COLUMN                                                      */
/*                                                                          */
/*    Erase Column from Display                                             */
/*                                                                          */
/*    The Erase Column From Display routine erases the specified portion of */
/*    the virtual display from the given position to the end of the column.  */
/*                                                                          */
unsigned long int smg$erase_column() ;
/*    SMG$ERASE_DISPLAY                                                     */
/*                                                                          */
/*    Erase Virtual Display                                                 */
/*                                                                          */
/*    The Erase Virtual Display routine erases all or part of a virtual     */
/*    display by replacing text characters with blanks.                     */
/*                                                                          */
unsigned long int smg$erase_display() ;
/*    SMG$ERASE_LINE                                                        */
/*                                                                          */
/*    Erase Line                                                            */
/*                                                                          */
/*    The Erase Line routine erases all or part of a line in a virtual display. */
/*                                                                          */
unsigned long int smg$erase_line() ;
/*    SMG$ERASE_PASTEBOARD                                                  */
/*                                                                          */
/*    Erase  Pasteboard                                                     */
/*                                                                          */
/*    The Erase Pasteboard routine erases the contents of a pasteboard.     */
/*                                                                          */
unsigned long int smg$erase_pasteboard() ;
/*    SMG$EXECUTE_COMMAND                                                   */
/*                                                                          */
/*    Execute Command in a Subprocess                                       */
/*                                                                          */
/*    The Execute Command in a Subprocess routine executes the specified    */
/*    command in the subprocess created with the SMG$CREATE_SUBPROCESS      */
/*    routine.                                                              */
/*                                                                          */
unsigned long int smg$execute_command() ;
/*    SMG$FIND_CURSOR_DISPLAY                                               */
/*                                                                          */
/*    Find Display that Contains the Cursor                                 */
/*                                                                          */
/*    The Find Display that Contains the Cursor routine returns the         */
/*    identifier of the most recently pasted virtual display that contains  */
/*    the physical cursor.                                                  */
/*                                                                          */
unsigned long int smg$find_cursor_display() ;
/*    SMG$FLUSH_BUFFER                                                      */
/*                                                                          */
/*    Flush Buffer                                                          */
/*                                                                          */
/*    The Flush Buffer routine flushes all buffered output to the terminal. */
/*                                                                          */
unsigned long int smg$flush_buffer() ;
/*    SMG$GET_BROADCAST_MESSAGE                                             */
/*                                                                          */
/*    Get Broadcast Message                                                 */
/*                                                                          */
/*    The Get Broadcast Message routine determines whether a message has    */
/*    been broadcast to the pasteboard and returns the message.             */
/*                                                                          */
unsigned long int smg$get_broadcast_message() ;
/*    SMG$GET_CHAR_AT_PHYSICAL_CURSOR                                       */
/*                                                                          */
/*    Return Character At Cursor                                            */
/*                                                                          */
/*    The Return Character At Cursor routine returns the character at the   */
/*    current physical cursor position.                                     */
/*                                                                          */
unsigned long int smg$get_char_at_physical_cursor() ;
/*    SMG$GET_DISPLAY_ATTR                                                  */
/*                                                                          */
/*    Get Display Attributes                                                */
/*                                                                          */
/*    The Get Display Attributes routine returns the attributes associated  */
/*    with a virtual display.                                               */
/*                                                                          */
unsigned long int smg$get_display_attr() ;
/*    SMG$GET_KEYBOARD_ATTRIBUTES                                           */
/*                                                                          */
/*    Get Keyboard Attributes                                               */
/*                                                                          */
/*    The Get Keyboard Attributes routine gets information about a virtual  */
/*    keyboard and leaves it in a user-supplied area: the keyboard          */
/*    information table (KIT).                                              */
/*                                                                          */
unsigned long int smg$get_keyboard_attributes() ;
/*    SMG$GET_KEY_DEF                                                       */
/*                                                                          */
/*    Get Key Definition                                                    */
/*                                                                          */
/*    The Get Key Definition routine returns the key definition for a specified key. */
/*                                                                          */
unsigned long int smg$get_key_def() ;
/*    SMG$GET_NUMERIC_DATA                                                  */
/*                                                                          */
/*    Get Numeric Terminal Data                                             */
/*                                                                          */
/*    The Get Numeric Terminal Data routine accesses TERMTABLE.EXE and      */
/*    returns the numeric sequence that causes a terminal to perform a      */
/*    specified operation.                                                  */
/*                                                                          */
unsigned long int smg$get_numeric_data() ;
/*    SMG$GET_PASTING_INFO                                                  */
/*                                                                          */
/*    Return Pasting Information                                            */
/*                                                                          */
/*    Provided that the specified virtual display is currently pasted, the  */
/*    Return Pasting Information routine returns the row and column of the  */
/*    pasting.                                                              */
/*                                                                          */
unsigned long int smg$get_pasting_info() ;
/*    SMG$GET_PASTEBOARD_ATTRIBUTES                                         */
/*                                                                          */
/*    Get Pasteboard Attributes                                             */
/*                                                                          */
/*    The Get Pasteboard Attributes routine gets pasteboard attributes and  */
/*    stores them in the pasteboard information table.                      */
/*                                                                          */
unsigned long int smg$get_pasteboard_attributes() ;
/*    SMG$GET_TERM_DATA                                                     */
/*                                                                          */
/*    Get Terminal Data                                                     */
/*                                                                          */
/*    The Get Terminal Data routine accesses TERMTABLE.EXE and returns the  */
/*    character sequence that causes a terminal to perform a specified      */
/*    operation.                                                            */
/*                                                                          */
unsigned long int smg$get_term_data() ;
/*    SMG$GET_VIEWPORT_CHAR                                                 */
/*                                                                          */
/*    Get Characteristics of Display Viewport                               */
/*                                                                          */
/*    The Get Characteristics of Display Viewport routine returns the       */
/*    characteristics of the specified viewport.                            */
/*                                                                          */
unsigned long int smg$get_viewport_char() ;
/*    SMG$HOME_CURSOR                                                       */
/*                                                                          */
/*    Home Cursor                                                           */
/*                                                                          */
/*    The Home Cursor routine moves the virtual cursor to the specified     */
/*    corner of a virtual display.                                          */
/*                                                                          */
unsigned long int smg$home_cursor() ;
/*    SMG$INIT_TERM_TABLE                                                   */
/*                                                                          */
/*    Initialize Terminal Table                                             */
/*                                                                          */
/*    The Initialize Terminal Table routine initializes the TERMTABLE       */
/*    database for the terminal named, so that subsequent calls to          */
/*    SMG$GET_TERM_DATA can extract information and command strings for that */
/*    terminal.                                                             */
/*                                                                          */
unsigned long int smg$init_term_table() ;
/*    SMG$INSERT_CHARS                                                      */
/*                                                                          */
/*    Insert Characters                                                     */
/*                                                                          */
/*    The Insert Characters routine inserts characters into a virtual display. */
/*                                                                          */
unsigned long int smg$insert_chars() ;
/*    SMG$INSERT_LINE                                                       */
/*                                                                          */
/*    Insert Line                                                           */
/*                                                                          */
/*    The Insert Line routine inserts a line into a virtual display and     */
/*    scrolls the display.                                                  */
/*                                                                          */
unsigned long int smg$insert_line() ;
/*    SMG$INIT_TERM_TABLE_BY_TYPE                                           */
/*                                                                          */
/*    Initialize TERMTABLE By VMS Terminal Type                             */
/*                                                                          */
/*    The Initialize TERMTABLE by VMS Terminal Type routine initializes the */
/*    TERMTABLE database for the terminal named, so that subsequent calls to */
/*    SMG$GET_TERM_DATA can extract information and command strings for that */
/*    terminal.                                                             */
/*                                                                          */
unsigned long int smg$init_term_table_by_type() ;
/*    SMG$INVALIDATE_DISPLAY                                                */
/*                                                                          */
/*    Mark a Display As Invalid                                             */
/*                                                                          */
/*    The Mark a Display as Invalid routine marks a display as invalid and  */
/*    causes the entire display to be redrawn.                              */
/*                                                                          */
unsigned long int smg$invalidate_display() ;
/*    SMG$KEYCODE_TO_NAME                                                   */
/*                                                                          */
/*    Translate a Key Code into a Key Name                                  */
/*                                                                          */
/*    The Translate a Key Code into a Key Name routine translates the key code  */
/*    of a key on the keyboard into its associated key name.                */
/*                                                                          */
unsigned long int smg$keycode_to_name() ;
/*    SMG$LABEL_BORDER                                                      */
/*                                                                          */
/*    Label A Virtual Display Border                                        */
/*                                                                          */
/*    The Label a Virtual Display Border routine supplies a label for a     */
/*    virtual display's border.                                             */
/*                                                                          */
unsigned long int smg$label_border() ;
/*    SMG$LOAD_KEY_DEFS                                                     */
/*                                                                          */
/*    Load Key Definitions                                                  */
/*                                                                          */
/*    The Load Key Definitions routine loads a file of key definitions      */
/*    (DEFINE/KEY commands) into a specified key table.                     */
/*                                                                          */
unsigned long int smg$load_key_defs() ;
/*    SMG$LIST_KEY_DEFS                                                     */
/*                                                                          */
/*    List Key Definitions                                                  */
/*                                                                          */
/*    The List Key Definitions routine returns, one at a time, the          */
/*    definition (equivalence string) associated with a specified           */
/*    keys in a specified key table.                                        */
/*                                                                          */
unsigned long int smg$list_key_defs() ;
/*    SMG$LIST_PASTING_ORDER                                                */
/*                                                                          */
/*    Return Pasting Information                                            */
/*                                                                          */
/*    The Return Pasting Information routine returns the identifiers of the */
/*    virtual displays pasted to a specified pasteboard. Optionally, the    */
/*    pasteboard row 1 and column 1 (origins) of the virtual                */
/*    display are also returned.                                            */
/*                                                                          */
unsigned long int smg$list_pasting_order() ;
/*    SMG$LOAD_VIRTUAL_DISPLAY                                              */
/*                                                                          */
/*    Load a Virtual Display from a File                                    */
/*                                                                          */
/*    The Load a Virtual Display from a File routine creates a new virtual  */
/*    display and loads it with a virtual display saved with                */
/*    SMG$SAVE_VIRTUAL_DISPLAY.                                             */
/*                                                                          */
unsigned long int smg$load_virtual_display() ;
/*    SMG$MOVE_VIRTUAL_DISPLAY                                              */
/*                                                                          */
/*    Move Virtual Display                                                  */
/*                                                                          */
/*    The Move Virtual Display routine relocates a virtual display on a pasteboard and */
/*    preserves the pasting order.                                          */
/*                                                                          */
unsigned long int smg$move_virtual_display() ;
/*    SMG$MOVE_TEXT                                                         */
/*                                                                          */
/*    Move Text from One Virtual Display to Another                         */
/*                                                                          */
/*    The Move Text from One Virtual Display to                             */
/*    Another routine moves a rectangle of text from one virtual display to  */
/*    another virtual display. Given two points in opposite corners of the  */
/*    rectangle, SMG$MOVE_TEXT determines the desired width and height of   */
/*    the new virtual display.                                              */
/*                                                                          */
unsigned long int smg$move_text() ;
/*    SMG$NAME_TO_KEYCODE                                                   */
/*                                                                          */
/*    Translate a Key Name into a Key Code                                  */
/*                                                                          */
/*    The Translate a Key Name into a Key Code routine translates the key   */
/*    name of a key on the keyboard into its associated key code.           */
/*                                                                          */
unsigned long int smg$name_to_keycode() ;
/*    SMG$PASTE_VIRTUAL_DISPLAY                                             */
/*                                                                          */
/*    Paste Virtual Display                                                 */
/*                                                                          */
/*    The Paste Virtual Display routine pastes a virtual display to a pasteboard. */
/*                                                                          */
unsigned long int smg$paste_virtual_display() ;
/*    SMG$PUT_CHARS                                                         */
/*                                                                          */
/*    Write Characters to a Virtual Display                                 */
/*                                                                          */
/*    The Write Characters to a Virtual Display routine writes              */
/*    characters in a virtual display with the text you specify.            */
/*                                                                          */
unsigned long int smg$put_chars() ;
/*    SMG$PUT_CHARS_HIGHWIDE                                                */
/*                                                                          */
/*    Write Double-Height Double-Width Characters                           */
/*                                                                          */
/*    The Write Double-Height Double-Width Characters routine writes        */
/*    double-height, double-width characters to a virtual display.          */
/*                                                                          */
unsigned long int smg$put_chars_highwide() ;
/*    SMG$PUT_CHARS_MULTI                                                   */
/*                                                                          */
/*    Put Text with Multiple Renditions to Display                          */
/*                                                                          */
/*    The Put Text with Multiple Renditions to Display routine writes text with */
/*    multiple renditions to the virtual display.                           */
/*                                                                          */
unsigned long int smg$put_chars_multi() ;
/*    SMG$PUT_CHARS_WIDE                                                    */
/*                                                                          */
/*    Write Double-Width Characters                                         */
/*                                                                          */
/*    The Write Double-Width Characters routine writes double-width characters to a */
/*    virtual display.                                                      */
/*                                                                          */
unsigned long int smg$put_chars_wide() ;
/*    SMG$PUT_HELP_TEXT                                                     */
/*                                                                          */
/*    Output HELP Text to the Display                                       */
/*                                                                          */
/*    The Output HELP Text to the Display routine retrieves and outputs the */
/*    HELP text for the specified topic in the virtual display provided.    */
/*                                                                          */
unsigned long int smg$put_help_text() ;
/*    SMG$PUT_LINE                                                          */
/*                                                                          */
/*    Write Line to Virtual Display                                         */
/*                                                                          */
/*    The Write Line to Virtual Display routine writes a line of text to a  */
/*    virtual display.                                                      */
/*                                                                          */
unsigned long int smg$put_line() ;
/*    SMG$PUT_LINE_HIGHWIDE                                                 */
/*                                                                          */
/*    Write Double-Height and Double-Width Line                             */
/*                                                                          */
/*    The Write Double-Height and Double-Width Line routine writes line of  */
/*    text with double-height and double-width characters.                  */
/*                                                                          */
unsigned long int smg$put_line_highwide() ;
/*    SMG$PUT_LINE_MULTI                                                    */
/*                                                                          */
/*    Write line with Multiple Renditions to Display                        */
/*                                                                          */
/*    The Write Line with Multiple Renditions to Display routine            */
/*    writes lines with multiple renditions to the virtual display,         */
/*    optionally followed by cursor movement sequences.                     */
/*                                                                          */
unsigned long int smg$put_line_multi() ;
/*    SMG$PUT_LINE_WIDE                                                     */
/*                                                                          */
/*    Write Double-Width Line                                               */
/*                                                                          */
/*    The Write Double-Width Line routine writes a line of double-width text */
/*    to a virtual display.                                                 */
/*                                                                          */
unsigned long int smg$put_line_wide() ;
/*    SMG$POP_VIRTUAL_DISPLAY                                               */
/*                                                                          */
/*    Delete a Series of Virtual Displays                                   */
/*                                                                          */
/*    The Delete a Series of Virtual Displays routine deletes a specified   */
/*    virtual display and all displays that were pasted on the specified    */
/*    pasteboard on top of the specified virtual display.                   */
/*                                                                          */
unsigned long int smg$pop_virtual_display() ;
/*    SMG$PUT_PASTEBOARD                                                    */
/*                                                                          */
/*    Output Pasteboard Using Routine                                       */
/*                                                                          */
/*    The Output Pasteboard Using Routine routine accesses the contents of a */
/*    pasteboard.                                                           */
/*                                                                          */
unsigned long int smg$put_pasteboard() ;
/*    SMG$PRINT_PASTEBOARD                                                  */
/*                                                                          */
/*    Print Pasteboard Using a Print Queue                                  */
/*                                                                          */
/*    The Print Pasteboard Using a Print Queue routine prints the contents  */
/*    of the specified pasteboard on a line printer.                        */
/*                                                                          */
unsigned long int smg$print_pasteboard() ;
/*    SMG$PUT_STATUS_LINE                                                   */
/*                                                                          */
/*    Output Line of Text to Hardware Status Line                           */
/*                                                                          */
/*    The Output Line of Text to Hardware Status Line routine outputs a line */
/*    of text to the hardware status line.                                  */
/*                                                                          */
unsigned long int smg$put_status_line() ;
/*    SMG$PUT_VIRTUAL_DISPLAY_ENCODED                                       */
/*                                                                          */
/*    Write Encoded String To Display                                       */
/*                                                                          */
/*    SMG$PUT_VIRTUAL_DISPLAY_ENCODED lets you write a string that has multiple video */
/*    renditions to a virtual display.                                      */
/*                                                                          */
unsigned long int smg$put_virtual_display_encoded() ;
/*    SMG$PUT_WITH_SCROLL                                                   */
/*                                                                          */
/*    Write Text and Scroll                                                 */
/*                                                                          */
/*    SMG$PUT_WITH_SCROLL writes a line of text to a virtual display and scrolls the */
/*    display if necessary.                                                 */
/*                                                                          */
unsigned long int smg$put_with_scroll() ;
/*    SMG$RING_BELL                                                         */
/*                                                                          */
/*    Ring the Terminal Bell or Buzzer                                      */
/*                                                                          */
/*    The Ring the Terminal Bell or Buzzer routine sounds the terminal bell or buzzer. */
/*                                                                          */
unsigned long int smg$ring_bell() ;
/*    SMG$READ_COMPOSED_LINE                                                */
/*                                                                          */
/*    Read Composed Line                                                    */
/*                                                                          */
/*    The Read Composed Line routine reads a line of input composed of      */
/*    normal keystrokes and equivalence strings.                            */
/*                                                                          */
unsigned long int smg$read_composed_line() ;
/*    SMG$REMOVE_LINE                                                       */
/*                                                                          */
/*    Remove a Line from a Virtual Display                                  */
/*                                                                          */
/*    The Remove a Line from a Virtual Display routine removes a line from a */
/*    specified virtual display that was drawn with the SMG$DRAW_LINE or    */
/*    SMG$DRAW_RECTANGLE routines.                                          */
/*                                                                          */
unsigned long int smg$remove_line() ;
/*    SMG$REPLACE_INPUT_LINE                                                */
/*                                                                          */
/*    Replace Input Line                                                    */
/*                                                                          */
/*    The Replace Input Line routine replaces the specified lines in the    */
/*    recall buffer with the specified string.                              */
/*                                                                          */
unsigned long int smg$replace_input_line() ;
/*    SMG$RETURN_INPUT_LINE                                                 */
/*                                                                          */
/*    Return Input Line                                                     */
/*                                                                          */
/*    The Return Input Line routine returns to the caller the requested line from the recall */
/*    buffer. This line is retrieved either by matching it with a specified string or */
/*    by specifying the appropriate line number.                            */
/*                                                                          */
unsigned long int smg$return_input_line() ;
/*    SMG$READ_FROM_DISPLAY                                                 */
/*                                                                          */
/*    Read Text from Display                                                */
/*                                                                          */
/*    The Read Text from Display routine reads a line of text from a virtual display. */
/*                                                                          */
unsigned long int smg$read_from_display() ;
/*    SMG$READ_KEYSTROKE                                                    */
/*                                                                          */
/*    Read a Single Character                                               */
/*                                                                          */
/*    The Read a Single Character routine reads a keystroke and returns that */
/*    keystroke's terminator code.                                          */
/*                                                                          */
unsigned long int smg$read_keystroke() ;
/*    SMG$REPAINT_LINE                                                      */
/*                                                                          */
/*    Repaint One or More Lines on the Current Pasteboard                   */
/*                                                                          */
/*    The Repaint One or More Lines on the Current Pasteboard routine repaints a */
/*    series of lines on the current pasteboard.                            */
/*                                                                          */
unsigned long int smg$repaint_line() ;
/*    SMG$REPAINT_SCREEN                                                    */
/*                                                                          */
/*    Repaint Current Pasteboard                                            */
/*                                                                          */
/*    The Repaint Current Pasteboard routine repaints the specified         */
/*    pasteboard after non-SMG I/O has occurred.                            */
/*                                                                          */
unsigned long int smg$repaint_screen() ;
/*    SMG$REPASTE_VIRTUAL_DISPLAY                                           */
/*                                                                          */
/*    Repaste Virtual Display                                               */
/*                                                                          */
/*    The Repaste Virtual Display routine moves a virtual display to a new  */
/*    position on the pasteboard. The pasting order is not preserved.       */
/*                                                                          */
unsigned long int smg$repaste_virtual_display() ;
/*    SMG$RESTORE_PHYSICAL_SCREEN                                           */
/*                                                                          */
/*    Restore Physical Pasteboard                                           */
/*                                                                          */
/*    The Restore Physical Pasteboard routine rewrites the pasteboard image as it */
/*    was at the time the SMG$SAVE_PHYSICAL_SCREEN routine was called.      */
/*                                                                          */
unsigned long int smg$restore_physical_screen() ;
/*    SMG$READ_STRING                                                       */
/*                                                                          */
/*    Read String                                                           */
/*                                                                          */
/*    The Read String routine reads a string from a virtual keyboard.       */
/*                                                                          */
unsigned long int smg$read_string() ;
/*    SMG$RETURN_CURSOR_POS                                                 */
/*                                                                          */
/*    Return Cursor Position                                                */
/*                                                                          */
/*    The Return Cursor Position routine returns the current virtual cursor */
/*    position in a specified virtual display.                              */
/*                                                                          */
unsigned long int smg$return_cursor_pos() ;
/*    SMG$READ_VERIFY                                                       */
/*                                                                          */
/*    Read and Verify a String                                              */
/*                                                                          */
/*    The Read and Verify a String routine reads a sequence of characters   */
/*    and verifies the sequence.                                            */
/*                                                                          */
unsigned long int smg$read_verify() ;
/*    SMG$SET_BROADCAST_TRAPPING                                            */
/*                                                                          */
/*    Enable Broadcast Trapping                                             */
/*                                                                          */
/*    The Enable Broadcast Trapping routine enables the trapping of broadcast */
/*    messages.                                                             */
/*                                                                          */
unsigned long int smg$set_broadcast_trapping() ;
/*    SMG$SCROLL_DISPLAY_AREA                                               */
/*                                                                          */
/*    Scroll Display Area                                                   */
/*                                                                          */
/*    The Scroll Display Area routine scrolls a rectangular region of a     */
/*    virtual display.                                                      */
/*                                                                          */
unsigned long int smg$scroll_display_area() ;
/*    SMG$SET_CURSOR_ABS                                                    */
/*                                                                          */
/*    Set Absolute Cursor Position                                          */
/*                                                                          */
/*    The Set Absolute Cursor Position routine moves the virtual cursor to  */
/*    the specified position in a virtual display.                          */
/*                                                                          */
unsigned long int smg$set_cursor_abs() ;
/*    SMG$SET_CURSOR_REL                                                    */
/*                                                                          */
/*    Move Cursor\Relative To Current Position                              */
/*                                                                          */
/*    The Move Cursor Relative to Current Position routine moves the virtual */
/*    cursor the specified number of rows and columns from the current      */
/*    virtual cursor position in a virtual display.                         */
/*                                                                          */
unsigned long int smg$set_cursor_rel() ;
/*    SMG$SCROLL_VIEWPORT                                                   */
/*                                                                          */
/*    Scroll a Display Under a Viewport                                     */
/*                                                                          */
/*    The Scroll a Display Under a Viewport routine scrolls a virtual display under its associated  */
/*    viewport.                                                             */
/*                                                                          */
unsigned long int smg$scroll_viewport() ;
/*    SMG$SET_DISPLAY_SCROLL_REGION                                         */
/*                                                                          */
/*    Create Display Scrolling Region                                       */
/*                                                                          */
/*    The Create Display Scrolling Region routine creates a scrolling region */
/*    in a virtual display.                                                 */
/*                                                                          */
unsigned long int smg$set_display_scroll_region() ;
/*    SMG$SELECT_FROM_MENU                                                  */
/*                                                                          */
/*    Make a Selection From the Menu                                        */
/*                                                                          */
/*    The Make a Selection from the Menu routine lets you move between the  */
/*    menu choices using the arrow keys and lets you make a selection by    */
/*    pressing RETURN.                                                      */
/*                                                                          */
unsigned long int smg$select_from_menu() ;
/*    SMG$SET_CURSOR_MODE                                                   */
/*                                                                          */
/*    Set the Cursor Mode                                                   */
/*                                                                          */
/*    The Set the Cursor Mode                                               */
/*    routine turns the physical cursor on or off and selects               */
/*    jump or smooth scrolling.                                             */
/*                                                                          */
unsigned long int smg$set_cursor_mode() ;
/*    SMG$SET_KEYPAD_MODE                                                   */
/*                                                                          */
/*    Set Keypad Mode                                                       */
/*                                                                          */
/*    The Set Keypad Mode routine sets the terminal's numeric keypad to either numeric */
/*    or applications mode.                                                 */
/*                                                                          */
unsigned long int smg$set_keypad_mode() ;
/*    SMG$SNAPSHOT                                                          */
/*                                                                          */
/*    Write Snapshot                                                        */
/*                                                                          */
/*    The Write Snapshot routine writes the current pasteboard buffer to the */
/*    file or hardcopy terminal specified by the pasteboard identifier.     */
/*                                                                          */
unsigned long int smg$snapshot() ;
/*    SMG$SET_OUT_OF_BAND_ASTS                                              */
/*                                                                          */
/*    Set Out-of-Band ASTs                                                  */
/*                                                                          */
/*    The Set Out-of-Band ASTs routine either enables or disables the       */
/*    trapping of out-of-band control characters.                           */
/*                                                                          */
unsigned long int smg$set_out_of_band_asts() ;
/*    SMG$SET_PHYSICAL_CURSOR                                               */
/*                                                                          */
/*    Set Cursor on Physical Screen                                         */
/*                                                                          */
/*    The Set Cursor on Physical Screen routine moves the physical cursor to */
/*    the specified position on the pasteboard.                             */
/*                                                                          */
unsigned long int smg$set_physical_cursor() ;
/*    SMG$SET_DEFAULT_STATE                                                 */
/*                                                                          */
/*    Set Default State                                                     */
/*                                                                          */
/*    The Set Default State routine sets and/or returns the current default */
/*    state for a key table.                                                */
/*                                                                          */
unsigned long int smg$set_default_state() ;
/*    SMG$SET_TERM_CHARACTERISTICS                                          */
/*                                                                          */
/*    Change Terminal Characterisitics                                      */
/*                                                                          */
/*    The Change Terminal Characteristics routine changes or retrieves the  */
/*    terminal characteristics for a given pasteboard.                      */
/*                                                                          */
unsigned long int smg$set_term_characteristics() ;
/*    SMG$SAVE_VIRTUAL_DISPLAY                                              */
/*                                                                          */
/*    Save the Virtual Display to a File                                    */
/*                                                                          */
/*    The Save the Virtual Display to a File routine saves the contents of a  */
/*    virtual display and stores it in a file.                              */
/*                                                                          */
unsigned long int smg$save_virtual_display() ;
/*    SMG$SAVE_PHYSICAL_SCREEN                                              */
/*                                                                          */
/*    Save Physical Screen                                                  */
/*                                                                          */
/*    The Save Physical Screen routine saves the contents of the pasteboard so */
/*    that a later call to SMG$RESTORE_PHYSICAL_SCREEN can restore it.      */
/*                                                                          */
unsigned long int smg$save_physical_screen() ;
/*    SMG$UNPASTE_VIRTUAL_DISPLAY                                           */
/*                                                                          */
/*    Remove Virtual Display                                                */
/*                                                                          */
/*    The Remove Virtual Display routine removes a virtual display from a pasteboard. */
/*                                                                          */
unsigned long int smg$unpaste_virtual_display() ;

#endif					/* __SMG$ROUTINES_LOADED */
#ifndef __SMGDEF_LOADED
#define __SMGDEF_LOADED	1

 
/*** MODULE $SMGDEF ***/

/* Include SMG status return code, for the convenience of the user only. */
#pragma nostandard
#include smgmsg
#pragma standard

/* Definitions for RTL Screen Management Facility                           */
/*                                                                          */
/* Input terminator codes                                                   */
/*                                                                          */
/*                                                                          */
/* Control characters                                                       */
/*                                                                          */
#define SMG$K_TRM_NULL_CHAR 0           /* NUL                              */
#define SMG$K_TRM_CTRLA 1               /* SOH                              */
#define SMG$K_TRM_CTRLB 2               /* STX                              */
#define SMG$K_TRM_CTRLC 3               /* ETX                              */
#define SMG$K_TRM_CTRLD 4               /* EOT                              */
#define SMG$K_TRM_CTRLE 5               /* ENQ                              */
#define SMG$K_TRM_CTRLF 6               /* ACK                              */
#define SMG$K_TRM_CTRLG 7               /* BEL                              */
#define SMG$K_TRM_CTRLH 8               /* BS                               */
#define SMG$K_TRM_CTRLI 9               /* HT                               */
#define SMG$K_TRM_CTRLJ 10              /* LF                               */
#define SMG$K_TRM_CTRLK 11              /* VT                               */
#define SMG$K_TRM_CTRLL 12              /* FF                               */
#define SMG$K_TRM_CTRLM 13              /* CR                               */
#define SMG$K_TRM_CTRLN 14              /* SO                               */
#define SMG$K_TRM_CTRLO 15              /* SI                               */
#define SMG$K_TRM_CTRLP 16              /* DLE                              */
#define SMG$K_TRM_CTRLQ 17              /* DC1                              */
#define SMG$K_TRM_CTRLR 18              /* DC2                              */
#define SMG$K_TRM_CTRLS 19              /* DC3                              */
#define SMG$K_TRM_CTRLT 20              /* DC4                              */
#define SMG$K_TRM_CTRLU 21              /* NAK                              */
#define SMG$K_TRM_CTRLV 22              /* SYN                              */
#define SMG$K_TRM_CTRLW 23              /* ETB                              */
#define SMG$K_TRM_CTRLX 24              /* CAN                              */
#define SMG$K_TRM_CTRLY 25              /* EM                               */
#define SMG$K_TRM_CTRLZ 26              /* SUB                              */
#define SMG$K_TRM_ESCAPE 27             /* ESC                              */
#define SMG$K_TRM_FS 28                 /* FS                               */
#define SMG$K_TRM_GS 29                 /* GS                               */
#define SMG$K_TRM_RS 30                 /* RS                               */
#define SMG$K_TRM_US 31                 /* US                               */
#define SMG$K_TRM_SPACE 32              /* SP                               */
#define SMG$K_TRM_EXCLAMATION_POINT 33  /* !                                */
#define SMG$K_TRM_DOUBLE_QUOTE 34       /* "                                */
#define SMG$K_TRM_NUMBER_SIGN 35        /* #                                */
#define SMG$K_TRM_DOLLAR_SIGN 36        /* $                                */
#define SMG$K_TRM_PERCENT_SIGN 37       /* %                                */
#define SMG$K_TRM_AMPERSAND 38          /* &                                */
#define SMG$K_TRM_QUOTE 39              /* '                                */
#define SMG$K_TRM_LEFT_PAREN 40         /* (                                */
#define SMG$K_TRM_RIGHT_PAREN 41        /* )                                */
#define SMG$K_TRM_ASTERISK 42           /* *                                */
#define SMG$K_TRM_PLUS_SIGN 43          /* +                                */
#define SMG$K_TRM_COMMA_CHAR 44         /* ,                                */
#define SMG$K_TRM_DASH 45               /* -                                */
#define SMG$K_TRM_DOT 46                /* .                                */
#define SMG$K_TRM_SLASH 47              /* /                                */
#define SMG$K_TRM_ZERO 48               /* 0                                */
#define SMG$K_TRM_ONE 49                /* 1                                */
#define SMG$K_TRM_TWO 50                /* 2                                */
#define SMG$K_TRM_THREE 51              /* 3                                */
#define SMG$K_TRM_FOUR 52               /* 4                                */
#define SMG$K_TRM_FIVE 53               /* 5                                */
#define SMG$K_TRM_SIX 54                /* 6                                */
#define SMG$K_TRM_SEVEN 55              /* 7                                */
#define SMG$K_TRM_EIGHT 56              /* 8                                */
#define SMG$K_TRM_NINE 57               /* 9                                */
#define SMG$K_TRM_COLON 58              /* :                                */
#define SMG$K_TRM_SEMICOLON 59          /* ;                                */
#define SMG$K_TRM_LESS_THAN 60          /* <                                */
#define SMG$K_TRM_EQUAL 61              /* =                                */
#define SMG$K_TRM_GREATER_THAN 62       /* >                                */
#define SMG$K_TRM_QUESTION_MARK 63      /* ?                                */
#define SMG$K_TRM_AT_SIGN 64            /* @                                */
#define SMG$K_TRM_UPPERCASE_A 65        /* A                                */
#define SMG$K_TRM_UPPERCASE_B 66        /* B                                */
#define SMG$K_TRM_UPPERCASE_C 67        /* C                                */
#define SMG$K_TRM_UPPERCASE_D 68        /* D                                */
#define SMG$K_TRM_UPPERCASE_E 69        /* E                                */
#define SMG$K_TRM_UPPERCASE_F 70        /* F                                */
#define SMG$K_TRM_UPPERCASE_G 71        /* G                                */
#define SMG$K_TRM_UPPERCASE_H 72        /* H                                */
#define SMG$K_TRM_UPPERCASE_I 73        /* I                                */
#define SMG$K_TRM_UPPERCASE_J 74        /* J                                */
#define SMG$K_TRM_UPPERCASE_K 75        /* K                                */
#define SMG$K_TRM_UPPERCASE_L 76        /* L                                */
#define SMG$K_TRM_UPPERCASE_M 77        /* M                                */
#define SMG$K_TRM_UPPERCASE_N 78        /* N                                */
#define SMG$K_TRM_UPPERCASE_O 79        /* O                                */
#define SMG$K_TRM_UPPERCASE_P 80        /* P                                */
#define SMG$K_TRM_UPPERCASE_Q 81        /* Q                                */
#define SMG$K_TRM_UPPERCASE_R 82        /* R                                */
#define SMG$K_TRM_UPPERCASE_S 83        /* S                                */
#define SMG$K_TRM_UPPERCASE_T 84        /* T                                */
#define SMG$K_TRM_UPPERCASE_U 85        /* U                                */
#define SMG$K_TRM_UPPERCASE_V 86        /* V                                */
#define SMG$K_TRM_UPPERCASE_W 87        /* W                                */
#define SMG$K_TRM_UPPERCASE_X 88        /* X                                */
#define SMG$K_TRM_UPPERCASE_Y 89        /* Y                                */
#define SMG$K_TRM_UPPERCASE_Z 90        /* Z                                */
#define SMG$K_TRM_LEFT_BRACKET 91       /* [                                */
#define SMG$K_TRM_BACKSLASH 92          /* \                                */
#define SMG$K_TRM_RIGHT_BRACKET 93      /* ]                                */
#define SMG$K_TRM_CARET 94              /* ^                                */
#define SMG$K_TRM_UNDERLINE 95          /* _                                */
#define SMG$K_TRM_GRAVE_ACCENT 96       /* `                                */
#define SMG$K_TRM_LOWERCASE_A 97        /* a                                */
#define SMG$K_TRM_LOWERCASE_B 98        /* b                                */
#define SMG$K_TRM_LOWERCASE_C 99        /* c                                */
#define SMG$K_TRM_LOWERCASE_D 100       /* d                                */
#define SMG$K_TRM_LOWERCASE_E 101       /* e                                */
#define SMG$K_TRM_LOWERCASE_F 102       /* f                                */
#define SMG$K_TRM_LOWERCASE_G 103       /* g                                */
#define SMG$K_TRM_LOWERCASE_H 104       /* h                                */
#define SMG$K_TRM_LOWERCASE_I 105       /* i                                */
#define SMG$K_TRM_LOWERCASE_J 106       /* j                                */
#define SMG$K_TRM_LOWERCASE_K 107       /* k                                */
#define SMG$K_TRM_LOWERCASE_L 108       /* l                                */
#define SMG$K_TRM_LOWERCASE_M 109       /* m                                */
#define SMG$K_TRM_LOWERCASE_N 110       /* n                                */
#define SMG$K_TRM_LOWERCASE_O 111       /* o                                */
#define SMG$K_TRM_LOWERCASE_P 112       /* p                                */
#define SMG$K_TRM_LOWERCASE_Q 113       /* q                                */
#define SMG$K_TRM_LOWERCASE_R 114       /* r                                */
#define SMG$K_TRM_LOWERCASE_S 115       /* s                                */
#define SMG$K_TRM_LOWERCASE_T 116       /* t                                */
#define SMG$K_TRM_LOWERCASE_U 117       /* u                                */
#define SMG$K_TRM_LOWERCASE_V 118       /* v                                */
#define SMG$K_TRM_LOWERCASE_W 119       /* w                                */
#define SMG$K_TRM_LOWERCASE_X 120       /* x                                */
#define SMG$K_TRM_LOWERCASE_Y 121       /* y                                */
#define SMG$K_TRM_LOWERCASE_Z 122       /* z                                */
#define SMG$K_TRM_LEFT_BRACE 123        /* left curly brace                 */
#define SMG$K_TRM_VERTICAL_LINE 124     /* |                                */
#define SMG$K_TRM_RIGHT_BRACE 125       /* right curly brace                */
#define SMG$K_TRM_TILDE 126             /* ~                                */
#define SMG$K_TRM_DELETE 127            /* DEL                              */
/*                                                                          */
/* Synonyms for control characters                                          */
/*                                                                          */
#define SMG$K_TRM_BS 8
#define SMG$K_TRM_HT 9
#define SMG$K_TRM_LF 10
#define SMG$K_TRM_VT 11
#define SMG$K_TRM_FF 12
#define SMG$K_TRM_CR 13
/*                                                                          */
/* Keypad keys                                                              */
/*                                                                          */
#define SMG$K_TRM_PF1 256
#define SMG$K_TRM_PF2 257
#define SMG$K_TRM_PF3 258
#define SMG$K_TRM_PF4 259
#define SMG$K_TRM_KP0 260
#define SMG$K_TRM_KP1 261
#define SMG$K_TRM_KP2 262
#define SMG$K_TRM_KP3 263
#define SMG$K_TRM_KP4 264
#define SMG$K_TRM_KP5 265
#define SMG$K_TRM_KP6 266
#define SMG$K_TRM_KP7 267
#define SMG$K_TRM_KP8 268
#define SMG$K_TRM_KP9 269
#define SMG$K_TRM_ENTER 270
#define SMG$K_TRM_MINUS 271
#define SMG$K_TRM_COMMA 272
#define SMG$K_TRM_PERIOD 273
/*                                                                          */
/* Cursor positioning keys                                                  */
/*                                                                          */
#define SMG$K_TRM_UP 274
#define SMG$K_TRM_DOWN 275
#define SMG$K_TRM_LEFT 276
#define SMG$K_TRM_RIGHT 277
/*                                                                          */
/* Function keys                                                            */
/*                                                                          */
#define SMG$K_TRM_F1 281
#define SMG$K_TRM_F2 282
#define SMG$K_TRM_F3 283
#define SMG$K_TRM_F4 284
#define SMG$K_TRM_F5 285
#define SMG$K_TRM_F6 286
#define SMG$K_TRM_F7 287
#define SMG$K_TRM_F8 288
#define SMG$K_TRM_F9 289
#define SMG$K_TRM_F10 290
#define SMG$K_TRM_F11 291
#define SMG$K_TRM_F12 292
#define SMG$K_TRM_F13 293
#define SMG$K_TRM_F14 294
#define SMG$K_TRM_F15 295
#define SMG$K_TRM_F16 296
#define SMG$K_TRM_F17 297
#define SMG$K_TRM_F18 298
#define SMG$K_TRM_F19 299
#define SMG$K_TRM_F20 300
/*                                                                          */
/* Synonyms for function keys                                               */
/*                                                                          */
#define SMG$K_TRM_HELP 295
#define SMG$K_TRM_DO 296
/*                                                                          */
/* Editing keys                                                             */
/*                                                                          */
#define SMG$K_TRM_E1 311                /* FIND                             */
#define SMG$K_TRM_E2 312                /* INSERT_HERE                      */
#define SMG$K_TRM_E3 313                /* REMOVE                           */
#define SMG$K_TRM_E4 314                /* SELECT                           */
#define SMG$K_TRM_E5 315                /* PREV_SCREEN                      */
#define SMG$K_TRM_E6 316                /* NEXT_SCREEN                      */
/*                                                                          */
/* Synonyms for editing keys                                                */
/*                                                                          */
#define SMG$K_TRM_FIND 311              /* E1                               */
#define SMG$K_TRM_INSERT_HERE 312       /* E2                               */
#define SMG$K_TRM_REMOVE 313            /* E3                               */
#define SMG$K_TRM_SELECT 314            /* E4                               */
#define SMG$K_TRM_PREV_SCREEN 315       /* E5                               */
#define SMG$K_TRM_NEXT_SCREEN 316       /* E6                               */
/*                                                                          */
/* Locator keys                                                             */
/*                                                                          */
#define SMG$K_TRM_FIRST_DOWN 321        /* Left button down                 */
#define SMG$K_TRM_SECOND_DOWN 322       /* Middle button down               */
#define SMG$K_TRM_THIRD_DOWN 323        /* Right button down                */
#define SMG$K_TRM_FOURTH_DOWN 324       /* Fourth button down               */
#define SMG$K_TRM_FIRST_UP 325          /* Left button up                   */
#define SMG$K_TRM_SECOND_UP 326         /* Middle button up                 */
#define SMG$K_TRM_THIRD_UP 327          /* Right button up                  */
#define SMG$K_TRM_FOURTH_UP 328         /* Fourth button up                 */
/*                                                                          */
/* Conditions                                                               */
/*                                                                          */
#define SMG$K_TRM_CANCELLED 508         /* I/O cancelled by SMG$CANCEL_INPUT */
#define SMG$K_TRM_TIMEOUT 509           /* Timeout period expired           */
#define SMG$K_TRM_BUFFER_FULL 510       /* Buffer is full                   */
#define SMG$K_TRM_UNKNOWN 511           /* Unknown terminator               */
/*                                                                          */
/* Screen Management request types - These constants are used internally    */
/* by SMG$ and should not be used by users.                                 */
/*                                                                          */
#define SMG$C_CHANGE_RENDITION 10
#define SMG$C_DELETE_CHARS 11
#define SMG$C_ERASE_DISPLAY 12
#define SMG$C_ERASE_LINE 13
#define SMG$C_HOME_CURSOR 14
#define SMG$C_INSERT_CHARS 15
#define SMG$C_INSERT_LINE 16
#define SMG$C_PUT_CHARS 17
#define SMG$C_PUT_LINE 18
#define SMG$C_PUT_DISPLAY_ENCODED 19
#define SMG$C_RETURN_CURSOR_POS 20
#define SMG$C_PUT_WITH_SCROLL 21
#define SMG$C_SET_CURSOR_ABS 22
#define SMG$C_SET_CURSOR_REL 23
#define SMG$C_DELETE_LINE 24
#define SMG$C_ERASE_CHARS 25
#define SMG$C_SCROLL_DISPLAY_AREA 26
#define SMG$C_CHANGE_VIRTUAL_DISPLAY 27
#define SMG$C_LABEL_BORDER 28
#define SMG$C_END_DISPLAY_UPDATE 29
#define SMG$C_MOVE_TEXT 30
/*                                                                          */
/* 	Character Set Codes                                                 */
/*                                                                          */
#define SMG$C_UNITED_KINGDOM 0          /* Unused                           */
#define SMG$C_ASCII 1                   /* ASCII char set                   */
#define SMG$C_SPEC_GRAPHICS 2           /* Line drawing set                 */
#define SMG$C_ALT_CHAR 3                /* Unused                           */
#define SMG$C_ALT_GRAPHICS 4            /* Unused                           */
/*                                                                          */
/*	The following constants define corner cursor positions used in      */
/*	SMG$HOME_CURSOR.                                                    */
/*                                                                          */
#define SMG$C_UPPER_LEFT 0              /* Home cursor to upper left corner */
#define SMG$C_LOWER_LEFT 1              /* Home cursor to lower left corner */
#define SMG$C_UPPER_RIGHT 2             /* Home cursor to upper right corner */
#define SMG$C_LOWER_RIGHT 3             /* Home cursor to lower right corner */
/*                                                                          */
/*	The following constants define label positions used in              */
/*	SMG$LABEL_BORDER.                                                   */
/*                                                                          */
#define SMG$K_TOP 0                     /* Place label on top border        */
#define SMG$K_BOTTOM 1                  /* Place label on bottom border     */
#define SMG$K_LEFT 2                    /* Place label on left border       */
#define SMG$K_RIGHT 3                   /* Place label on right border      */
/*                                                                          */
/*	The following constants define menu types used in                   */
/*	SMG$CREATE_MENU.                                                    */
/*                                                                          */
#define SMG$K_BLOCK 0                   /* Matrix of menu items             */
#define SMG$K_VERTICAL 1                /* Vertical vector of menu items    */
#define SMG$K_HORIZONTAL 2              /* Horizontal vector of menu items  */
/*                                                                          */
/*	Master color wheel for screen background colors.                    */
/*	Used with SMG$CHANGE_PBD_CHARACTERISTICS.                           */
/*                                                                          */
#define SMG$C_COLOR_UNKNOWN 0           /* Unknown background               */
#define SMG$C_COLOR_WHITE 1             /* White background                 */
#define SMG$C_COLOR_BLACK 2             /* Black background                 */
#define SMG$C_COLOR_BLUE 3              /* Blue background                  */
#define SMG$C_COLOR_CYAN 4              /* Cyan background                  */
#define SMG$C_COLOR_GREEN 5             /* Green background                 */
#define SMG$C_COLOR_MAGENTA 6           /* Magenta background               */
#define SMG$C_COLOR_RED 7               /* Red background                   */
#define SMG$C_COLOR_YELLOW 8            /* Yellow background                */
#define SMG$C_COLOR_LIGHT 9             /* Light background                 */
#define SMG$C_COLOR_DARK 10             /* Dark background                  */
#define SMG$C_COLOR_USER1 11            /* User 1 background                */
#define SMG$C_COLOR_USER2 12            /* User 2 background                */
/*                                                                          */
/* The following constants describe the type of terminal                    */
/* and are used with SMG$GET_PASTEBOARD_ATTRIBUTES.                         */
/*                                                                          */
#define SMG$K_UNKNOWN 0                 /* Unknown type                     */
#define SMG$K_VT05 1                    /* Unused                           */
#define SMG$K_VT52 2                    /* Unused                           */
#define SMG$K_VT100 3                   /* Unused                           */
#define SMG$K_VTFOREIGN 4               /* Foreign terminal (ft1-8)         */
#define SMG$K_HARDCOPY 5                /* Hardcopy device                  */
#define SMG$K_VTTERMTABLE 6             /* Video terminal                   */
#define SMG$K_FIRST_PRIV_TYPE 191       /* Used internally by SMG$          */
/*                                                                          */
/*	Define bits, masks, and fields for the control modes.               */
/*                                                                          */
#define SMG$K_BUF_ENABLED 0             /* Enable Buffering                 */
#define SMG$K_MINUPD 1                  /* Enable minimal update            */
#define SMG$K_CLEAR_SCREEN 2            /* Clear screen on exit             */
#define SMG$K_NOTABS 3                  /* Don't use physical tabs          */
#define SMG$K_PROTECT 4                 /* Protect against ASTs             */
#define SMG$M_BUF_ENABLED 1
#define SMG$M_MINUPD 2
#define SMG$M_CLEAR_SCREEN 4
#define SMG$M_NOTABS 8
#define SMG$M_PROTECT 16
#define SMG$m_spare15 -32
struct SMGMODE_BITS {
    unsigned SMG$V_BUF_ENABLED : 1;     /* Enable buffering                 */
    unsigned SMG$V_MINUPD : 1;          /* Enable minimal update (default)  */
    unsigned SMG$V_CLEAR_SCREEN : 1;    /* Clear screen on exit             */
    unsigned SMG$V_NOTABS : 1;          /* Don't use physical tabs          */
    unsigned SMG$V_PROTECT : 1;         /* Protect against ASTs             */
    unsigned SMG$v_spare15 : 27;        /* extra bits                       */
    } ;
/*                                                                          */
/*	Key definition attributes                                           */
/*                                                                          */
#define SMG$M_KEY_NOECHO 1
#define SMG$M_KEY_TERMINATE 2
#define SMG$M_KEY_LOCK 4
#define SMG$M_KEY_PROTECTED 8
#define SMG$M_KEY_SETSTATE 16
#define SMG$m_spare18 -32
struct SMG$R_KEY_DEF_ATTR {
    unsigned SMG$V_KEY_NOECHO : 1;      /* Don't echo strings               */
    unsigned SMG$V_KEY_TERMINATE : 1;   /* This key terminates read         */
    unsigned SMG$V_KEY_LOCK : 1;        /* Lock new state                   */
    unsigned SMG$V_KEY_PROTECTED : 1;   /* Definition is protected          */
    unsigned SMG$V_KEY_SETSTATE : 1;    /* Definition sets a state (output only) */
    unsigned SMG$v_spare18 : 27;        /* extra bits                       */
    } ;
/*                                                                          */
/*        Define bit masks and values for display renditions.               */
/*                                                                          */
#define SMG$M_BOLD 1
#define SMG$M_REVERSE 2
#define SMG$M_BLINK 4
#define SMG$M_UNDERLINE 8
#define SMG$M_INVISIBLE 16
#define SMG$M_USER1 256
#define SMG$M_USER2 512
#define SMG$M_USER3 1024
#define SMG$M_USER4 2048
#define SMG$M_USER5 4096
#define SMG$M_USER6 8192
#define SMG$M_USER7 16384
#define SMG$M_USER8 32768
#define SMG$m_spare14 -65536
struct SMGDEF_BITS {
    unsigned SMG$V_BOLD : 1;            /* Bold rendition                   */
    unsigned SMG$V_REVERSE : 1;         /* Reverse video rendition          */
    unsigned SMG$V_BLINK : 1;           /* Blink rendition                  */
    unsigned SMG$V_UNDERLINE : 1;       /* Underline rendition              */
    unsigned SMG$V_INVISIBLE : 1;       /* Invisible rendition              */
    unsigned SMG$v_fill1 : 3;           /* internally used by SMG$          */
    unsigned SMG$V_USER1 : 1;           /* User rendition 1                 */
    unsigned SMG$V_USER2 : 1;           /* User rendition 2                 */
    unsigned SMG$V_USER3 : 1;           /* User rendition 3                 */
    unsigned SMG$V_USER4 : 1;           /* User rendition 4                 */
    unsigned SMG$V_USER5 : 1;           /* User rendition 5                 */
    unsigned SMG$V_USER6 : 1;           /* User rendition 6                 */
    unsigned SMG$V_USER7 : 1;           /* User rendition 7                 */
    unsigned SMG$V_USER8 : 1;           /* User rendition 8                 */
    unsigned SMG$v_spare14 : 16;        /* extra bits                       */
    } ;
#define SMG$M_NORMAL 0                  /* no bits set                      */
/*                                                                          */
/*	The following masks define values to be used                        */
/*	to specify a display attribute.  These may be added                 */
/*	together to specify multiple attributes.                            */
/*                                                                          */
#define SMG$M_BORDER 1
#define SMG$M_TRUNC_ICON 2
#define SMG$M_DISPLAY_CONTROLS 4
#define SMG$M_USER_DISPLAY 8
#define SMG$M_BLOCK_BORDER 16
#define SMG$m_spare12 -32
struct DISPLAY_ATTRIBUTES {
    unsigned SMG$V_BORDER : 1;          /* Display is bordered              */
    unsigned SMG$V_TRUNC_ICON : 1;      /* Truncation icon enabled          */
    unsigned SMG$V_DISPLAY_CONTROLS : 1; /* Display carriage controls       */
    unsigned SMG$V_USER_DISPLAY : 1;    /* User display for DEBUG           */
    unsigned SMG$V_BLOCK_BORDER : 1;    /* Display is block bordered        */
    unsigned SMG$v_spare12 : 27;        /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with subprocess manipulation.       */
/*                                                                          */
#define SMG$M_DATA_FOLLOWS 1
#define SMG$M_SEND_EOF 2
#define SMG$m_spare11 -4
struct SMG$R_SUBPROCESS_FLAGS {
    unsigned SMG$V_DATA_FOLLOWS : 1;    /* The next call specifies data.    */
    unsigned SMG$V_SEND_EOF : 1;        /* Send an end-of-file to the subprocess */
    unsigned SMG$v_spare11 : 30;        /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$DELETE_PASTEBOARD.                                              */
/*                                                                          */
#define SMG$M_ERASE_PBD 1
#define SMG$m_spare10 -2
struct SMG$R_DELETE_PBD_FLAGS {
    unsigned SMG$V_ERASE_PBD : 1;       /* Erase the pasteboard             */
    unsigned SMG$v_spare10 : 31;        /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$CREATE_PASTEBOARD.                                              */
/*                                                                          */
#define SMG$M_KEEP_CONTENTS 1
#define SMG$m_spare9 -2
struct SMG$R_CREATE_PBD_FLAGS {
    unsigned SMG$V_KEEP_CONTENTS : 1;   /* Don't erase the pasteboard       */
    unsigned SMG$v_spare9 : 31;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$READ_xxxx.                                                      */
/*                                                                          */
#define SMG$M_FUNC_KEYS 1
#define SMG$M_NOKEEP 2
#define SMG$M_NORECALL 4
#define SMG$m_spare8 -8
struct SMG$R_READ_FLAGS {
    unsigned SMG$V_FUNC_KEYS : 1;       /* Disable line-editting.           */
    unsigned SMG$V_NOKEEP : 1;          /* Don't save input in recall buffer */
    unsigned SMG$V_NORECALL : 1;        /* Disable input recall for this call */
    unsigned SMG$v_spare8 : 29;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$SET_CURSOR_MODE.                                                */
/*                                                                          */
#define SMG$M_CURSOR_OFF 1
#define SMG$M_CURSOR_ON 2
#define SMG$M_SCROLL_JUMP 4
#define SMG$M_SCROLL_SMOOTH 8
#define SMG$m_spare16 -16
struct SMG$R_SET_CURSOR_FLAGS {
    unsigned SMG$V_CURSOR_OFF : 1;      /* Turn the physical cursor off     */
    unsigned SMG$V_CURSOR_ON : 1;       /* Turn the physical cursor on      */
    unsigned SMG$V_SCROLL_JUMP : 1;     /* Set jump scroll                  */
    unsigned SMG$V_SCROLL_SMOOTH : 1;   /* Set smooth scroll                */
    unsigned SMG$v_spare16 : 28;        /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$GET_DISPLAY_ATTR.                                               */
/*                                                                          */
#define SMG$M_VIEWPORT 1
#define SMG$M_SUBPROCESS 2
#define SMG$M_MENU 4
#define SMG$m_spare7 -8
struct SMG$R_GET_DISPLAY_FLAGS {
    unsigned SMG$V_VIEWPORT : 1;        /* Display contains a viewport      */
    unsigned SMG$V_SUBPROCESS : 1;      /* Display contains a subprocess    */
    unsigned SMG$V_MENU : 1;            /* Display contains a menu          */
    unsigned SMG$v_spare7 : 29;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$PUT_CHARS.                                                      */
/*                                                                          */
#define SMG$M_ERASE_LINE 1
#define SMG$M_ERASE_TO_EOL 2
#define SMG$m_spare6 -4
struct SMG$R_PUT_CHARS_FLAGS {
    unsigned SMG$V_ERASE_LINE : 1;      /* Erase the entire line            */
    unsigned SMG$V_ERASE_TO_EOL : 1;    /* Erase from cursor to end of line */
    unsigned SMG$v_spare6 : 30;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$MOVE_TEXT.                                                      */
/*                                                                          */
#define SMG$M_TEXT_SAVE 1
#define SMG$M_TEXT_ONLY 2
#define SMG$m_spare17 -4
struct SMG$R_MOVE_TEXT_FLAGS {
    unsigned SMG$V_TEXT_SAVE : 1;       /* Don't erase text after moving it */
    unsigned SMG$V_TEXT_ONLY : 1;       /* Don't move attributes            */
    unsigned SMG$v_spare17 : 30;        /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$PUT_PASTEBOARD and SMG$SNAPSHOT.                                */
/*                                                                          */
#define SMG$M_FORM_FEED 1
#define SMG$m_spare5 -2
struct SMG$R_SNAPSHOT_FLAGS {
    unsigned SMG$V_FORM_FEED : 1;       /* Output form feed before first row */
    unsigned SMG$v_spare5 : 31;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$PUT_xxxx.                                                       */
/*                                                                          */
#define SMG$M_WRAP_CHAR 1
#define SMG$M_WRAP_WORD 2
#define SMG$m_spare4 -4
struct SMG$R_PUT_LINE_FLAGS {
    unsigned SMG$V_WRAP_CHAR : 1;       /* Do character wrapping at end of line */
    unsigned SMG$V_WRAP_WORD : 1;       /* Do word wrapping at end of line  */
    unsigned SMG$v_spare4 : 30;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$SET_KEYPAD_MODE.                                                */
/*                                                                          */
#define SMG$M_KEYPAD_APPLICATION 1
#define SMG$M_KEYPAD_NUMERIC 2
#define SMG$m_spare3 -4
struct SMG$R_KEYPAD_MODES {
    unsigned SMG$V_KEYPAD_APPLICATION : 1; /* Application keypad            */
    unsigned SMG$V_KEYPAD_NUMERIC : 1;  /* Numeric keypad                   */
    unsigned SMG$v_spare3 : 30;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with the FLAGS parameter for        */
/*	SMG$GET_PASTING_INFO.                                               */
/*                                                                          */
#define SMG$M_DISPLAY_PASTED 1
#define SMG$m_spare19 -2
struct SMG$R_PASTING_INFO_FLAGS {
    unsigned SMG$V_DISPLAY_PASTED : 1;  /* Display is pasted                */
    unsigned SMG$v_spare19 : 31;        /* extra bits                       */
    } ;
/*                                                                          */
/*	The following defines bits used with menu manipulation.             */
/*                                                                          */
#define SMG$M_REMOVE_ITEM 1
#define SMG$M_FIXED_FORMAT 2
#define SMG$M_DOUBLE_SPACE 4
#define SMG$M_RETURN_IMMED 8
#define SMG$M_ERASE_MENU 16
#define SMG$M_WIDE_MENU 32
#define SMG$m_spare2 -64
struct SMG$R_MENU_FLAGS {
    unsigned SMG$V_REMOVE_ITEM : 1;     /* Only select item once            */
    unsigned SMG$V_FIXED_FORMAT : 1;    /* Use fixed size cols              */
    unsigned SMG$V_DOUBLE_SPACE : 1;    /* Double space menu rows           */
    unsigned SMG$V_RETURN_IMMED : 1;    /* Ret on non-arrow key             */
    unsigned SMG$V_ERASE_MENU : 1;      /* Erase menu when deleting         */
    unsigned SMG$V_WIDE_MENU : 1;       /* Wide menu items                  */
    unsigned SMG$v_spare2 : 26;         /* extra bits                       */
    } ;
/*                                                                          */
/*	The following are used with SMG$PUT_LINE_xxxx,                      */
/*	SMG$SCROLL_DISPLAY_AREA, and SMG$DRAW_CHAR.                         */
/*                                                                          */
#define SMG$M_UP 1
#define SMG$M_DOWN 2
#define SMG$M_RIGHT 4
#define SMG$M_LEFT 8
#define SMG$m_spare1 -16
struct SCROLL_DIRS {
    unsigned SMG$V_UP : 1;              /* Up                               */
    unsigned SMG$V_DOWN : 1;            /* Down                             */
    unsigned SMG$V_RIGHT : 1;           /* Right                            */
    unsigned SMG$V_LEFT : 1;            /* Left                             */
    unsigned SMG$v_spare1 : 28;         /* extra bits                       */
    } ;
/*                                                                          */
/* Define data structures                                                   */
/*                                                                          */
#define SMG$C_BAND_INFORMATION_TABLE 12 /* Length of table in bytes         */
/*                                                                          */
#define SMG$C_PASTEBOARD_INFO_BLOCK 32  /* Length of table in bytes         */
/*                                                                          */
#define SMG$C_KEYBOARD_INFO_BLOCK 20    /* Length of table in bytes         */
union SMGDEF {
/*                                                                          */
/*	When an out-of-band AST triggers, the user's AST routine            */
/*	will get called.  The first argument passed to his                  */
/*	routine is the address of a Band Information Table.                 */
/*	The offsets into this table are described below.                    */
/*	To make it easy to access from certain languages,                   */
/*	the table is arranged so that it is convenient to                   */
/*	reference it as a longword vector as well as a byte block.          */
/*                                                                          */
    struct  {
        unsigned long int SMG$L_PASTEBOARD_ID; /* Pasteboard ID             */
        unsigned long int SMG$L_ARG;    /* User's AST argument              */
        union  {
            unsigned char SMG$B_CHARACTER; /* The character typed           */
            unsigned long int SMG$L_CHARACTER; /* The character and 3 spaces */
            } SMG$R_CHARACTER_OVERLAY;
        } SMG$R_BAND_INFORMATION_TABLE;
/*	When SMG$GET_PASTEBOARD_ATTRIBUTES is called,                       */
/*	it returns data in a pasteboard information block.                  */
/*	The following structure is used to reference fields                 */
/*	in this block.                                                      */
/*	Items marked with a plus (+) will be 0 unless the                   */
/*	device is a terminal (DEVCLASS=DC$_TERM).                           */
/*                                                                          */
    struct  {
        unsigned long int SMG$L_DEVCHAR; /* Device characteristics          */
        unsigned long int SMG$L_DEVDEPEND; /* Specific characteristics (1)  */
        unsigned long int SMG$L_DEVDEPEND2; /* Specific characteristics (2) */
        unsigned char SMG$B_DEVCLASS;   /* Device class (e.g. DC$_TERM)     */
        unsigned char SMG$B_SMG_DEVTYPE; /* Internal SMG device type        */
        unsigned char SMG$B_PHY_DEVTYPE; /* Physical device type (e.g. DT$_VT100) */
        unsigned char SMG$B_ROWS;       /* Number of rows on device         */
        unsigned short int SMG$W_WIDTH; /* Terminal width                   */
        unsigned char SMG$B_COLOR;      /* PBD background color             */
        unsigned char SMG$B_PARITY;     /* Parity attributes (+)            */
        unsigned short int SMG$W_SPEED; /* Terminal Speed (+)               */
        unsigned short int SMG$W_FILL;  /* Fill characteristics (+)         */
        unsigned short int SMG$W_CURSOR_ROW; /* Row where physical cursor is */
/* (1-origin)                                                               */
        unsigned short int SMG$W_CURSOR_COL; /* Col where physical cursor is */
/* (1-origin)                                                               */
        unsigned long int SMG$L_CURSOR_DID; /* Display id of topmost        */
/* display that cursor is in.                                               */
/* 0 if cursor is not in a                                                  */
/* virtual display                                                          */
        } SMG$R_PASTEBOARD_INFO_BLOCK;
/*	When SMG$GET_KEYBOARD_ATTRIBUTES is called,                         */
/*	it returns data in a keyboard information block.                    */
/*	The following structure is used to reference fields                 */
/*	in this block.                                                      */
/*	Items marked with a plus (+) will be 0 unless the                   */
/*	device is a terminal (DEVCLASS=DC$_TERM).                           */
/*                                                                          */
    struct  {
        unsigned long int SMG$l_fill1;  /* Device characteristics           */
        unsigned long int SMG$l_fill2;  /* Specific characteristics (1)     */
        unsigned long int SMG$l_fill3;  /* Specific characteristics (2)     */
        unsigned char SMG$b_fill4;      /* Device class (e.g. DC$_TERM)     */
        unsigned char SMG$B_RECALL_SIZE; /* Size of recall buffer (+)       */
        unsigned char SMG$b_fill5;      /* Physical device type (e.g. DT$_VT100) */
        unsigned char SMG$B_TYPEAHEAD_CHAR; /* First char in typeahead buffer (+) */
        unsigned short int SMG$w_fill6; /* Terminal width                   */
        unsigned short int SMG$W_TYPEAHEAD_COUNT; /* Number of chars in typeahead buffer (+) */
        } SMG$R_KEYBOARD_INFO_BLOCK;
    } ;
/*                                                                          */
/* Define the out-of-band information table used when an out-of-band        */
/* AST routine is called as it's own record.                                */
/*                                                                          */
struct SMG$R_OUT_OF_BAND_TABLE {
    unsigned long int SMG$L_PBD_ID;     /* Pasteboard ID                    */
    unsigned long int SMG$L_USER_ARG;   /* User's AST argument              */
    union  {
        unsigned char SMG$B_CHAR;       /* The character typed              */
        unsigned long int SMG$L_CHAR;   /* The character and 3 spaces       */
        } SMG$R_CHAR_OVERLAY;
    } ;
#define SMG$C_OUT_OF_BAND_TABLE 12      /* Length of table in bytes         */
/*                                                                          */
/* Define the subprocess information table used when a subprocess           */
/* AST routine is called as it's own record.                                */
/*                                                                          */
struct SMG$R_SUBPROCESS_INFO_TABLE {
    unsigned long int SMG$L_DISP_ID;    /* Display ID                       */
    unsigned long int SMG$L_USR_ARG;    /* User's AST argument              */
    unsigned long int SMG$L_STATUS;     /* Status of executed command       */
    } ;
#define SMG$C_SUBPROCESS_INFO_TABLE 12  /* Length of table in bytes         */
/*                                                                          */
/* Define an information table that can be used by both                     */
/* SMG$GET_PASTEBOARD_ATTRIBUTES and SMG$GET_KEYBOARD_ATTRIBUTES            */
/* as it's own record.                                                      */
/*                                                                          */
struct SMG$R_ATTRIBUTE_INFO_BLOCK {
    unsigned long int SMG$L_DEV_CHAR;   /* Device characteristics           */
    unsigned long int SMG$L_DEV_DEPEND; /* Specific characteristics (1)     */
    unsigned long int SMG$L_DEV_DEPEND2; /* Specific characteristics (2)    */
    unsigned char SMG$B_DEV_CLASS;      /* Device class (e.g. DC$_TERM)     */
    union  {
        unsigned char SMG$B_PBD_TYPE;   /* Internal SMG device type         */
        unsigned char SMG$B_RECALL_NUM; /* Size of recall buffer (+)        */
        } SMG$R_DEV_OVERLAY;
    unsigned char SMG$B_DEV_TYPE;       /* Physical device type (e.g. DT$_VT100) */
    union  {
        unsigned char SMG$B_NUM_ROWS;   /* Number of rows on device         */
        unsigned char SMG$B_TYPEAHD_CHAR; /* First char in typeahead buffer (+) */
        } SMG$R_ROW_OVERLAY;
    unsigned short int SMG$W_NUM_COLUMNS; /* Terminal width                 */
    union  {
        unsigned short int SMG$W_TYPEAHD_CNT; /* Number of chars in typeahead buffer (+) */
        struct  {
            unsigned char SMG$B_PBD_COLOR; /* PBD background color          */
            unsigned char SMG$B_DEV_PARITY; /* Parity attributes (+)        */
            } SMG$R_COUNT_STRUCT;
        } SMG$R_COUNT_OVERLAY;
    unsigned short int SMG$W_DEV_SPEED; /* Terminal Speed (+)               */
    unsigned short int SMG$W_DEV_FILL;  /* Fill characteristics (+)         */
    unsigned short int SMG$W_PHYS_CURSOR_ROW; /* Row where physical cursor is */
    unsigned short int SMG$W_PHYS_CURSOR_COL; /* Col where physical cursor is */
    unsigned long int SMG$L_DISPLAY_ID; /* Display containing phy cursor    */
    } ;
#define SMG$C_ATTRIBUTE_INFO_BLOCK 32   /* Length of table in bytes         */

#endif					/* __SMGDEF_LOADED */
#ifndef __SMGMSG_LOADED
#define __SMGMSG_LOADED	1

/*** MODULE $smgmsg ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:20:09.17 */
/*                                                                          */
/* FILE: SMGMSG.MSG  EDIT: TS1034                                           */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984, 1985, 1986, 1987 BY		    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 1-034 ADD /MACRO=$SMGMSG FOR STARLETSD.  TS 7-MAY-1986                   */
/* 1-033 CHANGE WINTRUFIT TO WINTRUNCFIT JCW 18-MAR-1986                    */
/* 1-032 ADD SUBPROCESS MESSAGES. TS 12-DEC-1985                            */
/* 1-031 ADD VIEWPORT MESSAGES. JCW 21-NOV-1985                             */
/* 1-030 ADD SMG$_GETDATSTR FOR USE IN HELP TEXT DISPLAY.  TS 17-OCT-1985   */
/* 1-029 ADD SMG$_NOTIMP - NOT IMPLEMENTED ERROR MESSAGE. JCW 2-JUL-1985    */
/* 1-028 ADD LINNOTFND AND EXPTOOCOM.	TS 28-MAY-1985                      */
/* 1-027 ADD DISREQ, LENNOTEQL, LENMUSONE FOR SMG$READ_VERIFY.              */
/*	ADD FILESPEC TO TERMTABLE COMPILER ERROR MESSAGES. TS 8-JAN-1985    */
/* 1-001 ORIGINAL.  PLL 16-MAR-1983                                         */
/*-                                                                         */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	SMG$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/* THE NAMES OF ALL PROCEDURES USING EACH ERROR CONDITION VALUE SHOULD APPEAR */
/* IN THE COMMENTS INCLUDED WITH EACH ERROR DEFINITION.                     */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACROS CALL:                                                         */
/*                                                                          */
/*	$SMGDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS AS EXTERNAL;                 */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*                                                                          */
/*-                                                                         */
/* TEMPLATE FOR DOCUMENTING MESSAGES.                                       */
/* EACH EXPLANATION FOLLOWS THE MESSAGE IT APPLIES TO AND                   */
/* IS FOLLOWED BY A BLANK LINE.                                             */
/* BE SURE NOT TO USE THE SEQUENCE "++" AFTER A "!" IN REGULAR COMMENTS     */
/* AS THIS SEQUENCE BEGINS A DOCUMENTATION SEQUENCE AND CAN BE              */
/* SEARCHED FOR IF AND WHEN THE PROCESS OF EXTRACTING THE                   */
/* DOCUMENTATION BECOMES AUTOMATED.                                         */
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	X                                                           */
/* USER ACTION:	Y                                                           */
/*--                                                                        */
/*			; SET LH TO 18 (DECIMAL).                           */
#define SMG$_FACILITY 18
#define SMG$_NORMAL 1212417
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	NORMAL SUCCESSFUL COMPLETION.                               */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_PREDEFREP 1212433
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A PREVIOUS KEY DEFINITION WAS REPLACED BY A NEW             */
/*		DEFINITION.                                                 */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
/*+                                                                         */
/* THE NEXT THREE MESSAGES ARE USED BY THE "batching"                       */
/* PROCEDURES, SMG$BEGIN_DISPLAY_UPDATE AND SMG$END_DISPLAY_UPDATE.         */
/* THE TEXT OF THE MESSAGES SHOULD CHANGE IF WE DECIDE NOT                  */
/* TO PUBLICLY USE THE TERM "batching".                                     */
/*-                                                                         */
#define SMG$_BATSTIPRO 1212441
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A USER TRIED TO END BATCHING (UPDATING) WITH                */
/*		A CALL TO SMG$END_DISPLAY_UPDATE OR                         */
/*		SMG$END_PASTEBOARD_UPDATE.  THIS DID NOT                    */
/*		TERMINATE BATCHING BECAUSE THERE WERE MORE CALLS            */
/*		MADE TO BEGIN BATCHING THAN TO END BATCHING.                */
/* USER ACTION:	NONE.  SOME OUTER LEVEL ROUTINE PROBABLY STILL              */
/*		WANTS BATCHING TO BE IN EFFECT.                             */
/*--                                                                        */
#define SMG$_BATWASOFF 1212449
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A PROGRAM TRIED TO TURN OFF BATCHING WHEN                   */
/*		BATCHING WAS ALREADY OFF.                                   */
/* USER ACTION:	PROBABLY NONE.  CHECK THAT THERE WAS ONE CALL               */
/*		TO TURN ON BATCHING FOR EACH CALL TO TURN IT OFF.           */
/*--                                                                        */
#define SMG$_BATWAS_ON 1212457
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A PROGRAM TRIED TO TURN ON BATCHING WHEN                    */
/*		BATCHING WAS ALREADY ON.  THIS IS NORMAL IN                 */
/*		A MODULAR ENVIRONMENT.                                      */
/* USER ACTION:	NONE.  CHECK THAT THERE WAS ONE CALL                        */
/*		TO TURN ON BATCHING FOR EACH CALL TO TURN IT OFF.           */
/*--                                                                        */
#define SMG$_PASALREXI 1212465
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A USER TRIED TO CREATE A PASTEBOARD FOR A DEVICE,           */
/*		WHEN ONE WAS ALREADY CREATED.  THIS IS NORMAL IN            */
/*		A MODULAR ENVIRONMENT.  THE EXISTING PASTEBOARD ID          */
/*		IS RETURNED.                                                */
/* USER ACTION:	NONE. MAKE SURE YOU DON'T DELETE A PASTEBOARD               */
/*		THAT YOU ACTUALLY DIDN'T CREATE.                            */
/*--                                                                        */
#define SMG$_NOT_A_TRM 1212473
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THIS IS AN INFORMATIONAL MESSAGE TELLING YOU THAT           */
/*		THE PASTEBOARD HAS BEEN CREATED, BUT THE OUTPUT             */
/*		DEVICE IS NOT A TERMINAL.                                   */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define SMG$_NO_MORMSG 1212481
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A CALL TO SMG$GET_BROADCAST_MESSAGE FOUND THAT              */
/*		THERE WERE NO MORE MESSAGES TO BE OBTAINED.                 */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define SMG$_WILUSERMS 1212489
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	NORMALLY THE SCREEN IS UPDATED AT THE END OF                */
/*		EVERY OUTPUT OPERATION.  IF, HOWEVER, THE 'DEVICE'          */
/*		IS ACTUALLY A FILE OR AN UNKNOWN TERMINAL, THEN             */
/*		THIS MESSAGE IS GIVEN AT THE TIME OUTPUT WOULD              */
/*		HAVE BEEN SENT TO THE SCREEN.                               */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_NOTRMSOUT 1212497
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	SMG$SNAPSHOT IS USED WITH FILES AND UNKNOWN DEVICES         */
/*		TO CAPTURE THE CONTENTS OF THE PASTEBOARD AT VARIOUS        */
/*		TIMES.  IF SMG$SNAPSHOT IS CALLED FOR A PASTEBOARD          */
/*		ASSOCIATED WITH A VIDEO TERMINAL, THEN IT TAKES NO          */
/*		ACTION AND RETURNS THIS INFORMATIONAL MESSAGE.              */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_NO_CHADIS 1212505
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED NUMBER OF COLUMNS TO CHANGE WAS ZERO,         */
/*		SO NOTHING IN THE VIRTUAL DISPLAY WAS CHANGED.              */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_PRISECMAP 1212513
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED TERMINAL DEFINITION WAS FOUND IN              */
/*		THE CALLER'S PRIVATE COPY OF TERMTABLE.                     */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_GBLSECMAP 1212521
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED TERMINAL DEFINITION WAS FOUND IN              */
/*		THE SYSTEM TERMTABLE.  (REQUESTED TERMINAL DEFINITION       */
/*		DID NOT EXIST IN THE CALLER'S PRIVATE TERMTABLE.)           */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_WINTRUNCFIT 1212529
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE VIEWPORT SPECIFICATION WILL NOT FIT WHOLLY WITHIN       */
/*		THE VIRTUAL DISPLAY. THE VIEWPORT HAS BEEN TRUNCATED        */
/*		TO FIT WITHIN THE VIRTUAL DISPLAY.                          */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_SUBALREXI 1212537
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A USER TRIED TO CREATE A SUBPROCESS FOR A VIRTUAL           */
/*		DISPLAY, WHEN ONE WAS ALREADY CREATED.  THIS IS NORMAL      */
/*		IN A MODULAR ENVIRONMENT.                                   */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define SMG$_NONBRDMSG 1212545
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A CALL TO SMG$GET_BROADCAST_MESSAGE FOUND THAT              */
/*		THERE WAS A NON-BROADCAST MESSAGE TO BE OBTAINED.           */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define SMG$_FATERRLIB 1212932
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INTERNAL ERROR HAS OCCURED WITHIN SMG.                   */
/* USER ACTION:	SUBMIT AN SPR DESCRIBING THE PROBLEM.                       */
/*--                                                                        */
#define SMG$_INVARG 1212940
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE VALUE OF SOME ARGUMENT IS NOT IN THE CORRECT RANGE.     */
/* USER ACTION:	EXAMINE EACH ARGUMENT. DETERMINE WHICH ONE IS               */
/*		OUT OF RANGE AND CORRECT YOUR PROGRAM.                      */
/*--                                                                        */
#define SMG$_INVCOL 1212948
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID COLUMN NUMBER WAS SPECIFIED.  IT WAS EITHER      */
/*		LESS THAN 0 OR LARGER THAN THE NUMBER OF COLUMNS            */
/*		IN THE VIRTUAL DISPLAY.                                     */
/* USER ACTION:	SPECIFY A VALID COLUMN NUMBER.  COLUMNS ARE NUMBERED        */
/*		BEGINNING WITH 1.                                           */
/*--                                                                        */
#define SMG$_INVDIS_ID 1212956
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID DISPLAY-ID WAS SPECIFIED.                        */
/* USER ACTION:	CHECK THAT YOU ARE PASSING THE DISPLAY ID BY REFERENCE      */
/*		NOT BY VALUE. ENSURE THAT THE DISPLAY ID WAS                */
/*		PREVIOUSLY SET UP BY A CALL TO SMG$CREATE_VIRTUAL_DISPLAY.  */
/*--                                                                        */
#define SMG$_INVPAS_ID 1212964
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID PASTEBOARD ID WAS SPECIFIED.                     */
/* USER ACTION:	CHECK THAT YOU ARE PASSING THE PASTEBOARD ID BY REFERENCE   */
/*		NOT BY VALUE. (A REFERENCE TO A 0 IS VALID, SINCE 0         */
/*		IS A LEGAL PASTEBOARD ID.) ENSURE THAT THE PASTEBOARD       */
/*		WAS PREVIOUSLY SET UP BY A CALL TO                          */
/*		SMG$CREATE_PASTEBOARD AND THAT THE PASTEBOARD HAS NOT       */
/*		BEEN DELETED.                                               */
/*--                                                                        */
#define SMG$_INVROW 1212972
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID ROW NUMBER WAS SPECIFIED.  IT WAS EITHER         */
/*		LESS THAN 0 OR LARGER THAN THE NUMBER OF ROWS               */
/*		IN THE VIRTUAL DISPLAY.                                     */
/* USER ACTION:	SPECIFY A VALID ROW NUMBER.  ROWS ARE NUMBERED              */
/*		BEGINNING WITH 1.                                           */
/*--                                                                        */
#define SMG$_TOOMANDIS 1212980
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INTERNAL LIMIT ON THE NUMBER OF VIRTUAL DISPLAYS         */
/*		THAT YOUR PROGRAM MAY HAVE HAS BEEN EXCEEDED.               */
/*		THE LIMIT IS CURRENTLY 255.  THIS INCLUDES ANY              */
/*		VIRTUAL DISPLAYS THAT SOME OUTER ROUTINE MAY BE USING.      */
/*		THIS INCLUDES DISPLAYS ON ALL PASTEBOARDS.                  */
/* USER ACTION:	USE FEWER VIRTUAL DISPLAYS.                                 */
/*		MAKE SURE THAT YOUR PROGRAM IS NOT IN A LOOP                */
/*		CREATING VIRTUAL DISPLAYS.  BE SURE THAT YOU DELETE         */
/*		A VIRTUAL DISPLAY WHEN YOU ARE ALL DONE WITH IT.            */
/*--                                                                        */
#define SMG$_TOOMANPAS 1212988
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INTERNAL LIMIT ON THE NUMBER OF PASTEBOARDS              */
/*		THAT YOUR PROGRAM MAY HAVE HAS BEEN EXCEEDED.               */
/*		THE LIMIT IS CURRENTLY 16.                                  */
/* USER ACTION:	USE FEWER PASTEBOARDS.                                      */
/*--                                                                        */
#define SMG$_WRONUMARG 1212996
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN SMG ROUTINE WAS CALLED WITH TOO FEW ARGUMENTS            */
/*		(LESS THAN THE NUMBER OF REQUIRED ARGUMENTS)                */
/*		OR TOO MANY ARGUMENTS.                                      */
/* USER ACTION:	CORRECT THE CODE TO CALL THE ROUTINE WITH                   */
/*		THE PROPER NUMBER OF ARGUMENTS.                             */
/*--                                                                        */
#define SMG$_INVKBD_ID 1213004
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID KEYBOARD ID WAS PASSED.                          */
/* USER ACTION:	CHECK THAT YOU ARE PASSING THE KEYBOARD ID BY REFERENCE     */
/*		NOT BY VALUE. ENSURE THAT THE KEYBOARD ID WAS               */
/*		PREVIOUSLY SET UP BY A CALL TO                              */
/*		SMG$CREATE_VIRTUAL_KEYBOARD.                                */
/*--                                                                        */
#define SMG$_INVKTB_ID 1213012
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID KEY TABLE ID WAS PASSED.                         */
/* USER ACTION:	CHECK THAT YOU ARE PASSING THE KEY TABLE ID BY REFERENCE    */
/*		NOT BY VALUE. ENSURE THAT THE KEY TABLE ID WAS              */
/*		PREVIOUSLY SET UP BY A CALL TO                              */
/*		SMG$CREATE_KEY_TABLE.                                       */
/*--                                                                        */
#define SMG$_INVMAXLEN 1213020
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE MAXIMUM LENGTH SPECIFIED FOR AN INPUT STRING            */
/*		WAS TOO LONG.                                               */
/* USER ACTION:	CORRECT YOUR PROGRAM SO THAT IT REQUESTS AN INPUT           */
/*		STRING OF 512 CHARACTERS OR LESS.                           */
/*--                                                                        */
#define SMG$_FILTOOLON 1213028
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE LENGTH OF THE SPECIFIED STRING                          */
/*		WAS TOO LONG.                                               */
/* USER ACTION:	CORRECT YOUR PROGRAM SO THAT IT REQUESTS A FILE             */
/*		NAME OF 255 CHARACTERS OR LESS.                             */
/*--                                                                        */
#define SMG$_PROTOOLON 1213036
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE LENGTH OF A PROMPT STRING EXCEEDED 512 CHARACTERS.      */
/* USER ACTION:	SHORTEN THE PROMPT TO 512 CHARACTERS OR LESS.               */
/*--                                                                        */
#define SMG$_NOTPASTED 1213044
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN ATTEMPT WAS MADE TO UNPASTE OR MOVE A DISPLAY            */
/*		THAT WAS NOT PASTED TO THE SPECIFIED PASTEBOARD.            */
/* USER ACTION:	CHECK THAT YOU ARE REFERENCING THE CORRECT VIRTUAL          */
/*		DISPLAY.  VERIFY THAT THE DISPLAY HAS NOT BEEN              */
/*		UNPASTED OR THAT YOU FORGOT TO PASTE IT.                    */
/*--                                                                        */
#define SMG$_PBDIN_USE 1213052
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE OPERATION YOU HAVE TRIED TO PERFORM IS NOT              */
/*		LEGAL WHILE OUTPUT TO THE PASTEBOARD IS BEING BATCHED.      */
/*		FOR EXAMPLE, YOU CAN'T CHANGE THE PASTEBOARD                */
/*		CHARACTERISTICS WHILE THE PASTEBOARD IS BATCHED.            */
/* USER ACTION:	TURN OFF PASTEBOARD BATCHING BEFORE ATTEMPTING THE          */
/*		OPERATION.  YOU MAY TURN BATCHING ON AGAIN AFTER THE        */
/*		OPERATION.                                                  */
/*--                                                                        */
#define SMG$_INVWIDARG 1213060
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN ATTEMPT WAS MADE TO CHANGE THE CHARACTERISTICS           */
/*		OF THE TERMINAL, SETTING IT'S WIDTH TO 0.                   */
/* USER ACTION:	CORRECT THE CODE. A WIDTH OF 0 IS ILLEGAL.                  */
/*--                                                                        */
#define SMG$_INVPAGARG 1213068
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN ATTEMPT WAS MADE TO CHANGE THE CHARACTERISTICS           */
/*		OF THE TERMINAL, SETTING IT'S HEIGHT (PAGE SIZE) TO 0.      */
/* USER ACTION:	CORRECT THE CODE. A HEIGHT OF 0 IS ILLEGAL.                 */
/*--                                                                        */
#define SMG$_INVCOLARG 1213076
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN ATTEMPT WAS MADE TO CHANGE THE CHARACTERISTICS           */
/*		OF THE TERMINAL, CHANGING ITS BACKGROUND COLOR              */
/*		TO A VALUE THAT WAS NOT LEGAL.                              */
/* USER ACTION:	CHECK THE SYMBOLIC NAME FOR THE BACKGROUND COLOR            */
/*		DESIRED.  SPECIFY IT CORRECTLY.                             */
/*--                                                                        */
#define SMG$_DIALINNOT 1213084
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE VERTICES SPECIFIED WILL RESULT IN A DIAGONAL LINE,      */
/*		RATHER THAN A VERTICAL OR HORIZONTAL LINE.                  */
/* USER ACTION:	RE-SPECIFY THE VERTICES SO THAT THE LINE DRAWN WILL BE      */
/*		VERTICAL OR HORIZONTAL.                                     */
/*--                                                                        */
#define SMG$_TABID_MIS 1213092
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE TERMTABLE INTERNAL CONSISTENCY CHECK FAILED.  THE       */
/*		ROUTINES WHICH FETCH INFORMATION FROM TERMTABLE HAVE        */
/*		A DIFFERENT VERSION NUMBER THAN THE TERMTABLE DATA.         */
/* USER ACTION:	PROBABLY THE ROUTINES WHICH FETCH THE DATA ARE NEWER        */
/*		THAN YOUR TERMTABLE.EXE.  RE-COMPILE TERMTABLE.TXT TO       */
/*		UPDATE YOUR TERMTABLE.EXE.                                  */
/*--                                                                        */
#define SMG$_UNDTERNAM 1213100
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED TERMINAL DEFINITION WAS NOT FOUND IN          */
/*		THE CALLER'S PRIVATE COPY OF TERMTABLE OR THE SYSTEM        */
/*		COPY OF TERMTABLE.                                          */
/* USER ACTION:	IF YOU INTENDED TO USE A PRIVATE TERMINAL DEFINITION,       */
/*		MAKE SURE THAT TERMTABLE.EXE EXISTS IN YOUR PRIVATE         */
/*		DIRECTORY AND THAT THE LOGICAL NAME TERM$TABLOC POINTS      */
/*		TO IT.  IF YOU EXPECTED YOUR TERMINAL TO BE DEFINED IN      */
/*		THE SYSTEM TERMTABLE, CHECK WITH YOUR SYSTEM MANAGER.       */
/*--                                                                        */
#define SMG$_INVTERTAB 1213108
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN INVALID TERMINAL TABLE ADDRESS WAS SPECIFIED.            */
/* USER ACTION:	CHECK THAT YOU ARE PASSING THE TERMINAL TABLE ARGUMENT      */
/*		BY REFERENCE AND NOT BY VALUE.  MAKE SURE THE TERMINAL      */
/*		TABLE ADDRESS WAS ACQUIRED BY CALLING                       */
/*		SMG$INIT_TERM_TABLE.                                        */
/*--                                                                        */
#define SMG$_INVREQCOD 1213116
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	DATA IS REQUESTED FROM TERMTABLE VIA REQUEST CODES          */
/*		WHICH ARE AVAILABLE AS SYMBOLIC NAMES.	THE CODE YOU        */
/*		HAVE SPECIFIED IS INVALID.                                  */
/* USER ACTION:	CHECK THE SPELLING OF THE SYMBOLIC NAME YOU ARE USING.      */
/*--                                                                        */
#define SMG$_NOTBOOCAP 1213124
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER EXPECTED A BOOLEAN CAPABILITY        */
/*		NAME BUT ENCOUNTERED SOMETHING ELSE.                        */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITION.  PERHAPS YOU HAVE           */
/*		MISSPELLED THE BOOLEAN CAPABILITY NAME OR OMITTED           */
/*		ANOTHER STATEMENT SUCH AS STRING OR NUMERIC WHICH           */
/*		WOULD HAVE TERMINATED BOOLEAN CAPABILITIES.                 */
/*--                                                                        */
#define SMG$_SYNERR 1213132
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER ENCOUNTERED AN INVALID               */
/*		SYNTAX.  FOR INSTANCE, THERE MAY BE A MISPLACED OR          */
/*		MISSING EQUALS SIGN.                                        */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITION.                             */
/*--                                                                        */
#define SMG$_UNDTERTYP 1213140
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE DEFINITION FOR THE REQUESTED TERMINAL TYPE WAS          */
/*		NOT FOUND IN THE CALLER'S PRIVATE COPY OF TERMTABLE         */
/*		OR THE SYSTEM TERMTABLE.                                    */
/* USER ACTION:	IF YOU INTENDED TO USE A PRIVATE DEFINITION, MAKE           */
/*		SURE THAT TERMTABLE.EXE EXISTS IN YOUR PRIVATE DIRECTORY    */
/*		AND THAT THE LOGICAL NAME TERM$TABLOC POINTS TO IT.         */
/*		IF YOU EXPECTED YOUR TERMINAL DEFINITION TO EXIST IN        */
/*		THE SYSTEM TERMTABLE, CONSULT YOUR SYSTEM MANAGER.          */
/*--                                                                        */
#define SMG$_MISTERNAM 1213148
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	CAPABILITIES WERE NOT PRECEEDED BY THE NAME OF A            */
/*		TERMINAL.                                                   */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITIONS.  MAKE SURE THAT            */
/*		EACH DEFINITION STARTS WITH NAME = <terminal_name>.         */
/*--                                                                        */
#define SMG$_EXPTOOCOM 1213156
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE SPECIFIED EXPRESSION WAS                                */
/*		TOO COMPLEX FOR THE TERMTABLE COMPILER TO PARSE.            */
/* USER ACTION:	CORRECT YOUR CAPABILITY SO THAT IT IS LESS COMPLEX.         */
/*--                                                                        */
#define SMG$_ILLVAL 1213164
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	A BOOLEAN CAPABILITY WAS GIVEN A VALUE OTHER THAN           */
/*		0 OR 1.                                                     */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITIONS.  BOOLEAN CAPABILITIES      */
/*		MUST BE 0 OR 1 (OFF OR ON, RESPECTIVELY).                   */
/*--                                                                        */
#define SMG$_INVEXP 1213172
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER ENCOUNTERED AN INVALID               */
/*		ARITHMETIC EXPRESSION.                                      */
/* USER ACTION:	CHECK YOUR DEFINITION.  MAKE SURE THAT YOU HAVE             */
/*		USED ONLY VALID OPERATORS AND OPERANDS IN YOUR              */
/*		EXPRESSIONS.                                                */
/*--                                                                        */
#define SMG$_ERRAT_LIN 1213180
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	GENERAL INFORMATION MESSAGE INCLUDED WITH MANY              */
/*		TERMTABLE COMPILER MESSAGES.  ATTEMPTS TO IDENTIFY          */
/*		SPECIFICALLY WHERE AN ERROR OCCURRED.                       */
/* USER ACTION:	CHECK THE SPECIFIED LINE IN YOUR DEFINITION.                */
/*--                                                                        */
#define SMG$_ERRLIN 1213188
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	GENERAL INFORMATION MESSAGE INCLUDED WITH MANY              */
/*		TERMTABLE COMPILER MESSAGES.  ATTEMPTS TO IDENTIFY          */
/*		SPECIFICALLY WHICH LINE CONTAINED AN ERROR.                 */
/* USER ACTION:	CHECK THE SPECIFIED LINE IN YOUR DEFINITION.                */
/*--                                                                        */
#define SMG$_UNDTERNOP 1213196
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED TERMINAL DEFINITION WAS NOT FOUND IN THE      */
/*		CALLER'S PRIVATE COPY OF TERMTABLE OR THE SYSTEM            */
/*		TERMTABLE.  THE CALLER'S PRIVATE TERMTABLE COULDN'T BE      */
/*		BE ACCESSED, EITHER BECAUSE IT DIDN'T EXIST OR BECAUSE      */
/*		RMS COULD NOT OPEN THE FILE.                                */
/* USER ACTION:	IF YOU INTENDED TO USE A DEFINITION FROM YOUR PRIVATE       */
/*		TERMTABLE, MAKE SURE THAT TERMTABLE.EXE EXISTS IN YOUR      */
/*		PRIVATE DIRECTORY AND THAT THE LOGICAL NAME TERM$TABLOC     */
/*		POINTS TO IT.  MAKE SURE THAT YOU HAVE READ ACCESS TO       */
/*		THE FILE.                                                   */
/*--                                                                        */
#define SMG$_UNDTERNOS 1213204
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED TERMINAL DEFINITION WAS NOT FOUND IN          */
/*		THE CALLER'S PRIVATE TERMTABLE OR THE SYSTEM TERMTABLE.     */
/*		THE SYSTEM TERMTABLE WAS UNAVAILABLE.                       */
/* USER ACTION:	THE SYSTEM TERMTABLE SHOULD BE MAPPED AS A GLOBAL           */
/*		SECTION AND THEREFORE SHOULD ALWAYS BE AVAILABLE.           */
/*		CONSULT YOUR SYSTEM MANAGER REGARDING THIS.                 */
/*--                                                                        */
#define SMG$_MISFILSPE 1213212
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE REQUIRE STATEMENT NEEDS A FILE NAME IN ORDER TO         */
/*		LOCATE EXTERNAL DEFINITIONS WHICH SHOULD BECOME PART        */
/*		OF YOUR TERMTABLE.                                          */
/* USER ACTION:	CHECK YOUR TERMTABLE.TXT.  ADD A FILE NAME TO THE           */
/*		REQUIRE STATEMENT.                                          */
/*--                                                                        */
#define SMG$_UNRECSTA 1213220
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER ENCOUNTERED A STATEMENT THAT         */
/*		IT DOES NOT RECOGNIZE.                                      */
/* USER ACTION:	CHECK YOUR DEFINITION.  MAKE SURE YOU HAVE SPELLED          */
/*		KEYWORDS CORRECTLY AND THAT STATEMENTS APPEAR ONLY          */
/*		IN VALID SEQUENCES.                                         */
/*--                                                                        */
#define SMG$_FAIOPEFIL 1213228
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER COULD NOT OPEN THE FILE              */
/*		SPECIFIED IN A REQUIRE.                                     */
/* USER ACTION:	MAKE SURE THAT THE SPECIFIED FILE EXISTS AND THAT           */
/*		YOU HAVE READ ACCESS TO IT.                                 */
/*--                                                                        */
#define SMG$_NO_ARGS 1213236
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	YOU REQUESTED A CAPABILITY THAT REQUIRES USER               */
/*		ARGUMENTS (SUCH AS A ROW AND COLUMN NUMBER) BUT             */
/*		DID NOT PROVIDE ANY.                                        */
/* USER ACTION:	CHECK THE NUMBER OF ARGUMENTS REQUIRED BY THIS              */
/*		CAPABILITY AND CORRECT YOUR CALL TO SMG$GET_TERM_DATA.      */
/*--                                                                        */
#define SMG$_NOTNUMCAP 1213244
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER EXPECTED A NUMERIC CAPABILITY        */
/*		NAME BUT ENCOUNTERED SOMETHING ELSE.                        */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITION.  PERHAPS YOU HAVE           */
/*		MISSPELLED THE NUMERIC CAPABILITY NAME OR OMITTED           */
/*		ANOTHER STATEMENT SUCH AS STRING OR BOOLEAN WHICH           */
/*		WOULD HAVE TERMINATED NUMERIC CAPABILITIES.                 */
/*--                                                                        */
#define SMG$_NOTSTRCAP 1213252
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER EXPECTED A STRING CAPABILITY         */
/*		NAME BUT ENCOUNTERED SOMETHING ELSE.                        */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITION.  PERHAPS YOU HAVE           */
/*		MISSPELLED THE STRING CAPABILITY NAME OR OMITTED            */
/*		ANOTHER STATEMENT SUCH AS BOOLEAN OR NUMERIC WHICH          */
/*		WOULD HAVE TERMINATED STRING CAPABILITIES.                  */
/*--                                                                        */
#define SMG$_MISENDSTA 1213260
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER EXPECTED AN END STATEMENT            */
/*		TO TERMINATE THE CURRENT TERMINAL DEFINITION AND            */
/*		THIS END STATEMENT WAS MISSING.                             */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITIONS.                            */
/*--                                                                        */
#define SMG$_MISNAMREQ 1213268
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER EXPECTED TERMTABLE.TXT TO            */
/*		BEGIN WITH A TERMINAL DEFINITION (NAME STATEMENT)           */
/*		OR A REQUIRE.  SOMETHING ELSE WAS ENCOUNTERED.              */
/* USER ACTION:	CHECK YOUR TERMTABLE.TXT.                                   */
/*--                                                                        */
#define SMG$_ILLBATFNC 1213276
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN ATTEMPT WAS MADE TO PERFORM AN OPERATION THAT            */
/*		IS NOT PERMITTED WHILE A VIRTUAL DISPLAY IS BEING           */
/*		BATCHED (FOR EXAMPLE, PERFORMING INPUT OR MOVING            */
/*		THE VIRTUAL DISPLAY).                                       */
/* USER ACTION:	TERMINATE BATCHING FIRST BY CALLING                         */
/*		SMG$END_DISPLAY_UPDATE.                                     */
/*--                                                                        */
#define SMG$_INVDIR 1213284
/*++                                                                        */
/* FACILITY:	SMG (TERMTABLE COMPILER)                                    */
/* EXPLANATION:	THE TERMTABLE COMPILER ACCEPTS ONLY A FEW FAO               */
/*		DIRECTIVES.  IT ENCOUNTERED ONE THAT IT DOES NOT            */
/*		HANDLE.                                                     */
/* USER ACTION:	CHECK YOUR TERMINAL DEFINITION.  MAKE SURE THAT             */
/* 		YOU USE ONLY VALID FAO DIRECTIVES.                          */
/*--                                                                        */
#define SMG$_TRMNOTANS 1213292
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A CALL TO SMG$GET_PHYSICAL_CURSOR WAS MADE                  */
/*		SPECIFYING THAT THE TERMINAL IS TO BE QUERIED               */
/*		TO DETERMINE WHERE THE CURSOR IS.                           */
/*		THIS COULD NOT BE DONE BECAUSE THE TERMINAL                 */
/*		WAS NOT ANSI, AND THIS FEATURE IS AVAILABLE                 */
/*		ONLY ON ANSI TERMINALS.                                     */
/* USER ACTION:	RERUN YOUR APPLICATION ON AN ANSI TERMINAL,                 */
/*		SUCH AS A VT100.                                            */
/*--                                                                        */
#define SMG$_LENNOTEQL 1213300
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A CALL TO SMG$READ_VERIFY WAS MADE                          */
/*		SPECIFYING A PICTURE STRING AND AN INITIAL                  */
/*		STRING OF UNEQUAL LENGTH.  SINCE THE INITIAL                */
/*		STRING IS USED AS THE DEFAULT VALUE FOR THE                 */
/*		INPUT, IT MUST MATCH THE PICTURE STRING IN LENGTH.          */
/* USER ACTION:	MODIFY THE INITIAL STRING TO BE OF THE SAME LENGTH          */
/*		AS THE PICTURE STRING.                                      */
/*--                                                                        */
#define SMG$_LENMUSONE 1213308
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A CALL TO SMG$READ_VERIFY WAS MADE                          */
/*		SPECIFYING A FILL STRING OR A CLEAR                         */
/*		STRING OF MORE THAN ONE CHARACTER.  SINCE FILL CHARACTER    */
/*		MATCHING IS DONE ONE CHARACTER AT A TIME, ONLY ONE          */
/*		CHARACTER MAY BE SPECIFIED FOR THE FILL AND CLEAR STRING.   */
/* USER ACTION:	MODIFY THE FILL AND/OR CLEAR STRING TO BE ONE CHARACTER     */
/*		LONG.                                                       */
/*--                                                                        */
#define SMG$_DISREQ 1213316
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A CALL TO SMG$READ_VERIFY WAS MADE                          */
/*		SPECIFYING RIGHT-JUSTIFICATION, NO DISPLAY_ID WAS           */
/*		SPECIFIED AND THE SCROLL_REVERSE SEQUENCE WAS NOT           */
/*		FOUND FOR THIS TERMINAL IN TERMTABLE.EXE.  SINCE            */
/*		RIGHT-JUSTIFICATION REQUIRES A CURSOR POSITIONING           */
/*		SEQUENCE TO WORK PROPERLY, EITHER THE DISPLAY_ID            */
/*		PARAMETER MUST BE SPECIFIED OR THE SCROLL_REVERSE           */
/*		SEQUENCE MUST BE ADDED TO TERMTABLE.EXE.                    */
/* USER ACTION:	ADD THE DISPLAY_ID PARAMETER TO THE SMG$READ_VERIFY         */
/*		CALL OR ADD THE SCROLL_REVERSE SEQUENCE TO                  */
/*		TERMTABLE.EXE.                                              */
/*--                                                                        */
#define SMG$_NOTIMP 1213324
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	YOU TRIED TO USE A ROUTINE THAT IS NOT IMPLEMENTED          */
/*		IN THIS VERSION OF SMG$.                                    */
/* USER ACTION:	GET THE APPROPRIATE VERSION OF SMG$.                        */
/*--                                                                        */
#define SMG$_NO_WINASSOC 1213332
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A VIEWPORT HAS NOT BEEN ASSOCIATED WITH THE VIRTUAL         */
/*		DISPLAY.                                                    */
/* USER ACTION:	CREATE A VIEWPORT ON THE VIRTUAL DISPLAY.                   */
/*--                                                                        */
#define SMG$_WINEXISTS 1213340
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A VIEWPORT EXISTS. THAT IS, A VIEWPORT HAS ALREADY BEEN     */
/*		ASSOCIATED WITH THE VIRTUAL DISPLAY.                        */
/* USER ACTION:	1. USE THE VIEWPORT THAT ALREADY ASSOCIATED WITH THE        */
/*		VIRTUAL DISPLAY. 2. DELETE THE EXISTING VIEWPORT BEFORE     */
/*		YOU CREATE THE NEW VIEWPORT. OR, 3. USE OTHER VIEWPORT      */
/*		ROUTINES ON CHANGE/MOVE THE EXISTING VIEWPORT.              */
/*--                                                                        */
#define SMG$_NOSUBEXI 1213348
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	A SUBPROCESS DOES NOT EXIST FOR THE SPECIFIED VIRTUAL       */
/*		DISPLAY.                                                    */
/* USER ACTION:	CALL SMG$CREATE_SUBPROCESS TO CREATE A SUBPROCESS FOR       */
/*		THIS VIRTUAL DISPLAY.                                       */
/*--                                                                        */
#define SMG$_INSQUOCRE 1213356
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE CURRENT BYTLM OR PRCLM QUOTA VALUE IS TOO SMALL         */
/*		TO CREATE A SUBPROCESS.                                     */
/* USER ACTION:	INCREASE THE ACCOUNTS BYTLM AND/OR PRCLM VALUE.             */
/*--                                                                        */
#define SMG$_INPTOOLON 1213364
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE LENGTH OF AN INPUT STRING EXCEEDED 255 CHARACTERS.      */
/* USER ACTION:	SHORTEN THE STRING TO 255 CHARACTERS OR LESS.               */
/*--                                                                        */
#define SMG$_EOF 1213442
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	END OF FILE CONDITION WAS DETECTED ON INPUT.                */
/* USER ACTION:	IF NECESSARY, MODIFY YOUR PROGRAM TO RECOGNIZE THIS         */
/*		CONDITION AND RESPOND TO IT.                                */
/*--                                                                        */
#define SMG$_KEYDEFPRO 1213450
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE SPECIFIED KEY IS ALREADY DEFINED, AND SINCE ITS         */
/*		DEFINITION IS PROTECTED, IT CAN NOT BE CHANGED OR           */
/*		RE-DEFINED.                                                 */
/* USER ACTION:	NONE                                                        */
/*--                                                                        */
#define SMG$_INVDEFATT 1213458
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	WHEN A KEY IS DEFINED, ATTRIBUTES SUCH AS NOECHO MAY BE     */
/*		SPECIFIED  WITH THE DEFINITION.  AN ATTEMPT WAS MADE TO     */
/*		SPECIFY	AN UNKNOWN ATTRIBUTE.                               */
/* USER ACTION:	CHECK THE LIST OF VALID ATTRIBUTES AND CORRECT YOUR         */
/*		PROGRAM.                                                    */
/*--                                                                        */
#define SMG$_INVKEYNAM 1213466
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE SPECIFIED KEY NAME WAS LESS THAN 1 CHARACTER OR         */
/*		MORE THAN 31 CHARACTERS.                                    */
/* USER ACTION:	CHOOSE A KEY NAME WITH 1 TO 31 CHARACTERS.                  */
/*--                                                                        */
#define SMG$_INVSTANAM 1213474
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE SPECIFIED STATE NAME WAS LESS THAN 1 CHARACTER OR       */
/*		MORE THAN 31 CHARACTERS.                                    */
/* USER ACTION:	CHOOSE A STATE NAME WITH 1 TO 31 CHARACTERS.                */
/*--                                                                        */
#define SMG$_LINNOTFND 1213482
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE INPUT LINE REQUESTED IN A CALL TO                       */
/*		SMG$RETURN_INPUT_LINE WAS NOT FOUND.                        */
/* USER ACTION:	IF NECESSARY, MODIFY YOUR PROGRAM TO RECOGNIZE THIS         */
/*		CONDITION AND RESPOND TO IT.                                */
/*--                                                                        */
#define SMG$_KEYNOTDEF 1216512
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	AN ATTEMPT WAS MADE TO PERFORM AN OPERATION, SUCH AS        */
/*		SMG$GET_KEY_DEF, ON A KEY WHICH WAS NOT DEFINED.            */
/* USER ACTION:	CHECK YOUR PROGRAM TO SEE IF THIS KEY SHOULD HAVE           */
/*		BEEN DEFINED.                                               */
/*--                                                                        */
#define SMG$_NOMOREKEYS 1216520
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	SMG$LIST_KEY_DEFS, WHEN CALLED REPEATEDLY, RETURNS ALL      */
/*		THE KEY DEFINITIONS IN A KEY TABLE.  WHEN THERE ARE NO      */
/*		MORE DEFINITIONS, THIS ERROR IS RETURNED.                   */
/* USER ACTION:	MODIFY YOUR PROGRAM TO EXPECT THIS CONDITION, IF NECESSARY. */
/*--                                                                        */
#define SMG$_STRTERESC 1216528
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:  AN SMG OUTPUT ROUTINE WAS PASSED AN ESCAPE SEQUENCE        */
/*		EMBEDDED IN THE OUTPUT STRING.  THE OUTPUT STRING WAS       */
/*		WRITTEN TO THE VIRTUAL DISPLAY BUT THE STRING WAS           */
/*		TERMINATED AT THE ESCAPE SEQUENCE.                          */
/* USER ACTION:	CHECK YOUR OUTPUT STRING TO DETERMINE WHAT ESCAPE           */
/*		SEQUENCE WAS BEING PASSED.  IF YOU NEED THE ACTION          */
/*		PROVIDED BY THIS ESCAPE SEQUENCE, THERE IS MOST             */
/*		LIKELY A SMG ROUTINE THAT PROVIDES THAT FUNCTIONALITY.      */
/*--                                                                        */
#define SMG$_GBLNOTCRE 1216536
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE SYSTEM PROGRAM THAT MAPS TERMTABLE.EXE AS A GLOBAL      */
/*		SECTION WAS UNSUCCESSFUL.                                   */
/* USER ACTION:	THIS MESSAGE SHOULD BE HANDLED ONLY BY SYSTEM MANAGERS.     */
/*		IF THERE IS ALREADY AN EXISTING GLOBAL SECTION FOR          */
/*		TERMTABLE, THE SYSTEM MUST BE REBOOTED IN ORDER TO CREATE   */
/*		A NEW GLOBAL SECTION.                                       */
/*--                                                                        */
/* THE FOLLOWING IS USED WITH GBLNOTCRE                                     */
#define SMG$_DELEXIGBL 1216544
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE SYSTEM PROGRAM WHICH MAPS TERMTABLE AS A GLOBAL         */
/*		SECTION WAS UNSUCCESSFUL.  BEFORE A NEW GLOBAL SECTION      */
/*		CAN BE CREATED, THE PREVIOUS ONE MUST BE DELETED.           */
/* USER ACTION:	THE SYSTEM MUST BE REBOOTED IN ORDER TO MAP A NEW           */
/*		TERMTABLE.EXE AS THE GLOBAL SECTION.                        */
/*--                                                                        */
#define SMG$_GETDATSTR 1216552
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THIS MESSAGE IS SIGNALED INTERNALLY TO ALLOW THE HELP       */
/*		OUTPUT ROUTINE THAT WAS CALLED BY LBR$OUTPUT_HELP TO        */
/*		ACCESS THE DISPLAY_ID AND KEYBOARD_ID FOR THE SPECIFIED     */
/*		DISPLAY.  THIS MESSAGE SHOULD NEVER BE RETURNED AS A        */
/*		STATUS FROM ANY SMG ROUTINE AND MUST NOT BE DOCUMENTED.     */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */
#define SMG$_OPNOTSUP 1216560
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THE REQUESTED OPERATION CANNOT BE PERFORMED SINCE           */
/*		THE TERMINAL HARDWARE DOES NOT SUPPORT THIS FEATURE.        */
/* USER ACTION:	RUN THE APPLICATION ON A TERMINAL THAT SUPPORTS THIS        */
/*		FEATURE.                                                    */
/*--                                                                        */
#define SMG$_HLPPMTSTR 1216568
/*++                                                                        */
/* FACILITY:	SMG                                                         */
/* EXPLANATION:	THIS MESSAGE IS THE PROMPT STRING OUTPUT BY THE ROUTINE     */
/*		SMG$PUT_HELP_TEXT.  IT IS NOT A NORMAL ERROR MESSAGE        */
/*		BUT RESIDES HERE TO ALLOW TRANSLATION TO LANGUAGES          */
/*		OTHER THAN ENGLISH.                                         */
/* USER ACTION:	NONE.                                                       */
/*--                                                                        */

#endif					/* __SMGMSG_LOADED */
#ifndef __SMGTRMPTR_LOADED
#define __SMGTRMPTR_LOADED	1

/*** MODULE $smgtrmptr ***/
/* Terminal Capability Pointers for RTL SMG$ facility                       */
/*                                                                          */
/* Boolean capabilities here - 1 - 220                                      */
/*                                                                          */
#define SMG$K_ADVANCED_VIDEO 1
#define SMG$K_ANSI_CRT 2
#define SMG$K_AUTO_MARGIN 3
#define SMG$K_BACKSPACE 4
#define SMG$K_BLOCK_MODE 5
#define SMG$K_DEC_CRT 6
#define SMG$K_EDIT 7
#define SMG$K_EIGHT_BIT 8
#define SMG$K_FULLDUP 9
#define SMG$K_IGNORE_NEWLINE 10
#define SMG$K_INSERT_MODE_NULLS 11
#define SMG$K_LOWERCASE 12
#define SMG$K_NO_ERASE 13
#define SMG$K_NO_SCROLL 14
#define SMG$K_OVERSTRIKE 15
#define SMG$K_PRINTER_PORT 16
#define SMG$K_REGIS 17
#define SMG$K_SCOPE 18
#define SMG$K_SIXEL_GRAPHICS 19
#define SMG$K_SOFT_CHARACTERS 20
#define SMG$K_PHYSICAL_TABS 21
#define SMG$K_PHYSICAL_FF 22
#define SMG$K_UNDERLINE 23
#define SMG$K_CURSOR_REPORT_ANSI 24
#define SMG$K_DEC_CRT_2 25
#define SMG$K_DEC_CRT_3 26
#define SMG$K_SET_CURSOR_COL_ROW 27
/*                                                                          */
/* Private capabilities reserved for customer use.                          */
/* Put them at the end of the range.                                        */
/*                                                                          */
#define SMG$K_PRIVATE_BOO_1 211
#define SMG$K_PRIVATE_BOO_2 212
#define SMG$K_PRIVATE_BOO_3 213
#define SMG$K_PRIVATE_BOO_4 214
#define SMG$K_PRIVATE_BOO_5 215
#define SMG$K_PRIVATE_BOO_6 216
#define SMG$K_PRIVATE_BOO_7 217
#define SMG$K_PRIVATE_BOO_8 218
#define SMG$K_PRIVATE_BOO_9 219
#define SMG$K_PRIVATE_BOO_10 220
#define SMG$K_MAX_BOOLEAN_CODE 220
/*                                                                          */
/* Numeric capabilities here - 221 to 440                                   */
/*                                                                          */
#define SMG$K_COLUMNS 221
#define SMG$K_CR_FILL 222
#define SMG$K_FRAME 223
#define SMG$K_LF_FILL 224
#define SMG$K_NUMBER_FN_KEYS 225
#define SMG$K_ROWS 226
#define SMG$K_VMS_TERMINAL_NUMBER 227
#define SMG$K_WIDE_SCREEN_COLUMNS 228
/*                                                                          */
/* Private capabilities for customer use.                                   */
/* Put them at the end of the range.                                        */
/*                                                                          */
#define SMG$K_PRIVATE_NUM_1 431
#define SMG$K_PRIVATE_NUM_2 432
#define SMG$K_PRIVATE_NUM_3 433
#define SMG$K_PRIVATE_NUM_4 434
#define SMG$K_PRIVATE_NUM_5 435
#define SMG$K_PRIVATE_NUM_6 436
#define SMG$K_PRIVATE_NUM_7 437
#define SMG$K_PRIVATE_NUM_8 438
#define SMG$K_PRIVATE_NUM_9 439
#define SMG$K_PRIVATE_NUM_10 440
#define SMG$K_MAX_NUMERIC_CODE 440
/*                                                                          */
/* String capabilities here - 441 - 660                                     */
/*                                                                          */
#define SMG$K_BEGIN_ALTERNATE_CHAR 441
#define SMG$K_BEGIN_BLINK 442
#define SMG$K_BEGIN_BOLD 443
#define SMG$K_BEGIN_DELETE_MODE 444
#define SMG$K_BEGIN_INSERT_MODE 445
#define SMG$K_BEGIN_LINE_DRAWING_CHAR 446
#define SMG$K_BEGIN_REVERSE 447
#define SMG$K_BEGIN_UNDERSCORE 448
#define SMG$K_BOTTOM_T_CHAR 449
#define SMG$K_CLEAR_TAB 450
#define SMG$K_CROSS_CHAR 451
#define SMG$K_CURSOR_DOWN 452
#define SMG$K_CURSOR_LEFT 453
#define SMG$K_CURSOR_RIGHT 454
#define SMG$K_CURSOR_UP 455
#define SMG$K_DARK_SCREEN 456
#define SMG$K_DELETE_CHAR 457
#define SMG$K_DELETE_LINE 458
#define SMG$K_DEVICE_ATTRIBUTES 459
#define SMG$K_DOUBLE_HIGH_BOTTOM 460
#define SMG$K_DOUBLE_HIGH_TOP 461
#define SMG$K_DOUBLE_WIDE 462
#define SMG$K_DUPLICATE 463
#define SMG$K_END_ALTERNATE_CHAR 464
#define SMG$K_END_BLINK 465
#define SMG$K_END_BOLD 466
#define SMG$K_END_DELETE_MODE 467
#define SMG$K_END_INSERT_MODE 468
#define SMG$K_END_LINE_DRAWING_CHAR 469
#define SMG$K_END_REVERSE 470
#define SMG$K_END_UNDERSCORE 471
#define SMG$K_ERASE_TO_END_DISPLAY 472
#define SMG$K_ERASE_TO_END_LINE 473
#define SMG$K_ERASE_WHOLE_DISPLAY 474
#define SMG$K_ERASE_WHOLE_LINE 475
#define SMG$K_HOME 476
#define SMG$K_HORIZONTAL_BAR 477
#define SMG$K_INIT_STRING 478
#define SMG$K_INSERT_CHAR 479
#define SMG$K_INSERT_LINE 480
#define SMG$K_INSERT_PAD 481
#define SMG$K_KEY_0 482
#define SMG$K_KEY_1 483
#define SMG$K_KEY_2 484
#define SMG$K_KEY_3 485
#define SMG$K_KEY_4 486
#define SMG$K_KEY_5 487
#define SMG$K_KEY_6 488
#define SMG$K_KEY_7 489
#define SMG$K_KEY_8 490
#define SMG$K_KEY_9 491
#define SMG$K_KEY_BACKSPACE 492
#define SMG$K_KEY_COMMA 493
#define SMG$K_KEY_DOWN_ARROW 494
#define SMG$K_KEY_E1 495
#define SMG$K_KEY_E2 496
#define SMG$K_KEY_E3 497
#define SMG$K_KEY_E4 498
#define SMG$K_KEY_E5 499
#define SMG$K_KEY_E6 500
#define SMG$K_KEY_ENTER 501
#define SMG$K_KEY_F1 502
#define SMG$K_KEY_F2 503
#define SMG$K_KEY_F3 504
#define SMG$K_KEY_F4 505
#define SMG$K_KEY_F5 506
#define SMG$K_KEY_F6 507
#define SMG$K_KEY_F7 508
#define SMG$K_KEY_F8 509
#define SMG$K_KEY_F9 510
#define SMG$K_KEY_F10 511
#define SMG$K_KEY_F11 512
#define SMG$K_KEY_F12 513
#define SMG$K_KEY_F13 514
#define SMG$K_KEY_F14 515
#define SMG$K_KEY_F15 516
#define SMG$K_KEY_F16 517
#define SMG$K_KEY_F17 518
#define SMG$K_KEY_F18 519
#define SMG$K_KEY_F19 520
#define SMG$K_KEY_F20 521
#define SMG$K_KEY_LEFT_ARROW 522
#define SMG$K_KEY_MINUS 523
#define SMG$K_KEY_PERIOD 524
#define SMG$K_KEY_PF1 525
#define SMG$K_KEY_PF2 526
#define SMG$K_KEY_PF3 527
#define SMG$K_KEY_PF4 528
#define SMG$K_KEY_RIGHT_ARROW 529
#define SMG$K_KEY_UP_ARROW 530
#define SMG$K_LABEL_F1 531
#define SMG$K_LABEL_F2 532
#define SMG$K_LABEL_F3 533
#define SMG$K_LABEL_F4 534
#define SMG$K_LABEL_F5 535
#define SMG$K_LABEL_F6 536
#define SMG$K_LABEL_F7 537
#define SMG$K_LABEL_F8 538
#define SMG$K_LABEL_F9 539
#define SMG$K_LABEL_F10 540
#define SMG$K_LABEL_F11 541
#define SMG$K_LABEL_F12 542
#define SMG$K_LABEL_F13 543
#define SMG$K_LABEL_F14 544
#define SMG$K_LABEL_F15 545
#define SMG$K_LABEL_F16 546
#define SMG$K_LABEL_F17 547
#define SMG$K_LABEL_F18 548
#define SMG$K_LABEL_F19 549
#define SMG$K_LABEL_F20 550
#define SMG$K_LEFT_T_CHAR 551
#define SMG$K_LIGHT_SCREEN 552
#define SMG$K_LOWER_LEFT_CORNER 553
#define SMG$K_LOWER_RIGHT_CORNER 554
#define SMG$K_NAME 555
#define SMG$K_NEWLINE_CHAR 556
#define SMG$K_PAD_CHAR 557
#define SMG$K_RESTORE_CURSOR 558
#define SMG$K_RIGHT_T_CHAR 559
#define SMG$K_SAVE_CURSOR 560
#define SMG$K_SCROLL_FORWARD 561
#define SMG$K_SCROLL_REVERSE 562
#define SMG$K_SEL_ERASE_TO_END_DISPLAY 563
#define SMG$K_SEL_ERASE_TO_END_LINE 564
#define SMG$K_SEL_ERASE_WHOLE_DISPLAY 565
#define SMG$K_SEL_ERASE_WHOLE_LINE 566
#define SMG$K_SET_APPLICATION_KEYPAD 567
#define SMG$K_SET_CHAR_NOT_SEL_ERASE 568
#define SMG$K_SET_CHAR_SEL_ERASE 569
#define SMG$K_SET_CURSOR_ABS 570
#define SMG$K_SET_NUMERIC_KEYPAD 571
#define SMG$K_SET_SCROLL_REGION 572
#define SMG$K_SET_TAB 573
#define SMG$K_SINGLE_HIGH 574
#define SMG$K_TAB_CHAR 575
#define SMG$K_TOP_T_CHAR 576
#define SMG$K_UNDERLINE_CHAR 577
#define SMG$K_UPPER_LEFT_CORNER 578
#define SMG$K_UPPER_RIGHT_CORNER 579
#define SMG$K_VERTICAL_BAR 580
#define SMG$K_WIDTH_NARROW 581
#define SMG$K_WIDTH_WIDE 582
#define SMG$K_CURSOR_POSITION_REPORT 583
#define SMG$K_REQUEST_CURSOR_POSITION 584
#define SMG$K_CR_GRAPHIC 585
#define SMG$K_FF_GRAPHIC 586
#define SMG$K_LF_GRAPHIC 587
#define SMG$K_HT_GRAPHIC 588
#define SMG$K_VT_GRAPHIC 589
#define SMG$K_TRUNCATION_ICON 590
#define SMG$K_CURSOR_NEXT_LINE 591
#define SMG$K_CURSOR_PRECEDING_LINE 592
#define SMG$K_INDEX 593
#define SMG$K_REVERSE_INDEX 594
#define SMG$K_BEGIN_NORMAL_RENDITION 595
#define SMG$K_BEGIN_AUTOWRAP_MODE 596
#define SMG$K_END_AUTOWRAP_MODE 597
#define SMG$K_BEGIN_AUTOREPEAT_MODE 598
#define SMG$K_END_AUTOREPEAT_MODE 599
#define SMG$K_SET_ORIGIN_RELATIVE 600
#define SMG$K_SET_ORIGIN_ABSOLUTE 601
#define SMG$K_ERASE_LINE_TO_CURSOR 602
#define SMG$K_NEXT_LINE 603
#define SMG$K_BEGIN_AUTOPRINT_MODE 604
#define SMG$K_END_AUTOPRINT_MODE 605
#define SMG$K_PRINT_SCREEN 606
#define SMG$K_SET_CURSOR_ON 607
#define SMG$K_SET_CURSOR_OFF 608
#define SMG$K_SET_PRINTER_OUTPUT 609
#define SMG$K_SET_SCREEN_OUTPUT 610
#define SMG$K_ERASE_DISPLAY_TO_CURSOR 611
#define SMG$K_REQUEST_PRINTER_STATUS 612
#define SMG$K_PRINTER_READY 613
#define SMG$K_PRINTER_NOT_READY 614
#define SMG$K_NO_PRINTER 615
#define SMG$K_SET_JUMP_SCROLL 616
#define SMG$K_SET_SMOOTH_SCROLL 617
#define SMG$K_ERROR_ICON 618
#define SMG$K_PAGE_LENGTH 619
/*                                                                          */
/* Private capabilities reserved for customer use.                          */
/* Put them at the end of the range.                                        */
/*                                                                          */
#define SMG$K_PRIVATE_STR_1 651
#define SMG$K_PRIVATE_STR_2 652
#define SMG$K_PRIVATE_STR_3 653
#define SMG$K_PRIVATE_STR_4 654
#define SMG$K_PRIVATE_STR_5 655
#define SMG$K_PRIVATE_STR_6 656
#define SMG$K_PRIVATE_STR_7 657
#define SMG$K_PRIVATE_STR_8 658
#define SMG$K_PRIVATE_STR_9 659
#define SMG$K_PRIVATE_STR_10 660
#define SMG$K_MAX_STRING_CODE 660
/*                                                                          */
/* Second string capabilities here - 661 - 880                              */
/*                                                                          */
#define SMG$K_BEGIN_USER1 661
#define SMG$K_BEGIN_USER2 662
#define SMG$K_BEGIN_USER3 663
#define SMG$K_BEGIN_USER4 664
#define SMG$K_BEGIN_USER5 665
#define SMG$K_BEGIN_USER6 666
#define SMG$K_BEGIN_USER7 667
#define SMG$K_BEGIN_USER8 668
#define SMG$K_END_USER1 669
#define SMG$K_END_USER2 670
#define SMG$K_END_USER3 671
#define SMG$K_END_USER4 672
#define SMG$K_END_USER5 673
#define SMG$K_END_USER6 674
#define SMG$K_END_USER7 675
#define SMG$K_END_USER8 676
#define SMG$K_BLACK_SCREEN 677
#define SMG$K_BLUE_SCREEN 678
#define SMG$K_CYAN_SCREEN 679
#define SMG$K_MAGENTA_SCREEN 680
#define SMG$K_GREEN_SCREEN 681
#define SMG$K_RED_SCREEN 682
#define SMG$K_WHITE_SCREEN 683
#define SMG$K_YELLOW_SCREEN 684
#define SMG$K_USER1_SCREEN 685
#define SMG$K_USER2_SCREEN 686
#define SMG$K_BEGIN_STATUS_LINE 687
#define SMG$K_END_STATUS_LINE 688
#define SMG$K_BEGIN_LOCATOR 689
#define SMG$K_END_LOCATOR 690
#define SMG$K_KEY_FIRST_DOWN 691
#define SMG$K_KEY_SECOND_DOWN 692
#define SMG$K_KEY_THIRD_DOWN 693
#define SMG$K_KEY_FOURTH_DOWN 694
#define SMG$K_KEY_FIRST_UP 695
#define SMG$K_KEY_SECOND_UP 696
#define SMG$K_KEY_THIRD_UP 697
#define SMG$K_KEY_FOURTH_UP 698
#define SMG$K_MAX_STRING2_CODE 880

#endif					/* __SMGTRMPTR_LOADED */
#ifndef __SMRDEF_LOADED
#define __SMRDEF_LOADED	1

/*** MODULE $smrdef ***/
/*                                                                          */
/* DEFINE SYMBIONT MANAGER REQUEST CODES                                    */
/*                                                                          */
/* SYMBIONT MANAGER REQUEST CODES                                           */
#define SMR$K_INITIAL 0                 /* INITIALIZE A QUEUE               */
#define SMR$K_DELETE 1                  /* DELETE THE QUEUE                 */
#define SMR$K_START 2                   /* ACTIVATE OR RESUME PRINTING      */
#define SMR$K_PAUSE 3                   /* SUSPEND PRINTING FOR A WHILE     */
#define SMR$K_MERGE 4                   /* MOVE FILES FORM ONE QUEUE INTO ANOTHER  */
#define SMR$K_REDIRECT 5                /* ASSIGNMENT OF ONE QUEUE TO ANOTHER  */
#define SMR$K_JUSTIFY 6                 /* JUSTIFY PRINT FORMS(IE: ISSUE FF)  */
#define SMR$K_STOP 7                    /* DISABLE FURTHER DE-QUEING        */
#define SMR$K_ENTER 8                   /* ADD A FILE TO A QUEUE            */
#define SMR$K_CREJOB 9                  /* CREATE A PRINT JOB               */
#define SMR$K_ADDFIL 10                 /* ADD A FILE TO EXISTING JOB       */
#define SMR$K_CLSJOB 11                 /* CLOSE OPEN JOB                   */
#define SMR$K_RMVJOB 12                 /* REMOVE JOB FROM QUEUE            */
#define SMR$K_ALTER 13                  /* CHANGE A FILES CHARACTERISTICS   */
#define SMR$K_ABORT 14                  /* ABORT CURRENT JOB, START NEXT    */
#define SMR$K_RELEASE 15                /* RELEASE JOB FROM HOLD LIST       */
#define SMR$K_DETINIT 16                /* DETACHED JOB HAS INITIATED       */
#define SMR$K_SYNCJOB 17                /* SYNCRONIZE WITH A BATCH JOB      */
#define SMR$K_ASKQNAM 18                /* GET NAME OF QUEUE FOR LOG FILE   */
/*                                                                          */
/* ASSIGN SYMBIONT MANAGER PRINT JOB/RECORD OPTION CODES                    */
/*                                                                          */
/*                                                                          */
/* JOB FILE OPTIONS                                                         */
#define SMO$K_DELETE 1                  /* DELETE THE FILE AFTER PRINTING   */
#define SMO$K_BRSTPAG 2                 /* CREATE A BURST PAGE              */
#define SMO$K_NOBRSTPAG 3               /* INHIBIT BURST PAGE               */
#define SMO$K_FLAGPAG 4                 /* PRINT A FLAG PAGE                */
#define SMO$K_NOFLAGPAG 5               /* INHIBIT A FLAG PAGE              */
#define SMO$K_PAGHDR 6                  /* PRINT FILENAME AS PAGE HEADER    */
#define SMO$K_DOUBLE 7                  /* DOUBLE SPACE THE LISTING         */
#define SMO$K_NOFEED 8                  /* INHIBIT FORM FEED GENERATION     */
#define SMO$K_PAGCNT 9                  /* SPECIFY PAGE COUNT TO PRINT      */
#define SMO$K_COPIES 10                 /* NUMBER OF COPIES TO PRINT        */
#define SMO$K_FILESIZ 11                /* FILE SIZE                        */
#define SMO$K_DESTQUE 12                /* DESTINATION QUEUE                */
/* OPTIONS FOR CREATE JOB                                                   */
#define SMO$K_RLSTIM 32                 /* TIME TO HOLD UNTIL QUEUEING      */
#define SMO$K_HOLD 33                   /* HOLD THE JOB                     */
#define SMO$K_JOBPRI 34                 /* SPECIFY PRINT JOB/DETACHED JOB PRIOITY  */
#define SMO$K_JOBCOPY 35                /* NUMBER OF COPIES OF ENTIRE JOB   */
#define SMO$K_FORMTYPE 36               /* FORM TYPE TO USED WHEN PRINTED   */
#define SMO$K_LOWER 37                  /* UPPER/LOWER CASE PRINTER ONLY    */
#define SMO$K_PARAMS 38                 /* SUPPLY JOB PARAMETERS            */
#define SMO$K_JOBNAME 39                /* SUPPLY A NAME TO THE JOB         */
#define SMO$K_NOLOWER 40                /* CLEAR LOWER CASE REQUIRED        */
#define SMO$K_CPULIM 41                 /* CPU TIME LIMIT                   */
#define SMO$K_NOCPULM 42                /* NO CPU TIME LIMIT                */
#define SMO$K_WSQUOTA 43                /* WORKING SET QUOTA                */
#define SMO$K_NOWSQUO 44                /* NO WORKING SET QUOTA             */
#define SMO$K_WSDEFLT 45                /* WORKING SET DEFAULT              */
#define SMO$K_NOWSDFT 46                /* NO WORKING SET DEFAULT           */
#define SMO$K_DQCHAR 47                 /* CHAR. TO BE USED WHEN PRINTED    */
#define SMO$K_LOGFNAM 48                /* LOG FILE SPEC.                   */
#define SMO$K_LOGQNAM 49                /* QUEUE NAME FOR LOG FILE          */
#define SMO$K_KEEPLOG 50                /* KEEP LOG FILE                    */
#define SMO$K_NOSPOOL 51                /* DON'T SPOOL LOG FILE             */
#define SMO$K_NOKEEPLOG 52              /* DELETE LOG FILE                  */
#define SMO$K_NOLOG 53                  /* CREATE LOG ON NULL DEVICE        */
#define SMO$K_NOTIFY 54                 /* NOTIFY WHEN JOB COMPLETES        */
#define SMO$K_NONOTFY 55                /* NO NOTIFY                        */
#define SMO$K_WSEXTNT 56                /* WS EXTENT                        */
#define SMO$K_NOWSEXTNT 57              /* NO WS EXTENT                     */
/* OPTIONS FOR INIT OR START A QUEUE                                        */
#define SMO$K_CURFORM 64                /* CURRENT FORMS MOUNTED ON DEVICE  */
#define SMO$K_GENPRT 65                 /* ALLOW GENERIC PRINTING           */
#define SMO$K_NOGENPRT 66               /* DISALLOW GENERIC PRINTING        */
#define SMO$K_DETJOB 67                 /* QUEUE IS FOR DETACHED JOB QUEUING  */
#define SMO$K_GENDEV 68                 /* QUEUE IS GENERIC DEVICE QUEUE    */
#define SMO$K_NOGENDEV 69               /* NOT A GENERIC DEVICE             */
#define SMO$K_DEFBRST 70                /* QUEUE HAS BURST PAGE BY DEFAULT  */
#define SMO$K_NODEFBRST 71              /* NO DEFAULT BURST PAGE            */
#define SMO$K_DEFFLAG 72                /* QUEUE HAS FLAG PAGE BY DEFAULT   */
#define SMO$K_NODEFFLAG 73              /* NO DEFAULT FLAG                  */
#define SMO$K_TRMDEV 74                 /* DEVICE IS A TERMINAL             */
#define SMO$K_NOTRMDEV 75               /* DEVICE IS NOT A TERMINAL         */
#define SMO$K_JOBLIM 76                 /* JOB LIMIT FOR BATCH JOBS         */
#define SMO$K_INIPRI 77                 /* JOB INITIAL PRIORITY             */
#define SMO$K_DISWAP 78                 /* DISABLE SWAPING                  */
#define SMO$K_MCPULM 79                 /* MAX CPU TIME LIMIT               */
#define SMO$K_NOMCPULM 80               /* NO MAX CPU TIME LIMIT            */
#define SMO$K_DCPULM 81                 /* DEFAULT CPU TIME LIMIT           */
#define SMO$K_NODCPULM 82               /* NO DEFAULT CPU TIME LIMIT        */
#define SMO$K_WSQUTA 83                 /* WORKING SET QUOTA                */
#define SMO$K_NOWSQUTA 84               /* NO WORKING SET QUOTA             */
#define SMO$K_WSDFLT 85                 /* WORKING SET DEFAULT              */
#define SMO$K_NOWSDFLT 86               /* NO WORKING SET DEFAULT           */
#define SMO$K_CURDQCHAR 87              /* CURRENT CHAR. OF THE QUEUE       */
#define SMO$K_SMBNAME 88                /* SYMBIONT NAME FOR QUEUE          */
#define SMO$K_WSXTANT 89                /* WS EXTENT                        */
#define SMO$K_NOWSXTNT 90               /* NO WS EXTENT                     */
#define SMO$K_NODISWAP 91               /* ENABLE SWAPPING                  */
/* OPTIONS FOR RESTART                                                      */
#define SMO$K_NEXTJOB 96                /* RESTART AT END BEGINNING OF NEXT JOB  */
#define SMO$K_TOPOFILE 97               /* RESTART JOB AT TOP-OF-FILE       */
#define SMO$K_SPCCNT 98                 /* SPECIFY PAGES TO SPACE OVER      */
/* OPTIONS FOR ABORT                                                        */
#define SMO$K_REQUEUE 112               /* REQUEUE THE FILE                 */
#define SMO$K_REQDEST 113               /* SPECIFY NEW QUEUE DESTINATION    */
#define SMO$K_REQPRIO 114               /* SPECIFY PRIORITY ON REQUEUE      */
 

#endif					/* __SMRDEF_LOADED */
#ifndef __SOCKET_LOADED
#define __SOCKET_LOADED	1

/*
 * Copyright (c) 1982 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	socket.h	6.6 (Berkeley) 6/8/85
 */

#ifndef __SOCKET_TYPEDEFS
typedef char * caddr_t;

typedef unsigned short u_short;

typedef unsigned long u_long;

typedef unsigned char u_char;

#define __SOCKET_TYPEDEFS
#endif

/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Types
 */
#define	SOCK_STREAM	1		/* stream socket */
#define	SOCK_DGRAM	2		/* datagram socket */
#define	SOCK_RAW	3		/* raw-protocol interface */
#define	SOCK_RDM	4		/* reliably-delivered message */
#define	SOCK_SEQPACKET	5		/* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define	SO_DEBUG	0x01		/* turn on debugging info recording */
#define	SO_ACCEPTCONN	0x02		/* socket has had listen() */
#define	SO_REUSEADDR	0x04		/* allow local address reuse */
#define	SO_KEEPALIVE	0x08		/* keep connections alive */
#define	SO_DONTROUTE	0x10		/* just use interface addresses */
#define	SO_BROADCAST	0x20		/* permit sending of broadcast msgs */
#define	SO_USELOOPBACK	0x40		/* bypass hardware when possible */
#define	SO_LINGER	0x80		/* linger on close if data present */
#define SO_OOBINLINE	0x100		/* leave received OOB data in line */

/*
 * Additional options, not kept in so_options.
 */
#define SO_SNDBUF	0x1001		/* send buffer size */
#define SO_RCVBUF	0x1002		/* receive buffer size */
#define SO_SNDLOWAT	0x1003		/* send low-water mark */
#define SO_RCVLOWAT	0x1004		/* receive low-water mark */
#define SO_SNDTIMEO	0x1005		/* send timeout */
#define SO_RCVTIMEO	0x1006		/* receive timeout */
#define SO_ERROR	0x1007		/* get error status and clear */
#define SO_TYPE		0x1008		/* get socket type */

/*
 * Structure used for manipulating linger option.
 */
struct	linger {
	int	l_onoff;		/* option on/off */
	int	l_linger;		/* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define	SOL_SOCKET	0xffff		/* options for socket level */

/*
 * Address families.
 */
#define	AF_UNSPEC	0		/* unspecified */
#define	AF_UNIX		1		/* local to host (pipes, portals) */
#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
#define	AF_IMPLINK	3		/* arpanet imp addresses */
#define	AF_PUP		4		/* pup protocols: e.g. BSP */
#define	AF_CHAOS	5		/* mit CHAOS protocols */
#define	AF_NS		6		/* XEROX NS protocols */
#define	AF_NBS		7		/* nbs protocols */
#define	AF_ECMA		8		/* european computer manufacturers */
#define	AF_DATAKIT	9		/* datakit protocols */
#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
#define	AF_SNA		11		/* IBM SNA */
#define AF_DECnet	12		/* DECnet */
#define AF_DLI		13		/* Direct data link interface */
#define AF_LAT		14		/* LAT */
#define	AF_HYLINK	15		/* NSC Hyperchannel */
#define AF_APPLETALK	16		/* Apple talk */
#define AF_BSC		17		/* BISYNC 2780/3780 */
#define AF_DSS		18		/* Distributed system services */

#define	AF_MAX		19

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	u_short	sa_family;		/* address family */
	char	sa_data[14];		/* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
	u_short	sp_family;		/* address family */
	u_short	sp_protocol;		/* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define	PF_UNSPEC	AF_UNSPEC
#define	PF_UNIX		AF_UNIX
#define	PF_INET		AF_INET
#define	PF_IMPLINK	AF_IMPLINK
#define	PF_PUP		AF_PUP
#define	PF_CHAOS	AF_CHAOS
#define	PF_NS		AF_NS
#define	PF_NBS		AF_NBS
#define	PF_ECMA		AF_ECMA
#define	PF_DATAKIT	AF_DATAKIT
#define	PF_CCITT	AF_CCITT
#define	PF_SNA		AF_SNA
#define PF_DECnet	AF_DECnet
#define PF_DLI		AF_DLI
#define PF_LAT		AF_LAT
#define	PF_HYLINK	AF_HYLINK
#define PF_APPLETALK	AF_APPLETALK
#define PF_BSC		AF_BSC
#define PF_DSS		AF_DSS

#define	PF_MAX		AF_MAX

/*
 * Maximum queue length specifiable by listen.
 */
#define	SOMAXCONN	5

/*
 * I/O buffer element.
 */
struct iovec {
	caddr_t	iov_base;
	int	iov_len;
};

/*
 * Message header for recvmsg and sendmsg calls.
 */
struct msghdr {
	caddr_t	msg_name;		/* optional address */
	int	msg_namelen;		/* size of address */
	struct	iovec *msg_iov;		/* scatter/gather array */
	int	msg_iovlen;		/* # elements in msg_iov */
	caddr_t	msg_accrights;		/* access rights sent/received */
	int	msg_accrightslen;
};

#define	MSG_OOB		0x1		/* process out-of-band data */
#define	MSG_PEEK	0x2		/* peek at incoming message */
#define	MSG_DONTROUTE	0x4		/* send without using routing tables */

#define	MSG_MAXIOVLEN	16

/*  From Ultrix's time.h */
struct timeval {
    long tv_sec;
    long tv_usec;
};

int socket( int af, int mess_type, int prot_type);
int accept( int sd, struct sockaddr *S_addr, int addrlen);
int bind( int sd, struct sockaddr *s_name, int namelen);
int listen( int sd, int backlog);
int connect( int sd, struct sockaddr *name, int namelen);
int send( int sd, char * msg, int length, int flags);
int recvmsg( int sd, struct msghdr *msg, int flags);
int sendmsg( int sd, struct msghdr * msg, int flags);
int sendto( int sd, char * msg, int length, int flags, struct sockaddr *to, int tolen);
int recv( int sd, char * buf, int length, int flags);
int recvfrom( int sd, char * buf, int length, int flags, struct sockaddr *from, int *fromlen);
int shutdown( int sd, int mode);
int select( int nfds, int *readfds, int *writefds, int *exceptfds, struct timeval *timeout);
int gethostname( char *name, int namelen);
int gethostaddr( char *addr);
int getpeername( int sd, struct sockaddr *name, int *namelen);
int getsockname( int sd, struct sockaddr *name, int *namelen);
int getsockopt( int sd, int level, int optname, char *optval, int *optlen);
int setsockopt( int sd, int level, int optname, char *optval, int optlen);
int vaxc$get_sdc( int descrip_no);

#endif					/* __SOCKET_LOADED */
#ifndef __SOR$ROUTINES_LOADED
#define __SOR$ROUTINES_LOADED	1

/*** MODULE sor$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*                                                                          */
/*  SOR$BEGIN_MERGE                                                         */
/*                                                                          */
/*  Initialize a Merge Operation                                            */
/*                                                                          */
/*  Initializes the merge operation by opening the input and output files   */
/*  and by providing the number of input files, the key specifications,     */
/*  and the merge options.                                                  */
/*                                                                          */
unsigned long int sor$begin_merge() ;
/*                                                                          */
/*  SOR$BEGIN_SORT                                                          */
/*                                                                          */
/*  Begin a Sort Operation                                                  */
/*                                                                          */
/*  Initializes a sort operation by opening input and output files and by   */
/*  passing the key information and any sort options.                       */
/*                                                                          */
unsigned long int sor$begin_sort() ;
/*                                                                          */
/*  SOR$DO_MERGE                                                            */
/*                                                                          */
/*  Obsolete (from VMS V3)                                                  */
/*                                                                          */
long int sor$do_merge() ;
/*                                                                          */
/*  SOR$END_SORT                                                            */
/*                                                                          */
/*  End a Sort Operation                                                    */
/*                                                                          */
/*  Does cleanup functions, such as closing files and releasing memory.     */
/*                                                                          */
unsigned long int sor$end_sort() ;
/*                                                                          */
/*  SOR$INIT_MERGE                                                          */
/*                                                                          */
/*  Obsolete (from VMS V3)                                                  */
/*                                                                          */
long int sor$init_merge() ;
/*                                                                          */
/*  SOR$INIT_SORT                                                           */
/*                                                                          */
/*  Obsolete (from VMS V3)                                                  */
/*                                                                          */
long int sor$init_sort() ;
/*                                                                          */
/*  SOR$PASS_FILES                                                          */
/*                                                                          */
/*  Pass File Names                                                         */
/*                                                                          */
/*  Passes the names of input and output files and output file              */
/*  characteristics to SORT or MERGE.                                       */
/*                                                                          */
unsigned long int sor$pass_files() ;
/*                                                                          */
/*  SOR$RELEASE_REC                                                         */
/*                                                                          */
/*  Pass One Record to Sort                                                 */
/*                                                                          */
/*  Used with the record interface to pass one input record to SORT or      */
/*  MERGE.                                                                  */
/*                                                                          */
unsigned long int sor$release_rec() ;
/*                                                                          */
/*  SOR$RETURN_REC                                                          */
/*                                                                          */
/*  Return One Sorted Record                                                */
/*                                                                          */
/*  Used with the record interface to return one sorted or merged           */
/*  record to a program.                                                    */
/*                                                                          */
unsigned long int sor$return_rec() ;
/*                                                                          */
/*  SOR$SORT_MERGE                                                          */
/*                                                                          */
/*  Sort                                                                    */
/*                                                                          */
/*  Sorts the input records.                                                */
/*                                                                          */
unsigned long int sor$sort_merge() ;
/*                                                                          */
/*  SOR$SPEC_FILE                                                           */
/*                                                                          */
/*  Pass a Specification File Name                                          */
/*                                                                          */
/*  Used to pass a specification file or specification text.                */
/*                                                                          */
unsigned long int sor$spec_file() ;
/*                                                                          */
/*  SOR$STAT                                                                */
/*                                                                          */
/*  Obtain Sorting Statistics                                               */
/*                                                                          */
/*  Returns one statistic about the sort or merge operation to the user     */
/*  program.                                                                */
/*                                                                          */
unsigned long int sor$stat() ;

#endif					/* __SOR$ROUTINES_LOADED */
#ifndef __SORDEF_LOADED
#define __SORDEF_LOADED	1

/*** MODULE $sordef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 01:24:44.07 */
/*                                                                          */
/* FILE: SORMSG.MSG EDIT: MH4001                                            */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*++                                                                        */
/*                                                                          */
/* FACILITY:	VAX-11 SORT/MERGE                                           */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS FILE CONTAINS THE DEFINITION FOR THE SORT FACILITY SPECIFIC    */
/*	ERROR MESSAGES.  THE FACILITY CODE FOR SORT/MERGE IS 28.            */
/*                                                                          */
/* ENVIRONMENT:	VAX/VMS USER MODE                                           */
/*                                                                          */
/* AUTHOR: P. GILBERT, CREATION DATE: 15-FEB-1982                           */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*	T03-015		ORIGINAL                                            */
/*	T03-018	CHANGED THE SEVERITY OF WORK_DEV FROM FATAL TO SEVERE.      */
/*		PDG 16-DEC-1982                                             */
/*	T03-019	ADDED OPERFAIL, REQ_ALT AND USE_ALT.  PDG 21-DEC-1982       */
/*	T03-020	ADD NEW MESSAGES FOR ERRORS WITH COLLATING SEQUENCES.       */
/*		PDG 26-JAN-1983                                             */
/*	T03-021	ADDED NEW MESSAGES FOR CDD ERRORS.  PDG 11-FEB-1983         */
/*	T03-022	ADDED ENDDIAGS.  PDG 16-MAR-1983                            */
/*	T03-023	CHANGE TEXT OF COL_PAD.  PDG 20-APR-1983                    */
/*	T03-024	ADDED OPREPLY.  PDG 9-MAY-1983                              */
/*	T04-001 ADDED ODD_LEN.  MH 15-JUL-1985                              */
/*--                                                                        */
/*                                                                          */
/* SOME ERROR MESSAGES WERE ISSUED BY OLD VERSIONS OF VAX-11 SORT/MERGE,    */
/* BUT ARE NO LONGER BE ISSUED.  THESE MUST STILL BE DEFINED.               */
/*                                                                          */
/* SOME ERROR MESSAGES WILL BE USED BY THE NEW VERSION OF VAX-11 SORT/MERGE, */
/* BUT ARE NOT YET ISSUED BY THE CODE.  THESE ARE PREFIXED WITH A "?".      */
/*                                                                          */
#define SORT$_FACILITY 28
#define SOR$_MISS_KEY 1867780
#define SOR$_WORK_DEV 1867786
#define SOR$_NO_WRK 1867794
#define SOR$_VM_FAIL 1867804
#define SOR$_WS_FAIL 1867812
#define SOR$_SORT_ON 1867820
#define SOR$_BAD_KEY 1867828
#define SOR$_NUM_KEY 1867836
#define SOR$_BAD_LEN 1867844
#define SOR$_ONE_IN 1867852
#define SOR$_IND_OVR 1867860
#define SOR$_INCONSIS 1867868
#define SOR$_VAR_FIX 1867872
#define SOR$_BAD_TYPE 1867884
#define SOR$_LRL_MISS 1867892
#define SOR$_BAD_SPEC 1867900
#define SOR$_BAD_LRL 1867906
#define SOR$_BAD_FILE 1867916
#define SOR$_BAD_ADR 1867924
#define SOR$_MAP 1867932
#define SOR$_EXTEND 1867940
#define SOR$_KEY_LEN 1867946
#define SOR$_CLEAN_UP 1867956
#define SOR$_BAD_MERGE 1867962
#define SOR$_BAD_ROUTIN 1867972
#define SOR$_INP_FILES 1867980
#define SOR$_BAD_ORDER 1867984
/*                                                                          */
/* V3B MESSAGES ARE DEFINED BELOW                                           */
/*                                                                          */
#define SOR$_DUP_OUTPUT 1867996
#define SOR$_MISS_PARAM 1868004
#define SOR$_END_SORT 1868009
#define SOR$_KEYED 1868018
#define SOR$_BAD_SRL 1868024
#define SOR$_NODUPEXC 1868036
#define SOR$_DELETE1 1868041
#define SOR$_DELETE2 1868049
#define SOR$_DELBOTH 1868057
#define SOR$_NYI 1868066
#define SOR$_RTNERROR 1868074
#define SOR$_KEYAMBINC 1868084
#define SOR$_OBS_0 1868092
#define SOR$_ROPRAND 1868098
#define SOR$_UNDOPTION 1868108
#define SOR$_STABLEEXC 1868116
#define SOR$_SRTIWA 1868124
#define SOR$_SPCOVR 1868128
#define SOR$_SPCMIS 1868136
#define SOR$_SPCSIS 1868144
#define SOR$_SPCIVP 1868156
#define SOR$_SPCIVS 1868164
#define SOR$_SPCIVC 1868172
#define SOR$_SPCIVF 1868180
#define SOR$_SPCIVD 1868188
#define SOR$_SPCIVX 1868196
#define SOR$_SPCIVK 1868204
#define SOR$_SPCIVI 1868212
#define SOR$_INCNOKEY 1868220
#define SOR$_INCNODATA 1868228
#define SOR$_INVFOLD 1868234
#define SOR$_OPERFAIL 1868244
#define SOR$_REQ_ALT 1868251
#define SOR$_USE_ALT 1868259
#define SOR$_COL_ADJ 1868268
#define SOR$_COL_CMPLX 1868276
#define SOR$_COL_CHAR 1868284
#define SOR$_COL_PAD 1868292
#define SOR$_COL_THREE 1868300
#define SOR$_BADDTYPE 1868306
#define SOR$_BADLENOFF 1868314
#define SOR$_BADOCCURS 1868324
#define SOR$_BADOVRLAY 1868330
#define SOR$_BADPROTCL 1868340
#define SOR$_CDDERROR 1868348
#define SOR$_ILLBASE 1868354
#define SOR$_ILLLITERL 1868364
#define SOR$_ILLSCALE 1868370
#define SOR$_INCDIGITS 1868378
#define SOR$_MISLENOFF 1868384
#define SOR$_MULTIDIM 1868394
#define SOR$_NOTRECORD 1868404
#define SOR$_SIGNCOMPQ 1868408
#define SOR$_UNSUPLEVL 1868420
#define SOR$_ENDDIAGS 1868427
#define SOR$_OPREPLY 1868435
#define SOR$_CHKPNT 1868441
#define SOR$_ODD_LEN 1868452

#endif					/* __SORDEF_LOADED */
#ifndef __SRFDEF_LOADED
#define __SRFDEF_LOADED	1

/*** MODULE $srfdef ***/
/*                                                                          */
/* Symbol reference (SYM$M_DEF in GSY$W_FLAGS is 0)                         */
/*                                                                          */
#define SRF$K_NAME 5
#define SRF$C_NAME 5
struct srfdef {
#pragma nostandard
    variant_union  {
        unsigned char srf$b_gsdtyp;     /*Maps over GSY$B_GSDTYP            */
        variant_struct  {
            char srf$t_start [];
            char srfdef$$_fill_1;
            } srf$r_gsdtyp_fields;
        } srf$r_gsdtyp_overlay;
    unsigned char srf$b_datyp;          /*Maps over GSY$B_DATYP             */
    unsigned short int srf$w_flags;     /*Maps over GSY$W_FLAGS             */
    unsigned char srf$b_namlng;         /*Length of symbol name             */
    char srf$t_name [31];               /*Symbol name                       */
    } ;
 
#pragma standard

#endif					/* __SRFDEF_LOADED */
#ifndef __SRMDEF_LOADED
#define __SRMDEF_LOADED	1

/*** MODULE $srmdef ***/
/*+                                                                         */
/* Define SRM Hardware symbols                                              */
/*-                                                                         */
#define SRM$K_INT_OVF_T 1               /* Integer overflow trap code       */
#define SRM$K_INT_DIV_T 2               /* Integer divide by zero trap code  */
#define SRM$K_FLT_OVF_T 3               /* Floating overflow trap code      */
#define SRM$K_FLT_DIV_T 4               /* Floating/decimal Divide by zero trap code  */
#define SRM$K_FLT_UND_T 5               /* Floating Underflow trap code     */
#define SRM$K_DEC_OVF_T 6               /* Decimal string overflow trap code  */
#define SRM$K_SUB_RNG_T 7               /* Subscript range trap             */
#define SRM$K_FLT_OVF_F 8               /* Floating Overflow fault code     */
#define SRM$K_FLT_DIV_F 9               /* Floating Divide by zero fault code  */
#define SRM$K_FLT_UND_F 10              /* Floating Underflow fault code    */
 

#endif					/* __SRMDEF_LOADED */
#ifndef __SSDEF_LOADED
#define __SSDEF_LOADED	1

/*** MODULE $ssdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 00:50:17.73 */
/*                                                                          */
/* SSMSG.SDL - SYSTEM DEFINITION FILE FOR SYSTEM SERVICE MESSAGES           */
/*                                                                          */
/* VERSION:	'X-25'                                                      */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*++                                                                        */
/*                                                                          */
/* FACILITY:  VAX/VMS SYSTEM MACRO LIBRARIES                                */
/*                                                                          */
/* ABSTRACT:                                                                */
/*                                                                          */
/*	THIS FILE CONTAINS THE SDL SOURCE FOR SYSTEM SERVICE MESSAGES.      */
/*                                                                          */
/* ENVIRONMENT:                                                             */
/*                                                                          */
/*	N/A                                                                 */
/*                                                                          */
/*--                                                                        */
/*                                                                          */
/*                                                                          */
/* AUTHOR:  THE VMS GROUP	 CREATION DATE:  1-AUG-1976                 */
/*                                                                          */
/* MODIFIED BY:                                                             */
/*                                                                          */
/*       X-25    PT00010         PANKAJ TANDON           30-DEC-1987        */
/*               ADD ALLSTARTED,ALRDYSTRT,ALRDYSTPPD AND NSTPPD FOR         */
/*               $START/STOP CPU ERRONEOUS CASES.                           */
/*                                                                          */
/*	X-24	LMP0465		L. MARK PILANT,		28-OCT-1987  15:58  */
/*		ADD A NEW MESSAGE, SS$_NORIGHTSDB, TO INDICATE THAT THERE   */
/*		IS NOT A RIGHTS DATABASE IS NOT PRESENT ON THE SYSTEM.      */
/*                                                                          */
/*	X-23	SJF		STU FARNHAM		5-OCT-1987          */
/*		ADD NOSUCHCPU                                               */
/*                                                                          */
/*	X-22	DLM006		DAN MURPHY		13-SEP-1987         */
/*		INFORMATIONAL CODES FOR $GETSECI.                           */
/*                                                                          */
/*	X-21	WMC0021		WAYNE CARDOZA		4-SEP-1987          */
/*		FIX A MISSPELLING IN VA_IN_USE.                             */
/*                                                                          */
/*	X-20	WMC0020		WAYNE CARDOZA		27-JUL-1987         */
/*		ADD NODELETE.                                               */
/*                                                                          */
/*	X-19	WMC0019		WAYNE CARDOZA		10-MAR-1987         */
/*		EXPRCLM  SHOULD NOT MENTION SUBPROCESSES.                   */
/*                                                                          */
/*	X-18	WMC0018		WAYNE CARDOZA		19-FEB-1987         */
/*		ADD VA_IN_USE.                                              */
/*                                                                          */
/*	X-17	DDP0029		DERRELL D. PIPER	21-JAN-1987         */
/*		CONVERT SS$_BADXXXCTX TO SINGLE BADCONTEXT MSG.             */
/*                                                                          */
/*	X-16	DDP0027		DERRELL D. PIPER	12-JAN-1987         */
/*		ADD SS$_TOOMUCHCTX AND SS$_BADUAICTX.                       */
/*                                                                          */
/*	X-15	HH0237		HAI HUANG		06-JAN-1987         */
/*		ADD SS$_UNSUPPORTED.                                        */
/*                                                                          */
/*	X-14	DDP0008		DERRELL D. PIPER	08-DEC-1986         */
/*		ADD SS$_LASTID, SS$_NOMOREID, SS$_RLSEMPTY, AND             */
/*		SS$_BADJPICTX FOR JPI$_RIGHTSLIST ITEM CODE.                */
/*		(NB: S VARIANT IS NOW OBSOLETE.)                            */
/*                                                                          */
/*	X-9	NCD0001		NANCY C. DENARDO	21-OCT-1986         */
/*		ADDED SS$_EXLICENSE, SS$_INVLICENSE, SS$_LICENSE_LEVEL,     */
/*		AND SS$_INV_HW_ID FOR LMF SERVICE.                          */
/*                                                                          */
/*	X-8     SAS001		SCOTT A. SHURTS		02-OCT-1986         */
/*		ADDED SS$_SRVMMAT TO INDICATE CRYPTOGRAPHIC SERVICE         */
/*		MISMATCH.                                                   */
/*                                                                          */
/*	X-7	KL 0001		KEITH LOEPERE		12-JUN-1986         */
/*		ADDED SS$_REMOVED TO INDICATE DIR ENTRY ONLY REMOVED.       */
/*                                                                          */
/*	X-6	CWH5006		CW HOBBS		30-MAY-1986         */
/*		ADD SS$_REMOTE_PROC ERROR MESSAGE FOR CWPS.                 */
/*                                                                          */
/*	X-5H2	SJF		STU FARNHAM		29-MAY-1986         */
/*		ADD	SS$_CPUNOTACT TO INDICATE THAT THE REQUESTED        */
/*		CPU IN AN SMP SYSTEM IS NOT ACTIVE.                         */
/*                                                                          */
/*	X-5	PRD0184		PAUL R. DESTEFANO	07-NOV-1985         */
/*		ADD SS$_DATALOST "data lost" TO INDICATE DLS END            */
/*		FLAG SET IN CACHING TAPE DRIVE OR DRIVER HAS OTHERWISE      */
/*		DETECTED THE LOSS OF CACHED DATA.                           */
/*                                                                          */
/*	X-4	LMP0382		L. MARK PILANT,		 6-NOV-1985  10:10  */
/*		ADD SS$_OBJLOCKHELD TO INDICATE THAT A PROCESS ALREADY HOLDS */
/*		THE OBJECT'S ACL LOCK.                                      */
/*                                                                          */
/*	X-3	JMK0002		JOSEPH M. KRAETSCH	17-SEP-1985         */
/*		ADD SS$_RUCONFLICT "file has active RUs by another facility". */
/*		REMOVE NOTMPJNL, NOPRMJNL (OBSOLETE).                       */
/*                                                                          */
/*	V04-001	ROW0466		RALPH O. WEBER		11-JUN-1985         */
/*		REPLACE SS$_SHACPYINP (A NO LONGER USED SHADOWING ERROR     */
/*		STATUS) WITH SS$_DEVNOTSHR, "device not currently shareable".   */
/*		SS$_DEVNOTSHR IS AN ERROR STATUE FOR USE WITH DEVICES MARKED  */
/*		FOR EXCLUSIVE ACCESS BY SOMEONE ELSE BY AN MSCP CONTROLLER. */
/*                                                                          */
/*---                                                                       */
/*+                                                                         */
/* SYSTEM STATUS CODES                                                      */
/*                                                                          */
/*	LAYOUT OF MESSAGE SPACE:                                            */
/*                                                                          */
/*	MSG #S	   RANGE      # MSGS	    DESCRIPTION                     */
/*                                                                          */
/*	0-127       0-3FF	128	FATAL ERRORS                        */
/*     128-191	  400-5FF	 64	HARDWARE DEFINED FATAL ERRORS       */
/*     192-255	  600-7FF	 64	SUCCESS CODES                       */
/*     256-383	  800-BFF	128	WARNING CODES                       */
/*     384-447	  C00-DFF	 64	INFORMATIONAL CODES                 */
/*     448-511	  E00-FFF	 64	NONFATAL ERROR CODES                */
/*    512-1023	1000-1FFF	512	SHARED MESSAGES (NOT HERE, SEE SHRMSG) */
/*   1024-1279	2000-27FF	256	FATAL ERRORS (CONTINUED FROM 400)   */
/*   1280-1343	2800-29FF	 64	NO PRIVILEGE ERRORS                 */
/*   1344-1375	2A00-2AFF	 32	EXCEEDED QUOTA ERRORS               */
/*   1376-4031	2B00-7DFF      2656	(UNUSED)                            */
/*   4032-4095   7E00-7FFF        64	RESERVED FOR SCS SYSAPS             */
/*                                                                          */
/*-                                                                         */
/*                                                                          */
/* EXPLICITLY DEFINED SUCESS CODES                                          */
/*                                                                          */
/* DO NOT MIX THESE CODES WITH INCREMENTAL ASSIGNMENTS BELOW                */
/*                                                                          */
#define SYSTEM$_FACILITY 0
#define SS$_NORMAL 1
/*                                                                          */
/* NOTE THAT CONTINUE,WASCLR,WASSET DO NOT HAVE ANY MESSAGE TEXT --         */
/* SINCE THESE CODES USE THE SAME MESSAGE NUMBER AS NORMAL AND ACCVIO,      */
/* THEY CAN NEVER BE MADE TO HAVE MESSAGES ASSOCIATED WITH THEM.            */
/*                                                                          */
#define SS$_CONTINUE 1
#define SS$_WASCLR 1
#define SS$_WASSET 9
/*                                                                          */
/* SEVERE ERRORS (HEX 0-400, 2000-2800)                                     */
/*                                                                          */
#define SS$_ACCVIO 12
#define SS$_BADPARAM 20
#define SS$_EXQUOTA 28
#define SS$_NOPRIV 36
/* MAKE THE ABOVE ERRORS FALL INTO SHORT LITERALS                           */
#define SS$_ABORT 44
#define SS$_BADATTRIB 52
#define SS$_BADESCAPE 60
#define SS$_BADIMGHDR 68
#define SS$_CHANINTLK 76
#define SS$_CTRLERR 84
#define SS$_DATACHECK 92
#define SS$_DEVFOREIGN 100
#define SS$_DEVMOUNT 108
#define SS$_DEVNOTMBX 116
#define SS$_DEVNOTMOUNT 124
#define SS$_DEVOFFLINE 132
#define SS$_DRVERR 140
#define SS$_DUPLNAM 148
#define SS$_FILACCERR 156
#define SS$_FILALRACC 164
#define SS$_FILNOTACC 172
#define SS$_FILNOTEXP 180
#define SS$_FORMAT 188
#define SS$_GPTFULL 196
#define SS$_GSDFULL 204
#define SS$_LCKPAGFUL 212
#define SS$_ILLBLKNUM 220
#define SS$_ILLCNTRFUNC 228
#define SS$_ILLEFC 236
#define SS$_ILLIOFUNC 244
#define SS$_ILLPAGCNT 252
#define SS$_ILLSER 260
#define SS$_INCVOLLABEL 268
#define SS$_INSFARG 276
#define SS$_INSFWSL 284
#define SS$_INSFMEM 292
#define SS$_INSFRAME 300
#define SS$_IVADDR 308
#define SS$_IVCHAN 316
#define SS$_IVDEVNAM 324
#define SS$_IVGSDNAM 332
#define SS$_IVLOGNAM 340
#define SS$_IVLOGTAB 348
#define SS$_IVQUOTAL 356
#define SS$_IVSECFLG 364
#define SS$_IVSSRQ 372
#define SS$_IVSTSFLG 380
#define SS$_IVTIME 388
#define SS$_LENVIO 396
#define SS$_LKWSETFUL 404
#define SS$_MBTOOSML 412
#define SS$_MEDOFL 420
#define SS$_NODATA 428
#define SS$_NOIOCHAN 436
#define SS$_NOLOGNAM 444
#define SS$_NONEXDRV 452
#define SS$_NOTFILEDEV 460
#define SS$_NOTINTBLSZ 468
#define SS$_NOTLABELMT 476
#define SS$_NOTSQDEV 484
#define SS$_PAGOWNVIO 492
#define SS$_PARITY 500
#define SS$_PARTESCAPE 508
#define SS$_PFMBSY 516
#define SS$_PSTFULL 524
#define SS$_RESULTOVF 532
#define SS$_SECTBLFUL 540
#define SS$_TAPEPOSLOST 548
#define SS$_TIMEOUT 556
#define SS$_UNASEFC 564
#define SS$_UNSAFE 572
#define SS$_VASFULL 580
#define SS$_VECINUSE 588
#define SS$_VOLINV 596
#define SS$_WRITLCK 604
#define SS$_NOTAPEOP 612
#define SS$_IVCHNLSEC 620
#define SS$_NOMBX 628
#define SS$_NOLINKS 636
#define SS$_NOSOLICIT 644
#define SS$_NOSUCHNODE 652
#define SS$_REJECT 660
#define SS$_TOOMUCHDATA 668
#define SS$_BUGCHECK 676
#define SS$_FILNOTCNTG 684
#define SS$_BADSTACK 692
#define SS$_MCHECK 700
#define SS$_DEVACTIVE 708
#define SS$_HANGUP 716
#define SS$_OPINCOMPL 724
#define SS$_ILLSEQOP 732
#define SS$_IVSECIDCTL 740
#define SS$_NOTNETDEV 748
#define SS$_IVPROTECT 756
#define SS$_ACPVAFUL 764
#define SS$_MTLBLLONG 772
#define SS$_BUFBYTALI 780
#define SS$_NOAQB 788
#define SS$_WRONGACP 796
#define SS$_BUFNOTALIGN 804
#define SS$_DEVCMDERR 812
#define SS$_DEVREQERR 820
#define SS$_INSFBUFDP 828
#define SS$_INSFMAPREG 836
#define SS$_IVBUFLEN 844
#define SS$_IVMODE 852
#define SS$_MCNOTVALID 860
#define SS$_POWERFAIL 868
#define SS$_SHMGSNOTMAP 876
#define SS$_TOOMANYLNAM 884
#define SS$_SHMNOTCNCT 892
#define SS$_NOTCREATOR 900
#define SS$_INTERLOCK 908
#define SS$_BADQUEUEHDR 916
#define SS$_NOSLOT 924
#define SS$_SUSPENDED 932
#define SS$_EXPORTQUOTA 940
#define SS$_NOSHMBLOCK 948
#define SS$_BADQFILE 956
#define SS$_NOQFILE 964
#define SS$_QFACTIVE 972
#define SS$_QFNOTACT 980
#define SS$_DUPDSKQUOTA 988
#define SS$_NODISKQUOTA 996
#define SS$_EXDISKQUOTA 1004
#define SS$_IDMISMATCH 1012
#define SS$_NOWRT 1020
/* **************                                                           */
/* NOTE:  THE ABOVE SET OF SEVERE ERROR MESSAGES IS FULL!!!!                */
/*	 [VMSLIB.SRC]SHRMSG.MDL HAS USED MESSAGE NUMBERS HEX 1000-2000.     */
/*	 ANY ADDITIONAL SEVERE ERROR MESSAGES MUST BE ADDED                 */
/*	 BELOW, IN THE RANGE HEX 2000-2800.                                 */
/* **************                                                           */
#define SS$_BADISD 8196
#define SS$_RELINK 8204
#define SS$_NOTINSTALL 8212
#define SS$_SHARTOOBIG 8220
#define SS$_NOP1VA 8228
#define SS$_MULTRMS 8236
#define SS$_VECFULL 8244
#define SS$_IVLVEC 8252
#define SS$_INSFSPTS 8260
#define SS$_DISCONNECT 8268
#define SS$_PRIVINSTALL 8276
#define SS$_PROTINSTALL 8284
#define SS$_BADVEC 8292
#define SS$_REMRSRC 8300
#define SS$_PROTOCOL 8308
#define SS$_THIRDPARTY 8316
#define SS$_NOSUCHUSER 8324
#define SS$_SHUT 8332
#define SS$_UNREACHABLE 8340
#define SS$_INVLOGIN 8348
#define SS$_NOSUCHOBJ 8356
#define SS$_EXCPUTIM 8364
#define SS$_OPRABORT 8372
#define SS$_SHRIDMISMAT 8380
#define SS$_COMMHARD 8388
#define SS$_IVCHAR 8396
#define SS$_DEVINACT 8404
#define SS$_CONNECFAIL 8412
#define SS$_LINKABORT 8420
#define SS$_LINKDISCON 8428
#define SS$_LINKEXIT 8436
#define SS$_PATHLOST 8444
#define SS$_CLEARED 8452
#define SS$_RESET 8460
#define SS$_UNSOLICIT 8468
#define SS$_TOOMANYREDS 8476
#define SS$_IVLOCKID 8484
#define SS$_SUBLOCKS 8492
#define SS$_PARNOTGRANT 8500
#define SS$_CVTUNGRANT 8508
#define SS$_FORCEDERROR 8516
#define SS$_ILLSELF 8524
#define SS$_ILLCDTST 8532
#define SS$_NOLISTENER 8540
#define SS$_EXGBLPAGFIL 8548
#define SS$_BADRCT 8556
#define SS$_DIRNOTEMPTY 8564
#define SS$_FORCEDEXIT 8572
#define SS$_NOTPRINTED 8580
#define SS$_JBCERROR 8588
#define SS$_NOLICENSE 8596
#define SS$_VCBROKEN 8604
#define SS$_VCCLOSED 8612
#define SS$_INSFCDT 8620
#define SS$_DEVNOTDISM 8628
#define SS$_NOSHRIMG 8636
#define SS$_DUPUNIT 8644
#define SS$_BADACLCTX 8652
#define SS$_SERIOUSEXCP 8660
#define SS$_TEMPLATEDEV 8668
#define SS$_IVACL 8676
#define SS$_NOSUCHID 8684
#define SS$_NOLCLMEDA 8692
#define SS$_NOREGAVIL 8700
#define SS$_NOREGSUIT 8708
#define SS$_NOSUCHPGM 8716
#define SS$_PGMLDFAIL 8724
#define SS$_PGMSTDALN 8732
#define SS$_IVIDENT 8740
#define SS$_DUPIDENT 8748
#define SS$_INCSEGTRA 8756
#define SS$_NODELEAVE 8764
#define SS$_KERNELINV 8772
#define SS$_EXLNMQUOTA 8780
#define SS$_PARENT_DEL 8788
#define SS$_PARNOTSYS 8796
#define SS$_INSSWAPSPACE 8804
#define SS$_VOLOERR 8812
#define SS$_DATALATE 8820
#define SS$_OVRMAXARG 8828
#define SS$_SHACHASTA 8836
#define SS$_TERMNETDEV 8844
#define SS$_NOLOGTAB 8852
#define SS$_WRONGNAME 8860
#define SS$_NOVOLACC 8868
#define SS$_NOFILACC 8876
#define SS$_INVEXHLIST 8884
#define SS$_NOACLSUPPORT 8892
#define SS$_INVSECLASS 8900
#define SS$_INCSHAMEM 8908
#define SS$_DEVNOTSHR 8916
#define SS$_RUCONFLICT 8924
#define SS$_DATALOST 8932
#define SS$_REMOTE_PROC 8940
#define SS$_CPUNOTACT 8948
#define SS$_SRVMMAT 8956
#define SS$_EXLICENSE 8964
#define SS$_INVLICENSE 8972
#define SS$_LICENSE_LEVEL 8980
#define SS$_INV_HW_ID 8988
#define SS$_BADCONTEXT 8996
#define SS$_TOOMUCHCTX 9004
#define SS$_VA_IN_USE 9012
#define SS$_NODELETE 9020
#define SS$_NOSUCHCPU 9028
/*                                                                          */
/* HARDWARE FATAL EXCEPTION CODES (HEX 400-600)                             */
/*                                                                          */
#define SS$_PLHLDR 1028
#define SS$_ASTFLT 1036
#define SS$_BREAK 1044
#define SS$_CMODSUPR 1052
#define SS$_CMODUSER 1060
#define SS$_COMPAT 1068
#define SS$_OPCCUS 1076
#define SS$_OPCDEC 1084
#define SS$_PAGRDERR 1092
#define SS$_RADRMOD 1100
#define SS$_ROPRAND 1108
#define SS$_SSFAIL 1116
#define SS$_TBIT 1124
#define SS$_DEBUG 1132
/* THE FOLLOWING CODES MUST BE IN ORDER SINCE THEY ARE CALCULATED           */
#define SS$_ARTRES 1140
#define SS$_INTOVF 1148
#define SS$_INTDIV 1156
#define SS$_FLTOVF 1164
#define SS$_FLTDIV 1172
#define SS$_FLTUND 1180
#define SS$_DECOVF 1188
#define SS$_SUBRNG 1196
#define SS$_FLTOVF_F 1204
#define SS$_FLTDIV_F 1212
#define SS$_FLTUND_F 1220
/* THE ABOVE CODES MUST BE IN ORDER SINCE THEY ARE CALCULATED               */
#define SS$_INHCHMK 1228
#define SS$_INHCHME 1236
/*                                                                          */
/* SUCCESS CODES (HEX 600-800)                                              */
/*                                                                          */
#define SS$_BUFFEROVF 1537
#define SS$_CONTROLO 1545
#define SS$_CONTROLY 1553
#define SS$_CREATED 1561
#define SS$_MSGNOTFND 1569
#define SS$_NOTRAN 1577
#define SS$_SUPERSEDE 1585
#define SS$_WASECC 1593
#define SS$_DEVALRALLOC 1601
#define SS$_REMOTE 1609
#define SS$_CONTROLC 1617
#define SS$_NOTMODIFIED 1625
#define SS$_RDDELDATA 1633
#define SS$_OVRDSKQUOTA 1641
#define SS$_SYSVERDIF 1649
#define SS$_FILEPURGED 1657
#define SS$_NOTALLPRIV 1665
#define SS$_SYNCH 1673
#define SS$_CONCEALED 1681
#define SS$_INCOMPAT 1689
#define SS$_DBGOPCREQ 1697
#define SS$_ALRDYCLOSED 1705
#define SS$_LNMCREATED 1713
#define SS$_ACEIDMATCH 1721
#define SS$_DBGEVENT 1729
#define SS$_REMOVED 1737
#define SS$_LASTID 1745
#define SS$_NOMOREID 1753
/*                                                                          */
/* WARNING CODES (HEX 800-C00)                                              */
/*                                                                          */
#define SS$_ACCONFLICT 2048
#define SS$_BADCHKSUM 2056
#define SS$_BADFILEHDR 2064
#define SS$_BADFILENAME 2072
#define SS$_BADFILEVER 2080
#define SS$_BADIRECTORY 2088
#define SS$_CANCEL 2096
#define SS$_DATAOVERUN 2104
#define SS$_DEVALLOC 2112
#define SS$_DEVASSIGN 2120
#define SS$_DEVICEFULL 2128
#define SS$_DEVNOTALLOC 2136
#define SS$_DIRFULL 2144
#define SS$_DUPFILENAME 2152
#define SS$_ENDOFFILE 2160
#define SS$_ENDOFTAPE 2168
#define SS$_EXTIDXFILE 2176
#define SS$_FCPREADERR 2184
#define SS$_FCPREWNDERR 2192
#define SS$_FCPSPACERR 2200
#define SS$_FCPWRITERR 2208
#define SS$_FILELOCKED 2216
#define SS$_FILENUMCHK 2224
#define SS$_FILESEQCHK 2232
#define SS$_FILESTRUCT 2240
#define SS$_HEADERFULL 2248
#define SS$_IDXFILEFULL 2256
#define SS$_MBFULL 2264
#define SS$_NOHOMEBLK 2272
#define SS$_NONEXPR 2280
#define SS$_NONLOCAL 2288
#define SS$_NOHANDLER 2296
#define SS$_NOSIGNAL 2304
#define SS$_NOSUCHDEV 2312
#define SS$_NOSUCHFILE 2320
#define SS$_RESIGNAL 2328
#define SS$_UNWIND 2336
#define SS$_UNWINDING 2344
#define SS$_NOMOREFILES 2352
#define SS$_BEGOFFILE 2360
#define SS$_BLOCKCNTERR 2368
#define SS$_MUSTCLOSEFL 2376
#define SS$_WAITUSRLBL 2384
#define SS$_ILLUSRLBLRD 2392
#define SS$_ILLUSRLBLWT 2400
#define SS$_ILLLBLAST 2408
#define SS$_ENDOFUSRLBL 2416
#define SS$_NOSUCHSEC 2424
#define SS$_CLIFRCEXT 2432
#define SS$_FCPREPSTN 2440
#define SS$_TOOMANYVER 2448
#define SS$_NOTVOLSET 2456
#define SS$_ENDOFVOLUME 2464
#define SS$_NOMOREPROC 2472
#define SS$_NODEVAVL 2480
#define SS$_NOTQUEUED 2488
#define SS$_DGQINCOMP 2496
#define SS$_DIRALLOC 2504
#define SS$_ACLEMPTY 2512
#define SS$_NOENTRY 2520
#define SS$_NOMOREACE 2528
#define SS$_RIGHTSFULL 2536
#define SS$_VALNOTVALID 2544
#define SS$_ACLFULL 2552
#define SS$_NOMORENODE 2560
#define SS$_NOMORELOCK 2568
#define SS$_BEGOFTAPE 2576
#define SS$_OBJLOCKHELD 2584
#define SS$_RLSEMPTY 2592
#define SS$_ALLSTARTED 2600
#define SS$_ALRDYSTRT 2608
#define SS$_ALRDYSTPPD 2616
#define SS$_NSTPPD 2624
/*                                                                          */
/* INFORMATIONAL CODES (HEX C00-E00)                                        */
/*                                                                          */
#define SS$_EOTIN 3075
#define SS$_CHAINW 3083
#define SS$_NOTINSEC 3091
#define SS$_NONXPAG 3099
/*                                                                          */
/* NONFATAL ERROR CODES (HEX E00-1000)                                      */
/*                                                                          */
#define SS$_LINEABRT 3586
#define SS$_DEADLOCK 3594
#define SS$_NOLOCKID 3602
#define SS$_EXDEPTH 3610
#define SS$_PARTMAPPED 3618
#define SS$_CANCELGRANT 3626
#define SS$_RETRY 3634
#define SS$_BADACL 3642
#define SS$_ACEEXISTS 3650
#define SS$_UNSUPPORTED 3658
#define SS$_NORIGHTSDB 3666             /*                                  */
/* NO PRIVILEGE FATAL ERROR CODES (HEX 2800-2A00)                           */
/*                                                                          */
#define SS$_NOPRIVSTRT 10240
#define SS$_NOCMKRNL 10244
#define SS$_NOCMEXEC 10252
#define SS$_NOSYSNAM 10260
#define SS$_NOGRPNAM 10268
#define SS$_NOALLSPOOL 10276
#define SS$_NODETACH 10284
#define SS$_NODIAGNOSE 10292
#define SS$_NOLOG_IO 10300
#define SS$_NOGROUP 10308
#define SS$_NOACNT 10316
#define SS$_NOPRMCEB 10324
#define SS$_NOPRMMBX 10332
#define SS$_NOPSWAPM 10340
#define SS$_NOALTPRI 10348
#define SS$_NOSETPRV 10356
#define SS$_NOTMPMBX 10364
#define SS$_NOWORLD 10372
#define SS$_NOMOUNT 10380
#define SS$_NOOPER 10388
#define SS$_NOEXQUOTA 10396
#define SS$_NONETMBX 10404
#define SS$_NOVOLPRO 10412
#define SS$_NOPHY_IO 10420
#define SS$_NOBUGCHK 10428
#define SS$_NOPRMGBL 10436
#define SS$_NOSYSGBL 10444
#define SS$_NOPFNMAP 10452
#define SS$_NOSHMEM 10460
#define SS$_NOSYSPRV 10468
#define SS$_NOBYPASS 10476
#define SS$_NOSYSLCK 10484
#define SS$_UNUSED_1 10492
#define SS$_UNUSED_2 10500
#define SS$_NODOWNGRADE 10508
#define SS$_NOUPGRADE 10516
#define SS$_NOGRPPRV 10524
#define SS$_NOREADALL 10532
#define SS$_NOSHARE 10540
#define SS$_NOSECURITY 10548
#define SS$_NOPRIVEND 10751
/*                                                                          */
/* EXCEEDED QUOTA FATAL ERROR CODES (HEX 2A00-2B00)                         */
/*                                                                          */
#define SS$_EXQUOTASTRT 10752
#define SS$_EXASTLM 10756
#define SS$_EXBIOLM 10764
#define SS$_EXBYTLM 10772
#define SS$_EXDIOLM 10780
#define SS$_EXFILLM 10788
#define SS$_EXPGFLQUOTA 10796
#define SS$_EXPRCLM 10804
#define SS$_EXTQELM 10812
#define SS$_EXENQLM 10820
#define SS$_EXQUOTAEND 11007
/*                                                                          */
/* RESERVED FOR SCA SYSAPS (HEX 7E00-7FFF)                                  */
/*                                                                          */
/*	MESSAGE CODES IN THIS BLOCK ARE GUARANTEED NOT TO                   */
/*	BE TRANSLATED BY VMS WHEN THEY ARE SEND OUT BY VMSSCS               */
/*	OR WHEN THEY ARE RECEIVED BY VMSSCS.  SCA SYSAPS ARE                */
/*	FREE TO USE THESE CODES IN ANY SYSAP-DEPENDENT MANNER               */
/*	IN WHICH THEY CHOOSE.                                               */
/*                                                                          */
/*	THIS ADDRESS OF THIS BLOCK OF CODES MUST BE IN CONFORMANCE          */
/*	WITH THE SCA ARCHITECTURE, I.E., MUST NOT BE MOVED.                 */
/*                                                                          */
#define SS$_SYSAPMIN 32256
#define SS$_SYSAPMAX 32767

#endif					/* __SSDEF_LOADED */
#ifndef __STARLET_LOADED
#define __STARLET_LOADED	1

/*** MODULE starlet ***/
/*                                                                          */
/* SYSTEM SERVICE ENTRY POINT DESCRIPTIONS                                  */
/*                                                                          */
/*                                                                          */
/*  $ADD_HOLDER                                                             */
/*                                                                          */
/*    Add Holder Record To The Rights Database                              */
/*                                                                          */
/*	$ADD_HOLDER id, holder, [attrib]                                    */
/*                                                                          */
/*	id	= identifier longword to associate the                      */
/*		  holder record with                                        */
/*	holder	= address of the holder identifier quadword                 */
/*	attrib	= attributes longword to grant to the holder                */
/*                                                                          */
long int sys$add_holder() ;
/*                                                                          */
/*  $ADD_IDENT                                                              */
/*                                                                          */
/*    Add Identifier To The Rights Database                                 */
/*                                                                          */
/*	$ADD_IDENT name, [id], [attrib], [resid]                            */
/*                                                                          */
/*	name	= address of the identifier name character                  */
/*		  string descriptor                                         */
/*	id	= identifier longword to associate with 'name'              */
/*	attrib	= attributes longword to grant to the                       */
/*		  identifier                                                */
/*	resid	= address of a longword to return the assigned              */
/*		  identifier                                                */
/*                                                                          */
long int sys$add_ident() ;
/*                                                                          */
/*  $ADJSTK                                                                 */
/*                                                                          */
/*    Adjust Outer Mode Stack Pointer                                       */
/*                                                                          */
/*      $ADJSTK [acmode] ,[adjust] ,newadr                                  */
/*                                                                          */
/*      acmode = access mode for which to adjust stack pointer              */
/*      adjust = 16-bit signed adjustment value                             */
/*      newadr = address of longword to store updated value                 */
/*                                                                          */
long int sys$adjstk() ;
/*                                                                          */
/*  $ADJWSL                                                                 */
/*                                                                          */
/*    Adjust Working Set Limit                                              */
/*                                                                          */
/*      $ADJWSL [pagcnt] ,[wsetlm]                                          */
/*                                                                          */
/*      pagcnt = number of pages to add to working set (if  positive).      */
/*               Number  of  pages  to  subtract  from working set (if      */
/*               negative).                                                 */
/*      wsetlm = address of longword to receive new working set limit,      */
/*               or current working set limit if pagcnt not specified.      */
/*                                                                          */
long int sys$adjwsl() ;
/*                                                                          */
/*  $ALLOC                                                                  */
/*                                                                          */
/*    Allocate Device                                                       */
/*                                                                          */
/*      $ALLOC devnam ,[phylen] ,[phybuf] ,[acmode] ,[flags]                */
/*                                                                          */
/*      devnam = address  of  device  name  or  logical  name   string      */
/*               descriptor                                                 */
/*      phylen = address of word to receive length of physical name         */
/*      phybuf = address of physical name buffer descriptor                 */
/*      acmode = access mode associated with allocated device               */
/*	flags  = options flags longword                                     */
/*                                                                          */
long int sys$alloc() ;
/*                                                                          */
/*  $ASCEFC                                                                 */
/*                                                                          */
/*    Associate Common Event Flag Cluster                                   */
/*                                                                          */
/*      $ASCEFC  efn ,name ,[prot] ,[perm]                                  */
/*                                                                          */
/*      efn    = number of any event flag in the cluster with which to      */
/*               associate                                                  */
/*      name   = address of the text name string descriptor                 */
/*      prot   = protection indicator for the cluster                       */
/*               0 -> default, any process in group                         */
/*               1 -> only owner's UIC                                      */
/*      perm   = permanent indicator                                        */
/*               0 -> temporary cluster                                     */
/*               1 -> permanent cluster                                     */
/*                                                                          */
long int sys$ascefc() ;
/*                                                                          */
/*  $ASCTIM                                                                 */
/*                                                                          */
/*    Convert Binary Time to ASCII String                                   */
/*                                                                          */
/*      $ASCTIM  [timlen] ,timbuf ,[timadr] ,[cvtflg]                       */
/*                                                                          */
/*      timlen = address of a word to receive the number of characters      */
/*               inserted into the output buffer.                           */
/*      timbuf = address  of a  character string descriptor describing      */
/*               the buffer to receive the converted time.                  */
/*      timadr = address of the quadword containing the 64-bit time to      */
/*               be converted to ASCII.  If 0, use current time.            */
/*      cvtflg = conversion indicator                                       */
/*               0 -> return full date and time                             */
/*               1 -> return converted time only                            */
/*                                                                          */
long int sys$asctim() ;
/*                                                                          */
/*  $ASCTOID                                                                */
/*                                                                          */
/*    Ascii To Identifier Conversion                                        */
/*                                                                          */
/*	$ASCTOID name, [id], [attrib]                                       */
/*                                                                          */
/*	name	= address of the identifier name character                  */
/*		  string descriptor to be converted                         */
/*	id	= address to return the identifier longword                 */
/*	attrib	= address to return the attributes longword                 */
/*                                                                          */
long int sys$asctoid() ;
/*                                                                          */
/*  $ASSIGN                                                                 */
/*                                                                          */
/*    Assign I/O Channel                                                    */
/*                                                                          */
/*      $ASSIGN  devnam ,chan ,[acmode]  ,[mbxnam]                          */
/*                                                                          */
/*      devnam = address  of  device  name  or  logical  name   string      */
/*               descriptor                                                 */
/*      chan   = address of word to receive channel number assigned         */
/*      acmode = access mode associated with channel                        */
/*      mbxnam = address of mailbox logical name string descriptor, if      */
/*               mailbox associated with device                             */
/*                                                                          */
long int sys$assign() ;
/*                                                                          */
/*  $BINTIM                                                                 */
/*                                                                          */
/*    Convert ASCII String to Binary Time                                   */
/*                                                                          */
/*      $BINTIM  timbuf ,timadr                                             */
/*                                                                          */
/*      timbuf = address of string descriptor for ASCII time string         */
/*      timadr = address of quadword to  receive  64-bit  binary  time      */
/*               value                                                      */
/*                                                                          */
/*          Absolute time strings are specified in the format:              */
/*               dd-mmm-yyyy hh:mm:ss.cc                                    */
/*          Delta time strings are specified in the format:                 */
/*               dddd hh:mm:ss.cc                                           */
/*                                                                          */
long int sys$bintim() ;
/*                                                                          */
/*  $BRDCST                                                                 */
/*                                                                          */
/*    Broadcast                                                             */
/*                                                                          */
/*      $BRDCST  msgbuf ,[devnam]                                           */
/*                                                                          */
/*      msgbuf   = address of message buffer string descriptor              */
/*      devnam   = terminal device name string descriptor.  If 0, send      */
/*                 message   to  all  terminals.   If  first  word  in      */
/*                 descriptor is 0,  send  message  to  all  allocated      */
/*                 terminals.                                               */
/*                                                                          */
long int sys$brdcst() ;
/*  $BRKTHRU                                                                */
/*                                                                          */
/*    Write to terminal breakthru                                           */
/*                                                                          */
/*     $BRKTHRU     [efn] ,msgbuf, [sendto], [sndtyp], [iosb],              */
/*	($BRKTHRUW) [carcon], [flags], [reqid], [timout],                   */
/*		    [astadr], [astprm]                                      */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     msgbuf = address of message buffer descriptor                        */
/*                                                                          */
/*     sendto = address of send address descriptor                          */
/*                                                                          */
/*     sndtyp = value to describe sendto                                    */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     carcon = carriage control                                            */
/*                                                                          */
/*     flags = flags to modify broadcast                                    */
/*                                                                          */
/*     reqid = broadcast class requestor id                                 */
/*                                                                          */
/*     timout = address of timeout value                                    */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine as an argument            */
/*                                                                          */
/*                                                                          */
long int sys$brkthru() ;
long int sys$brkthruw() ;
/*                                                                          */
/*  $CANCEL                                                                 */
/*                                                                          */
/*    Cancel I/O on Channel                                                 */
/*                                                                          */
/*      $CANCEL  chan                                                       */
/*                                                                          */
/*      chan   = number of the channel on which I/O is to be canceled       */
/*                                                                          */
long int sys$cancel() ;
/*                                                                          */
/*  $CANEXH                                                                 */
/*                                                                          */
/*    Cancel Exit Handler                                                   */
/*                                                                          */
/*      $CANEXH  [desblk]                                                   */
/*                                                                          */
/*      desblk = address of exit control block describing exit handler      */
/*               to be deleted.  If 0, delete all.                          */
/*                                                                          */
long int sys$canexh() ;
/*                                                                          */
/*  $CANTIM                                                                 */
/*                                                                          */
/*    Cancel Timer Request                                                  */
/*                                                                          */
/*      $CANTIM  [reqidt] ,[acmode]                                         */
/*                                                                          */
/*      reqidt = request identification for request  to  be  canceled.      */
/*               If 0, all requests canceled.                               */
/*      acmode = access mode of requests to be canceled                     */
/*                                                                          */
long int sys$cantim() ;
/*                                                                          */
/*  $CANWAK                                                                 */
/*                                                                          */
/*    Cancel Wakeup                                                         */
/*                                                                          */
/*      $CANWAK  [pidadr] ,[prcnam]                                         */
/*                                                                          */
/*      pidadr = address of  process  identification  of  process  for      */
/*               which wakeups are to be canceled                           */
/*      prcnam = address of process name string descriptor                  */
/*                                                                          */
long int sys$canwak() ;
/*  $CHANGE_ACL                                                             */
/*                                                                          */
/*    Set or modify an object's ACL                                         */
/*                                                                          */
/*	$CHANGE_ACL	[chan], objtyp, [objnam],                           */
/*			itmlst, [acmode], [iosb],                           */
/*			[contxt] , [routin], [orbadr]                       */
/*                                                                          */
/*	chan   = number of a channel assigned to the object or              */
/* 		 0 if object is specified by the objnam parameter           */
/*                                                                          */
/*	objtyp = address of an object type code                             */
/*                                                                          */
/*	objnam = address of object name                                     */
/*                                                                          */
/*	itmlst = address of a list of item descriptors                      */
/*                                                                          */
/*	acmode = address of a byte containing the access mode in            */
/*		 which the arguments will be validated                      */
/*                                                                          */
/*	iosb   = address of a quadword I/O status block                     */
/*                                                                          */
/*	contxt = address of a context long word (used for iterative         */
/*		 calls or a multi-entry item list)                          */
/*                                                                          */
/*	routin = address of routine to be executed in kernel mode           */
/*		 (obsolete)                                                 */
/*                                                                          */
/*	orbadr = address of a user supplied ORB                             */
/*                                                                          */
long int sys$change_acl() ;
/*  $CHANGE_CLASS	objtyp, [objnam], itmlst                            */
/*			[acmode], [orbadr]                                  */
/*                                                                          */
/*    Modify an objects access class                                        */
/*                                                                          */
/*     objtyp = address of an object type code                              */
/*                                                                          */
/*     objnam = address of an object name descriptor                        */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     acmode = address of a byte containing the access mode in             */
/*		which the arguments will be validated                       */
/*                                                                          */
/*     orbadr = address of routine to be executed in kernel mode            */
/*                                                                          */
/*                                                                          */
long int sys$change_class() ;
/*  $CHECK_ACCESS                                                           */
/*                                                                          */
/*    Check User Access to an Object                                        */
/*                                                                          */
/*     objtyp = address of an object type code                              */
/*                                                                          */
/*     objnam = address of an object name descriptor                        */
/*                                                                          */
/*     usrnam = address of a user name descriptor                           */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     orbadr = address of a user supplied ORB                              */
/*                                                                          */
long int sys$check_access() ;
/*                                                                          */
/*  $CHKPRO                                                                 */
/*                                                                          */
/*	Check Access Protection                                             */
/*                                                                          */
/*      $CHKPRO itmlst                                                      */
/*                                                                          */
/*	itmlst = address of a list of item descriptors                      */
/*                                                                          */
long int sys$chkpro() ;
/*                                                                          */
/*  $CLREF                                                                  */
/*                                                                          */
/*    Clear Event Flag                                                      */
/*                                                                          */
/*      $CLREF efn                                                          */
/*                                                                          */
/*      efn    = number of event flag to be cleared                         */
/*                                                                          */
long int sys$clref() ;
/*                                                                          */
/*  $CLOSE                                                                  */
/*                                                                          */
/*    Close File                                                            */
/*                                                                          */
/*      $CLOSE fab, [err], [suc]                                            */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$close() ;
/*                                                                          */
/*  $CMEXEC                                                                 */
/*                                                                          */
/*    Change to Executive Mode                                              */
/*                                                                          */
/*      $CMEXEC  routin ,[arglst]                                           */
/*                                                                          */
/*      routin = address of the routine to be  executed  in  executive      */
/*               mode                                                       */
/*      arglst = address of  argument  list  to  be  supplied  to  the      */
/*               routine                                                    */
/*                                                                          */
long int sys$cmexec() ;
/*  $CMKRNL                                                                 */
/*                                                                          */
/*    Change to Kernel Mode                                                 */
/*                                                                          */
/*     $CMKRNL  routin ,[arglst]                                            */
/*                                                                          */
/*     routin = address of routine to be executed in kernel mode            */
/*                                                                          */
/*     arglst = address of argument list to be supplied to routine          */
/*                                                                          */
long int sys$cmkrnl() ;
/*                                                                          */
/*  $CONNECT                                                                */
/*                                                                          */
/*    Connect File                                                          */
/*                                                                          */
/*      $CONNECT rab, [err], [suc]                                          */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$connect() ;
/*  $CNTREG                                                                 */
/*                                                                          */
/*    Contract Program/Control Region                                       */
/*                                                                          */
/*     $CNTREG  pagcnt ,[retadr] ,[acmode] ,[region]                        */
/*                                                                          */
/*     pagcnt = number of pages to be deleted from end of region            */
/*                                                                          */
/*     retadr = address  of  2-longword  array  to  receive   virtual       */
/*	     addresses of starting and ending page of deleted area          */
/*                                                                          */
/*     acmode = access mode for which service is performed                  */
/*                                                                          */
/*     region = region indicator                                            */
/*      0 -> program (P0) region   1 -> control (P1) region                 */
/*                                                                          */
long int sys$cntreg() ;
/*                                                                          */
/*  $CREATE                                                                 */
/*                                                                          */
/*    Create File                                                           */
/*                                                                          */
/*      $CREATE fab, [err], [suc]                                           */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$create() ;
/*                                                                          */
/*  $CREATE_RDB                                                             */
/*                                                                          */
/*    Create The Rights Database                                            */
/*                                                                          */
/*	$CREATE_RDB [sysid]                                                 */
/*                                                                          */
/*	sysid	= address of the quadword system identifier                 */
/*		  to store in the maintenance record                        */
/*                                                                          */
long int sys$create_rdb() ;
/*  $CRELNM                                                                 */
/*                                                                          */
/*    Create Logical Name                                                   */
/*                                                                          */
/*     $CRELNM  [attr], tabnam, lognam, [acmode], [itemlist]                */
/*                                                                          */
/*     attr = address of logical name attributes                            */
/*                                                                          */
/*	Attribute	Meaning                                             */
/*	LNM$M_CONFINE   Logical name not to be copied into sub-process      */
/*	LNM$M_NO_ALIAS  Logical name can not be aliased                     */
/*	LNM$M_CRELOG	Logical name created using $CRELOG                  */
/*                                                                          */
/*     tabnam = address of logical name table string descriptor             */
/*                                                                          */
/*     lognam = address of logical name string descriptor                   */
/*                                                                          */
/*     acmode = address of access mode for logical name                     */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
long int sys$crelnm() ;
/*  $CRELNT                                                                 */
/*                                                                          */
/*    Create Logical Name Table                                             */
/*                                                                          */
/*     $CRELNT  [attr], [resnam], [reslen], [quota],                        */
/*	        [promsk], [tabnam], [acmode], [partab]                      */
/*                                                                          */
/*     attr = address of logical name table attributes                      */
/*                                                                          */
/*     resnam = address of descriptor of a buffer to receive the            */
/*		    created table's name                                    */
/*                                                                          */
/*     reslen = address of word to recieve length of created table's        */
/*		    name                                                    */
/*                                                                          */
/*     quota = address of quota associated with logical name table          */
/*                                                                          */
/*     promsk = address of protection mask                                  */
/*                                                                          */
/*     tabnam = address of descriptor of logical name table name to be created  */
/*                                                                          */
/*     partab = address of name of table parent string descriptor           */
/*                                                                          */
/*     acmode = address of access mode for logical name                     */
/*                                                                          */
long int sys$crelnt() ;
/*  $CRELOG                                                                 */
/*                                                                          */
/*    Create Logical Name                                                   */
/*                                                                          */
/*     $CRELOG  [tblflg] ,lognam ,eqlnam ,[acmode]                          */
/*                                                                          */
/*     tblflg = logical name table number                                   */
/*       0 -> system (default)   1 -> group    2 -> process                 */
/*                                                                          */
/*     lognam = address of logical name string descriptor                   */
/*                                                                          */
/*     eqlnam = address of equivalence name string descriptor               */
/*                                                                          */
/*     acmode = access mode for logical name (process table only)           */
/*                                                                          */
long int sys$crelog() ;
/*  $CREMBX                                                                 */
/*                                                                          */
/*    Create Mailbox and Assign Channel                                     */
/*                                                                          */
/*     $CREMBX  [prmflg] ,chan ,[maxmsg] ,[bufquo] ,[promsk] ,[acmode] ,[lognam] */
/*                                                                          */
/*     prmflg = permanent flag                                              */
/*       0 -> temporary (default)   1 -> permanent                          */
/*                                                                          */
/*     chan   = address of word to receive channel                          */
/*                                                                          */
/*     maxmsg = maximum message size that may be received                   */
/*                                                                          */
/*     bufquo = number of bytes that can be used to buffer messages         */
/*                                                                          */
/*     promsk = protection mask                                             */
/*                                                                          */
/*     acmode = access mode of created mailbox                              */
/*                                                                          */
/*     lognam = address of logical name string descriptor for mailbox       */
/*                                                                          */
long int sys$crembx() ;
/*  $CREPRC                                                                 */
/*                                                                          */
/*    Create Process                                                        */
/*                                                                          */
/*     $CREPRC  [pidadr] ,[image] ,[input] ,[output] ,[error] ,[prvadr]     */
/*     ,[quota] ,[prcnam] ,[baspri] ,[uic] ,[mbxunt] ,[stsflg] ,[itmlst]    */
/*                                                                          */
/*     pidadr = address of longword to return id of created process         */
/*                                                                          */
/*     image  = address of string descriptor for image name                 */
/*                                                                          */
/*     input  = address of string descriptor for SYS$INPUT                  */
/*                                                                          */
/*     output = address of string descriptor for SYS$OUTPUT                 */
/*                                                                          */
/*     error  = address of string descriptor for SYS$ERROR                  */
/*                                                                          */
/*     prvadr = address of quadword privilege list                          */
/*                                                                          */
/*     quota  = address of quota list                                       */
/*                                                                          */
/*     prcnam = address of string descriptor for process name               */
/*                                                                          */
/*     baspri = base priority (0-31)                                        */
/*                                                                          */
/*     uic    = user identification code.  If 0, create a subprocess        */
/*                                                                          */
/*     mbxunt = mailbox unit for termination message                        */
/*                                                                          */
/*     stsflg = status and mode flag bits                                   */
/*                                                                          */
/*          Bit  Meaning                                                    */
/*                                                                          */
/*           0   disable resource wait mode                                 */
/*	     1   enable system service failure exception mode               */
/*	     2   inhibit process swapping                                   */
/*           3   disable accounting messages                                */
/*           4   batch process                                              */
/*           5   cause created process to hibernate                         */
/*           6   allow login without authorization file check               */
/*           7   process is a network connect object                        */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
long int sys$creprc() ;
/*  $CRETVA                                                                 */
/*                                                                          */
/*    Create Virtual Address Space                                          */
/*                                                                          */
/*     $CRETVA  inadr ,[retadr] ,[acmode]                                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing  starting  and       */
/*              ending virtual address of pages to be created               */
/*                                                                          */
/*     retadr = address of a 2-longword array to receive starting and       */
/*              ending virtual address of pages actually created            */
/*                                                                          */
/*     acmode = access  mode  for  the  new  pages   (protection   is       */
/*              read/write for acmode and more privileged modes)            */
/*                                                                          */
long int sys$cretva() ;
/*  $CRMPSC                                                                 */
/*                                                                          */
/*    Create and Map Section                                                */
/*                                                                          */
/*     $CRMPSC  [inadr] ,[retadr] ,[acmode] ,[flags] ,[gsdnam] ,[ident]     */
/*              ,[relpag] ,[chan] ,[pagcnt] ,[vbn] ,[prot] ,[pfc]           */
/*                                                                          */
/*     inadr  = address of 2-longword array containing  starting  and       */
/*              ending virtual addresses of space to map section            */
/*                                                                          */
/*     retadr = address of  2-longword  array  to  receive  addresses       */
/*              actually mapped                                             */
/*                                                                          */
/*     acmode = access mode of owner of pages                               */
/*                                                                          */
/*     flags  = section characteristics                                     */
/*                                                                          */
/*       Flag         Meaning                                               */
/*                                                                          */
/*       SEC$M_GBL    Global section                                        */
/*       SEC$M_CRF    Copy-on-reference pages                               */
/*       SEC$M_DZRO   Demand zero pages                                     */
/*       SEC$M_EXPREG Find first available space                            */
/*       SEC$M_PERM   Permanent section                                     */
/*       SEC$M_PFNMAP Physical page frame section                           */
/*       SEC$M_SYSGBL System global section                                 */
/*       SEC$M_WRT    Read/write section                                    */
/*                                                                          */
/*     gsdnam = address of global section name string descriptor            */
/*                                                                          */
/*     ident  = address of quadword containing version id and match control */
/*                                                                          */
/*     relpag = relative page number within section                         */
/*                                                                          */
/*     chan   = number of channel on which file is accessed                 */
/*                                                                          */
/*     pagcnt = number of pages in section                                  */
/*                                                                          */
/*     vbn    = virtual block  number  of  beginning  of  section  or       */
/*              physical page frame number of beginning of section          */
/*                                                                          */
/*     prot   = protection mask                                             */
/*                                                                          */
/*     pfc    = page fault cluster size                                     */
/*                                                                          */
long int sys$crmpsc() ;
/*  $DACEFC                                                                 */
/*                                                                          */
/*    Disassociate Common Event Flag Cluster                                */
/*                                                                          */
/*     $DACEFC  efn                                                         */
/*                                                                          */
/*     efn    = number of any event flag in the cluster                     */
/*                                                                          */
long int sys$dacefc() ;
/*  $DALLOC                                                                 */
/*                                                                          */
/*    Deallocate Device                                                     */
/*                                                                          */
/*     $DALLOC  [devnam] ,[acmode]                                          */
/*                                                                          */
/*     devnam = address of device name descriptor.  If 0, deallocate all    */
/*                                                                          */
/*     acmode = access mode associated with device                          */
/*                                                                          */
long int sys$dalloc() ;
/*  $DASSGN                                                                 */
/*                                                                          */
/*    Deassign I/O Channel                                                  */
/*                                                                          */
/*     $DASSGN  chan                                                        */
/*                                                                          */
/*     chan   = number of channel to be deassigned                          */
/*                                                                          */
long int sys$dassgn() ;
/*  $DCLAST                                                                 */
/*                                                                          */
/*    Declare AST                                                           */
/*                                                                          */
/*     $DCLAST  astadr ,[astprm] ,[acmode]                                  */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine                           */
/*                                                                          */
/*     acmode = access mode for which the AST is to be declared             */
/*                                                                          */
long int sys$dclast() ;
/*  $DCLCMH                                                                 */
/*                                                                          */
/*    Declare Change Mode or Compatibility Mode Handler                     */
/*                                                                          */
/*     $DCLCMH  addres ,[prvhnd] ,[type]                                    */
/*                                                                          */
/*     addres = address of handler                                          */
/*                                                                          */
/*     prvhnd = address of longword to receive previous handler address     */
/*                                                                          */
/*     type   = handler type indicator                                      */
/*               0 -> change mode (current mode)   1 -> compatibility mode  */
/*                                                                          */
long int sys$dclcmh() ;
/*  $DCLEXH                                                                 */
/*                                                                          */
/*    Declare Exit Handler                                                  */
/*                                                                          */
/*     $DCLEXH  desblk                                                      */
/*                                                                          */
/*     desblk = address of exit control block containing:                   */
/*                                                                          */
/*      +-------------------------------+                                   */
/*      |         forward link          |                                   */
/*      +-------------------------------+                                   */
/*      |     exit handler address      |                                   */
/*      +-------------------------------+                                   */
/*      |        argument count         |                                   */
/*      +-------------------------------+                                   */
/*      |   address to store reason     |                                   */
/*      +-------------------------------+                                   */
/*      |     additional arguments      |                                   */
/*      +--      for exit handler,    --+                                   */
/*      |            if any             |                                   */
/*      +-------------------------------+                                   */
/*                                                                          */
long int sys$dclexh() ;
/*                                                                          */
/*  $DELETE                                                                 */
/*                                                                          */
/*    Delete Record                                                         */
/*                                                                          */
/*      $DELETE rab, [err], [suc]                                           */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$delete() ;
/*  $DELLNM                                                                 */
/*                                                                          */
/*    Delete Logical Name and/or Table                                      */
/*                                                                          */
/*     $DELLNM  [tabnam], [lognam], [acmode]                                */
/*                                                                          */
/*     tabnam = address of descriptor of logical name table name string     */
/*                                                                          */
/*     lognam = address of descriptor of logical name string                */
/*                                                                          */
/*     acmode = address of access mode for logical name                     */
/*                                                                          */
long int sys$dellnm() ;
/*  $DELLOG                                                                 */
/*                                                                          */
/*    Delete Logical Name                                                   */
/*                                                                          */
/*     $DELLOG  [tblflg] ,[lognam] ,[acmode]                                */
/*                                                                          */
/*     tblflg = logical name table number                                   */
/*                0 -> system   1 -> group   2 -> process                   */
/*                                                                          */
/*     lognam = address of logical name string descriptor.  If 0,           */
/*              delete all names                                            */
/*                                                                          */
/*     acmode = access mode of logical name (process table only)            */
/*                                                                          */
long int sys$dellog() ;
/*  $DELMBX                                                                 */
/*                                                                          */
/*    Delete Mailbox                                                        */
/*                                                                          */
/*     $DELMBX  chan                                                        */
/*                                                                          */
/*     chan   = channel number assigned to the mailbox                      */
/*                                                                          */
long int sys$delmbx() ;
/*  $DELPRC                                                                 */
/*                                                                          */
/*    Delete Process                                                        */
/*                                                                          */
/*     $DELPRC  [pidadr] ,[prcnam]                                          */
/*                                                                          */
/*     pidadr = address of longword containing id of process to be deleted  */
/*                                                                          */
/*     prcnam = address of string descriptor for process name to be deleted */
/*                                                                          */
long int sys$delprc() ;
/*  $DELTVA                                                                 */
/*                                                                          */
/*    Delete Virtual Address Space                                          */
/*                                                                          */
/*     $DELTVA  inadr ,[retadr] ,[acmode]                                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing  starting  and       */
/*              ending virtual addresses of pages to delete                 */
/*                                                                          */
/*     retadr = address of 2-longword array to receive  starting  and       */
/*              ending addresses of pages actually deleted                  */
/*                                                                          */
/*     acmode = access mode for which service is performed                  */
/*                                                                          */
long int sys$deltva() ;
/*  $DEQ                                                                    */
/*                                                                          */
/*    Dequeue Lock                                                          */
/*                                                                          */
/*     $DEQ  [lkid] ,[valblk] ,[acmode] ,[flags]                            */
/*                                                                          */
/*     lkid   = lock ID of the lock to be dequeued                          */
/*                                                                          */
/*     valblk = address of the lock value block                             */
/*                                                                          */
/*     acmode = access mode of the locks to be dequeued                     */
/*                                                                          */
/*     flags  = optional flags.                                             */
/*                                                                          */
/*                   LCK$M_DEQALL                                           */
/*                                                                          */
long int sys$deq() ;
/*  $DGBLSC                                                                 */
/*                                                                          */
/*    Delete Global Section                                                 */
/*                                                                          */
/*     $DGBLSC  [flags] ,gsdnam ,[ident]                                    */
/*                                                                          */
/*     flags  = type of section                                             */
/*                0 -> group section   SEC$M_SYSGBL -> system section       */
/*                                                                          */
/*     gsdnam = address of global section name string descriptor            */
/*                                                                          */
/*     ident  = address of quadword containing version id and match control */
/*                                                                          */
long int sys$dgblsc() ;
/*                                                                          */
/*  $DISCONNECT                                                             */
/*                                                                          */
/*    Disconnect Record Stream                                              */
/*                                                                          */
/*      $DISCONNECT rab, [err], [suc]                                       */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$disconnect() ;
/*  $DISMOU                                                                 */
/*                                                                          */
/*    Dismount Volume                                                       */
/*                                                                          */
/*     $DISMOU devnam ,[flags]                                              */
/*                                                                          */
/*     devnam = address of device name string descriptor                    */
/*                                                                          */
/*     flags  = 32-bit status mask  selecting options for  the  dismount    */
/*              The  symbols  for  the flags are  defined by the $DMTDEF    */
/*              macro.                                                      */
/*                                                                          */
/*               Flag      Meaning                                          */
/*                                                                          */
/*           DMT$M_NOUNLOAD   Do not unload the volume.                     */
/*                                                                          */
/*           DMT$M_UNIT       Dismount the specified device, rather         */
/*                            than the entire volume set.                   */
/*                                                                          */
long int sys$dismou() ;
/*                                                                          */
/*  $DISPLAY                                                                */
/*                                                                          */
/*    Display File                                                          */
/*                                                                          */
/*      $DISPLAY fab, [err], [suc]                                          */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$display() ;
/*  $DLCEFC                                                                 */
/*                                                                          */
/*    Delete Common Event Flag Cluster                                      */
/*                                                                          */
/*     $DLCEFC  name                                                        */
/*                                                                          */
/*     name   = address of cluster name string descriptor                   */
/*                                                                          */
long int sys$dlcefc() ;
/*  $ENQ                                                                    */
/*                                                                          */
/*    Enqueue Lock Request                                                  */
/*                                                                          */
/*     $ENQ     [efn] ,lkmode ,lksb ,[flags] ,[resnam] ,[parid]             */
/*     ($ENQW)  ,[astadr] ,[astprm] ,[blkast] ,[acmode], [prot]             */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     lkmode = type of lock mode requested.  Modes are:                    */
/*                                                                          */
/*               LCK$K_NLMODE null lock                                     */
/*               LCK$K_CRMODE concurrent read                               */
/*               LCK$K_CWMODE concurrent write                              */
/*               LCK$K_PRMODE protected read                                */
/*               LCK$K_PWMODE protected write                               */
/*               LCK$K_EXMODE exclusive lock                                */
/*                                                                          */
/*     lksb  = address of the lock status block                             */
/*                                                                          */
/*     flags = flags defining the characteristics of the lock.  These are:  */
/*                                                                          */
/*               LCK$M_NOQUEUE                                              */
/*               LCK$M_SYNCSTS                                              */
/*               LCK$M_SYSTEM                                               */
/*               LCK$M_VALBLK                                               */
/*               LCK$M_CONVERT                                              */
/*                                                                          */
/*     resnam = address of string descriptor of the resource name           */
/*                                                                          */
/*     parid  = lock ID of the parent lock                                  */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine                           */
/*                                                                          */
/*     blkast = address of entry mask of blocking AST routine               */
/*                                                                          */
/*     acmode = Access mode to be associated with the lock                  */
/*                                                                          */
/*	prot  = optional additional arg for extension                       */
/*                                                                          */
long int sys$enq() ;
long int sys$enqw() ;
/*                                                                          */
/*  $ENTER                                                                  */
/*                                                                          */
/*    Enter File                                                            */
/*                                                                          */
/*      $ENTER fab, [err], [suc]                                            */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$enter() ;
/*  $ERAPAT                                                                 */
/*                                                                          */
/*    Generate a security erase pattern.                                    */
/*                                                                          */
/*	$ERAPAT type, [count], patadr                                       */
/*                                                                          */
/*	type	= type of security erase                                    */
/*                                                                          */
/*	count	= iteration count (seed for erase pattern)                  */
/*                                                                          */
/*	patadr	= address of longword to receive erase pattern              */
/*                                                                          */
long int sys$erapat() ;
/*  $ERASE                                                                  */
/*                                                                          */
/*    Erase File                                                            */
/*                                                                          */
/*      $ERASE fab, [err], [suc]                                            */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$erase() ;
/*  $EXIT                                                                   */
/*                                                                          */
/*    Exit image                                                            */
/*                                                                          */
/*     $EXIT    [code]                                                      */
/*                                                                          */
/*     code   = longword completion status                                  */
/*                                                                          */
long int sys$exit() ;
/*  $EXPREG                                                                 */
/*                                                                          */
/*    Expand Program/Control Region                                         */
/*                                                                          */
/*     $EXPREG  pagcnt ,[retadr] ,[acmode] ,[region]                        */
/*                                                                          */
/*     pagcnt = number of pages to add to end of specified region           */
/*                                                                          */
/*     retadr = address  of  2-longword  array  to  receive   virtual       */
/*              addresses of starting and ending pages                      */
/*                                                                          */
/*     acmode = access mode of the new pages                                */
/*                                                                          */
/*     region = region indicator                                            */
/*               0 -> program (P0) region   1 -> control (P1) region        */
/*                                                                          */
long int sys$expreg() ;
/*                                                                          */
/*  $EXTEND                                                                 */
/*                                                                          */
/*    Extend File                                                           */
/*                                                                          */
/*      $EXTEND fab, [err], [suc]                                           */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$extend() ;
/*  $FAO                                                                    */
/*                                                                          */
/*    Formatted ASCII Output                                                */
/*                                                                          */
/*     $FAO     ctrstr ,[outlen] ,outbuf ,[p1] ,[p2]...[pn]                 */
/*                                                                          */
/*     ctrstr = address of string descriptor for control string             */
/*                                                                          */
/*     outlen = address of word in which to store output length             */
/*                                                                          */
/*     outbuf = address of output buffer string descriptor                  */
/*                                                                          */
/*     p1...  = variable number of arguments to FAO                         */
/*                                                                          */
long int sys$fao() ;
/*  $FAOL                                                                   */
/*                                                                          */
/*    Formatted ASCII Output With List Parameter                            */
/*                                                                          */
/*     $FAOL    ctrstr ,[outlen] ,outbuf ,prmlst                            */
/*                                                                          */
/*     ctrstr = address of string descriptor for control string             */
/*                                                                          */
/*     outlen = address of word to receive output string length             */
/*                                                                          */
/*     outbuf = address of output buffer string descriptor                  */
/*                                                                          */
/*     prmlst = address of a list of longword parameters                    */
/*                                                                          */
long int sys$faol() ;
/*  $FILESCAN                                                               */
/*                                                                          */
/*    Scan a string and identify a file specification                       */
/*                                                                          */
/*     $FILESCAN    srcstr, [valuelst], [fldflags]                          */
/*                                                                          */
/*     srcstr = address of string descriptor for source string              */
/*                                                                          */
/*     valuelst = address of a list of item descriptors                     */
/*                                                                          */
/*	fldflags = address of a longword to receive flags                   */
/*                                                                          */
long int sys$filescan() ;
/*                                                                          */
/*  $FIND                                                                   */
/*                                                                          */
/*    Find Record in File                                                   */
/*                                                                          */
/*      $FIND rab, [err], [suc]                                             */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$find() ;
/*                                                                          */
/*  $FIND_HELD                                                              */
/*                                                                          */
/*    Find Identifiers Held By Holder                                       */
/*                                                                          */
/*	$FIND_HELD holder, [id], [attrib], [contxt]                         */
/*                                                                          */
/*	holder	= address of a quadword which specifies the holder          */
/*		  id of the records to find                                 */
/*	id	= address to return the identifier longword                 */
/*	attrib	= address to return the holder attributes longword          */
/*	contxt	= address of a longword containing the record stream        */
/*		  context. initially should be zero, value output           */
/*		  on first call, value input on subsequent calls.           */
/*                                                                          */
long int sys$find_held() ;
/*                                                                          */
/*  $FIND_HOLDER                                                            */
/*                                                                          */
/*    Find Holder Of Identifier                                             */
/*                                                                          */
/*	$FIND_HOLDER id, [holder], [attrib], [contxt]                       */
/*                                                                          */
/*	id	= identifier longword whose holder records                  */
/*		  are to be found                                           */
/*	holder	= address to return the holder id quadword                  */
/*	attrib	= address to return the attributes longword                 */
/*	contxt	= address of a longword containing the record stream        */
/*		  context. initially should be zero, value output           */
/*		  on first call, value input on subsequent calls.           */
/*                                                                          */
long int sys$find_holder() ;
/*                                                                          */
/*  $FINISH_RDB                                                             */
/*                                                                          */
/*    Clean up RMS Stream                                                   */
/*                                                                          */
/*	$FINISH_RDB contxt                                                  */
/*                                                                          */
/*	contxt	= address of a longword containing the record stream        */
/*		  context.                                                  */
/*                                                                          */
long int sys$finish_rdb() ;
/*  $FORCEX                                                                 */
/*                                                                          */
/*    Force Exit                                                            */
/*                                                                          */
/*     $FORCEX  [pidadr] ,[prcnam] ,[code]                                  */
/*                                                                          */
/*     pidadr = address of process id of process to be forced to exit       */
/*                                                                          */
/*     prcnam = address of process name descriptor for forced process       */
/*                                                                          */
/*     code   = longword completion status for exit service                 */
/*                                                                          */
long int sys$forcex() ;
/*                                                                          */
/*  $FORMAT_ACL                                                             */
/*                                                                          */
/*    Format an Access Control list Entry                                   */
/*                                                                          */
/*	$FORMAT_ACL acl-entry, [acl-length], acl-string,                    */
/*		    [line-width], [term-desc], [line-indent],               */
/*		    [bit-names], [routin]                                   */
/*                                                                          */
/*	acl-entry	= address of a descriptor of a buffer which         */
/*			  contains the ACE                                  */
/*                                                                          */
/*	acl-length	= address of a word to receive the length of        */
/*			  the output string                                 */
/*                                                                          */
/*	acl-string	= address of a descriptor of a buffer into          */
/*			  which the output string is to be stored           */
/*                                                                          */
/*	line-width	= address of the maximum line width                 */
/*			  (0 = infinite)                                    */
/*                                                                          */
/*	term_desc	= address of a character descriptor containing      */
/*			  a character string to be inserted whenever        */
/*			  the line segment length exceeds the line-width    */
/*                                                                          */
/*	line-indent	= address of the number of columns to indent        */
/*			  the output line segment                           */
/*                                                                          */
/*	bit-names	= address of a access bit name table (32 entries)   */
/*                                                                          */
/*	routin		= address of routine to be executed in kernel mode  */
/*                                                                          */
long int sys$format_acl() ;
/*  $FORMAT_CLASS	itmlst, [routin]                                    */
/*                                                                          */
/*    Format access class strings                                           */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     routin = address of routine to be executed in kernel mode            */
/*                                                                          */
/*                                                                          */
long int sys$format_class() ;
/*                                                                          */
/*  $FREE                                                                   */
/*                                                                          */
/*    Free Record                                                           */
/*                                                                          */
/*      $FREE rab, [err], [suc]                                             */
/*                                                                          */
/*      rab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$free() ;
/*                                                                          */
/*  $FLUSH                                                                  */
/*                                                                          */
/*    Flush Record                                                          */
/*                                                                          */
/*      $FLUSH rab, [err], [suc]                                            */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$flush() ;
/*                                                                          */
/*  $GET                                                                    */
/*                                                                          */
/*    Get Record from File                                                  */
/*                                                                          */
/*      $GET rab, [err], [suc]                                              */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$get() ;
/*  $GETCHN                                                                 */
/*                                                                          */
/*    Get I/O Channel Information                                           */
/*                                                                          */
/*     $GETCHN  chan ,[prilen] ,[pribuf] ,[scdlen] ,[scdbuf]                */
/*                                                                          */
/*     chan   = number of a channel assigned to the device                  */
/*                                                                          */
/*     prilen = address of word to receive length of primary buffer         */
/*                                                                          */
/*     pribuf = address of primary buffer descriptor                        */
/*                                                                          */
/*     scdlen = address of word to receive length of secondary buffer       */
/*                                                                          */
/*     scdbuf = address of secondary buffer descriptor                      */
/*                                                                          */
long int sys$getchn() ;
/*  $GETDEV                                                                 */
/*                                                                          */
/*    Get I/O Device Information                                            */
/*                                                                          */
/*     $GETDEV  devnam  ,[prilen] ,[pribuf] ,[scdlen] ,[scdbuf]             */
/*                                                                          */
/*     devnam = address of device name or logical name descriptor           */
/*                                                                          */
/*     prilen = address of word to receive length of primary buffer         */
/*                                                                          */
/*     pribuf = address of primary buffer descriptor                        */
/*                                                                          */
/*     scdlen = address of word to receive length of secondary buffer       */
/*                                                                          */
/*     scdbuf = address of secondary buffer descriptor                      */
/*                                                                          */
long int sys$getdev() ;
/*  $GETDVI                                                                 */
/*                                                                          */
/*    Get Device/Volume Information                                         */
/*                                                                          */
/*     $GETDVI  [efn] ,[chan] ,[devnam] ,itmlst ,[iosb] ,[astadr]           */
/*    ($GETDVIW)          ,[astprm] ,[nullarg]                              */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     chan   = number of a channel assigned to the device or               */
/*              0 if device is specified by the devnam parameter            */
/*                                                                          */
/*     devnam = address of device name or logical name descriptor           */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine                           */
/*                                                                          */
/*     nullarg = reserved argument                                          */
/*                                                                          */
/*                                                                          */
long int sys$getdvi() ;
long int sys$getdviw() ;
/*  $GETJPI                                                                 */
/*                                                                          */
/*    Get Job/Process Information                                           */
/*                                                                          */
/*     $GETJPI  [efn] ,[pidadr] ,[prcnam] ,itmlst ,[iosb], [astadr],        */
/*     ($GETJPIW)   [astprm]                                                */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     pidadr = address of process identification                           */
/*                                                                          */
/*     prcnam = address of process name string descriptor                   */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine as an argument            */
/*                                                                          */
/*                                                                          */
long int sys$getjpi() ;
long int sys$getjpiw() ;
/*  $GETLKI                                                                 */
/*                                                                          */
/*    Get Lock Information                                                  */
/*                                                                          */
/*     $GETLKI  [efn] ,lkidadr ,itmlst ,[iosb], [astadr], [astprm],         */
/*     ($GETLKIW)   [reserved]                                              */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     lkidadr = address of lock identification                             */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine as an argument            */
/*                                                                          */
/*     reserved = reserved parameter                                        */
/*                                                                          */
/*                                                                          */
long int sys$getlki() ;
long int sys$getlkiw() ;
/*  $GETMSG                                                                 */
/*                                                                          */
/*    Get Message                                                           */
/*                                                                          */
/*     $GETMSG  msgid ,msglen ,bufadr ,[flags] ,[outadr]                    */
/*                                                                          */
/*     msgid  = identification of message to be retrieved                   */
/*                                                                          */
/*     msglen = address  of  a  word  to  receive  length  of  string       */
/*       returned                                                           */
/*                                                                          */
/*     bufadr = address of buffer descriptor  of  buffer  to  receive       */
/*       string                                                             */
/*                                                                          */
/*     flags  = flag bits for message content (macro default = 15)          */
/*                                                                          */
/*           Bit  Value/Meaning                                             */
/*                                                                          */
/*            0  1 Include text                                             */
/*               0 Do not include text                                      */
/*            1  1 Include identifier                                       */
/*               0 Do not include identifier                                */
/*            2  1 Include severity                                         */
/*               0 Do not include severity                                  */
/*            3  1 Include component                                        */
/*               0 Do not include component                                 */
/*                                                                          */
/*     outadr = address of 4-byte array to receive the following values:    */
/*                                                                          */
/*       Byte       Contents                                                */
/*                                                                          */
/*        0  Reserved                                                       */
/*        1  Count of FAO arguments                                         */
/*        2  User value                                                      */
/*        3  Reserved                                                       */
/*                                                                          */
long int sys$getmsg() ;
/*  $GETPTI                                                                 */
/*                                                                          */
/*    Get Page Table Information                                            */
/*                                                                          */
/*     $GETPTI  [inadr],[retadr],[acmode],[mask],[pagcnt]                   */
/*                                                                          */
/*     inadr	= address of two longwords containing starting              */
/*	and ending virtual address to operate on                            */
/*                                                                          */
/*     retadr	= address of two longwords into which starting              */
/*	and ending address of pages operated on is returned                 */
/*                                                                          */
/*     acmode   = access mode against which ownership is checked            */
/*                                                                          */
/*     mask	= mask of page table information control bits               */
/*                                                                          */
/*     pagcnt	= minimum page count                                        */
/*                                                                          */
/*                                                                          */
long int sys$getpti() ;
/*  $GETQUI                                                                 */
/*                                                                          */
/*    Get Queue Information                                                 */
/*                                                                          */
/*     $GETQUI   [efn], func, [nullarg], [itmlst],                          */
/*    ($GETQUIW) [iosb], [astadr], [astprm]                                 */
/*                                                                          */
/*     efn     = event flag to be set when request completes                */
/*     func    = code specifying function to be performed                   */
/*     nullarg = reserved argument for similarity with $getxxx services     */
/*     itmlst  = address of a list of item descriptors for the operation    */
/*     iosb    = address of a quadword status block to receive the final status */
/*     astadr  = address of an ast routine to be called when request completes */
/*     astprm  = 32-bit ast parameter                                       */
/*                                                                          */
long int sys$getqui() ;
long int sys$getquiw() ;
/*  $GETSYI                                                                 */
/*                                                                          */
/*    Get System-Wide Information                                           */
/*                                                                          */
/*     $GETSYI  [efn] ,[csidadr],[nodename],itmlst ,[iosb] ,[astadr],       */
/*    ($GETSYIW)  [astprm]                                                  */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     csidadr = address of cluster system identification                   */
/*                                                                          */
/*     nodename = address of node name string descriptor                    */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine                           */
/*                                                                          */
/*                                                                          */
/*     The second and third arguments in the $GETSYI argument list are      */
/*     not used; they are reserved for future use.                          */
/*                                                                          */
long int sys$getsyi() ;
long int sys$getsyiw() ;
/*  $GETTIM                                                                 */
/*                                                                          */
/*    Get Time                                                              */
/*                                                                          */
/*     $GETTIM  timadr                                                      */
/*                                                                          */
/*     timadr = address of a quadword to receive 64-bit current time value  */
/*                                                                          */
long int sys$gettim() ;
/*  $GETUAI                                                                 */
/*                                                                          */
/*    Get User Authorization Information                                    */
/*                                                                          */
/*     $GETUAI  [efn] ,[contxt] ,usrnam ,itmlst ,[iosb] ,[astadr]           */
/*    		,[astprm]                                                   */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     contxt = address of a context longword (UAF IFI & ISI)               */
/*                                                                          */
/*     usrnam = address of user name descriptor                             */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine                           */
/*                                                                          */
/*                                                                          */
long int sys$getuai() ;
/*                                                                          */
/*  $GRANTID                                                                */
/*                                                                          */
/*    Grant Identifier to Process                                           */
/*                                                                          */
/*	$GRANTID [pidadr], [prcnam], [id], [name], [prvatr]                 */
/*                                                                          */
/*	pidadr  = address of PID of affected process                        */
/*	prcnam  = address of string descriptor of process name              */
/*	id      = address of quadword identifier and attributes             */
/*	name    = address of string descriptor of identifier name           */
/*	prvatr  = address to store attributes of superseded id              */
/*                                                                          */
long int sys$grantid() ;
/*                                                                          */
/*  $GRANT_LICENSE                                                          */
/*                                                                          */
/*  Grant authorization to execute licensed software product.               */
/*                                                                          */
/*	$GRANT_LICENSE  prdnam ,prducer [,contxt] [,itmlst]                 */
/*                                                                          */
/*	prdnam	= address of descriptor for software product name           */
/*	prducer	= address of descriptor for software producer name          */
/*	contxt  = address of context buffer (4 longwords)                   */
/*	itmlst	= address of a list of item descriptors                     */
/*                                                                          */
long int sys$grant_license() ;
/*  $HIBER                                                                  */
/*                                                                          */
/*    Hibernate                                                             */
/*                                                                          */
/*     $HIBER_S                                                             */
/*                                                                          */
long int sys$hiber() ;
/*                                                                          */
/*  $IDTOASC                                                                */
/*                                                                          */
/*    Identifier To Ascii Conversion                                        */
/*                                                                          */
/*	$IDTOASC id, [namlen], [nambuf], [resid], [attrib], [contxt]        */
/*                                                                          */
/*	id	= identifier longword to convert, or zero to                */
/*		  find all identifiers (wildcarding)                        */
/*	namlen	= address of a word to store the length of the              */
/*		  identifier name                                           */
/*	nambuf	= address of a character string descriptor that             */
/*		  describes the buffer to return the identifier name        */
/*	resid	= address of a longword to return the id found              */
/*		  while wildcarding                                         */
/*	attrib	= address to return the attributes longword                 */
/*	contxt	= address of a longword containing the record stream        */
/*		  context. initially should be zero, value output           */
/*		  on first call, value input on subsequent calls.           */
/*                                                                          */
long int sys$idtoasc() ;
/*  $IMGACT                                                                 */
/*                                                                          */
/*    Image Activation                                                      */
/*                                                                          */
/*     $IMGACT	name,[dflnam],hdrbuf,[imgctl],[inadr],                      */
/*		[retadr], [ident], [acmode]                                 */
/*                                                                          */
/*                                                                          */
/*     name	= address of descriptor for file name string                */
/*                                                                          */
/*     dflnam	= descriptor for file name string                           */
/*                                                                          */
/*     hdrbuf	= address of 512 byte buffer to write in                    */
/*                                                                          */
/*     imgctl	= image activation control flags                            */
/*                                                                          */
/*     inadr	= address of quadword specifying virtual address            */
/*		  range to be mapped                                        */
/*                                                                          */
/*     retadr	= address of quadword specifying virtual address            */
/*		  range actually mapped                                     */
/*                                                                          */
/*     ident	= address of quadword holding image section match           */
/*		  control and identifier                                    */
/*                                                                          */
/*     acmode	= access mode to be the owner of the created pages          */
/*                                                                          */
long int sys$imgact() ;
/*  $IMGFIX                                                                 */
/*                                                                          */
/*    Image Address Fixup Service                                           */
/*                                                                          */
/*     $IMGFIX                                                              */
/*                                                                          */
long int sys$imgfix() ;
/*  $LCKPAG                                                                 */
/*                                                                          */
/*    Lock Pages in Memory                                                  */
/*                                                                          */
/*     $LCKPAG  inadr ,[retadr] ,[acmode]                                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending addresses of pages to be locked                      */
/*                                                                          */
/*     retadr = address of 2-longword array to receive addresses of         */
/*              pages actually locked                                       */
/*                                                                          */
/*     acmode = access mode to check against the owner of the pages         */
/*                                                                          */
long int sys$lckpag() ;
/*  $LKWSET                                                                 */
/*                                                                          */
/*    Lock Pages in Working Set                                             */
/*                                                                          */
/*     $LKWSET  inadr ,[retadr] ,[acmode]                                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending virtual addresses of pages to be locked              */
/*                                                                          */
/*     retadr = address of a 2-longword array to receive starting and       */
/*              ending virtual addresses of pages actually locked           */
/*                                                                          */
/*     acmode = access mode to be checked against the page owner            */
/*                                                                          */
long int sys$lkwset() ;
/*  $MGBLSC                                                                 */
/*                                                                          */
/*    Map Global Section                                                    */
/*                                                                          */
/*     $MGBLSC  inadr ,[retadr] ,[acmode] ,[flags] ,gsdnam ,[ident] ,[relpag] */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending addresses of pages to be mapped                      */
/*                                                                          */
/*     retadr = address of 2-longword array to receive virtual              */
/*              addresses of pages mapped                                   */
/*                                                                          */
/*     acmode = access mode of owner of mapped pages                        */
/*                                                                          */
/*     flags  = flags overriding default section characteristics            */
/*                                                                          */
/*         Flag        Meaning                                              */
/*                                                                          */
/*       SEC$M_WRT      Read/write section                                  */
/*       SEC$M_SYSGBL   System global section                               */
/*       SEC$M_EXPREG   Find first available space                          */
/*                                                                          */
/*     gsdnam = address of global section name descriptor                   */
/*                                                                          */
/*     ident  = address of quadword containing version id and match control */
/*                                                                          */
/*     relpag = relative page number within global section                  */
/*                                                                          */
long int sys$mgblsc() ;
/*                                                                          */
/*  $MODIFY                                                                 */
/*                                                                          */
/*    Modify File                                                           */
/*                                                                          */
/*      $MODIFY fab, [err], [suc]                                           */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$modify() ;
/*                                                                          */
/*  $MOD_HOLDER                                                             */
/*                                                                          */
/*    Modify Holder Record In Rights Database                               */
/*                                                                          */
/*	$MOD_HOLDER id, holder, [set_attrib], [clr_attrib]                  */
/*                                                                          */
/*	id	   = identifier longword                                    */
/*	holder	   = address of the holder identifier quadword              */
/*	set_attrib = longword containing the attributes to set              */
/*		     into the holder record                                 */
/*	clr_attrib = longword containing the attributes to clear            */
/*		     in the holder record                                   */
/*                                                                          */
long int sys$mod_holder() ;
/*                                                                          */
/*  $MOD_IDENT                                                              */
/*                                                                          */
/*    Modify Identifier Record In Rights Database                           */
/*                                                                          */
/*	$MOD_IDENT id, [set_attrib], [clr_attrib], [new_name], [new_value]  */
/*                                                                          */
/*	id	   = identifier longword                                    */
/*	set_attrib = longword containing the attributes                     */
/*		     to set into the identifier record                      */
/*	clr_attrib = longword containing the attributes                     */
/*		     to clear in the identifier record                      */
/*	new_name   = address of the new identifier name character           */
/*                   string descriptor                                      */
/*	new_value  = new identifier value longword                          */
/*                                                                          */
long int sys$mod_ident() ;
/*  $MOUNT                                                                  */
/*                                                                          */
/*    Mount Volume                                                          */
/*                                                                          */
/*     $MOUNT  itmlst                                                       */
/*                                                                          */
/*     itmlst = Address of a list of item identifiers                       */
/*                                                                          */
long int sys$mount() ;
/*  $MTACCESS                                                               */
/*                                                                          */
/*    Installation specific accessibility routine                           */
/*                                                                          */
/*  $MTACCESS lblnam, [uic], [std_version], [access_char],                  */
/*	      [access_spec],type                                            */
/*                                                                          */
/*    lblnam = 	  On input this field is the address of the                 */
/*		  VOL1 or HDR1 label read off the magnetic tape. On         */
/*		  output of labels this field is zero. The type             */
/*		  of label is determined by the TYPE field.                 */
/*    uic   = 	  This field contains the longword volme UIC passed         */
/*		  by value.                                                 */
/*    std_version =  This field contains a byte value of the                */
/*		     decimal equivalent of the version number               */
/*		     gotten from the VOL1 label, passed by value.           */
/*    access_char =  This field contins the byte value of the               */
/*		     accessibility character specified by the user,         */
/*		     passed by value. For output of labels only.            */
/*    access_spec =  This field determines if the character passed          */
/*		     in ACCESS_CHAR  was specified by user, passed          */
/*		     by value.  It must contain one of the following        */
/*		     values:                                                */
/*			MTA$K_CHARVALID = YES                               */
/*			MTA$K_NOCHAR = NO                                   */
/*	 	     For output of labels only.                             */
/*    type = This field contains the type of accessibility to process,      */
/*	     passed by value. It must contain one of the following          */
/*	     values:                                                        */
/*			MTA$K_INVOL1 = Input a VOL1 label                   */
/*			MTA$K_INHDR1 = Input a HDR1 label                   */
/*			MTA$K_OUTVOL1 = Output a VOL1 label                 */
/*			MTA$K_OUTHDR1 = Output a HDR1 label                 */
/*                                                                          */
long int sys$mtaccess() ;
/*  $NUMTIM                                                                 */
/*                                                                          */
/*    Convert Binary Time to Numeric Time                                   */
/*                                                                          */
/*     $NUMTIM  timbuf ,[timadr]                                            */
/*                                                                          */
/*     timbuf = address of a 7-word buffer to receive numeric time          */
/*              information                                                 */
/*                                                                          */
/*     timadr = address of a quadword containing the 64-bit time.  If       */
/*              0, use current time                                         */
/*                                                                          */
long int sys$numtim() ;
/*                                                                          */
/*  $NXTVOL                                                                 */
/*                                                                          */
/*    Go to Next Volume                                                     */
/*                                                                          */
/*      $NXTVOL rab, [err], [suc]                                           */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$nxtvol() ;
/*                                                                          */
/*  $OPEN                                                                   */
/*                                                                          */
/*    Open File                                                             */
/*                                                                          */
/*      $OPEN fab, [err], [suc]                                             */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$open() ;
/*                                                                          */
/*  $PARSE                                                                  */
/*                                                                          */
/*    Parse File Name                                                       */
/*                                                                          */
/*      $PARSE fab, [err], [suc]                                            */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$parse() ;
/*                                                                          */
/*  $PARSE_ACL                                                              */
/*                                                                          */
/*    Parse an Access Control list Entry                                    */
/*                                                                          */
/*	$PARSE_ACL acl-string ,acl-entry ,[error-position],                 */
/*		   [bit-names], [routin]                                    */
/*                                                                          */
/*	acl-string	= address of a descriptor of a buffer which         */
/*			  contains the text to be parsed                    */
/*                                                                          */
/*	acl-entry	= address of a descriptor of a buffer into          */
/*			  which the converted ACE is to be written          */
/*                                                                          */
/*	error-position	= address of a word to receive the number of        */
/*			  characters actually processed by the service.     */
/*			  If the service fails, this count points to        */
/*			  the failing point in the input string.            */
/*                                                                          */
/*	bit-names	= address of a access bit name table (32 entries)   */
/*                                                                          */
/*	routin		= address of routine to be executed in kernel mode  */
/*                                                                          */
long int sys$parse_acl() ;
/*  $PARSE_CLASS	itmlst, [routin]                                    */
/*                                                                          */
/*    Parse access class strings                                            */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     routin = address of routine to be executed in kernel mode            */
/*                                                                          */
/*                                                                          */
long int sys$parse_class() ;
/*  $PURGWS                                                                 */
/*                                                                          */
/*    Purge Working Set                                                     */
/*                                                                          */
/*     $PURGWS  inadr                                                       */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending addresses of pages to be removed                     */
/*                                                                          */
long int sys$purgws() ;
/*                                                                          */
/*  $PUT                                                                    */
/*                                                                          */
/*    Put Record to File                                                    */
/*                                                                          */
/*      $PUT rab, [err], [suc]                                              */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$put() ;
/*  $PUTMSG                                                                 */
/*                                                                          */
/*    Put Message                                                           */
/*                                                                          */
/*     $PUTMSG  msgvec ,[actrtn] ,[facnam], [actprm]                        */
/*                                                                          */
/*     msgvec = address of message argument vector                          */
/*                                                                          */
/*     actrtn = address of entry mask of action routine                     */
/*                                                                          */
/*     facnam = address of facility name string descriptor                  */
/*                                                                          */
/*     actprm = parameter to pass to action routine                         */
/*                                                                          */
long int sys$putmsg() ;
/*  $QIO                                                                    */
/*                                                                          */
/*    Queue I/O Request                                                     */
/*                                                                          */
/*     $QIO     [efn] ,chan ,func ,[iosb] ,[astadr] ,[astprm]               */
/*     ($QIOW)  ,[p1] ,[p2] ,[p3] ,[p4] ,[p5] ,[p6]                         */
/*                                                                          */
/*     efn    = number of event flag to set on completion                   */
/*                                                                          */
/*     chan   = number of channel on which I/O is directed                  */
/*                                                                          */
/*     func   = function code specifying action to be performed             */
/*                                                                          */
/*     iosb   = address of quadword I/O status block to receive final       */
/*              completion status                                           */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine as argument               */
/*                                                                          */
/*     p1...  = optional device- and function-specific parameters           */
/*                                                                          */
long int sys$qio() ;
long int sys$qiow() ;
/*                                                                          */
/*  $READ                                                                   */
/*                                                                          */
/*    Read Block from File                                                  */
/*                                                                          */
/*      $READ rab, [err], [suc]                                             */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$read() ;
/*  $READEF                                                                 */
/*                                                                          */
/*    Read Event Flag                                                       */
/*                                                                          */
/*     $READEF  efn ,state                                                  */
/*                                                                          */
/*     efn    = event flag number of any flag in the cluster                */
/*                                                                          */
/*     state  = address of a longword to receive current state of all       */
/*              flags in the cluster                                        */
/*                                                                          */
long int sys$readef() ;
/*                                                                          */
/*  $RELEASE                                                                */
/*                                                                          */
/*    Release Record                                                        */
/*                                                                          */
/*      $RELEASE rab, [err], [suc]                                          */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$release() ;
/*                                                                          */
/*  $RELEASE_LICENSE                                                        */
/*                                                                          */
/*  Release authorization to execute licensed software product.             */
/*                                                                          */
/*	$RELEASE_LICENSE  context                                           */
/*                                                                          */
/*  	contxt	= address of context buffer returned by                     */
/*		  $grant_license (4 longwords)                              */
/*                                                                          */
long int sys$release_license() ;
/*                                                                          */
/*  $REMOVE                                                                 */
/*                                                                          */
/*    Remove File                                                           */
/*                                                                          */
/*      $REMOVE fab, [err], [suc]                                           */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$remove() ;
/*                                                                          */
/*  $REM_HOLDER                                                             */
/*                                                                          */
/*    Remove Holder Record From Rights Database                             */
/*                                                                          */
/*	$REM_HOLDER id, holder                                              */
/*                                                                          */
/*	id	= identifier longword                                       */
/*	holder	= address of the holder identifier quadword                 */
/*                                                                          */
long int sys$rem_holder() ;
/*                                                                          */
/*  $REM_IDENT                                                              */
/*                                                                          */
/*    Remove Identifier From Rights Database                                */
/*                                                                          */
/*	$REM_IDENT id                                                       */
/*                                                                          */
/*	id	= identifier longword                                       */
/*                                                                          */
long int sys$rem_ident() ;
/*                                                                          */
/*  $RENAME                                                                 */
/*                                                                          */
/*    Rename File                                                           */
/*                                                                          */
/*      $RENAME oldfab, [err], [suc], newfab                                */
/*                                                                          */
/*      oldfab	= address of oldfab                                         */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
/*	newfab	= address of new fab                                        */
long int sys$rename() ;
/*  $RESUME                                                                 */
/*                                                                          */
/*    Resume Suspended Process                                              */
/*                                                                          */
/*     $RESUME  [pidadr] ,[prcnam]                                          */
/*                                                                          */
/*     pidadr = address of process id of process to be resumed              */
/*                                                                          */
/*     prcnam = address of process name string descriptor                   */
/*                                                                          */
long int sys$resume() ;
/*                                                                          */
/*  $REVOKID                                                                */
/*                                                                          */
/*    Revoke Identifier from Process                                        */
/*                                                                          */
/*	$REVOKID [pidadr], [prcnam], [id], [name], [prvatr]                 */
/*                                                                          */
/*	pidadr  = address of PID of affected process                        */
/*	prcnam  = address of string descriptor of process name              */
/*	id      = address of quadword identifier and attributes             */
/*	name    = address of string descriptor of identifier name           */
/*	prvatr  = address to store attributes of superseded id              */
/*                                                                          */
long int sys$revokid() ;
/*                                                                          */
/*  $REWIND                                                                 */
/*                                                                          */
/*    Rewind File                                                           */
/*                                                                          */
/*      $REWIND rab, [err], [suc]                                           */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$rewind() ;
/*  $RUNDWN                                                                 */
/*                                                                          */
/*    Rundown Process                                                       */
/*                                                                          */
/*     $RUNDWN  [acmode]                                                    */
/*                                                                          */
/*     acmode = access mode to rundown; this and all less                   */
/*		privileged access modes are rundown                         */
/*                                                                          */
long int sys$rundwn() ;
/*  $SCHDWK                                                                 */
/*                                                                          */
/*    Schedule Wakeup                                                       */
/*                                                                          */
/*     $SCHDWK  [pidadr] ,[prcnam] ,daytim ,[reptim]                        */
/*                                                                          */
/*     pidadr = address of process id of process to be awakened             */
/*                                                                          */
/*     prcnam = address of process name string descriptor                   */
/*                                                                          */
/*     daytim = address of quadword containing time to wake                 */
/*                                                                          */
/*     reptim = address of quadword containing repeat time interval         */
/*                                                                          */
long int sys$schdwk() ;
/*                                                                          */
/*  $SEARCH                                                                 */
/*                                                                          */
/*    Search for File Name                                                  */
/*                                                                          */
/*      $SEARCH fab, [err], [suc]                                           */
/*                                                                          */
/*      fab	= address of fab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$search() ;
/*  $SETAST                                                                 */
/*                                                                          */
/*    Set AST Enable                                                        */
/*                                                                          */
/*     $SETAST  enbflg                                                      */
/*                                                                          */
/*     enbflg = AST enable indicator for current access mode                */
/*                0 -> disable    1 -> enable                               */
/*                                                                          */
long int sys$setast() ;
/*  $SETEF                                                                  */
/*                                                                          */
/*    Set Event Flag                                                        */
/*                                                                          */
/*     $SETEF  efn                                                          */
/*                                                                          */
/*     efn    = event flag number of flag to set                            */
/*                                                                          */
long int sys$setef() ;
/*  $SETEXV                                                                 */
/*                                                                          */
/*    Set Exception Vector                                                  */
/*                                                                          */
/*     $SETEXV  [vector] ,[addres] ,[acmode] ,[prvhnd]                      */
/*                                                                          */
/*     vector = vector number                                               */
/*                0 -> primary vector   1 -> secondary    2 -> last chance  */
/*                                                                          */
/*     addres = exception handler address (0 indicates deassign vector)     */
/*                                                                          */
/*     acmode = access mode for which vector is set                         */
/*                                                                          */
/*     prvhnd = address of longword to receive previous handler address     */
/*                                                                          */
long int sys$setexv() ;
/*  $SETIME                                                                 */
/*                                                                          */
/*    Set System Time                                                       */
/*                                                                          */
/*     $SETIME [timadr]                                                     */
/*                                                                          */
/*     timadr = address of quadword containing  new  system  time  in       */
/*              64-bit  format.   If 0, recalibrate system time using       */
/*              hardware time-of-year clock.                                */
/*                                                                          */
long int sys$setime() ;
/*  $SETIMR                                                                 */
/*                                                                          */
/*    Set Timer                                                             */
/*                                                                          */
/*     $SETIMR  [efn] ,daytim ,[astadr] ,[reqidt] ,[flags]                  */
/*                                                                          */
/*     efn    = event flag to set when timer expires                        */
/*                                                                          */
/*     daytim = address of quadword containing 64-bit time value            */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     reqidt = request identification of this timer request                */
/*                                                                          */
/*	flags = only bit 0 used right now.  If bit 0 is set,                */
/*		 then this timer request is in terms of CPU time.           */
/*                                                                          */
long int sys$setimr() ;
/*  $SETPFM                                                                 */
/*                                                                          */
/*    Set Page Fault Monitoring                                             */
/*                                                                          */
/*     $SETPFM  [pfmflg] ,[astadr] ,[astprm] ,[acmode]                      */
/*                                                                          */
/*	pfmflg	= function/subfunction bits                                 */
/*                                                                          */
/*	astadr	= address of entry mask of AST routine                      */
/*                                                                          */
/*	astprm	= value to be passed to AST routine                         */
/*                                                                          */
/*	acmode	= access mode for which the AST is to be declared           */
/*                                                                          */
long int sys$setpfm() ;
/*  $SETPRA                                                                 */
/*                                                                          */
/*    Set Power Recovery AST                                                */
/*                                                                          */
/*     $SETPRA  astadr ,[acmode]                                            */
/*                                                                          */
/*     astadr = address of power recovery AST routine                       */
/*                                                                          */
/*     acmode = access mode of AST                                          */
/*                                                                          */
long int sys$setpra() ;
/*  $SETPRI                                                                 */
/*                                                                          */
/*    Set Priority                                                          */
/*                                                                          */
/*     $SETPRI  [pidadr] ,[prcnam] ,pri ,[prvpri]                           */
/*                                                                          */
/*     pidadr = address of process id of process to be set                  */
/*                                                                          */
/*     prcnam = address of process name string descriptor                   */
/*                                                                          */
/*     pri    = new base priority for the process                           */
/*                                                                          */
/*     prvpri = address of longword to receive previous base priority       */
/*                                                                          */
long int sys$setpri() ;
/*  $SETPRN                                                                 */
/*                                                                          */
/*    Set Process Name                                                      */
/*                                                                          */
/*     $SETPRN  [prcnam]                                                    */
/*                                                                          */
/*     prcnam = address of the process name string descriptor               */
/*                                                                          */
long int sys$setprn() ;
/*  $SETPRT                                                                 */
/*                                                                          */
/*    Set Protection on Pages                                               */
/*                                                                          */
/*     $SETPRT  inadr ,[retadr] ,[acmode] ,prot ,[prvprt]                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending virtual addresses of pages to change                 */
/*                                                                          */
/*     retadr = address of 2-longword array containing starting and         */
/*              ending addresses of pages which were changed                */
/*                                                                          */
/*     acmode = access mode of request                                      */
/*                                                                          */
/*     prot   = new protection                                              */
/*                                                                          */
/*     prvprt = address of byte to receive previous protection of           */
/*              last page changed                                           */
/*                                                                          */
long int sys$setprt() ;
/*  $SETPRV                                                                 */
/*                                                                          */
/*    Set privileges.                                                       */
/*     $SETPRV [enbflg] ,[prvadr] ,[prmflg] ,[prvprv]                       */
/*                                                                          */
/*     enbflg = enable indicator                                            */
/*                0 -> disable   1 -> enable                                */
/*                                                                          */
/*     prvadr = 64-bit mask defining the privileges to be enabled or        */
/*              disabled                                                    */
/*                                                                          */
/*     prmflg = permanent indicator                                         */
/*                0 -> temporary (for this image)  1 -> permanent           */
/*                                                                          */
/*     prvprv = address of quadword buffer to receive previous privileges   */
/*                                                                          */
long int sys$setprv() ;
/*  $SETRWM                                                                 */
/*                                                                          */
/*    Set Resource Wait Mode                                                */
/*                                                                          */
/*     $SETRWM  [watflg]                                                    */
/*                                                                          */
/*     watflg = wait indicator                                              */
/*         0 -> wait for resources   1 -> return failure immediately        */
/*	   (type is NUMBER rather than BOOLEAN since WATFLG=TRUE            */
/*	   means don't wait, which is the opposite of what is seems)        */
/*                                                                          */
long int sys$setrwm() ;
/*  $SETSFM                                                                 */
/*                                                                          */
/*    Set System Service Failure Mode                                       */
/*                                                                          */
/*     $SETSFM  [enbflg]                                                    */
/*                                                                          */
/*     enbflg = enable indicator                                            */
/*                0 -> disable generation of exceptions on service failures */
/*                1 -> generate exceptions for system service failures      */
/*                                                                          */
long int sys$setsfm() ;
/*  $SETSSF                                                                 */
/*                                                                          */
/*    Set System Service Filter                                             */
/*                                                                          */
/*     $SETSSF  [mask]                                                      */
/*                                                                          */
/*     mask = flags for services to inhibit                                 */
/*                                                                          */
long int sys$setssf() ;
/*  $SETSTK                                                                 */
/*                                                                          */
/*    SET VIRTUAL STACK LIMITS                                              */
/*                                                                          */
/*     $SETSTK inadr ,[retadr] ,[acmode]                                    */
/*                                                                          */
/*     inadr  = address of 2-longword array containing  starting  and       */
/*              ending virtual address of stack limits to set               */
/*                                                                          */
/*     retadr = address of a 2-longword array to receive starting and       */
/*              ending virtual address of stack limits to set               */
/*                                                                          */
/*     acmode = access  mode  for  the  stack to change                     */
/*                                                                          */
long int sys$setstk() ;
/*  $SETSWM                                                                 */
/*                                                                          */
/*    Set Process Swap Mode                                                 */
/*                                                                          */
/*     $SETSWM  [swpflg]                                                    */
/*                                                                          */
/*     swpflg = swap indicator                                              */
/*                0 -> enable swapping   1 -> disable swapping              */
/*                                                                          */
long int sys$setswm() ;
/*  $SETUAI                                                                 */
/*                                                                          */
/*    Modify User Authorization Information                                 */
/*                                                                          */
/*     $SETUAI  [efn] ,[contxt] ,usrnam ,itmlst ,[iosb] ,[astadr]           */
/*    		,[astprm]                                                   */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     contxt = address of a context longword (UAF IFI & ISI)               */
/*                                                                          */
/*     usrnam = address of user name descriptor                             */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
/*     astadr = address of entry mask of AST routine                        */
/*                                                                          */
/*     astprm = value to be passed to AST routine                           */
/*                                                                          */
/*                                                                          */
long int sys$setuai() ;
/*  $SNDACC                                                                 */
/*                                                                          */
/*    Send Message to Accounting Manager                                    */
/*                                                                          */
/*     $SNDACC  msgbuf ,[chan]                                              */
/*                                                                          */
/*     msgbuf = address of message buffer string descriptor                 */
/*                                                                          */
/*     chan   = number of channel assigned to mailbox to receive reply      */
/*                                                                          */
long int sys$sndacc() ;
/*  $SNDERR                                                                 */
/*                                                                          */
/*    Send Message to Error Logger                                          */
/*                                                                          */
/*     $SNDERR msgbuf                                                       */
/*                                                                          */
/*     msgbuf = address of message buffer string descriptor                 */
/*                                                                          */
long int sys$snderr() ;
/*  $SNDOPR                                                                 */
/*                                                                          */
/*    Send Message to Operator                                              */
/*                                                                          */
/*     $SNDOPR  msgbuf ,[chan]                                              */
/*                                                                          */
/*     msgbuf = address of message buffer string descriptor                 */
/*                                                                          */
/*     chan   = number of channel assigned to mailbox to receive reply      */
/*                                                                          */
long int sys$sndopr() ;
/*  $SNDSMB                                                                 */
/*                                                                          */
/*    Send Message to Symbiont Manager                                      */
/*                                                                          */
/*     $SNDSMB  msgbuf ,[chan]                                              */
/*                                                                          */
/*     msgbuf = address of message buffer string descriptor                 */
/*                                                                          */
/*     chan   = number of channel assigned to mailbox to receive reply      */
/*                                                                          */
long int sys$sndsmb() ;
/*  $SNDJBC                                                                 */
/*                                                                          */
/*    Send Message to Job Controller                                        */
/*                                                                          */
/*     $SNDJBC   [efn], func, [nullarg], [itmlst],                          */
/*    ($SNDJBCW) [iosb], [astadr], [astprm]                                 */
/*                                                                          */
/*     efn     = event flag to be set when request completes                */
/*     func    = code specifying function to be performed                   */
/*     nullarg = reserved argument for similarity with $getxxx services     */
/*     itmlst  = address of a list of item descriptors for the operation    */
/*     iosb    = address of a quadword status block to receive the final status */
/*     astadr  = address of an ast routine to be called when request completes */
/*     astprm  = 32-bit ast parameter                                       */
/*                                                                          */
long int sys$sndjbc() ;
long int sys$sndjbcw() ;
/*                                                                          */
/*  $SPACE                                                                  */
/*                                                                          */
/*    Space to Record in File                                               */
/*                                                                          */
/*      $SPACE rab, [err], [suc]                                            */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$space() ;
/*  $SUSPND                                                                 */
/*                                                                          */
/*    Suspend Process                                                       */
/*                                                                          */
/*     $SUSPND  [pidadr] ,[prcnam], [flags]                                 */
/*                                                                          */
/*     pidadr = address of process id of process to be suspended            */
/*                                                                          */
/*     prcnam = address of name string descriptor of process                */
/*                                                                          */
/*     flags  = longword of bit flags, of which only bit 0 is               */
/*		  currently used.  If bit 0 is set, then this               */
/*		  is a hard suspend request; if clear this is               */
/*		  a soft suspend request.                                   */
/*                                                                          */
long int sys$suspnd() ;
/*  $SYNCH                                                                  */
/*                                                                          */
/*    Synchronize Event Completion                                          */
/*                                                                          */
/*     $SYNCH [iosb] ,[efn]                                                 */
/*                                                                          */
/*     efn    = event flag to be set at completion                          */
/*                                                                          */
/*     iosb   = address of a quadword I/O status block                      */
/*                                                                          */
long int sys$synch() ;
/*  $TRNLNM                                                                 */
/*                                                                          */
/*    Translate Logical Name                                                */
/*                                                                          */
/*     $TRNLNM  [attr], tabnam, [lognam], [acmode], [itemlist]              */
/*                                                                          */
/*     attr = address of logical name translation attributes                */
/*                                                                          */
/*	Attribute	 Meaning                                            */
/*	LNM$M_CASE_BLIND Search of string is case insensitive               */
/*                                                                          */
/*     tabnam = address of logical name table name string descriptor        */
/*                                                                          */
/*     lognam = address of logical name string descriptor                   */
/*                                                                          */
/*     acmode = address of access mode for logical name                     */
/*                                                                          */
/*     itmlst = address of a list of item descriptors                       */
/*                                                                          */
long int sys$trnlnm() ;
/*  $TRNLOG                                                                 */
/*                                                                          */
/*    Translate Logical Name                                                */
/*                                                                          */
/*     $TRNLOG  lognam ,[rsllen] ,rslbuf ,[table] ,[acmode] ,[dsbmsk]       */
/*                                                                          */
/*     lognam = address of logical name string descriptor                   */
/*                                                                          */
/*     rsllen = address of word to receive length of resultant name         */
/*                                                                          */
/*     rslbuf = address of descriptor for buffer to receive resultant       */
/*              string                                                      */
/*                                                                          */
/*     table  = address of byte to receive logical name table number        */
/*                                                                          */
/*     acmode = address of byte to receive access mode of entry             */
/*              (process table only)                                        */
/*                                                                          */
/*     dsbmsk = table search disable mask                                   */
/*                                                                          */
/*       Bit Set    Meaning                                                 */
/*                                                                          */
/*          0       Do not search system table                              */
/*          1       Do not search group table                               */
/*          2       Do not search process table                             */
/*                                                                          */
long int sys$trnlog() ;
/*                                                                          */
/*  $TRUNCATE                                                               */
/*                                                                          */
/*    Truncate Record                                                       */
/*                                                                          */
/*      $TRUNCATE rab, [err], [suc]                                         */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$truncate() ;
/*  $ULKPAG                                                                 */
/*                                                                          */
/*    Unlock Pages From Memory                                              */
/*                                                                          */
/*     $ULKPAG  inadr ,[retadr] ,[acmode]                                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending virtual addresses of pages to be unlocked            */
/*                                                                          */
/*     retadr = address of a 2-longword array to receive starting and       */
/*              ending virtual addresses of pages actually unlocked         */
/*                                                                          */
/*     acmode = access mode to check against the owner of the pages         */
/*                                                                          */
long int sys$ulkpag() ;
/*  $ULWSET                                                                 */
/*                                                                          */
/*    Unlock Pages From Working Set                                         */
/*                                                                          */
/*     $ULWSET  inadr ,[retadr] ,[acmode]                                   */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending virtual addresses of pages to be unlocked            */
/*                                                                          */
/*     retadr = address of a 2-longword array to receive starting and       */
/*              ending virtual addresses of pages actually unlocked         */
/*                                                                          */
/*     acmode = access mode to check against the owner of the pages         */
/*                                                                          */
long int sys$ulwset() ;
/*  $UNWIND                                                                 */
/*                                                                          */
/*    Unwind Call Stack                                                     */
/*                                                                          */
/*     $UNWIND  [depadr] ,[newpc]                                           */
/*                                                                          */
/*     depadr = address of longword containing number of logical frames     */
/*              (depth) to unwind call stack                                */
/*                                                                          */
/*     newpc  = address to be given control when the unwind is complete     */
/*                                                                          */
long int sys$unwind() ;
/*                                                                          */
/*  $UPDATE                                                                 */
/*                                                                          */
/*    Update Record                                                         */
/*                                                                          */
/*      $UPDATE fab, [err], [suc]                                           */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$update() ;
/*  $UPDSEC                                                                 */
/*                                                                          */
/*    Update Section File on Disk                                           */
/*                                                                          */
/*     $UPDSEC  inadr ,[retadr] ,[acmode] ,[updflg] ,[efn] ,[iosb]          */
/*     ($UPDSECW)  ,[astadr] ,[astprm]                                      */
/*                                                                          */
/*     inadr  = address of 2-longword array containing starting and         */
/*              ending  addresses  of  the  pages  to  be potentially       */
/*              written                                                     */
/*                                                                          */
/*     retadr = address of 2-longword array to receive  addresses  of       */
/*              the  first  and  last  page  queued  in the first I/O       */
/*              request                                                     */
/*                                                                          */
/*     acmode = access  mode  on  behalf  of  which  the  service  is       */
/*              performed                                                   */
/*                                                                          */
/*     updflg = update indicator for read/write global sections             */
/*                0 -> write all read/write pages in the section            */
/*                1 -> write all pages modified by the caller               */
/*                                                                          */
/*     efn    = number of event flag to set when the section file  is       */
/*              updated                                                     */
/*                                                                          */
/*     iosb   = address of quadword I/O status block                        */
/*                                                                          */
/*     astadr = address of entry mask of an AST service routine             */
/*                                                                          */
/*     astprm = AST parameter to be passed to the AST service routine       */
/*                                                                          */
long int sys$updsec() ;
long int sys$updsecw() ;
/*                                                                          */
/*  $WAIT                                                                   */
/*                                                                          */
/*    Wait on File                                                          */
/*                                                                          */
/*      $WAIT rab                                                           */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*                                                                          */
long int sys$wait() ;
/*  $WAITFR                                                                 */
/*                                                                          */
/*    Wait for Single Event Flag                                            */
/*                                                                          */
/*     $WAITFR  efn                                                         */
/*                                                                          */
/*     efn    = event flag number to wait for                               */
/*                                                                          */
long int sys$waitfr() ;
/*  $WAKE                                                                   */
/*                                                                          */
/*    Wake                                                                  */
/*                                                                          */
/*     $WAKE  [pidadr] ,[prcnam]                                            */
/*                                                                          */
/*     pidadr = address of process id  of process to be awakened            */
/*                                                                          */
/*     prcnam = address of name string descriptor of process to be          */
/*              awakened                                                    */
/*                                                                          */
long int sys$wake() ;
/*  $WFLAND                                                                 */
/*                                                                          */
/*    Wait for Logical AND of Event Flags                                   */
/*                                                                          */
/*     $WFLAND  efn ,mask                                                   */
/*                                                                          */
/*     efn    = event flag number of any flag within the cluster            */
/*                                                                          */
/*     mask   = 32-bit mask of flags that must be set                       */
/*                                                                          */
long int sys$wfland() ;
/*  $WFLOR                                                                  */
/*                                                                          */
/*    Wait for Logical OR of Event Flags                                    */
/*                                                                          */
/*     $WFLOR  efn ,mask                                                    */
/*                                                                          */
/*     efn    = event flag number of any flag within the cluster            */
/*                                                                          */
/*     mask   = 32-bit mask of flags, any of which must be set              */
/*                                                                          */
long int sys$wflor() ;
/*                                                                          */
/*  $WRITE                                                                  */
/*                                                                          */
/*    Write Block to  File                                                  */
/*                                                                          */
/*      $WRITE rab, [err], [suc]                                            */
/*                                                                          */
/*      rab	= address of rab                                            */
/*                                                                          */
/*	err	= address of user error completion routine                  */
/*                                                                          */
/*	suc	= address of user success completion routine                */
/*                                                                          */
long int sys$write() ;

#endif					/* __STARLET_LOADED */
#ifndef __STAT_LOADED
#define __STAT_LOADED	1

/*	STAT - V3.0	*/

/*
 * Include file for use with stat/fstat UNIX emulation functions
 */

typedef unsigned off_t;
typedef unsigned short ino_t;
typedef char *dev_t;
struct  stat
{
        dev_t   st_dev;		/* pointer to physical device name */
        ino_t   st_ino[3];	/* 3 words to receive fid */
        unsigned short st_mode;	/* file "mode" i.e. prot, dir, reg, etc. */
        int	st_nlink;	/* for compatibility - not really used */
        unsigned st_uid;	/* from ACP - QIO uic field */
        unsigned short st_gid;	/* group number extracted from st_uid */
        dev_t   st_rdev;	/* for compatibility - always zero */
        off_t   st_size;	/* file size in bytes */
        unsigned st_atime;	/* file access time; always same as st_mtime */
        unsigned st_mtime;	/* last modification time */
        unsigned st_ctime;	/* file creation time */
	char	st_fab_rfm;	/* record format */
	char	st_fab_rat;	/* record attributes */
	char	st_fab_fsz;	/* fixed header size */
	unsigned st_fab_mrs;	/* record size */
};

typedef struct stat stat_t; 

#define S_IFMT   0170000         /* type of file */
#define          S_IFDIR 0040000 /* directory */
#define          S_IFCHR 0020000 /* character special */
#define          S_IFBLK 0060000 /* block special */
#define          S_IFREG 0100000 /* regular */
#define          S_IFMPC 0030000 /* multiplexed char special */
#define          S_IFMPB 0070000 /* multiplexed block special */
#define S_ISUID  0004000         /* set user id on execution */
#define S_ISGID  0002000         /* set group id on execution */
#define S_ISVTX  0001000         /* save swapped text even after use */
#define S_IREAD  0000400         /* read permission, owner */
#define S_IWRITE 0000200         /* write permission, owner */
#define S_IEXEC  0000100         /* execute/search permission, owner */

#endif					/* __STAT_LOADED */
#ifndef __STDARG_LOADED
#define __STDARG_LOADED	1

/*	STDARG - V3.0	*/

/*
 * Definitions for access to variable length argument lists
 * specified via the ellipsis notation in a function prototype
 */

#ifdef __VARARGS_LOADED
#undef __VARARGS_LOADED
#undef va_dcl
#undef va_count
#undef va_start_1
#undef va_start
#undef va_arg
#undef va_end
#else
typedef char *	va_list;
#endif

#define va_start(ap, parmN)	ap = (va_list) ((int) &parmN + ((sizeof (parmN) + 3) & ~3))
#define va_arg(ap, type)	(ap = (va_list) ((int) ap + ((sizeof (type) + 3) & ~3)), \
 * (type *) ((int) ap - ((sizeof (type) + 3) & ~3)))
#define va_end(ap)		ap = (va_list) 0

#endif					/* __STDARG_LOADED */
#ifndef __STDDEF_LOADED
#define __STDDEF_LOADED	1

/*	STDDEF - V3.0	*/

typedef int ptrdiff_t;
typedef unsigned int size_t;
typedef unsigned int wchar_t;
#define NULL		(void *) 0
#define offsetof( type, identifier)			\
     	((size_t)(&((type*) NULL)->identifier))

#endif					/* __STDDEF_LOADED */
#ifndef __STDIO_LOADED
#define __STDIO_LOADED	1

/*	STDIO - V3.0 - UNIX 'Standard I/O' Definitions	*/

#pragma nostandard
# include stddef

# define _NFILE 20
# define BUFSIZ 512
# define _IOLBF 1
# define _IOFBF 2

	extern	struct	_iobuf 
		{
		int	_cnt;
		char	*_ptr;
		char	*_base;
		char	_flag;

#define	_IOREAD		0x01
#define	_IOWRT		0x02
#define	_IONBF		0x04
#define	_IOMYBUF	0x08
#define	_IOEOF		0x10
#define	_IOERR		0x20
#define	_IOSTRG		0x40
#define _IORW		0x80

		char	_file;

		};

typedef struct _iobuf*	FILE;
typedef struct {unsigned : 32; unsigned : 32;} fpos_t;

#ifdef CC$VAXCSHR

#define	stdin (*vaxc$ga_stdin)
#define	stdout (*vaxc$ga_stdout)
#define	stderr (*vaxc$ga_stderr)

globalref	FILE	*stdin, *stdout, *stderr;

#else

extern noshare	FILE	*stdin, *stdout, *stderr;

#endif

#pragma standard

#pragma NOSTANDARD
#undef  NULL
#pragma STANDARD

#define	NULL		(void *) 0
#define	EOF		(-1)
#define	TRUE		1
#define	FALSE		0

# define SEEK_SET 0
# define SEEK_CUR 1
# define SEEK_EOF 2
# define SEEK_END 2		/* ANSI C defintion */

# define FOPEN_MAX 8
# define OPEN_MAX 8
# define TMP_MAX  32
# define FILENAME_MAX 39

#define L_ctermid	64
#define L_cuserid	16
#define L_tmpnam	256
#define L_lcltmpnam	256
#define L_nettmpnam	256

#pragma NOSTANDARD
#undef getc
#undef getchar
#undef putc
#undef putchar
#undef feof
#undef ferror
#undef clearerr
#pragma STANDARD

#define getc(p)		fgetc(p)
#define getchar()	fgetc(stdin)
#define putc(x,p)	fputc(x,p)
#define putchar(x)	fputc(x,stdout)
#define feof(p)		(((*p)->_flag&_IOEOF)!=0)
#define ferror(p)	(((*p)->_flag&_IOERR)!=0)
#ifndef CC$VAXCSHR
#pragma NOSTANDARD
#undef fileno
#pragma STANDARD
#define fileno(p)	((*p)->_file)
#endif
#define clearerr(p)	((*p)->_flag &= ~(_IOERR|_IOEOF))

#define vaxc$record_read(fp, buf, max_size) read(fileno(fp),(buf),(max_size))
#define vaxc$record_write(fp, buf, size) fwrite((buf),(size),1,(fp))

#define FILE_TYPE	struct _iobuf *

int fsetpos (FILE *file_ptr, const fpos_t *position);

int fgetpos (FILE *file_ptr, fpos_t *position);

char *fgetname (FILE *file_ptr, char *buffer, ...);

FILE *fopen (const char *filespec, const char *a_mode, ...);

FILE *fdopen (int file_desc, char *a_mode);

FILE *freopen (const char *file_spec, const char *a_mode, FILE *file_ptr, ...);

int fclose (FILE *file_ptr);

int fgetc (FILE *file_ptr);
int getw (FILE *file_ptr);

char *fgets (char *str, int maxchar, FILE *file_ptr);
char *gets  (char *str);

int fputs (const char *str, FILE *file_ptr);
int puts (char *str);

size_t fread (void *ptr, size_t size_of_item, 
			size_t number_items, FILE *file_ptr);

size_t fwrite (void *ptr, size_t size_of_item,
			 size_t number_items, FILE *file_ptr);

int ungetc (int character, FILE *file_ptr);

#pragma NOSTANDARD
#undef vsprintf
#undef vprintf
#undef vfprintf
#undef sprintf
#undef printf
#undef fprintf
#undef sscanf
#undef scanf
#undef fscanf
#pragma STANDARD

int fscanf (FILE *file_ptr, const char *format_spec, ...);
int scanf  (const char *format_spec, ...);
int sscanf (char *str, const char *format_spec, ...);

int fprintf (FILE *file_ptr, const char *format_spec, ...);
int printf  (const char *format_spec, ...);
int sprintf (char *str, const char *format_spec, ...);

/* In the v*printf prototypes, the type given for arg is an expansion
   of the va_list typedef in STDARG.H */
int vfprintf (FILE *file_ptr, const char *format, char * arg); 
int vprintf  (const char *format, char * arg);
int vsprintf (char *s, const char *format, char * arg);

int fputc (int character, FILE *file_ptr);
int putw (int integer, FILE *file_ptr);

int fflush (FILE *file_ptr);

int fseek (FILE *file_ptr, int offset, int direction);

int ftell (FILE *file_ptr);

void perror (const char *str);

int rewind (FILE *file_ptr);

int remove (const char *file_spec);

FILE *tmpfile (void);

char *tmpnam (char *name);

void setbuf (FILE *file_ptr, char *buffer);
int setvbuf (FILE *file_ptr, char *buffer, int type, size_t size);

#if defined(CC$mixed_float) || defined(CC$VAXCSHR)
/* 
 * For DEC C, CC$gfloat's definition was modified so that it's defined when
 * g_float is in effect, and undefined otherwise.  The following code makes
 * the new behavior compatible with the old.
 */
#ifndef CC$gfloat
#define CC$gfloat 0
#endif

#if CC$gfloat
int vaxc$gvsprintf (char *s, const char *format, char * arg);

int vaxc$gvprintf  (const char *format, char * arg);

int vaxc$gvfprintf (FILE *file_ptr, const char *format, char * arg); 

int vaxc$gsprintf (char *str, const char *format_spec, ...);

int vaxc$gprintf  (const char *format_spec, ...);

int vaxc$gfprintf (FILE *file_ptr, const char *format_spec, ...);

int vaxc$gsscanf (char *str, const char *format_spec, ...);

int vaxc$gscanf  (const char *format_spec, ...);

int vaxc$gfscanf (FILE *file_ptr, const char *format_spec, ...);

#else

int vaxc$dvsprintf (char *s, const char *format, char * arg);

int vaxc$dvprintf  (const char *format, char * arg);

int vaxc$dvfprintf (FILE *file_ptr, const char *format, char * arg); 

int vaxc$dsprintf (char *str, const char *format_spec, ...);

int vaxc$dprintf  (const char *format_spec, ...);

int vaxc$dfprintf (FILE *file_ptr, const char *format_spec, ...);

int vaxc$dsscanf (char *str, const char *format_spec, ...);

int vaxc$dscanf  (const char *format_spec, ...);

int vaxc$dfscanf (FILE *file_ptr, const char *format_spec, ...);

#define vsprintf vaxc$dvsprintf
#define vprintf vaxc$dvprintf
#define vfprintf vaxc$dvfprintf
#define sprintf vaxc$dsprintf
#define printf vaxc$dprintf
#define fprintf vaxc$dfprintf
#define sscanf vaxc$dsscanf
#define scanf vaxc$dscanf
#define fscanf vaxc$dfscanf

#endif
#endif

#endif					/* __STDIO_LOADED */
#ifndef __STDLIB_LOADED
#define __STDLIB_LOADED	1

/*	STDLIB - V3.0 - General utility definitions	*/

#pragma nostandard
#include stddef
#pragma standard

#define RAND_MAX 2147483647

#define EXIT_FAILURE 2
#define EXIT_SUCCESS 0

struct DIV_T {
    int quot,rem;
    };
typedef struct DIV_T div_t;

struct LDIV_T {
    long quot,rem;
    };
typedef struct LDIV_T ldiv_t;

#pragma NOSTANDARD
#undef atof
#undef strtod
#pragma STANDARD

double atof(const char *nptr);

int atoi(const char *nptr);

long int atol(const char *nptr);

double strtod(const char *nptr, char **endptr);
#if defined(CC$mixed_float) || defined(CC$VAXCSHR)
/* 
 * For DEC C, CC$gfloat's definition was modified so that it's defined when
 * g_float is in effect, and undefined otherwise.  The following makes the
 * old behavior compatible with the new.
 */
#ifndef CC$gfloat
#define CC$gfloat 0
#endif

#if CC$gfloat
double vaxc$gatof(const char *nptr);

double vaxc$gstrtod(const char *nptr, char **endptr);

#define atof vaxc$gatof
#define strtod vaxc$gstrtod

#else
double vaxc$gatof(const char *nptr);

double vaxc$dstrtod(const char *nptr, char **endptr);

#define atof vaxc$gatof
#define strtod vaxc$dstrtod

#endif
#endif

long int strtol(const char *nptr, char **endptr, int base);

unsigned long int strtoul(const char *nptr, char **endptr, int base );

int rand(void);

int srand(int seed);

void *calloc(size_t nmemb, size_t size);

void cfree (void *ptr);

void free (void *ptr);

void *malloc(size_t size);

void *realloc(void *ptr, size_t size);

/* 
 * CC$parallel's definition was modified so that it's defined when
 * /PARALLEL is in effect, and undefined otherwise.  The syntax below is used
 * to allow VAX C to still be able to compile the header files correctly. 
*/
#ifdef CC$parallel
#if CC$parallel

void *lib$vm_calloc_p(size_t nmemb, size_t size);
#define calloc lib$vm_calloc_p

void lib$vm_cfree_p (void *ptr);
#define cfree lib$vm_cfree_p

void lib$vm_free_p (void *ptr);
#define free lib$vm_free_p

void *lib$vm_malloc_p(size_t size);
#define malloc lib$vm_malloc_p

void *lib$vm_realloc_p(void *ptr, size_t size);
#define realloc lib$vm_realloc_p
#endif
#endif

void abort(void);

void exit(int status);

char *getenv(const char *name);

int atexit(void (*func)(void));

int system(const char *string);

void *bsearch(const void *key, const void *base, size_t nmemb,
     	      size_t size, int (*compar)(void *, void *));

void qsort(void *base, size_t nmemb, size_t size,
     	   int (*compar)(void *, void *));

int abs(int j);

div_t div(int number, int denom);

long int labs(long int j);

ldiv_t ldiv(long int numer, long int denom);

#endif					/* __STDLIB_LOADED */
#ifndef __STR$ROUTINES_LOADED
#define __STR$ROUTINES_LOADED	1

/*** MODULE str$routines ***/
/**************************************************************************** */
/*									    * */
/*  COPYRIGHT (c) 1988 BY               				    * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/*  ALL RIGHTS RESERVED.						    * */
/* 									    * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *  */
/*  TRANSFERRED.			       				    * */
/* 									    * */
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/*  CORPORATION.							    * */
/* 									    * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/* 									    * */
/*									    * */
/**************************************************************************** */
/*    STR$ADD                                                               */
/*                                                                          */
/*    Add Two Decimal Strings                                               */
/*                                                                          */
/*    The Add Two Decimal Strings routine                                   */
/*    adds two decimal strings of digits.                                   */
/*                                                                          */
unsigned long int str$add() ;
/*    STR$ANALYZE_SDESC                                                     */
/*                                                                          */
/*    Analyze String Descriptor                                             */
/*                                                                          */
/*    The Analyze String Descriptor routine extracts the                    */
/*    length and starting address of the data                               */
/*    for a variety of string descriptor classes.                           */
/*                                                                          */
int str$analyze_sdesc() ;
/*    STR$APPEND                                                            */
/*                                                                          */
/*    Append String                                                         */
/*                                                                          */
/*    The Append String routine appends a source string to the end of a destination string.  */
/*    The destination string must be a dynamic or varying-length string.    */
/*                                                                          */
unsigned long int str$append() ;
/*    STR$CASE_BLIND_COMPARE                                                */
/*                                                                          */
/*    Compare Strings Without Regard to Case                                */
/*                                                                          */
/*    The Compare Strings Without Regard to Case routine compares two input  */
/*    strings of any supported class                                        */
/*    and data type without regard to whether the alphabetic characters are uppercase  */
/*    or lowercase.                                                         */
/*                                                                          */
long int str$case_blind_compare() ;
/*    STR$COMPARE                                                           */
/*                                                                          */
/*    Compare Two Strings                                                   */
/*                                                                          */
/*    The Compare Two Strings routine compares the                          */
/*    contents of two strings.                                              */
/*                                                                          */
long int str$compare() ;
/*    STR$CONCAT                                                            */
/*                                                                          */
/*    Concatenate Two or More Strings                                       */
/*                                                                          */
/*    The Concatenate Two or More Strings routine concatenates all specified */
/*    source strings into a single destination string.                      */
/*                                                                          */
unsigned long int str$concat() ;
/*    STR$COPY_DX                                                           */
/*                                                                          */
/*    Copy a Source String Passed by Descriptor to a Destination String     */
/*                                                                          */
/*    The Copy a Source String Passed by Descriptor to                      */
/*    a Destination String routine copies a source string to                */
/*    a destination string. Both strings are                                */
/*    passed by descriptor.                                                 */
/*                                                                          */
unsigned long int str$copy_dx() ;
/*    STR$COPY_R                                                            */
/*                                                                          */
/*    Copy a Source String Passed by Reference to a Destination String      */
/*                                                                          */
/*    The Copy a Source String Passed by Reference to                       */
/*    a Destination String routine copies a source string passed by reference to a destination */
/*    string.                                                               */
/*                                                                          */
unsigned long int str$copy_r() ;
/*    STR$DIVIDE                                                            */
/*                                                                          */
/*    Divide Two Decimal Strings                                            */
/*                                                                          */
/*    The Divide Two Decimal Strings routine divides two decimal strings.   */
/*                                                                          */
unsigned long int str$divide() ;
/*    STR$DUPL_CHAR                                                         */
/*                                                                          */
/*    Duplicate Character  Times                                            */
/*                                                                          */
/*    The Duplicate Character empty Times routine                           */
/*    generates a string containing n duplicates of the input               */
/*    character. If the destination string is an empty dynamic string descriptor,  */
/*    STR$DUPL_CHAR will allocate and initialize the string.                */
/*                                                                          */
unsigned long int str$dupl_char() ;
/*    STR$ELEMENT                                                           */
/*                                                                          */
/*    Extract Delimited Element Substring                                   */
/*                                                                          */
/*    The Extract Delimited Element Substring routine                       */
/*    extracts an element from a string in which the elements are separated  */
/*    by a specified delimiter.                                             */
/*                                                                          */
unsigned long int str$element() ;
/*    STR$COMPARE_EQL                                                       */
/*                                                                          */
/*    Compare Two Strings for Equality                                      */
/*                                                                          */
/*    The Compare Two Strings for Equality routine, compares two            */
/*    strings to see if they have the same length                           */
/*    and contents. Uppercase and lowercase characters are not considered equal. */
/*                                                                          */
unsigned long int str$compare_eql() ;
/*    STR$FIND_FIRST_IN_SET                                                 */
/*                                                                          */
/*    Find First Character in a Set of Characters                           */
/*                                                                          */
/*    The Find First Character in a Set of                                  */
/*    Characters routine                                                    */
/*    searches a string one character at a time, from                       */
/*    left to right, comparing each character in the string to every character in */
/*    a specified set of characters for which it is searching.              */
/*                                                                          */
long int str$find_first_in_set() ;
/*    STR$FIND_FIRST_NOT_IN_SET                                             */
/*                                                                          */
/*    Find First Character that Does Not Occur in Set                       */
/*                                                                          */
/*    The Find First Character that Does Not                                */
/*    Occur in Set routine                                                  */
/*    searches a string, comparing each character to the                    */
/*    characters in a specified set of characters.  The string is searched character */
/*    by character, from left to right.  STR$FIND_FIRST_NOT_IN_SET returns the */
/*    position of the first character in the string that does not match any of the */
/*    characters in the selected set of characters.                         */
/*                                                                          */
long int str$find_first_not_in_set() ;
/*    STR$FREE1_DX                                                          */
/*                                                                          */
/*    Free One Dynamic String                                               */
/*                                                                          */
/*    The Free One Dynamic String routine                                   */
/*    deallocates one dynamic string.                                       */
/*                                                                          */
unsigned long int str$free1_dx() ;
/*    STR$FIND_FIRST_SUBSTRING                                              */
/*                                                                          */
/*    Find First Substring in Input String                                  */
/*                                                                          */
/*    The Find First Substring in Input String routine                      */
/*    finds the first substring (in a provided list of                      */
/*    substrings) occurring in a given string.                              */
/*                                                                          */
unsigned long int str$find_first_substring() ;
/*    STR$GET1_DX                                                           */
/*                                                                          */
/*    Allocate One Dynamic String                                           */
/*                                                                          */
/*    The Allocate One Dynamic String routine                               */
/*    allocates a specified number of bytes of dynamic virtual memory       */
/*    to a specified dynamic string descriptor.                             */
/*                                                                          */
unsigned long int str$get1_dx() ;
/*    STR$LEFT                                                              */
/*                                                                          */
/*    Extract a Substring of a String                                       */
/*                                                                          */
/*    The Extract a Substring of a String routine copies a substring of a   */
/*    source string into a                                                  */
/*    destination string. The relative starting position in the source      */
/*    string is 1.                                                          */
/*                                                                          */
unsigned long int str$left() ;
/*    STR$LEN_EXTR                                                          */
/*                                                                          */
/*    Extract a Substring of a String                                       */
/*                                                                          */
/*    The Extract a Substring of a String routine copies a                  */
/*    substring of a source string into a                                   */
/*    destination string.                                                   */
/*                                                                          */
unsigned long int str$len_extr() ;
/*    STR$MATCH_WILD                                                        */
/*                                                                          */
/*    Match Wildcard Specification                                          */
/*                                                                          */
/*    The Match Wildcard Specification routine is used to compare a         */
/*    pattern string that includes wildcard                                 */
/*    characters with a candidate string.  It returns a condition value of STR$_MATCH */
/*    if the strings match and line_break STR$_NOMATCH if they do not match.  */
/*                                                                          */
unsigned long int str$match_wild() ;
/*    STR$MUL                                                               */
/*                                                                          */
/*    Multiply Two Decimal Strings                                          */
/*                                                                          */
/*    The Multiply Two Decimal Strings routine multiplies two decimal strings. */
/*                                                                          */
unsigned long int str$mul() ;
/*    STR$COMPARE_MULTI                                                     */
/*                                                                          */
/*    Compare Two Strings for Equality Using Multinational Character Set    */
/*                                                                          */
/*    The Compare Two Strings for Equality Using                            */
/*    Multinational Character Set routine compares two character            */
/*    strings for equality using the                                        */
/*    DEC Multinational character set.                                      */
/*                                                                          */
long int str$compare_multi() ;
/*    STR$POS_EXTR                                                          */
/*                                                                          */
/*    Extract a Substring of a String                                       */
/*                                                                          */
/*    The Extract a Substring of a String routine                           */
/*    copies a substring of a source string into a                          */
/*    destination string.                                                   */
/*                                                                          */
unsigned long int str$pos_extr() ;
/*    STR$POSITION                                                          */
/*                                                                          */
/*    Return Relative Position of Substring                                 */
/*                                                                          */
/*    The Return Relative Position of Substring routine                     */
/*    searches for the first occurrence of a                                */
/*    single substring within a source string.  If STR$POSITION finds the substring,  */
/*    it returns the relative position of that substring.                   */
/*    If the substring is not found, STR$POSITION returns a zero.           */
/*                                                                          */
unsigned long int str$position() ;
/*    STR$PREFIX                                                            */
/*                                                                          */
/*    Prefix a String                                                       */
/*                                                                          */
/*    The Prefix a String routine                                           */
/*    inserts a source string at the beginning of a destination             */
/*    string. The destination string must be dynamic or varying length.     */
/*                                                                          */
unsigned long int str$prefix() ;
/*    STR$RECIP                                                             */
/*                                                                          */
/*    Reciprocal of a Decimal String                                        */
/*                                                                          */
/*    The Reciprocal of a Decimal String routine                            */
/*    takes the reciprocal of the first decimal string to the precision     */
/*    limit specified by the second decimal string and returns the result as a */
/*    decimal string.                                                       */
/*                                                                          */
unsigned long int str$recip() ;
/*    STR$REPLACE                                                           */
/*                                                                          */
/*    Replace a Substring                                                   */
/*                                                                          */
/*    The Replace a Substring routine                                       */
/*    copies a source string to a destination string, replacing part        */
/*    of the string with another string.  The substring to be replaced is   */
/*    specified by its starting and ending positions.                       */
/*                                                                          */
unsigned long int str$replace() ;
/*    STR$RIGHT                                                             */
/*                                                                          */
/*    Extract a Substring of a String                                       */
/*                                                                          */
/*    The Extract a Substring of a String routine                           */
/*    copies a substring of a source string into a                          */
/*    destination string.                                                   */
/*                                                                          */
unsigned long int str$right() ;
/*    STR$ROUND                                                             */
/*                                                                          */
/*    Round or Truncate a Decimal String                                    */
/*                                                                          */
/*    The Round or Truncate a Decimal String routine                        */
/*    rounds or truncates a decimal string to a specified number of         */
/*    significant digits and places the result in another decimal string.   */
/*                                                                          */
unsigned long int str$round() ;
/*    STR$TRANSLATE                                                         */
/*                                                                          */
/*    Translate Matched Characters                                          */
/*                                                                          */
/*    The Translate Matched Characters routine successively compares each character in a source string */
/*    to all characters in a match string.  If a source character has a match,  */
/*    the destination character is taken from the translate string.  Otherwise, */
/*    STR$TRANSLATE moves the source character to the destination string.   */
/*                                                                          */
unsigned long int str$translate() ;
/*    STR$TRIM                                                              */
/*                                                                          */
/*    Trim Trailing Blanks and Tabs                                         */
/*                                                                          */
/*    The Trim Trailing Blanks and Tabs routine                             */
/*    copies a source string to a destination string and deletes the        */
/*    trailing blank and tab characters.                                    */
/*                                                                          */
unsigned long int str$trim() ;
/*    STR$UPCASE                                                            */
/*                                                                          */
/*    Convert String to All Uppercase Characters                            */
/*                                                                          */
/*    The Convert String to All Uppercase Characters routine                */
/*    converts a source string to uppercase.                                */
/*                                                                          */
unsigned long int str$upcase() ;

#endif					/* __STR$ROUTINES_LOADED */
#ifndef __STRDEF_LOADED
#define __STRDEF_LOADED	1

/*** MODULE $strdef ***/
/*                                                                          */
/* This SDL File Generated by VAX-11 Message V04-00 on  8-APR-1988 06:19:46.10 */
/*                                                                          */
/* FILE: STRMSG.MSG  EDIT: JWN2008                                          */
/*                                                                          */
/***************************************************************************** */
/**									    * */
/**  COPYRIGHT (C) 1978, 1980, 1982, 1984 BY				    * */
/**  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * */
/**  ALL RIGHTS RESERVED.						    * */
/** 									    * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * */
/**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * */
/**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * */
/**  TRANSFERRED.							    * */
/** 									    * */
/**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * */
/**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * */
/**  CORPORATION.							    * */
/** 									    * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * */
/** 									    * */
/**									    * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/* 2-001 - CONVERT TO MESSAGE UTILITY SOURCE FORMAT.  ADAPTED FROM STRMSG.MSG */
/*	  VERSION 1-004.  SBL 22-APR-1981                                   */
/* 2-005 - ADD .TITLE AND .IDENT.  SBL 28-AUG-1982                          */
/* 2-002 - DON'T DEFINE STR$_NORMAL HERE, DO IT IN STRMSGDEF.MAR.  SBL 27-APR-1981 */
/* 2-003 - ADD STR$_MATCH AND STR$_NOMATCH.  RKR 2-JUL-1982                 */
/* 2-004 - NOW DEFINE STR$_NORMAL HERE.  SBL 24-AUG-1982                    */
/* 2-006 - ADD DEFINITIONS FOR STR$_INVDELIM (INVALID DELIMITER) AND        */
/*	  STR$_NOELEM (NO ELEMENT FOUND), TWO NEW STATUS VALUES TO BE       */
/*      	  USED BY STR$ELEMENT.  ROW 03-NOV-1986                     */
/* 2-007 - ADD STR$_ERRFREDYN, USED WHEN LIB$FREE_VM BARFS ON A STRING      */
/*	  WE ARE TRYING TO FREE. IE. THE USER HAS A CLASS_D DESCR POINTING  */
/*	  AT SOME ARBITRARY MEMORY.                                         */
/* 2-008 - REMOVE FIRST LETTER CAPITALIZATION FROM ERROR MESSAGES.          */
/*							JWN 26-APR-1987     */
/*+                                                                         */
/* SYMBOLS ARE DEFINED FOLLOWING THE STANDARD FOR GLOBAL NAMES:             */
/*                                                                          */
/*	STR$_ABCMNOXYZ                                                      */
/*                                                                          */
/* IN ADDITION, THE LIBRARY STANDARDS SPECIFY THAT THE LETTERS "abc", "mno", */
/* AND "xyz" ARE THE FIRST THREE LETTERS OF THE FIRST THREE WORDS OF THE ERROR */
/* MESSAGE, NOT COUNTING ARTICLES AND PREPOSITIONS.                         */
/*                                                                          */
/*                                                                          */
/* MACRO-32 PROGRAMMING:                                                    */
/*                                                                          */
/* THE MACRO CALL:                                                          */
/*                                                                          */
/*	$STRDEF                                                             */
/*                                                                          */
/* WILL CAUSE ALL SYMBOLS TO BE MADE AVAILABLE TO THE MODULE.               */
/* THE RUN-TIME LIBRARY DECLARES THESE SYMBOLS AS EXTERNAL;                 */
/* THE MACROS ARE PROVIDED ONLY FOR THE CONVENIENCE OF THE USER.            */
/*-                                                                         */
/*                                                                          */
/* THE FOLLOWING SEVERE ERRORS ARE ALWAYS SIGNALLED.                        */
/*                                                                          */
/*			; NOTE: ERROR CODES MUST NOT OVERLAP SUCESS CODES!!! */
#define STR$_FACILITY 36
#define STR$_FATINTERR 2392132
#define STR$_DIVBY_ZER 2392140
#define STR$_ILLSTRCLA 2392148
#define STR$_STRIS_INT 2392156
#define STR$_WRONUMARG 2392164
#define STR$_INSVIRMEM 2392172
#define STR$_STRTOOLON 2392180
#define STR$_ERRFREDYN 2392188
/*                                                                          */
/* THE FOLLOWING ARE WARNING ERRORS.                                        */
/*                                                                          */
/*			; GO IN STEPS OF 8.                                 */
#define STR$_TRU 2392576
#define STR$_NOMATCH 2392584
#define STR$_INVDELIM 2392592
#define STR$_NOELEM 2392600
/*                                                                          */
/* THE FOLLOWING ARE QUALIFIED SUCCESS MESSAGES                             */
/*                                                                          */
/*			; GO IN STEPS OF 8.                                 */
#define STR$_NEGSTRLEN 2393089
#define STR$_ILLSTRPOS 2393097
#define STR$_ILLSTRSPE 2393105
#define STR$_MATCH 2393113
/*                                                                          */
/* DEFINE STR$_NORMAL TO BE THE SAME AS SS$_NORMAL.                         */
/*                                                                          */
#define STR$_NORMAL 1
/*                                                                          */

#endif					/* __STRDEF_LOADED */
#ifndef __STRING_LOADED
#define __STRING_LOADED	1

/*	STRING - V3.0 - String handling function definitions	*/

#pragma nostandard
#include stddef
#pragma standard

char   *strcpy	(char *s1, const char *s2);
char   *strncpy	(char *s1, const char *s2, size_t n);
char   *strcat	(char *s1, const char *s2);
char   *strncat	(char *s1, const char *s2, size_t n);
int	strcmp	(const char *s1, const char *s2);
int	strncmp	(const char *s1, const char *s2, size_t n);
char   *strchr	(const char *s, int character);
char   *strrchr	(const char *s, int character);
size_t	strspn	(const char *s1, const char *s2);
size_t	strcspn	(const char *s1, const char *s2);
size_t	strlen	(const char *s);
char   *strpbrk	(const char *s1, const char *s2);
char   *strstr	(const char *s1, const char *s2);
char   *strtok	(char *s1, const char *s2);
char   *strerror(int errnum, ...);

int	memcmp	(const void *s1, const void *s2, size_t size);
void   *memchr	(const void *s1, int c, size_t size);
void   *memcpy	(void *s1, const void *s2, size_t size);
void   *memmove	(void *s1, const void *s2, size_t size);
void   *memset	(void *s, int character, size_t size);

#endif					/* __STRING_LOADED */
#ifndef __STSDEF_LOADED
#define __STSDEF_LOADED	1

/*** MODULE $stsdef ***/
/*                                                                          */
/* MACROS TO DEFINE SYSTEM SERVICE FAILURE AND STATUS CODES.                */
/*                                                                          */
/*                                                                          */
/*        $STRUCT        SS                                                 */
/*                                                                          */
/* THIS STRUCTURE IS NOW CONTAINED IN 'SSMSG.MDL'                           */
/*+                                                                         */
/* Define 32-bit VAX-11 error code longword fields                          */
/* Changed to agree with Handbook - TNH 26-OCT-77 - CHANGE M 1 to P 1       */
/* Changed to agree with new status value  W. H. Brown 18-NOV-1977          */
/*-                                                                         */

#define STS$M_SEVERITY 7
#define STS$M_COND_ID 268435448
#define STS$M_CONTROL -268435456
#define STS$M_SUCCESS 1
#define STS$M_MSG_NO 65528
#define STS$M_CODE 32760
#define STS$M_FAC_SP 32768
#define STS$M_CUST_DEF 134217728
#define STS$M_INHIB_MSG 268435456
#define STS$M_FAC_NO 268369920
#define STS$K_WARNING 0                 /* WARNING                          */
#define STS$K_SUCCESS 1                 /* SUCCESSFUL COMPLETION            */
#define STS$K_ERROR 2                   /* ERROR                            */
#define STS$K_INFO 3                    /* INFORMATION                      */
#define STS$K_SEVERE 4                  /* SEVERE ERROR                     */

#pragma nostandard
union stsdef {
    variant_struct  {
        unsigned sts$v_severity : 3;    /* severity code                    */
        unsigned sts$v_cond_id : 25;    /* condition id                     */
        unsigned sts$v_control : 4;     /* control bits                     */
        } sts$r_stsdef_bits0;
    variant_struct  {
        unsigned sts$v_success : 1;     /* Success                          */
        unsigned stsdef$$_fill_1 : 2;   /* skip severity field              */
        unsigned sts$v_msg_no : 13;     /* Message number                   */
        } sts$r_stsdef_bits1;
    variant_struct  {
        unsigned stsdef$$_fill_2 : 3;   /* Skip severity field              */
        unsigned sts$v_code : 12;       /* code                             */
        unsigned sts$v_fac_sp : 1;      /* 1 if facility specific           */
        unsigned stsdef$$_fill_3 : 11;
        unsigned sts$v_cust_def : 1;    /* 1 if sub-system is customer (or CSS) defined  */
        unsigned sts$v_inhib_msg : 1;   /* 1 if message should not be printed  */
        unsigned stsdef$$_fill_4 : 3;   /* reserved control bits            */
        } sts$r_stsdef_bits2;
    variant_struct  {
        unsigned stsdef$$_fill_5 : 16;  /* Skip message nubmer field        */
        unsigned sts$v_fac_no : 12;     /* Facility is 12 bits              */
        unsigned stsdef$$_fill_6 : 4;   /* Control bits                     */
        } sts$r_stsdef_bits3;
/*+                                                                         */
/* Define severity codes                                                    */
/*-                                                                         */
    } ;
#pragma standard

#define STS$S_CODE       0x0C
#define STS$S_COND_ID    0x19
#define STS$S_CONTROL    0x04
#define STS$S_FAC_NO     0x0C
#define STS$S_MSG_NO     0x0D
#define STS$S_SEVERITY   0x03

#define STS$V_CODE       0x03
#define STS$V_COND_ID    0x03
#define STS$V_CONTROL    0x1C
#define STS$V_CUST_DEF   0x1B
#define STS$V_FAC_NO     0x10
#define STS$V_FAC_SP     0x0F
#define STS$V_INHIB_MSG  0x1C
#define STS$V_MSG_NO     0x03
#define STS$V_SEVERITY   0x00
#define STS$V_SUCCESS    0x00

/* Define MACROS to extract individual fields from a status value */

#define $VMS_STATUS_CODE(code) 		( ( (code) & STS$M_CODE ) 	>> STS$V_CODE )
#define $VMS_STATUS_COND_ID(code) 	( ( (code) & STS$M_COND_ID ) 	>> STS$V_COND_ID )
#define $VMS_STATUS_CONTROL(code) 	( ( (code) & STS$M_CONTROL ) 	>> STS$V_CONTROL )
#define $VMS_STATUS_CUST_DEF(code) 	( ( (code) & STS$M_CUST_DEF ) 	>> STS$V_CUST_DEF )
#define $VMS_STATUS_FAC_NO(code) 	( ( (code) & STS$M_FAC_NO ) 	>> STS$V_FAC_NO )
#define $VMS_STATUS_FAC_SP(code) 	( ( (code) & STS$M_FAC_SP ) 	>> STS$V_FAC_SP )
#define $VMS_STATUS_INHIB_MSG(code)	( ( (code) & STS$M_INHIB_MSG ) 	>> STS$V_INHIB_MSG )
#define $VMS_STATUS_MSG_NO(code) 	( ( (code) & STS$M_MSG_NO ) 	>> STS$V_MSG_NO )
#define $VMS_STATUS_SEVERITY(code) 	( ( (code) & STS$M_SEVERITY ) 	>> STS$V_SEVERITY )
#define $VMS_STATUS_SUCCESS(code) 	( ( (code) & STS$M_SUCCESS ) 	>> STS$V_SUCCESS )

#endif					/* __STSDEF_LOADED */
#ifndef __SYIDEF_LOADED
#define __SYIDEF_LOADED	1

/*** MODULE $syidef ***/
/*+                                                                         */
/* Get System Information Data Identifier Definitions                       */
/*                                                                          */
/* **** NOTE ****                                                           */
/*                                                                          */
/*        New items must always be added to the END of each item list       */
/*        (preceeding the ENDlistname item) so that users will not have     */
/*        to relink.                                                        */
/*-                                                                         */
/* DEFINE TABLE TYPES                                                       */
#define SYI$C_EXETYPE 1                 /* Executive cells                  */
#define SYI$C_FLDTYPE 2                 /* Sub-field data                   */
#define SYI$C_RSDTYPE 3                 /* Reduced system data              */
/*	The following item-codes are for executive data cells.              */
/*	Processor registers are a special case of this type.                */
/*	Some EXE-type cells have frequently used sub-fields,                */
/*	which have item-codes in the FLD section. (after this one)          */
#define SYI$_VERSION 4096               /* VMS version number               */
#define SYI$_SID 4097                   /* System ID register               */
#define SYI$_PFCDEFAULT 4098            /* Default page fault cluster size  */
#define SYI$_PAGTBLPFC 4099             /* Default page table page fault cluster */
#define SYI$_SYSPFC 4100                /* Page fault cluster for system paging */
#define SYI$_KFILSTCNT 4101             /* Number of known file lists       */
#define SYI$_GBLSECTIONS 4102           /* Global section count             */
#define SYI$_GBLPAGES 4103              /* Global page count                */
#define SYI$_GBLPAGFIL 4104             /* Global page page file page limit */
#define SYI$_MAXPROCESSCNT 4105         /* Maximum process count            */
#define SYI$_PIXSCAN 4106               /* Process scan count               */
#define SYI$_PROCSECTCNT 4107           /* Process section count            */
#define SYI$_MINWSCNT 4108              /* Minimum working set size         */
#define SYI$_PAGFILCNT 4109             /* Number of paging files           */
#define SYI$_SWPFILCNT 4110             /* Number of swap files             */
#define SYI$_SYSMWCNT 4111              /* System working set count         */
#define SYI$_INTSTKPAGES 4112           /* Interrupt stack size             */
#define SYI$_DLCKEXTRASTK 4113          /* Extra int stack for deadlock searches */
#define SYI$_BALSETCNT 4114             /* Balance set count                */
#define SYI$_IRPCOUNT 4115              /* Count of I/O packets             */
#define SYI$_IRPCOUNTV 4116             /* Limit of extension of IRP list   */
#define SYI$_WSMAX 4117                 /* Max size of process working set  */
#define SYI$_NPAGEDYN 4118              /* Non-paged dynamic pool           */
#define SYI$_NPAGEVIR 4119              /* Limit of extension of above      */
#define SYI$_PAGEDYN 4120               /* Paged dynamic pool               */
#define SYI$_VIRTUALPAGECNT 4121        /* Max virtual page count           */
#define SYI$_SPTREQ 4122                /* Requested SPT extension          */
#define SYI$_EXUSRSTK 4123              /* Extra user stack provided        */
#define SYI$_LRPCOUNT 4124              /* Number of large request packets  */
#define SYI$_LRPCOUNTV 4125             /* Limit of extension of LRP list   */
#define SYI$_LRPSIZE 4126               /* Size of large request packet     */
#define SYI$_LRPMIN 4127                /* Min alloc request for LRPs       */
#define SYI$_SRPCOUNT 4128              /* Number of small request packets  */
#define SYI$_SRPCOUNTV 4129             /* Limit of extension of SRP list   */
#define SYI$_SRPSIZE 4130               /* Size of small request packet     */
#define SYI$_SRPMIN 4131                /* Min alloc request for SRPs       */
#define SYI$_CHANNELCNT 4132            /* Number of permanent I/O channels */
#define SYI$_PIOPAGES 4133              /* Process I/O pages                */
#define SYI$_CTLPAGES 4134              /* Control region impure pages      */
#define SYI$_CTLIMGLIM 4135             /* Limit on use of proc alloc region */
#define SYI$_IMGIOCNT 4136              /* Default image I/O address space  */
#define SYI$_QUANTUM 4137               /* Process quantum                  */
#define SYI$_MPW_WRTCLUSTER 4138        /* Page write cluster factor        */
#define SYI$_MPW_HILIMIT 4139           /* Modified page list high limit    */
#define SYI$_MPW_LOLIMIT 4140           /* Modified page list low limit     */
#define SYI$_MPW_PRIO 4141              /* Modified page writer I/O priority */
#define SYI$_SWP_PRIO 4142              /* Swapper I/O priority             */
#define SYI$_MPW_THRESH 4143            /* Modified page writer lower threshold */
#define SYI$_MPW_WAITLIMIT 4144         /* Modified page writer busy wait limit */
#define SYI$_TBSKIPWSL 4145             /* Max number WSlist entries to skip */
#define SYI$_PHYSICALPAGES 4146         /* Max number of physical pages to use */
#define SYI$_PFRATL 4147                /* Page fault rate lower threshold  */
#define SYI$_PFRATH 4148                /* Page fault rate high threshold   */
#define SYI$_PFRATS 4149                /* Page fault rate system threshold */
#define SYI$_WSINC 4150                 /* Working set increment            */
#define SYI$_WSDEC 4151                 /* Working set decrement            */
#define SYI$_AWSMIN 4152                /* Working set minimum              */
#define SYI$_AWSTIME 4153               /* Working set measurement interval */
#define SYI$_SWPRATE 4154               /* Swap rate control (max)          */
#define SYI$_SWPOUTPGCNT 4155           /* Desired proc page cnt for an outswap */
#define SYI$_SWPALLOCINC 4156           /* Swap file allocation increment value */
#define SYI$_IOTA 4157                  /* I/O time allowance               */
#define SYI$_LONGWAIT 4158              /* When HIB or LEF proc becomes longwait */
#define SYI$_SWPFAIL 4159               /* Swap fail count                  */
#define SYI$_VMSD1 4160                 /* Reserved to VMS development (DYNAMIC) */
#define SYI$_VMSD2 4161                 /* "                                */
#define SYI$_VMSD3 4162                 /* "                                */
#define SYI$_VMSD4 4163                 /* "                                */
#define SYI$_VMS5 4164                  /* Reserved to VMS development (STATIC) */
#define SYI$_VMS6 4165                  /* "                                */
#define SYI$_VMS7 4166                  /* "                                */
#define SYI$_VMS8 4167                  /* "                                */
#define SYI$_USERD1 4168                /* Reserved for users (DYNAMIC)     */
#define SYI$_USERD2 4169                /* "                                */
#define SYI$_USER3 4170                 /* Reserved for users (STATIC)      */
#define SYI$_USER4 4171                 /* "                                */
#define SYI$_EXTRACPU 4172              /* Extra CPU time allowed on expiration */
#define SYI$_MAXSYSGROUP 4173           /* Max group code for system UIC    */
#define SYI$_MVTIMEOUT 4174             /* Timeout for mount verification   */
#define SYI$_MAXBUF 4175                /* Maximum allowable buffered I/O size */
#define SYI$_DEFMBXBUFQUO 4176          /* Def buffer quota for mailbox creation */
#define SYI$_DEFMBXMXMSG 4177           /* Def max msg size for mailbox creation */
#define SYI$_DEFMBXNUMMSG 4178          /* Def number of messages for "     */
#define SYI$_FREELIM 4179               /* Desired free list length         */
#define SYI$_FREEGOAL 4180              /* Target free list length          */
#define SYI$_GROWLIM 4181               /* Free > growlim to grow proc > wsquota */
#define SYI$_BORROWLIM 4182             /* Same as above???                 */
#define SYI$_LOCKRETRY 4183             /* Multi-CPU lock retry count       */
#define SYI$_XFMAXRATE 4184             /* Max DR32 data rate               */
#define SYI$_LAMAPREGS 4185             /* Number of UBA map regs for LPA11 */
#define SYI$_REALTIME_SPTS 4186         /* SPT entries for CONINTERR processes */
#define SYI$_CLISYMTBL 4187             /* Number of pages for CLI symbol table */
#define SYI$_LOCKIDTBL 4188             /* Size of lock ID table            */
#define SYI$_RESHASHTBL 4189            /* Size of resource hash table      */
#define SYI$_DEADLOCK_WAIT 4190         /* Deadlock detection timeout period */
#define SYI$_SCSBUFFCNT 4191            /* SCS buffer descriptor table entries */
#define SYI$_SCSCONNCNT 4192            /* SCS connect descriptor table entries */
#define SYI$_SCSRESPCNT 4193            /* SCS response descriptor table entries */
#define SYI$_SCSMAXDG 4194              /* SCS maximum datagram size        */
#define SYI$_SCSMAXMSG 4195             /* SCS max sequenced message size   */
#define SYI$_SCSFLOWCUSH 4196           /* SCS flow control cushion         */
#define SYI$_SCSSYSTEMID 4197           /* SCS system ID (48 bits)          */
#define SYI$_SCSSYSTEMIDH 4198          /* High bits of above               */
#define SYI$_SCSNODE 4199               /* SCS system node name             */
/* Used to be SCSNODEH. Unused for now.                                     */
#define SYI$_PRCPOLINTERVAL 4201        /* SCA process polling interval     */
#define SYI$_PASTIMOUT 4202             /* CI port START/STACK timeout      */
#define SYI$_PASTDGBUF 4203             /* CI port DG buffers for START handshake */
#define SYI$_PANUMPOLL 4204             /* Number of CI ports to poll       */
#define SYI$_PAPOLLINTERVAL 4205        /* Time between CI port polls       */
#define SYI$_PAPOOLINTERVAL 4206        /* Time between SYSAPs pool check   */
#define SYI$_TIMEPROMPTWAIT 4207        /* Time prompt timeout (when booting) */
#define SYI$_UDABURSTRATE 4208          /* Max number of longwords per NPR - 1 */
#define SYI$_LNMSHASHTBL 4209           /* Size of system space log name hash table */
#define SYI$_LNMPHASHTBL 4210           /* Size of process space "          */
#define SYI$_TTY_SCANDELTA 4211         /* Delta time for dialup timer scan */
#define SYI$_TTY_DIALTYPE 4212          /* Flags for dialup type            */
#define SYI$_TTY_SPEED 4213             /* Terminal default: speed          */
#define SYI$_TTY_RSPEED 4214            /* " " receive speed                */
#define SYI$_TTY_PARITY 4215            /* " " parity                       */
#define SYI$_TTY_BUF 4216               /* " " line width                   */
#define SYI$_TTY_DEFCHAR 4217           /* " " characteristics              */
#define SYI$_TTY_DEFCHAR2 4218          /* " " characteristics, 2nd longword */
#define SYI$_TTY_TYPAHDSZ 4219          /* Size of typeahead buffer         */
#define SYI$_TTY_ALTYPAHD 4220          /* Alternate typeahead size         */
#define SYI$_TTY_ALTALARM 4221          /* Alt typeahead alarm size         */
#define SYI$_TTY_DMASIZE 4222           /* Dma size                         */
#define SYI$_TTY_PROT 4223              /* Default terminal alloc protection */
#define SYI$_TTY_OWNER 4224             /* Default terminal owner           */
#define SYI$_TTY_CLASSNAME 4225         /* Default terminal class name prefix */
#define SYI$_TTY_SILOTIME 4226          /* Default silo timeout for DMF32   */
#define SYI$_TTY_DEFPORT 4227           /* DEFAULT PORT ACTION PARAMETER    */
#define SYI$_RMS_DFMBC 4228             /* RMS default: multi-block count   */
#define SYI$_RMS_DFMBFSDK 4229          /* " " multi-buffer count for disk (SEQ) */
#define SYI$_RMS_DFMBFSMT 4230          /* " " multi-buffer count for tape  */
#define SYI$_RMS_DFMBFSUR 4231          /* " " multi-buffer count for unit record */
#define SYI$_RMS_DFMBFREL 4232          /* " " multi-buffer count for REL files */
#define SYI$_RMS_DFMBFIDX 4233          /* " " multi-buffer count for ISAM files */
#define SYI$_RMS_DFMBFHSH 4234          /* " " multi-buffer count for HASH files */
#define SYI$_RMS_PROLOGUE 4235          /* " " prolog                       */
#define SYI$_RMS_EXTEND_SIZE 4236       /* " " file extend quantity         */
#define SYI$_RMS_FILEPROT 4237          /* " " file protection              */
#define SYI$_PQL_DASTLM 4238            /* Def AST limit                    */
#define SYI$_PQL_MASTLM 4239            /* Min "                            */
#define SYI$_PQL_DBIOLM 4240            /* Def buffered I/O limit           */
#define SYI$_PQL_MBIOLM 4241            /* Min "                            */
#define SYI$_PQL_DBYTLM 4242            /* Def buffered I/O byte count limit */
#define SYI$_PQL_MBYTLM 4243            /* Min "                            */
#define SYI$_PQL_DCPULM 4244            /* Def CPU time limit               */
#define SYI$_PQL_MCPULM 4245            /* Min "                            */
#define SYI$_PQL_DDIOLM 4246            /* Def direct I/O limit             */
#define SYI$_PQL_MDIOLM 4247            /* Min "                            */
#define SYI$_PQL_DFILLM 4248            /* Def open file limit              */
#define SYI$_PQL_MFILLM 4249            /* Min "                            */
#define SYI$_PQL_DPGFLQUOTA 4250        /* Def paging file quota            */
#define SYI$_PQL_MPGFLQUOTA 4251        /* Min "                            */
#define SYI$_PQL_DPRCLM 4252            /* Def sub-process limit            */
#define SYI$_PQL_MPRCLM 4253            /* Min "                            */
#define SYI$_PQL_DTQELM 4254            /* Def timer queue entry limit      */
#define SYI$_PQL_MTQELM 4255            /* Min "                            */
#define SYI$_PQL_DWSDEFAULT 4256        /* Def working set default size     */
#define SYI$_PQL_MWSDEFAULT 4257        /* Min "                            */
#define SYI$_PQL_DWSQUOTA 4258          /* Def working set quota            */
#define SYI$_PQL_MWSQUOTA 4259          /* Min "                            */
#define SYI$_PQL_DWSEXTENT 4260         /* Def working set extent           */
#define SYI$_PQL_MWSEXTENT 4261         /* Min "                            */
#define SYI$_PQL_DENQLM 4262            /* Def enqueue limit                */
#define SYI$_PQL_MENQLM 4263            /* Min "                            */
#define SYI$_ACP_MAPCACHE 4264          /* Number of blocks in bitmap cache */
#define SYI$_ACP_HDRCACHE 4265          /* Number of blocks in file header cache */
#define SYI$_ACP_DIRCACHE 4266          /* Number of blocks in directory cache */
#define SYI$_ACP_WORKSET 4267           /* ACP working set                  */
#define SYI$_ACP_FIDCACHE 4268          /* Number of cached index file slots */
#define SYI$_ACP_EXTCACHE 4269          /* Number of cached disk extents    */
#define SYI$_ACP_EXTLIMIT 4270          /* Max fraction of disk to cache    */
#define SYI$_ACP_QUOCACHE 4271          /* Number of file quota entries to cache */
#define SYI$_ACP_SYSACC 4272            /* Default access for system volumes */
#define SYI$_ACP_MAXREAD 4273           /* Max number of direct blks to read */
#define SYI$_ACP_WINDOW 4274            /* Default window size for system volumes */
#define SYI$_ACP_WRITEBACK 4275         /* Deferred cache writeback enable  */
#define SYI$_ACP_DATACHECK 4276         /* ACP datacheck enable flags       */
#define SYI$_ACP_BASEPRIO 4277          /* ACP base priority                */
#define SYI$_ACP_SWAPFLGS 4278          /* ACP swap flags                   */
#define SYI$_DEFPRI 4279                /* Default priority for Job Initiations */
#define SYI$_IJOBLIM 4280               /* Limit for interactive jobs       */
#define SYI$_BJOBLIM 4281               /* Limit for batch jobs             */
#define SYI$_NJOBLIM 4282               /* Limit for network jobs           */
#define SYI$_RJOBLIM 4283               /* Limit for remote terminal jobs   */
#define SYI$_QUORUM 4284                /* Connection manager cluster QUORUM */
#define SYI$_VOTES 4285                 /* Connection manager VOTES from this system */
#define SYI$_RECNXINTERVAL 4286         /* Connection manager reconnect interval */
#define SYI$_BOOTTIME 4287              /* 64-bit abs. system time at system boot */
#define SYI$_LOCKIDTBL_MAX 4288         /* Maximum size of lock ID table.   */
#define SYI$_TAILORED 4289              /* Is this system tailored?         */
#define SYI$_STARTUP_P1 4290            /* Parameters for passing information */
#define SYI$_STARTUP_P2 4291            /* to system startup procedure.     */
#define SYI$_STARTUP_P3 4292
#define SYI$_STARTUP_P4 4293
#define SYI$_STARTUP_P5 4294
#define SYI$_STARTUP_P6 4295
#define SYI$_STARTUP_P7 4296
#define SYI$_STARTUP_P8 4297
#define SYI$_CLUSTER_NODES 4298         /* total number of nodes in cluster */
#define SYI$_CLUSTER_VOTES 4299         /*  "     "     "  votes "   "      */
#define SYI$_CLUSTER_QUORUM 4300        /*  "     quorum in cluster         */
#define SYI$_CLUSTER_FSYSID 4301        /* founding systemid                */
#define SYI$_CLUSTER_FTIME 4302         /* founding boottime                */
#define SYI$_CLUSTER_MEMBER 4303        /* true if in a live cluster        */
#define SYI$_NODE_CSID 4304             /* cluster system id of target node */
#define SYI$_NODE_VOTES 4305            /* votes of target node             */
#define SYI$_NODE_QUORUM 4306           /* quorum of "      "               */
#define SYI$_NODE_SYSTEMID 4307         /* systemid of "    "               */
#define SYI$_NODE_SWINCARN 4308         /* S/W incarnation of "     "       */
#define SYI$_NODE_SWTYPE 4309           /* S/W type of  "     "             */
#define SYI$_NODE_SWVERS 4310           /* S/W version of "   "             */
#define SYI$_NODE_HWTYPE 4311           /* H/W type of    "   "             */
#define SYI$_NODE_HWVERS 4312           /* H/W version of "   "             */
#define SYI$_NODENAME 4313              /* SCS nodename of "    "           */
#define SYI$_ARCHFLAG 4314              /* Flags used by uVAX code          */
#define SYI$_SCS_EXISTS 4315            /* Flag to indicate presence of SCS */
#define SYI$_DISK_QUORUM 4316           /* Cluster quorum device name (in ASCII) */
#define SYI$_XSID 4317                  /* Extended System Identification Register */
/* Used to be DISK_QUORUM3. Unused for now.                                 */
/* Used to be DISK_QUORUM4. Unused for now.                                 */
#define SYI$_PAMAXPORT 4320             /* Max PA port to poll              */
#define SYI$_PASANITY 4321              /* PA sanity timer enable/disable switch */
#define SYI$_DEFQUEPRI 4322             /* Default Que Priority             */
#define SYI$_MAXQUEPRI 4323             /* Max Que Priority                 */
#define SYI$_QDSKINTERVAL 4324          /* Disk Quorum Interval             */
#define SYI$_ALLOCLASS 4325             /* Allocation class                 */
#define SYI$_LGI_RETRY_LIM 4326         /* Login retry limit                */
#define SYI$_LGI_RETRY_TMO 4327         /* Login retry timeout              */
#define SYI$_LGI_BRK_LIM 4328           /* Login failure limit              */
#define SYI$_LGI_BRK_TMO 4329           /* Login suspect timeout            */
#define SYI$_LGI_HID_TIM 4330           /* Login evasive action time        */
#define SYI$_LGI_PWD_TMO 4331           /* System password drop dead time   */
#define SYI$_PQL_DJTQUOTA 4332          /* Default Job-wide Logical Name Table Creation Quota */
#define SYI$_PQL_MJTQUOTA 4333          /* Minimum Job-wide Logical Name Table Creation Quota */
#define SYI$_VAXCLUSTER 4334            /* VAXcluster participation         */
#define SYI$_LOCKDIRWT 4335             /* Lock manager directory system weight */
#define SYI$_QDSKVOTES 4336             /* Votes held by quorum disk        */
#define SYI$_DORMANTWAIT 4337           /* When low pri COM proc becomes dormant */
#define SYI$_PAGEFILE_PAGE 4338         /* Total pagefile pages             */
#define SYI$_SWAPFILE_PAGE 4339         /* Total swapfile pages             */
#define SYI$_PAGEFILE_FREE 4340         /* Free pagefile pages              */
#define SYI$_SWAPFILE_FREE 4341         /* Free swapfile pages              */
#define SYI$_TTY_TIMEOUT 4342           /* Seconds for virtual terminal timeout */
#define SYI$_TTY_AUTOCHAR 4343          /* autobaud recognition character   */
#define SYI$_PANOPOLL 4344              /* Disable/enable CI port polling   */
#define SYI$_PE1 4345                   /* Reserved TO PEDRIVER (DYNAMIC)   */
#define SYI$_PE2 4346                   /* "                                */
#define SYI$_PE3 4347                   /* "                                */
#define SYI$_PE4 4348                   /* "                                */
#define SYI$_PE5 4349                   /* Reserved TO PEDRIVER (STATIC)    */
#define SYI$_PE6 4350                   /* "                                */
#define SYI$_RMS_GBLBUFQUO 4351         /* RMS global buffer quota          */
#define SYI$_RMS_DFNBC 4352             /* " " network block count          */
#define SYI$_ACP_DINDXCACHE 4353        /* File system directory index cache blocks */
#define SYI$_MAXATTACHPRI 4354          /* Maximum scheduling prio for ASMP attached processor */
#define SYI$_SMP_CPUS 4355              /* Number of CPUs to boot in SMP system */
#define SYI$_SMP_CPUSH 4356             /* Hi Number of CPUs to boot in SMP system */
#define SYI$_FALLBACK_MODE 4357         /* Cluster fallback mode            */
#define SYI$_MPW_LOWAITLIMIT 4358       /* Modified page writer lower busy wait limit */
#define SYI$_MPW_IOLIMIT 4359           /* Modified page writer max concurrent I/O count */
#define SYI$_S0_PAGING 4360             /* System space paging flags        */
#define SYI$_HW_MODEL 4361              /* VAX model number (from SB$B_HWVERS) */
#define SYI$_HW_NAME 4362               /* VAX model name from #/name trans. table */
#define SYI$_SCH_CTLFLAGS 4363          /* CPU scheduling control flags     */
#define SYI$_NODE_EVOTES 4364           /* Votes expected by target node    */
#define SYI$_CLUSTER_EVOTES 4365        /* Number of expected votes in cluster */
#define SYI$_MULTIPROCESSING 4366       /* Multiprocessor participation     */
#define SYI$_FREE_GBLPAGES 4367         /* Total, free global pages         */
#define SYI$_CONTIG_GBLPAGES 4368       /* Maximum, contiguous free global pages */
#define SYI$_FREE_GBLSECTS 4369         /* Total, free global sections      */
#define SYI$_EXPECTED_VOTES 4370        /* Expected votes                   */
#define SYI$_PU_OPTIONS 4371            /* Select PUDRIVER load options     */
#define SYI$_WPTTE_SIZE 4372            /* # Watchpoint Trace Table Entries */
#define SYI$_WPRE_SIZE 4373             /* Watchpoint Restore Entry size    */
#define SYI$_SMP_SANITY_CNT 4374        /* # SMP Sanity events bef. timeout */
#define SYI$_SMP_TICK_CNT 4375          /* Clock ticks between SMP sanity time cycles */
#define SYI$_QBUS_MULT_INTR 4376        /* uVAX/QBUS multi-level interrupt enable flag */
#define SYI$_RIGHTSLIST 4377            /* System rights segment descriptor */
#define SYI$_SMP_SPINWAIT 4378          /* SMP normal busywait timeout      */
#define SYI$_SMP_LNGSPINWAIT 4379       /* SMP LONG busywait timeout        */
#define SYI$_TIME_CONTROL 4380          /* Time-related control functions   */
#define SYI$_AVAILCPU_CNT 4381          /* Number of CPUs in this machine   */
#define SYI$_ACTIVECPU_CNT 4382         /* Number of CPUs up and running    */
/* Used to be LAVC_CONV_BOOT. Unused now.                                   */
/* Used to be LAVC_LOAD_PEA0. Unused now.                                   */
/* Used to be LAVC_PORT_SERV. Unused now.                                   */
#define SYI$_MSCP_LOAD 4386             /* Load MSCP server at boot time    */
#define SYI$_MSCP_SERVE_ALL 4387        /* Serve all disks                  */
#define SYI$_POOLCHECK 4388             /* Pool debugging in MEMORYALC.MAR  */
#define SYI$_TAPE_MVTIMEOUT 4389        /* Magtape mount verification       */
#define SYI$_PSEUDOLOA 4390             /* Pseudoloa image size for tape boot */
#define SYI$_MINCLASSPRI 4391           /* Min. priority for class scheduling  */
#define SYI$_MAXCLASSPRI 4392           /* Max. priority for class scheduling  */
#define SYI$_MINPRPRI 4393              /* Min. priority for preemptive-resume scheduling  */
#define SYI$_AUTOCONFIG_ALGO 4394       /* Selects which algorithmn SYSGEN uses to autoconfigure. */
#define SYI$_ERRORLOGBUFFERS 4395       /* Number of buffers for error logging */
#define SYI$_JOBCTLD 4396               /* Dynamic SYSGEN flag to handle job controller diagnostics and Rolling upgrade. */
#define SYI$_WINDOW_SYSTEM 4397         /* Default windowing system for workstation */
#define SYI$_MSCP_BUFFER 4398           /* Pages allocated to server local pool */
#define SYI$_MSCP_CREDITS 4399          /* Number of send credits extended by server */
#define SYI$_BREAKPOINTS 4400           /* Mask of INI$BRK callers in exec used in this boot */
#define SYI$_CLOCK_INTERVAL 4401        /* Time  (in usec) between interval timer clock interrupts */
#define SYI$_DUMPSTYLE 4402             /* Mask specifying desired format of dump file (full dump or subset dump) */
#define SYI$_NISCS_PORT_SERV 4403       /* Port services flag               */
#define SYI$_RSRVPAGCNT 4404            /* No. of pagefile pages to escrow  */
/*	ADD 'EXE' ITEM-CODES ONLY JUST BEFORE THIS COMMENT ***********      */
#define SYI$_LASTEXE 4405               /* LAST INDEX                       */
/*  ) equals SYI$C_EXETYPE@12 increment 1  prefix SYI tag $;                */
/*	The following item-codes are for 'sub-field data' items.            */
/*	There usually exists another item-code to retrieve the              */
/*	whole parent cell (longword) - in the EXE section above.            */
#define SYI$_CPU 8192                   /* CPU type                         */
#define SYI$_BUGREBOOT 8193             /* Bugcheck reboot enable           */
#define SYI$_CRDENABLE 8194             /* Memory error checking enable     */
#define SYI$_DUMPBUG 8195               /* Bugcheck dump enable             */
#define SYI$_BUGCHECKFATAL 8196         /* All bugchecks become fatal       */
#define SYI$_ACP_MULTIPLE 8197          /* New ACP for each disk class      */
#define SYI$_NOAUTOCONFIG 8198          /* Auto configuration inhibit       */
#define SYI$_NOCLOCK 8199               /* Interval timer inhibit           */
#define SYI$_NOCLUSTER 8200             /* Page read clustering inhibit     */
#define SYI$_POOLPAGING 8201            /* Enable paging of paged pool      */
#define SYI$_SBIERRENABLE 8202          /* SBI error detection enable       */
#define SYI$_SETTIME 8203               /* Force entry of time at system boot */
#define SYI$_ACP_SHARE 8204             /* Enable sharing of F11ACP         */
#define SYI$_SYSPAGING 8205             /* Enable paging of system code     */
#define SYI$_UAFALTERNATE 8206          /* Select alternate authorization file */
#define SYI$_WRITABLESYS 8207           /* Leave system writable for debugging */
#define SYI$_RESALLOC 8208              /* Enable resource allocation checking */
#define SYI$_SSINHIBIT 8209             /* Inhibit system services for processes */
#define SYI$_CONCEAL_DEVICES 8210       /* Enable concealed devices         */
#define SYI$_SAVEDUMP 8211              /* Save dump if it's in page file   */
#define SYI$_MOUNTMSG 8212              /* Enable oper notification of vol mounts */
#define SYI$_DISMOUMSG 8213             /* Enable oper notification of vol dism */
#define SYI$_LOADERAPT 8214             /* Load alt erase pattern generator */
#define SYI$_LOADCHKPRT 8215            /* Load alt protection check routine */
#define SYI$_XCPU 8216                  /* CPU subtype (Extended SID info)  */
#define SYI$_CJFLOAD 8217               /* Load common journaling code      */
#define SYI$_CJFSYSRUJ 8218             /* Load recovery unit journaling code */
#define SYI$_NODE_AREA 8219             /* System ID node area              */
#define SYI$_NODE_NUMBER 8220           /* System ID node number            */
#define SYI$_CLASS_PROT 8221            /* Non-discretionary check flag     */
#define SYI$_CHARACTER_EMULATED 8222    /* Character string instructions emulated */
#define SYI$_DECIMAL_EMULATED 8223      /* Decimal string instructions emulated */
#define SYI$_D_FLOAT_EMULATED 8224      /* D floating instructions emulated */
#define SYI$_F_FLOAT_EMULATED 8225      /* F floating instructions emulated */
#define SYI$_G_FLOAT_EMULATED 8226      /* G floating instructions emulated */
#define SYI$_H_FLOAT_EMULATED 8227      /* H floating instructions emulated */
#define SYI$_LOADMTACCESS 8228          /* Load installation specific access routine */
#define SYI$_ACP_XQP_RES 8229           /* Resident XQP                     */
#define SYI$_WRITESYSPARAMS 8230        /* Write active parameters to the system .PAR file */
#define SYI$_LGI_BRK_TERM 8231          /* Use term name in breakin detection */
#define SYI$_LGI_BRK_DISUSER 8232       /* Disable user account on breakin  */
#define SYI$_ACP_REBLDSYSD 8233         /* Rebuild system disk when mounting it */
#define SYI$_WS_OPA0 8234               /* Workstation using QVSS for OPA0  */
#define SYI$_NOPGFLSWP 8235             /* Inhibit swapping into pagefiles  */
#define SYI$_SHADOWING 8236             /* Load Volume Shadowing code (DSDRIVER) */
#define SYI$_LOAD_SYS_IMAGES 8237       /* Load System Images               */
#define SYI$_NISCS_CONV_BOOT 8238       /* Allow remote conversational boot */
#define SYI$_NISCS_LOAD_PEA0 8239       /* Load NI-SCS driver for PEA0      */
/*	ADD 'FLD' ITEM-CODES ONLY JUST BEFORE THIS COMMENT ***********      */
#define SYI$_LASTFLD 8240               /* LAST INDEX                       */
/*  ) equals SYI$C_FLDTYPE@12 increment 1  prefix SYI tag $;                */
/***************************************************************************** */
/**                                                                         */
/**	THE FOLLOWING DEFINITIONS EXIST FOR COMPATIBILITY WITH THE 1ST      */
/**	IMPLEMENTATION OF SYS$GETSYI.  DO NOT CHANGE THEM!!!                */
/**	ADD NEW GETSYI ITEM-CODES ONLY TO THE PREVIOUS LISTS.               */
/**                                                                         */
/***************************************************************************** */
#define SYI$C_SFWTYPE 1                 /* SYSTEM SOFTWARE ITEM             */
#define SYI$C_HDWTYPE 2                 /* HARDWARE ITEM                    */
#define SYI$C_LISTEND 0                 /* ITMLST TERMINATOR                */
/* IDENTIFIER FOR SYSTEM SOFTWARE                                           */
#define SYI$_OLDVERSION 256             /* VMS VERSION NUMBER               */
#define SYI$_LASTSFW 257                /* LAST INDEX                       */
/* *******************************************************************      */
/* ********************* BEGIN TEMP FIX ******************************      */
/* ********************* BEGIN TEMP FIX ******************************      */
/* *******************************************************************      */
/*  ) equals SYI$C_SFWTYPE@8 increment 1  prefix SYI tag $;                 */
/* *******************************************************************      */
/* ********************** END TEMP FIX *******************************      */
/* ********************** END TEMP FIX *******************************      */
/* *******************************************************************      */
/* IDENTIFIER FOR HARDWARE TYPE                                             */
#define SYI$_OLDCPU 512                 /* CPU TYPE                         */
#define SYI$_OLDSID 513                 /* SYSTEM ID REGISTER               */
#define SYI$_LASTHDW 514                /* LAST INDEX                       */
/*    ) equals SYI$C_HDWTYPE@8 increment 1  prefix SYI tag $;               */
 

#endif					/* __SYIDEF_LOADED */
/* static	char	*sccsid = "@(#)tcp.h	4.1	(ULTRIX)	11/23/87"; */

/************************************************************************
 *									*
 *			Copyright (c) 1985 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/************************************************************************
 *			Modification History				*
 *	Larry Cohen  -  01/28/87
 *		Add new tcp option definitions: TCP_NODELAY, TCP_MAXSEG
 *									*
 *	Larry Cohen  -	09/16/85					*
 * 		Add 43bsd alpha tape changes for subnet routing		*
 *									*
 ************************************************************************/

/*
 * Copyright (c) 1982 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	@(#)tcp.h	6.3 (Berkeley) 6/8/85
 */

/*
 * Modifications history:
 *
 *  Alex Conta	17 March 1988
 *	Add VAXVMS conditional for VAX/VMS support
 *
 */

#ifndef VAXVMS
#define TCPLOOPBACK
#endif VAXVMS
typedef	u_long	tcp_seq;
/*
 * TCP header.
 * Per RFC 793, September, 1981.
 */
struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
#ifdef vax
	u_char	th_x2:4,		/* (unused) */
		th_off:4;		/* data offset */
#endif
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PUSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
};

#define	TCPOPT_EOL	0
#define	TCPOPT_NOP	1
#define	TCPOPT_MAXSEG	2

/*
 *  Default maximum segment size for TCP.
 *  With an IP MSS of 576, this is 536,
 *  but 512 is probably more convenient.
 */
#define	TCP_MSS	MIN(512, IP_MSS - sizeof (struct tcpiphdr))

/*
 * User-settable options (used with setsockopt).
 */
#define TCP_NODELAY     0x01    /* don't delay send to coalesce packets */
#define TCP_MAXSEG      0x02    /* set maximum segment size */

#ifndef __TIME_LOADED
#define __TIME_LOADED	1

/*	TIME - V3.0 - Localtime() RTL Routine Return Structure Definition	*/

# define CLK_TCK (100)

typedef  long int clock_t;

#pragma nostandard
#include types


	struct tbuffer 
	{
		int proc_user_time, proc_system_time;
		int child_user_time, child_system_time;
	};

typedef struct tbuffer tbuffer_t;

#include timeb
#pragma standard

	struct tm
	{
		int	tm_sec, tm_min, tm_hour;
		int	tm_mday, tm_mon, tm_year;
		int	tm_wday, tm_yday, tm_isdst;
	};

typedef struct tm tm_t;

clock_t clock (void);

#pragma nostandard
#undef difftime
#pragma standard
double difftime (time_t time2, time_t time1);

time_t time (time_t *time_location);

void times (tbuffer_t *buffer);

char *asctime (const tm_t *timeptr);

char *ctime (const time_t *bintim);

tm_t *gmtime (const time_t *timer); 

struct tm *localtime (const time_t *bintim); 

time_t mktime (tm_t *timeptr);

void ftime (timeb_t *time_pointer);

#if defined(CC$mixed_float) || defined(CC$VAXCSHR)
/* 
 * CC$gfloat's definition was modified so that it's defined when
 * g_float is in effect, and undefined otherwise.  The following makes
 * the new behavior compatible with the old.
 */
#ifndef CC$gfloat
#define CC$gfloat 0
#endif

#if CC$gfloat

double vaxc$gdifftime(time_t time2, time_t time1);
#define difftime vaxc$gdifftime

#else

double vaxc$ddifftime(time_t time2, time_t time1);
#define difftime vaxc$ddifftime

#endif
#endif

#endif					/* __TIME_LOADED */
#ifndef __TIMEB_LOADED
#define __TIMEB_LOADED	1

/*	TIMEB - V3.0 - Ftime() RTL Routine Return Structure Definition	*/

#pragma nostandard
#include types
#pragma standard

struct timeb 
    {
	time_t		time;
	unsigned short 	millitm;
	short		timezone;
	short		dstflag;
    };

typedef struct timeb timeb_t;

#endif					/* __TIMEB_LOADED */
#ifndef __TIRDEF_LOADED
#define __TIRDEF_LOADED	1

/*** MODULE $tirdef ***/
/*                                                                          */
/* Text, information and relocation record (TIR)                            */
/*                                                                          */
#define TIR$C_STA_GBL 0                 /*Stack global symbol value         */
#define TIR$C_STA_SB 1                  /*Stack signed byte                 */
#define TIR$C_STA_SW 2                  /*Stack signed word                 */
#define TIR$C_STA_LW 3                  /*Stack longword                    */
#define TIR$C_STA_PB 4                  /*Stack psect base plus byte offset  */
#define TIR$C_STA_PW 5                  /*Stack psect base plus word offset  */
#define TIR$C_STA_PL 6                  /*Stack psect base plus longword offset  */
#define TIR$C_STA_UB 7                  /*Stack unsigned byte               */
#define TIR$C_STA_UW 8                  /*Stack unsigned word               */
#define TIR$C_STA_BFI 9                 /*Stack byte from image             */
#define TIR$C_STA_WFI 10                /*Stack word from image             */
#define TIR$C_STA_LFI 11                /*Stack longword from image         */
#define TIR$C_STA_EPM 12                /*Stack entry point mask            */
#define TIR$C_STA_CKARG 13              /*Stack result of argument checking (true or false)  */
#define TIR$C_STA_WPB 14                /*Stack psect base plus byte offset -- word psect number  */
#define TIR$C_STA_WPW 15                /*Stack psect base plus word offset -- word psect number  */
#define TIR$C_STA_WPL 16                /*Stack psect base plus longword offset -- word of psect number  */
#define TIR$C_STA_LSY 17                /*Stack local symbol value          */
#define TIR$C_STA_LIT 18                /*Stack literal                     */
#define TIR$C_STA_LEPM 19               /*Stack local symbol entry point mask  */
#define TIR$C_MAXSTACOD 19              /*Last assigned code of stack group  */
#define TIR$C_MINSTOCOD 20              /*First assigned store command code  */
#define TIR$C_STO_SB 20                 /*Store signed byte                 */
#define TIR$C_STO_SW 21                 /*Store signed word                 */
#define TIR$C_STO_L 22                  /*Store longword                    */
#define TIR$C_STO_BD 23                 /*Store byte displaced              */
#define TIR$C_STO_WD 24                 /*Store word displaced              */
#define TIR$C_STO_LD 25                 /*Store longword displaced          */
#define TIR$C_STO_LI 26                 /*Store short literal               */
#define TIR$C_STO_PIDR 27               /*Store pos. indep. data reference  */
#define TIR$C_STO_PICR 28               /*Store pos. indep. code reference  */
#define TIR$C_STO_RSB 29                /*Store repeated signed byte        */
#define TIR$C_STO_RSW 30                /*Store repeated signed word        */
#define TIR$C_STO_RL 31                 /*Store repeated longword           */
#define TIR$C_STO_VPS 32                /*Store arbitrary field             */
#define TIR$C_STO_USB 33                /*Store unsigned byte               */
#define TIR$C_STO_USW 34                /*Store unsigned word               */
#define TIR$C_STO_RUB 35                /*Store repeated unsigned byte      */
#define TIR$C_STO_RUW 36                /*Store repeated unsigned word      */
#define TIR$C_STO_B 37                  /*Store byte                        */
#define TIR$C_STO_W 38                  /*Store word                        */
#define TIR$C_STO_RB 39                 /*Store repeated byte               */
#define TIR$C_STO_RW 40                 /*Store repeated word               */
#define TIR$C_STO_RIVB 41               /*Store repeated immediate variable bytes  */
#define TIR$C_STO_PIRR 42               /*Store pos. indep. relative reference  */
#define TIR$C_MAXSTOCOD 42              /*Last assigned store command code  */
#define TIR$C_MINOPRCOD 50              /*First assigned operator command code  */
#define TIR$C_OPR_NOP 50                /*No-op                             */
#define TIR$C_OPR_ADD 51                /*Add                               */
#define TIR$C_OPR_SUB 52                /*Subtract                          */
#define TIR$C_OPR_MUL 53                /*Multiply                          */
#define TIR$C_OPR_DIV 54                /*Divide                            */
#define TIR$C_OPR_AND 55                /*Logical AND                       */
#define TIR$C_OPR_IOR 56                /*Logical inclusive OR              */
#define TIR$C_OPR_EOR 57                /*Logical exclusive OR              */
#define TIR$C_OPR_NEG 58                /*Negate                            */
#define TIR$C_OPR_COM 59                /*Complement                        */
#define TIR$C_OPR_INSV 60               /*Insert bit field                  */
#define TIR$C_OPR_ASH 61                /*Arithmetic shift                  */
#define TIR$C_OPR_USH 62                /*Unsigned shift                    */
#define TIR$C_OPR_ROT 63                /*Rotate                            */
#define TIR$C_OPR_SEL 64                /*Select one of three longwords on top of stack  */
#define TIR$C_OPR_REDEF 65              /*Redefine this symbol after pass 2  */
#define TIR$C_OPR_DFLIT 66              /*Define a literal                  */
#define TIR$C_MAXOPRCOD 66              /*Last assigned operator command code  */
#define TIR$C_MINCTLCOD 80              /*First assigned control command code  */
#define TIR$C_CTL_SETRB 80              /*Set relocation base               */
#define TIR$C_CTL_AUGRB 81              /*Augment relocation base           */
#define TIR$C_CTL_DFLOC 82              /*Define debug location             */
#define TIR$C_CTL_STLOC 83              /*Set debug location                */
#define TIR$C_CTL_STKDL 84              /*Stack debug location              */
#define TIR$C_MAXCTLCOD 84              /*Last assigned control command code  */
union tirdef {
    unsigned char tir$b_rectyp;         /*Record type (OBJ$C_TIR)           */
/* Define relocation commands                                               */
    } ;

#endif					/* __TIRDEF_LOADED */
#ifndef __TPADEF_LOADED
#define __TPADEF_LOADED	1

/*** MODULE $tpadef ***/
/*                                                                          */
/* TPARSE CONTROL BLOCK. THIS BLOCK IS ONE OF THE ARGUMENTS USED TO CALL TPARSE, */
/* AND BECOMES THE ARGUMENT LIST TO ACTION ROUTINES.                        */
/*                                                                          */
#define TPA$K_COUNT0 8                  /* ZERO LEVEL VALUE IS 8            */
#define TPA$M_BLANKS 1
#define TPA$M_ABBREV 2
#define TPA$M_ABBRFM 4
#define TPA$M_AMBIG 65536
#define TPA$K_LENGTH0 36                /* LENGTH OF ZERO LEVEL PARAMETER BLOCK  */
#define TPA$C_LENGTH0 36                /* LENGTH OF ZERO LEVEL PARAMETER BLOCK  */
struct tpadef {
    unsigned long int tpa$l_count;      /* ARGUMENT COUNT (NUMBER OF LONGWORDS)  */
#pragma nostandard
    variant_union  {
        unsigned long int tpa$l_options; /* OPTIONS LONGWORD                */
        variant_struct  {
            unsigned tpa$v_blanks : 1;  /* PROCESS BLANKS AND TABS EXPLICITLY  */
            unsigned tpa$v_abbrev : 1;  /* ALLOW MINIMAL ABBREVIATION       */
            unsigned tpa$v_abbrfm : 1;  /* ALLOW FIRST MATCH ABBREVIATION   */
            unsigned tpadef$$_fill_1 : 13;
            unsigned tpa$v_ambig : 1;   /* AMBIGUOUS KEYWORD AT THIS STATE  */
            unsigned tpa$v_fill_1 : 7;
            } tpa$r_options_bits;
        variant_struct  {
            char tpadef$$_fill_2 [3];
            unsigned char tpa$b_mcount; /* MINIMUM ABBREVIATION ON KEYWORDS  */
            } tpa$r_options_fields;
        } tpa$r_options_overlay;
    unsigned long int tpa$l_stringcnt;  /* BYTE COUNT OF STRING BEING PARSED  */
    unsigned long int tpa$l_stringptr;  /* ADDRESS OF STRING BEING PARSED   */
    unsigned long int tpa$l_tokencnt;   /* BYTE COUNT OF CURRENT MATCHING TOKEN  */
    unsigned long int tpa$l_tokenptr;   /* ADDRESS OF MATCHING TOKEN        */
    variant_union  {
        unsigned long int tpa$l_char;   /* ASCII CODE OF SINGLE CHARACTER TOKEN  */
        unsigned char tpa$b_char;       /* BYTE FORM OF SINGLE CHAR CELL    */
        } tpa$r_char_overlay;
    unsigned long int tpa$l_number;     /* NUMERIC VALUE OF NUMERIC TOKEN   */
    unsigned long int tpa$l_param;      /* PARAMETER LONGWORD FROM STATE TABLE  */
    } ;
 
#pragma standard

#endif					/* __TPADEF_LOADED */
#ifndef __TRMDEF_LOADED
#define __TRMDEF_LOADED	1

/*** MODULE $trmdef ***/
/*                                                                          */
/* Define symbols for the item list QIO format                              */
/*                                                                          */
/* Item list type codes                                                     */
#define TRM$_MODIFIERS 0
#define TRM$_EDITMODE 1
#define TRM$_TIMEOUT 2
#define TRM$_TERM 3
#define TRM$_PROMPT 4
#define TRM$_INISTRNG 5
#define TRM$_PICSTRNG 6
#define TRM$_FILLCHR 7
#define TRM$_INIOFFSET 8
#define TRM$_ALTECHSTR 9
#define TRM$_ESCTRMOVR 10
#define TRM$_LASTITM 11                 /* must remain the last item        */
/*                                                                          */
/* Editmode type codes                                                      */
/*                                                                          */
#define TRM$K_EM_DEFAULT 0
#define TRM$K_EM_RDVERIFY 1
#define TRM$M_TM_NOECHO 64
#define TRM$M_TM_TIMED 128
#define TRM$M_TM_CVTLOW 256
#define TRM$M_TM_NOFILTR 512
#define TRM$M_TM_DSABLMBX 1024
#define TRM$M_TM_PURGE 2048
#define TRM$M_TM_TRMNOECHO 4096
#define TRM$M_TM_REFRESH 8192
#define TRM$M_TM_ESCAPE 16384
#define TRM$M_TM_NOEDIT 32768
#define TRM$M_TM_NORECALL 65536
#define TRM$M_TM_R_JUST 131072
#define TRM$M_TM_AUTO_TAB 262144
#define TRM$M_CV_UPPER 1
#define TRM$M_CV_LOWER 2
#define TRM$M_CV_NUMERIC 4
#define TRM$M_CV_NUMPUNC 8
#define TRM$M_CV_PRINTABLE 16
#define TRM$M_CV_ANY 32
union trmdef {
#pragma nostandard
    variant_struct  {
        unsigned trmdef$$_fill_1 : 6;   /*FUNCTION CODE                     */
        unsigned trm$v_tm_noecho : 1;   /*NOECHO                            */
        unsigned trm$v_tm_timed : 1;    /*TIMED                             */
        unsigned trm$v_tm_cvtlow : 1;   /*CONVERT LOWER CASE                */
        unsigned trm$v_tm_nofiltr : 1;  /*NO FILTER                         */
        unsigned trm$v_tm_dsablmbx : 1; /*DISABLE MAILBOX                   */
        unsigned trm$v_tm_purge : 1;    /*PURGE TYPEAHEAD                   */
        unsigned trm$v_tm_trmnoecho : 1; /*TERMINATORS ARE NOT ECHOED       */
        unsigned trm$v_tm_refresh : 1;  /*Control-R interrupted read n      */
        unsigned trm$v_tm_escape : 1;   /*TERMINATE READ ON ESCAPE SEQUENCE  */
        unsigned trm$v_tm_noedit : 1;   /*DISABLE ADVANCED EDITING          */
        unsigned trm$v_tm_norecall : 1; /*Disable the recall feature of advanced editing */
        unsigned trm$v_tm_r_just : 1;   /*Right justification               */
        unsigned trm$v_tm_auto_tab : 1; /*Auto tab field                    */
        unsigned trm$v_fill_2 : 5;
        } trm$r_trmdef_bits0;
    variant_struct  {                   /* picture string mask              */
        unsigned trm$v_cv_upper : 1;    /* upper case                       */
        unsigned trm$v_cv_lower : 1;    /* lower case                       */
        unsigned trm$v_cv_numeric : 1;  /* numeric (0-9)                    */
        unsigned trm$v_cv_numpunc : 1;  /* numeric punctuation (+ - .)      */
        unsigned trm$v_cv_printable : 1; /* printable character             */
        unsigned trm$v_cv_any : 1;      /* any character                    */
        unsigned trm$v_fill_3 : 2;
        } trm$r_trmdef_bits1;
    } ;
 
#pragma standard

#endif					/* __TRMDEF_LOADED */
#ifndef __TT2DEF_LOADED
#define __TT2DEF_LOADED	1

/*** MODULE $tt2def ***/
#define TT2$M_LOCALECHO 1
#define TT2$M_AUTOBAUD 2
#define TT2$M_HANGUP 4
#define TT2$M_MODHANGUP 8
#define TT2$M_BRDCSTMBX 16
#define TT2$M_XON 32
#define TT2$M_DMA 64
#define TT2$M_ALTYPEAHD 128
#define TT2$M_SETSPEED 256
#define TT2$M_DCL_MAILBX 512
#define TT2$M_DCL_OUTBND 1024
#define TT2$M_DCL_CTRLC 2048
#define TT2$M_EDITING 4096
#define TT2$M_INSERT 8192
#define TT2$M_FALLBACK 16384
#define TT2$M_DIALUP 32768
#define TT2$M_SECURE 65536
#define TT2$M_DISCONNECT 131072
#define TT2$M_PASTHRU 262144
#define TT2$M_SYSPWD 524288
#define TT2$M_SIXEL 1048576
#define TT2$M_DRCS 2097152
#define TT2$M_PRINTER 4194304
#define TT2$M_APP_KEYPAD 8388608
#define TT2$M_ANSICRT 16777216
#define TT2$M_REGIS 33554432
#define TT2$M_BLOCK 67108864
#define TT2$M_AVO 134217728
#define TT2$M_EDIT 268435456
#define TT2$M_DECCRT 536870912
#define TT2$M_DECCRT2 1073741824
#define TT2$M_DECCRT3 -2147483648
#pragma nostandard
union tt2def {
    variant_struct  {
        unsigned tt2$v_localecho : 1;
        unsigned tt2$v_autobaud : 1;
        unsigned tt2$v_hangup : 1;
        unsigned tt2$v_modhangup : 1;
        unsigned tt2$v_brdcstmbx : 1;
        unsigned tt2$v_xon : 1;
        unsigned tt2$v_dma : 1;
        unsigned tt2$v_altypeahd : 1;
        unsigned tt2$v_setspeed : 1;
        unsigned tt2$v_dcl_mailbx : 1;  /* TEMP DEFINITIONS FOR DCL SPAWN   */
        unsigned tt2$v_dcl_outbnd : 1;
        unsigned tt2$v_dcl_ctrlc : 1;
        unsigned tt2$v_editing : 1;     /* enable advanced editing          */
        unsigned tt2$v_insert : 1;      /* INPUT EDITING INSTER DEFAULT     */
        unsigned tt2$v_fallback : 1;    /* USE MULTINATIONAL FALLBACK       */
        unsigned tt2$v_dialup : 1;      /* TERMINAL IS CONNECTED TO DIALUP  */
        unsigned tt2$v_secure : 1;      /* RECOGNIZE SECURE SERVER          */
        unsigned tt2$v_disconnect : 1;  /* TERMINAL CAN BE DISCONNECTED     */
        unsigned tt2$v_pasthru : 1;     /* passall with flowcontrol         */
        unsigned tt2$v_syspwd : 1;      /* System password required         */
        unsigned tt2$v_sixel : 1;       /* SIXEL SUPPORTED                  */
        unsigned tt2$v_drcs : 1;        /*                                  */
        unsigned tt2$v_printer : 1;     /* PRINTER PORT AVAILABLE           */
        unsigned tt2$v_app_keypad : 1;  /* Keypad in applicationis mode     */
        unsigned tt2$v_ansicrt : 1;     /* ANSI, REGIS, BLOCK and AVO       */
        unsigned tt2$v_regis : 1;       /* must be contiguous for SCRPKG.   */
        unsigned tt2$v_block : 1;
        unsigned tt2$v_avo : 1;
        unsigned tt2$v_edit : 1;
        unsigned tt2$v_deccrt : 1;
        unsigned tt2$v_deccrt2 : 1;     /* DECCRT level 2                   */
        unsigned tt2$v_deccrt3 : 1;     /* DECCRT level 3                   */
        } tt2$r_tt2def_bits;
    } ;
#pragma standard
# define TT2$V_LOCALECHO	0X0
# define TT2$V_AUTOBAUD		0X1
# define TT2$V_HANGUP		0X2
# define TT2$V_MODHANGUP	0X3
# define TT2$V_BRDCSTMBX	0X4
# define TT2$V_XON		0X5
# define TT2$V_DMA		0X6
# define TT2$V_ALTYPEAHD	0X7
# define TT2$V_SETSPEED		0X8
# define TT2$V_DCL_MAILBX	0X9
# define TT2$V_DCL_OUTBND	0XA
# define TT2$V_DCL_CTRLC	0XB
# define TT2$V_EDITING		0XC
# define TT2$V_INSERT		0XD
# define TT2$V_FALLBACK		0XE
# define TT2$V_DIALUP		0XF
# define TT2$V_SECURE		0X10
# define TT2$V_DISCONNECT	0X11
# define TT2$V_PASTHRU		0X12
# define TT2$V_SYSPWD		0X13
# define TT2$V_SIXEL		0X14
# define TT2$V_DRCS		0X15
# define TT2$V_PRINTER		0X16
# define TT2$V_APP_KEYPAD	0X17
# define TT2$V_ANSICRT		0X18
# define TT2$V_REGIS		0X19
# define TT2$V_BLOCK		0X1A
# define TT2$V_AVO		0X1B
# define TT2$V_EDIT		0X1C
# define TT2$V_DECCRT		0X1D
# define TT2$V_DECCRT2		0X1E

#endif					/* __TT2DEF_LOADED */
#ifndef __TTDEF_LOADED
#define __TTDEF_LOADED	1

/*** MODULE $ttdef ***/
/*                                                                          */
/* DEFINE TERMINAL SPECIAL SYMBOLS                                          */
/*                                                                          */
#define TT$C_BAUD_50 1
#define TT$C_BAUD_75 2
#define TT$C_BAUD_110 3
#define TT$C_BAUD_134 4
#define TT$C_BAUD_150 5
#define TT$C_BAUD_300 6
#define TT$C_BAUD_600 7
#define TT$C_BAUD_1200 8
#define TT$C_BAUD_1800 9
#define TT$C_BAUD_2000 10
#define TT$C_BAUD_2400 11
#define TT$C_BAUD_3600 12
#define TT$C_BAUD_4800 13
#define TT$C_BAUD_7200 14
#define TT$C_BAUD_9600 15
#define TT$C_BAUD_19200 16
#define TT$C_BAUD_38400 17
/* *** MATCHES DCDEF MACRO                                                  */
#define TT$_UNKNOWN 0
#define TT$_VT05 1                      /* VT05                             */
#define TT$_VK100 2                     /* strange terminals                */
#define TT$_VT173 3
#define TT$_TQ_BTS 4
#define TT$_TEK401X 10
#define TT$_FT1 16                      /* FOREIGN TERMINAL TYPES           */
#define TT$_FT2 17                      /* new support also includes        */
#define TT$_FT3 18                      /* the negative numbers             */
#define TT$_FT4 19
#define TT$_FT5 20
#define TT$_FT6 21
#define TT$_FT7 22
#define TT$_FT8 23                      /* END OF FOREIGN TYPES             */
/* RESERVE REST UP TO 32 FOR EXTENSIONS                                     */
#define TT$_LAX 32
#define TT$_LA36 32
#define TT$_LA120 33
#define TT$_LA34 34
#define TT$_LA38 35
#define TT$_LA12 36
#define TT$_LA100 37
#define TT$_LA24 37
#define TT$_LQP02 38
#define TT$_LA84 39
#define TT$_LA210 40
#define TT$_LN03 41
#define TT$_LN01K 42
#define TT$_LA80 43
#define TT$_VT5X 64
#define TT$_VT52 64
#define TT$_VT55 65
#define TT$_VT100 96                    /* VT100                            */
#define TT$_VT101 97
#define TT$_VT102 98
#define TT$_VT105 99
#define TT$_VT125 100
#define TT$_VT131 101
#define TT$_VT132 102
#define TT$_VT80 103
#define TT$_VT200_SERIES 110
#define TT$_PRO_SERIES 111
#define TT$_VT300_SERIES 112
/* from 128 on is reserved for foreign terminals and must not be            */
/* used for terminal definitions                                            */
#define TT$M_PASSALL 1
#define TT$M_NOECHO 2
#define TT$M_NOTYPEAHD 4
#define TT$M_ESCAPE 8
#define TT$M_HOSTSYNC 16
#define TT$M_TTSYNC 32
#define TT$M_SCRIPT 64
#define TT$M_LOWER 128
#define TT$M_MECHTAB 256
#define TT$M_WRAP 512
#define TT$M_CRFILL 1024
#define TT$M_LFFILL 2048
#define TT$M_SCOPE 4096
#define TT$M_REMOTE 8192
#define TT$M_RESERVED 16384
#define TT$M_EIGHTBIT 32768
#define TT$M_MBXDSABL 65536
#define TT$M_NOBRDCST 131072
#define TT$M_READSYNC 262144
#define TT$M_MECHFORM 524288
#define TT$M_HALFDUP 1048576
#define TT$M_MODEM 2097152
#define TT$M_OPER 4194304
#define TT$M_PAGE -16777216
#define TT$M_ALTFRAME 16
#define TT$M_ALTRPAR 32
#define TT$M_PARITY 64
#define TT$M_ODD 128
#define TT$M_TWOSTOP 256
#define TT$M_DISPARERR 512
#define TT$M_ALTDISPAR 1024
#define TT$M_BREAK 2048
#define TT$M_DS_DTR 2
#define TT$M_DS_SECTX 8
#define TT$M_DS_RTS 16
#define TT$M_DS_SECREC 8
#define TT$M_DS_CTS 16
#define TT$M_DS_CARRIER 32
#define TT$M_DS_RING 64
#define TT$M_DS_DSR 128
#pragma nostandard
union ttdef {
    variant_struct  {
        unsigned tt$v_passall : 1;
        unsigned tt$v_noecho : 1;
        unsigned tt$v_notypeahd : 1;
        unsigned tt$v_escape : 1;
        unsigned tt$v_hostsync : 1;
        unsigned tt$v_ttsync : 1;
        unsigned tt$v_script : 1;
        unsigned tt$v_lower : 1;
        unsigned tt$v_mechtab : 1;
        unsigned tt$v_wrap : 1;
        unsigned tt$v_crfill : 1;
        unsigned tt$v_lffill : 1;
        unsigned tt$v_scope : 1;
        unsigned tt$v_remote : 1;
        unsigned tt$v_reserved : 1;
        unsigned tt$v_eightbit : 1;
        unsigned tt$v_mbxdsabl : 1;
        unsigned tt$v_nobrdcst : 1;
        unsigned tt$v_readsync : 1;
        unsigned tt$v_mechform : 1;
        unsigned tt$v_halfdup : 1;
        unsigned tt$v_modem : 1;
        unsigned tt$v_oper : 1;
        unsigned ttdef$$_fill_1 : 1;
        unsigned tt$v_page : 8;
        } tt$r_ttdef_bits0;
    variant_struct  {
        unsigned ttdef$$_fill_2 : 4;
        unsigned tt$v_altframe : 1;
        unsigned tt$v_altrpar : 1;
        unsigned tt$v_parity : 1;
        unsigned tt$v_odd : 1;
        unsigned tt$v_twostop : 1;
        unsigned tt$v_disparerr : 1;
        unsigned tt$v_altdispar : 1;
        unsigned tt$v_break : 1;
        unsigned tt$v_fill_4 : 4;
        } tt$r_ttdef_bits1;
    variant_struct  {
        unsigned ttdef$$_fill_3 : 1;
        unsigned tt$v_ds_dtr : 1;       /*OUTPUT MODEM CONTROL              */
        unsigned ttdef$$_fill_4 : 1;
        unsigned tt$v_ds_sectx : 1;
        unsigned tt$v_ds_rts : 1;
        unsigned tt$v_fill_5 : 3;
        } tt$r_ttdef_bits2;
    variant_struct  {
        unsigned ttdef$$_fill_5 : 3;
        unsigned tt$v_ds_secrec : 1;
        unsigned tt$v_ds_cts : 1;
        unsigned tt$v_ds_carrier : 1;
        unsigned tt$v_ds_ring : 1;
        unsigned tt$v_ds_dsr : 1;
        } tt$r_ttdef_bits3;
    } ;
#pragma standard
#define	TT$V_ALTDISPAR	0x0A
#define	TT$V_ALTFRAME	0x04
#define TT$V_ALTRPAR    0x05
#define TT$V_BREAK	0x0B
#define TT$V_CRFILL     0x0A
#define	TT$V_DISPARERR	0x09
#define TT$V_DS_CARRIER 0x05
#define TT$V_DS_CTS	0x04
#define TT$V_DS_DSR	0x07
#define TT$V_DS_DTR	0x01
#define TT$V_DS_RING	0x06
#define TT$V_DS_RTS	0x04
#define TT$V_DS_SECREC	0x03
#define TT$V_DS_SECTX	0x03
#define TT$V_EIGHTBIT   0x0F
#define TT$V_ESCAPE     0x03
#define TT$V_HALFDUP    0x14
#define TT$V_HOLDSCREEN 0x0E
#define TT$V_HOSTSYNC   0x04
#define TT$V_LFFILL     0x0B
#define TT$V_LOWER      0x07
#define TT$V_MBXDSABL   0x10
#define TT$V_MECHFORM   0x13
#define TT$V_MECHTAB    0x08
#define TT$V_MODEM	0x15
#define TT$V_NOBRDCST   0x11
#define TT$V_NOECHO     0x01
#define TT$V_NOTYPEAHD  0x02
#define TT$V_ODD        0x07
#define TT$V_OPER	0x16
#define TT$V_PAGE       0x18
#define TT$V_PARITY     0x06
#define TT$V_PASSALL    0x00
#define TT$V_READSYNC   0x12
#define TT$V_REMOTE     0x0D
#define TT$V_SCOPE      0x0C
#define TT$V_SCRIPT     0x06
#define TT$V_TTSYNC     0x05
#define	TT$V_TWOSTOP	0x08
#define TT$V_WRAP       0x09

#endif					/* __TTDEF_LOADED */
#ifndef __TYPES_LOADED
#define __TYPES_LOADED	1

/*	TYPES - V3.0 - RTL Typedef Definitions	*/

typedef unsigned long int time_t;

#endif					/* __TYPES_LOADED */
#ifndef __UAIDEF_LOADED
#define __UAIDEF_LOADED	1

/*** MODULE $uaidef ***/
/*+                                                                         */
/*                                                                          */
/* Get User Authorization Information Data Identifier Definitions           */
/*                                                                          */
/* **** NOTE ****                                                           */
/*                                                                          */
/*        New items must always be added to the END of each item list       */
/*        so that users will not have to relink.                            */
/*-                                                                         */
#define UAI$_RTYPE 1                    /* UAF record type                  */
#define UAI$_VERSION 2                  /* UAF format version               */
#define UAI$_USRDATOFF 3                /* offset of counted string of user data */
#define UAI$_USERNAME 4                 /* username                         */
#define UAI$_USERNAME_TAG 5             /* tag to differentiate records     */
#define UAI$_UIC 6                      /* user ID code                     */
#define UAI$_MEM 7                      /* member subfield                  */
#define UAI$_GRP 8                      /* group subfield                   */
#define UAI$_SUB_ID 9                   /* user sub-identifier              */
#define UAI$_PARENT_ID 10               /* identifier of owner of this account */
#define UAI$_ACCOUNT 11                 /* account name                     */
#define UAI$_OWNER 12                   /* owner's name                     */
#define UAI$_DEFDEV 13                  /* default device                   */
#define UAI$_DEFDIR 14                  /* default directory                */
#define UAI$_LGICMD 15                  /* login command file               */
#define UAI$_DEFCLI 16                  /* default command interpreter      */
#define UAI$_CLITABLES 17               /* user CLI tables                  */
#define UAI$_PWD 18                     /* hashed password                  */
#define UAI$_PWD2 19                    /* second password                  */
#define UAI$_LOGFAILS 20                /* count of login failures          */
#define UAI$_SALT 21                    /* random password salt             */
#define UAI$_ENCRYPT 22                 /* encryption algorithm             */
#define UAI$_ENCRYPT2 23                /* encryption algorithm for 2nd pwd */
#define UAI$_PWD_LENGTH 24              /* minimum password length          */
#define UAI$_EXPIRATION 25              /* expiration date for account      */
#define UAI$_PWD_LIFETIME 26            /* password lifetime                */
#define UAI$_PWD_DATE 27                /* date of password change          */
#define UAI$_PWD2_DATE 28               /* date of 2nd password change      */
#define UAI$_LASTLOGIN_I 29             /* date of last interactive login   */
#define UAI$_LASTLOGIN_N 30             /* date of last non-interactive login */
#define UAI$_PRIV 31                    /* process privilege vector         */
#define UAI$_DEF_PRIV 32                /* default process privileges       */
#define UAI$_MIN_CLASS 33               /* minimum security class           */
#define UAI$_MAX_CLASS 34               /* maximum security class           */
#define UAI$_FLAGS 35                   /* user flags longword              */
#define UAI$_NETWORK_ACCESS_P 36        /* hourly network access, primary   */
#define UAI$_NETWORK_ACCESS_S 37        /* hourly network access, secondary */
#define UAI$_BATCH_ACCESS_P 38          /* hourly batch access, primary     */
#define UAI$_BATCH_ACCESS_S 39          /* hourly batch access, secondary   */
#define UAI$_LOCAL_ACCESS_P 40          /* hourly local access, primary     */
#define UAI$_LOCAL_ACCESS_S 41          /* hourly local access, secondary   */
#define UAI$_DIALUP_ACCESS_P 42         /* hourly dialup access, primary    */
#define UAI$_DIALUP_ACCESS_S 43         /* hourly dialup access, secondary  */
#define UAI$_REMOTE_ACCESS_P 44         /* hourly remote access, primary    */
#define UAI$_REMOTE_ACCESS_S 45         /* hourly remote access, secondary  */
#define UAI$_PRIMEDAYS 46               /* bits representing primary days   */
#define UAI$_PRI 47                     /* base process priority            */
#define UAI$_QUEPRI 48                  /* maximum job queuing priority     */
#define UAI$_MAXJOBS 49                 /* maximum jobs for UIC allowed     */
#define UAI$_MAXACCTJOBS 50             /* maximum jobs for account allowed */
#define UAI$_MAXDETACH 51               /* maximum detached processes for UIC */
#define UAI$_PRCCNT 52                  /* subprocess creation limit        */
#define UAI$_BIOLM 53                   /* buffered I/O limit               */
#define UAI$_DIOLM 54                   /* direct I/O limit                 */
#define UAI$_TQCNT 55                   /* timer queue entry limit          */
#define UAI$_ASTLM 56                   /* AST queue limit                  */
#define UAI$_ENQLM 57                   /* enqueue limit                    */
#define UAI$_FILLM 58                   /* open file limit                  */
#define UAI$_SHRFILLM 59                /* shared file limit                */
#define UAI$_WSQUOTA 60                 /* working set size quota           */
#define UAI$_DFWSCNT 61                 /* default working set size         */
#define UAI$_WSEXTENT 62                /* working set size limit           */
#define UAI$_PGFLQUOTA 63               /* page file quota                  */
#define UAI$_CPUTIM 64                  /* CPU time quota                   */
#define UAI$_BYTLM 65                   /* buffered I/O byte count limit    */
#define UAI$_PBYTLM 66                  /* paged buffer I/O byte count limit */
#define UAI$_JTQUOTA 67                 /* job-wide logical name table creation quota */
#define UAI$_PROXY_LIM 68               /* number of proxies user can grant */
#define UAI$_PROXIES 69                 /* number of proxies granted        */
#define UAI$_ACCOUNT_LIM 70             /* number of sub-accounts allowed   */
#define UAI$_ACCOUNTS 71                /* number of sub-accounts in use    */
/* ADD ITEM-CODES BEFORE THIS COMMENT                                       */
#define UAI$_MAX_ITEM_CODE 72           /* maximum legal item code + 1      */
/* Define the various encryption codes, returned by the encryption algorithm */
/* item.                                                                    */
#define UAI$C_AD_II 0                   /* AUTODIN-II 32 bit crc code       */
#define UAI$C_PURDY 1                   /* Purdy polynomial over salted input */
#define UAI$C_PURDY_V 2                 /* Purdy polynomial + variable length username */
/* Define the flags for the user flags longword.                            */
#define UAI$M_DISCTLY 1
#define UAI$M_DEFCLI 2
#define UAI$M_LOCKPWD 4
#define UAI$M_CAPTIVE 8
#define UAI$M_DISACNT 16
#define UAI$M_DISWELCOM 32
#define UAI$M_DISMAIL 64
#define UAI$M_NOMAIL 128
#define UAI$M_GENPWD 256
#define UAI$M_PWD_EXPIRED 512
#define UAI$M_PWD2_EXPIRED 1024
#define UAI$M_AUDIT 2048
#define UAI$M_DISREPORT 4096
#define UAI$M_DISRECONNECT 8192
#define UAI$M_AUTOLOGIN 16384
#define UAI$M_DISFORCE_PWD_CHANGE 32768
#pragma nostandard
struct flags {                          /* user flags longword              */
    unsigned uai$v_disctly : 1;         /* no user control-y                */
    unsigned uai$v_defcli : 1;          /* only allow user default CLI      */
    unsigned uai$v_lockpwd : 1;         /* disable SET PASSWORD command     */
    unsigned uai$v_captive : 1;         /* captive account (no overrides)   */
    unsigned uai$v_disacnt : 1;         /* no interactive login             */
    unsigned uai$v_diswelcom : 1;       /* skip welcome message             */
    unsigned uai$v_dismail : 1;         /* skip new mail message            */
    unsigned uai$v_nomail : 1;          /* disable mail delivery            */
    unsigned uai$v_genpwd : 1;          /* passwords must be generated      */
    unsigned uai$v_pwd_expired : 1;     /* password has expired             */
    unsigned uai$v_pwd2_expired : 1;    /* 2nd password has expired         */
    unsigned uai$v_audit : 1;           /* audit all actions                */
    unsigned uai$v_disreport : 1;       /* skip last login messages         */
    unsigned uai$v_disreconnect : 1;    /* inhibit reconnections            */
    unsigned uai$v_autologin : 1;       /* auto-login only                  */
    unsigned uai$v_disforce_pwd_change : 1; /* disable forced password change */
    } ;
/* Define the flags representing primary days.                              */
struct primedays {                      /* bits representing primary days   */
    unsigned uai$v_monday : 1;          /* bit clear means this is a primary day */
    unsigned uai$v_tuesday : 1;         /* bit set means this is an off day */
    unsigned uai$v_wednesday : 1;
    unsigned uai$v_thursday : 1;
    unsigned uai$v_friday : 1;
    unsigned uai$v_saturday : 1;
    unsigned uai$v_sunday : 1;
    unsigned uai$v_fill_6 : 1;
    } ;
#pragma standard
#define	UAI$V_DISCTLY	0
#define	UAI$V_DEFCLI	1
#define	UAI$V_LOCKPWD	2
#define	UAI$V_CAPTIVE	3
#define	UAI$V_DISACNT	4
#define	UAI$V_DISWELCOM	5
#define	UAI$V_DISMAIL	6
#define	UAI$V_NOMAIL	7
#define	UAI$V_GENPWD	8
#define	UAI$V_PWD_EXPIRED	9
#define	UAI$V_PWD2_EXPIRED	10
#define	UAI$V_AUDIT	11
#define	UAI$V_DISREPORT	12
#define	UAI$V_DISRECONNECT	13
#define	UAI$V_AUTOLOGIN	14
#define	UAI$V_DISFORCE_PWD_CHANGE	15
#define	UAI$V_MONDAY	0
#define	UAI$V_TUESDAY	1
#define	UAI$V_WEDNESDAY	2
#define	UAI$V_THURSDAY	3
#define	UAI$V_FRIDAY	4
#define	UAI$V_SATURDAY	5
#define	UAI$V_SUNDAY	6

#endif					/* __UAIDEF_LOADED */
/********************************************************************************************************************************/
/* Created 25-APR-1995 21:20:51 by VAX SDL V3.2-12     Source: 21-NOV-1994 16:47:12 BUILD2$:[UCX.V33.BL7.SRC.NET]INET_USER.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $ARPREQDEF ***/
#define ARP$M_IN_USE 1
#define ARP$M_COM 2
#define ARP$M_PERM 4
#define ARP$M_PUBL 8
#define ARP$M_USETRAILERS 16
#define ARP$C_LENGTH 34
#define ARP$K_LENGTH 34
struct ARPREQDEF {
    char ARP$T_PA [16];                 /* IP address                       */
/* $SOCKADDRINDEF defines offsets                                           */
    char ARP$T_HA [16];                 /* Ethernet hardware address        */
/* $SOCKADDRDEF defines offsets                                             */
    union  {                            /*                                  */
        unsigned short int ARP$W_FLAGS; /* flags                            */
        struct  {                       /*                                  */
            unsigned ARP$V_IN_USE : 1;  /* ARP entry is in use              */
            unsigned ARP$V_COM : 1;     /* ARP entry is complete            */
            unsigned ARP$V_PERM : 1;    /* ARP entry is pemanent            */
            unsigned ARP$V_PUBL : 1;    /* ARP entry is public              */
            unsigned ARP$V_USETRAILERS : 1; /* hosts uses trailers          */
            unsigned ARP$V_fill_0 : 3;
            } ARP$R_O_FLAGS;
        } ARP$R_OVLY;
    } ;
 
/*** MODULE $IFREQDEF ***/
#define IFR$M_IFF_UP 1
#define IFR$M_IFF_BROADCAST 2
#define IFR$M_IFF_DEBUG 4
#define IFR$M_IFF_LOOPBACK 8
#define IFR$M_IFF_POINTOPOINT 16
#define IFR$M_IFF_NOTRAILERS 32
#define IFR$M_IFF_RUNNING 64
#define IFR$M_IFF_NOARP 128
#define IFR$M_IFF_PROMISC 256
#define IFR$M_IFF_ALLMULTI 512
#define IFR$M_IFF_DYNPROTO 1024
#define IFR$M_IFF_MOP 2048
#define IFR$M_IFF_NONAME 16384
#define IFR$M_IFF_CLUSTER 32768
#define IFR$C_LENGTH 32
#define IFR$K_LENGTH 32
struct IFREQDEF {
    char IFR$T_NAME [16];               /* device name                      */
    union  {
        char IFR$T_ADDR [16];           /* SOCKADDRIN structure             */
        char IFR$T_DSTADDR [16];        /* SOCKADDRIN structure             */
        char IFR$T_BROADADDR [16];      /* SOCKADDRIN structure             */
        union  {
            unsigned short int IFR$W_FLAGS; /* flags                        */
            struct  {
                unsigned IFR$V_IFF_UP : 1; /* Interface is up               */
                unsigned IFR$V_IFF_BROADCAST : 1; /* Broadcast address valid */
                unsigned IFR$V_IFF_DEBUG : 1; /* Turn on tracing            */
                unsigned IFR$V_IFF_LOOPBACK : 1; /* Interface set to loopback */
                unsigned IFR$V_IFF_POINTOPOINT : 1; /* Interface is point-to-point link */
                unsigned IFR$V_IFF_NOTRAILERS : 1; /* Avoid use of trailers */
                unsigned IFR$V_IFF_RUNNING : 1; /* Resources are allocated  */
                unsigned IFR$V_IFF_NOARP : 1; /* No address resolution protocol */
                unsigned IFR$V_IFF_PROMISC : 1; /* Receive all packets      */
                unsigned IFR$V_IFF_ALLMULTI : 1; /* Receive all multicasting packets */
                unsigned IFR$V_IFF_DYNPROTO : 1; /* Support dynamic proto dispatching */
                unsigned IFR$V_IFF_MOP : 1; /* Device in MOP mode; not in use */
                unsigned IFR$V_IFF_RESERVE : 2; /* SPARE bits               */
                unsigned IFR$V_IFF_NONAME : 1; /* Interface cluster name flag */
                unsigned IFR$V_IFF_CLUSTER : 1; /* Interface is a cluster IFNET */
                } IFR$R_DUMMY_1_BITS;
            } IFR$R_DUMMY_1_OVRL;
        int *IFR$L_DATA;                /* pointer to data                  */
        } IFR$R_DUMMY;
    } ;
 
/*** MODULE $INETERRDEF ***/
#define EPERM 1                         /* Not owner                        */
#define ENOENT 2                        /* No such file or directory        */
#define ESRCH 3                         /* No such process                  */
#define EINTR 4                         /* Interrupted system call          */
#define EIO 5                           /* I/O error                        */
#define ENXIO 6                         /* No such device or address        */
#define E2BIG 7                         /* Arg list too long                */
#define ENOEXEC 8                       /* Exec format error                */
#define EBADF 9                         /* Bad file number                  */
#define ECHILD 10                       /* No children                      */
#define EAGAIN 11                       /* No more processes                */
#define ENOMEM 12                       /* Not enough core                  */
#define EACCES 13                       /* Permission denied                */
#define EFAULT 14                       /* Bad address                      */
#define ENOTBLK 15                      /* Block device required            */
#define EBUSY 16                        /* Mount device busy                */
#define EEXIST 17                       /* File exists                      */
#define EXDEV 18                        /* Cross-device link                */
#define ENODEV 19                       /* No such device                   */
#define ENOTDIR 20                      /* Not a directory                  */
#define EISDIR 21                       /* Is a directory                   */
#define EINVAL 22                       /* Invalid argument                 */
#define ENFILE 23                       /* File table overflow              */
#define EMFILE 24                       /* Too many open files              */
#define ENOTTY 25                       /* Not a typewriter                 */
#define ETXTBSY 26                      /* Text file busy                   */
#define EFBIG 27                        /* File too large                   */
#define ENOSPC 28                       /* No space left on device          */
#define ESPIPE 29                       /* Illegal seek                     */
#define EROFS 30                        /* Read-only file system            */
#define EMLINK 31                       /* Too many links                   */
#define EPIPE 32                        /* Broken pipe                      */
/* math software                                                            */
#define EDOM 33                         /* Argument too large               */
#define ERANGE 34                       /* Result too large                 */
/* non-blocking and interrupt i/o                                           */
#define EWOULDBLOCK 35                  /* Operation would block            */
#define EINPROGRESS 36                  /* Operation now in progress        */
#define EALREADY 37                     /* Operation already in progress    */
/* ipc/network software                                                     */
/* argument errors                                                          */
#define ENOTSOCK 38                     /* Socket operation on non-socket   */
#define EDESTADDRREQ 39                 /* Destination address required     */
#define EMSGSIZE 40                     /* Message too long                 */
#define EPROTOTYPE 41                   /* Protocol wrong type for socket   */
#define ENOPROTOOPT 42                  /* Protocol not available           */
#define EPROTONOSUPPORT 43              /* Protocol not supported           */
#define ESOCKTNOSUPPORT 44              /* Socket type not supported        */
#define EOPNOTSUPP 45                   /* Operation not supported on socket  */
#define EPFNOSUPPORT 46                 /* Protocol family not supported    */
#define EAFNOSUPPORT 47                 /* Address family not supported by protocol family  */
#define EADDRINUSE 48                   /* Address already in use           */
#define EADDRNOTAVAIL 49                /* Can't assign requested address   */
/* operational errors                                                       */
#define ENETDOWN 50                     /* Network is down                  */
#define ENETUNREACH 51                  /* Network is unreachable           */
#define ENETRESET 52                    /* Network dropped connection on reset  */
#define ECONNABORTED 53                 /* Software caused connection abort  */
#define ECONNRESET 54                   /* Connection reset by peer         */
#define ENOBUFS 55                      /* No buffer space available        */
#define EISCONN 56                      /* Socket is already connected      */
#define ENOTCONN 57                     /* Socket is not connected          */
#define ESHUTDOWN 58                    /* Can't send after socket shutdown  */
#define ETOOMANYREFS 59                 /* Too many references: can't splice  */
#define ETIMEDOUT 60                    /* Connection timed out             */
#define ECONNREFUSED 61                 /* Connection refused               */
#define ELOOP 62                        /* Too many levels of symbolic links  */
#define ENAMETOOLONG 63                 /* File name too long               */
/* should be rearranged                                                     */
#define EHOSTDOWN 64                    /* Host is down                     */
#define EHOSTUNREACH 65                 /* No route to host                 */
/* quotas & mush                                                            */
#define EPROCLIM 67                     /* Too many processes               */
#define EUSERS 68                       /* Too many users                   */
#define EDQUOT 69                       /* Disc quota exceeded              */
 
/*** MODULE $INETSYMDEF ***/
#define DVI$_ACP_TCP 2
#define INET$C_ICMP 1
#define INET$C_RAW_IP 255
#define INET$C_TCP 6
#define INET$C_UDP 17
#define INET$C_AUXS 127
#define INET$C_REXEC 128
#define IPPROTO$C_ICMP 1
#define IPPROTO$C_RAW_IP 255
#define IPPROTO$C_TCP 6
#define IPPROTO$C_UDP 17
#define IPPROTO$C_AUXS 127
#define IPPROTO$C_REXEC 128
/*                                                                          */
#define UCX$C_ICMP 1
#define UCX$C_RAW_IP 255
#define UCX$C_TCP 6
#define UCX$C_UDP 17
#define UCX$C_AUXS 127
#define UCX$C_REXEC 128
/*                                                                          */
/* Ports < IP_PROTO$C_RESERVED are reserved for                             */
/* privileged processes (e.g. root).                                        */
/*                                                                          */
#define IP_PROTO$C_RESERVED 1024
#define INET_PROTYP$C_STREAM 1          /* stream type                      */
#define INET_PROTYP$C_DGRAM 2           /* datagram type                    */
#define INET_PROTYP$C_RAW 3             /* raw type                         */
/*                                                                          */
#define UCX$C_STREAM 1
#define UCX$C_DGRAM 2
#define UCX$C_RAW 3
#define INET$C_IPOPT 0                  /* IP opt type parameter            */
#define INET$C_SOCKOPT 1                /* setsockopt type parameter        */
#define INET$C_IOCTL 2                  /* ioctl type parameter             */
#define INET$C_DATA 3                   /* data                             */
#define INET$C_SOCK_NAME 4              /* socket name                      */
#define INET$C_RESERVE_1 5
#define INET$C_TCPOPT 6                 /* TCP option type                  */
/*                                                                          */
#define UCX$C_IPOPT 0
#define UCX$C_SOCKOPT 1
#define UCX$C_TCPOPT 6
#define UCX$C_IOCTL 2
#define UCX$C_DATA 3
#define INET$C_DSC_RCV 0                /* discard received messages        */
#define INET$C_DSC_SND 1                /* discard sent messages            */
#define INET$C_DSC_ALL 2                /* discard all messages             */
#define UCX$C_DSC_RCV 0
#define UCX$C_DSC_SND 1
#define UCX$C_DSC_ALL 2
#define UCX$C_SO_SNDBUF 4097
#define UCX$C_SO_RCVBUF 4098
#define UCX$C_SO_SNDLOWAT 4099
#define UCX$C_SO_RCVLOWAT 4100
#define UCX$C_SO_SNDTIMEO 4101
#define UCX$C_SO_RCVTIMEO 4102
#define UCX$C_SO_ERROR 4103
#define UCX$C_SO_TYPE 4104
#define UCX$C_SO_SHARE 4105
#define UCX$C_SO_CCL 4106
#define UCX$C_SO_NO_RCV_CHKSUM 16384
#define UCX$C_SO_NO_SND_CHKSUM 32768
#define UCX$C_SO_NO_CHKSUM 49152
/*;constant (                                                               */
/*;	DEBUGGING 	                                                    */
/*;	,ACCEPTCONN                                                         */
/*;	,REUSEADDR                                                          */
/*;	,KEEPALIVE                                                          */
/*;	,DONTROUTE                                                          */
/*;	,BROADCAST                                                          */
/*;	,USELOOPBACK                                                        */
/*;	,LINGER                                                             */
/*;	,OOBINLINE                                                          */
/*;	) equals 1 increment 1 prefix UCX$ tag C counter #types;            */
#define INET$C_TCPOPT_EOL 0
#define INET$C_TCPOPT_NOP 1
#define INET$C_TCPOPT_MAXSEG 2
#define INET$C_TCP_NODELAY 1            /* don't delay send to coalesce packets  */
#define INET$C_TCP_MAXSEG 2             /* set maximum segment size         */
#define INET$C_TCP_PROBE_IDLE 128       /* probe idle timer                 */
#define INET$C_TCP_DROP_IDLE 129        /* drop idle timer                  */
#define UCX$C_TCPOPT_EOL 0
#define UCX$C_TCPOPT_NOP 1
#define UCX$C_TCPOPT_MAXSEG 2
#define UCX$C_TCP_NODELAY 1
#define UCX$C_TCP_MAXSEG 2
#define UCX$C_TCP_PROBE_IDLE 128
#define UCX$C_TCP_DROP_IDLE 129
#define INET$C_IP_TOS 3
#define INET$C_IP_TTL 4
#define UCX$C_IP_TOS 3
#define UCX$C_IP_TTL 4
#define INET$C_AF_UNSPEC 0              /* unspecified                      */
#define INET$C_AF_UNIX 1                /* local to host (pipes, portals)   */
#define INET$C_AF_INET 2                /* internetwork: UDP, TCP, etc.     */
#define INET$C_AF_MAX 3                 /* maximum value                    */
#define INET$C_INADDR_ANY 0
#define INET$C_INADDR_BROADCAST -1
/*                                                                          */
#define UCX$C_AF_UNSPEC 0
#define UCX$C_AF_UNIX 1
#define UCX$C_AF_INET 2
#define UCX$C_AF_MAX 3
#define UCX$C_INADDR_ANY 0
#define UCX$C_INADDR_BROADCAST -1
/*                                                                          */
#define INET$M_MSG_OOB 1
#define INET$M_MSG_PEEK 2
#define INET$M_MSG_DONTROUTE 4
#define INET$M_DUMMYN_4 8
#define INET$M_DUMMYN_5 16
#define INET$M_MSG_PURGE 32
#define INET$M_MSG_NBIO 64
#define INET$M_MSG_BLOCKALL 128
struct MSGBITS {
    struct  {
/*                                                                          */
        unsigned INET$V_MSG_OOB : 1;    /* turn on event logging, not used  */
        unsigned INET$V_MSG_PEEK : 1;   /* socket has had LISTEN            */
        unsigned INET$V_MSG_DONTROUTE : 1; /* use only the interface addr   */
/*                                                                          */
        unsigned INET$V_DUMMYN_4 : 1;   /* reserve space                    */
/*                                                                          */
        unsigned INET$V_DUMMYN_5 : 1;   /* reserve space                    */
/*                                                                          */
        unsigned INET$V_MSG_PURGE : 1;  /* Purge I/O                        */
        unsigned INET$V_MSG_NBIO : 1;   /* NON-block I/O                    */
        unsigned INET$V_MSG_BLOCKALL : 1; /* record TCP I/O                 */
        } INET$R_MSG_BITS;
    } ;
#define INET$C_MSG_OOB 1                /* process out-of-band data         */
#define INET$C_MSG_PEEK 2               /* peek at incoming message         */
#define INET$C_MSG_DONTROUTE 4          /* send without                     */
/* using routing tables                                                     */
#define INET$C_MSG_PURGE 32             /* block read until fill buffer     */
#define INET$C_MSG_NBIO 64              /* block read until fill buffer     */
#define INET$C_MSG_BLOCKALL 128         /* block read until fill buffer     */
#define INET$C_MSG_MAXIOVLEN 16
/*                                                                          */
#define UCX$C_MSG_OOB 1                 /* process out-of-band data         */
#define UCX$C_MSG_PEEK 2                /* peek at incoming message         */
#define UCX$C_MSG_DONTROUTE 4           /* send without                     */
/* using routing tables                                                     */
#define UCX$C_MSG_PURGE 32              /* block read until fill buffer     */
#define UCX$C_MSG_NBIO 64               /* block read until fill buffer     */
#define UCX$C_MSG_BLOCKALL 128          /* block read until fill buffer     */
#define UCX$C_MSG_MAXIOVLEN 16
#define UCX$M_MSG_OOB 1
#define UCX$M_MSG_PEEK 2
#define UCX$M_MSG_DONTROUTE 4
#define UCX$M_DUMMYX_4 8
#define UCX$M_DUMMYX_5 16
#define UCX$M_MSG_PURGE 32
#define UCX$M_MSG_NBIO 64
#define UCX$M_MSG_BLOCKALL 128
struct MSGBITS_1 {
    struct  {
/*                                                                          */
        unsigned UCX$V_MSG_OOB : 1;     /* turn on event logging, not used  */
        unsigned UCX$V_MSG_PEEK : 1;    /* socket has had LISTEN            */
        unsigned UCX$V_MSG_DONTROUTE : 1; /* use only the interface addr    */
/*                                                                          */
        unsigned UCX$V_DUMMYX_4 : 1;    /* reserve space                    */
/*                                                                          */
        unsigned UCX$V_DUMMYX_5 : 1;    /* reserve space                    */
/*                                                                          */
        unsigned UCX$V_MSG_PURGE : 1;   /* Purge I/O                        */
        unsigned UCX$V_MSG_NBIO : 1;    /* NON-block I/O                    */
        unsigned UCX$V_MSG_BLOCKALL : 1; /* record TCP I/O                  */
        } UCX$R_MSG_BITS;
    } ;
#define UCX$M_DEBUGGING 1
#define UCX$M_ACCEPTCONN 2
#define UCX$M_REUSEADDR 4
#define UCX$M_KEEPALIVE 8
#define UCX$M_DONTROUTE 16
#define UCX$M_BROADCAST 32
#define UCX$M_USELOOPBACK 64
#define UCX$M_LINGER 128
#define UCX$M_OOBINLINE 256
#define UCX$M_DUMMYM_2 512
#define UCX$M_DUMMYM_3 1024
#define UCX$M_DUMMYM_4 2048
#define UCX$M_DUMMYM_5 4096
#define UCX$M_FULL_DUPLEX_CLOSE 8192
#define UCX$M_NO_RCV_CHKSUM 16384
#define UCX$M_NO_SND_CHKSUM 32768
#define UCX$C_DEBUG 1                   /* turn on event logging, not used  */
#define UCX$C_ACCEPTCONN 2              /* socket has had LISTEN            */
#define UCX$C_REUSEADDR 4               /* allow local address reuse        */
#define UCX$C_KEEPALIVE 8               /* keep connection alive            */
#define UCX$C_DONTROUTE 16              /* use only the interface addr      */
#define UCX$C_BROADCAST 32              /* allow broadcasting               */
#define UCX$C_USELOOPBACK 64            /* loopback interface, not used     */
#define UCX$C_LINGER 128                /* linger at close                  */
#define UCX$C_OOBINLINE 256             /* leave received OOB data in line  */
#define UCX$C_FULL_DUPLEX_CLOSE 8192    /* full duplex close                */
#define UCX$C_NO_RCV_CHKSUM 16384       /* no receive checksum calculation  */
#define UCX$C_NO_SND_CHKSUM 32768       /* no send checksum calculation     */
#define UCX$M_NO_CHKSUM 49152           /* no checksum calculation          */
#define UCX$C_NO_CHKSUM 49152           /* no checksum calculation          */
/*                                                                          */
#define UCX$C_SNDBUF 4097               /* send buffer size                 */
#define UCX$C_RCVBUF 4098               /* receive buffer size              */
#define UCX$C_SNDLOWAT 4099             /* send low-water mark              */
#define UCX$C_RCVLOWAT 4100             /* receive low-water mark           */
#define UCX$C_SNDTIMEO 4101             /* send timeout                     */
#define UCX$C_RCVTIMEO 4102             /* receive timeout                  */
#define UCX$C_ERROR 4103                /* get error status and clear       */
#define UCX$C_TYPE 4104                 /* get socket type                  */
#define UCX$C_SHARE 4105                /* shared between processes         */
#define UCX$C_CCL 4106                  /* carriage control added           */
/*                                                                          */
#define UCX$M_SNDBUF 4097               /* send buffer size                 */
#define UCX$M_RCVBUF 4098               /* receive buffer size              */
#define UCX$M_SNDLOWAT 4099             /* send low-water mark              */
#define UCX$M_RCVLOWAT 4100             /* receive low-water mark           */
#define UCX$M_SNDTIMEO 4101             /* send timeout                     */
#define UCX$M_RCVTIMEO 4102             /* receive timeout                  */
#define UCX$M_ERROR 4103                /* get error status and clear       */
#define UCX$M_TYPE 4104                 /* get socket type                  */
#define UCX$M_SHARE 4105                /* shared between processes         */
#define UCX$M_CCL 4106                  /* carriage control added           */
struct SOCKOPTDEF {
    union  {                            /*                                  */
        unsigned short int UCX$W_OPTIONS; /* Socket options, see socket.h   */
        struct  {
/*                                                                          */
/* Socket options bits.                                                     */
/*                                                                          */
            unsigned UCX$V_DEBUGGING : 1; /* turn on event logging, not used */
            unsigned UCX$V_ACCEPTCONN : 1; /* socket has had LISTEN         */
            unsigned UCX$V_REUSEADDR : 1; /* allow local address reuse      */
            unsigned UCX$V_KEEPALIVE : 1; /* keep connection alive          */
            unsigned UCX$V_DONTROUTE : 1; /* use only the interface addr    */
            unsigned UCX$V_BROADCAST : 1; /* allow broadcasting             */
            unsigned UCX$V_USELOOPBACK : 1; /* loopback interface, not used */
            unsigned UCX$V_LINGER : 1;  /* linger at close                  */
            unsigned UCX$V_OOBINLINE : 1; /* leave received OOB data in line  */
/*                                                                          */
/*                                                                          */
            unsigned UCX$V_DUMMYM_2 : 1; /* reserve space                   */
            unsigned UCX$V_DUMMYM_3 : 1; /* reserve space                   */
            unsigned UCX$V_DUMMYM_4 : 1; /* reserve space                   */
            unsigned UCX$V_DUMMYM_5 : 1; /* reserve space                   */
/*                                                                          */
            unsigned UCX$V_FULL_DUPLEX_CLOSE : 1; /* full duplex close      */
            unsigned UCX$V_NO_RCV_CHKSUM : 1; /* no receive checksum calculation */
            unsigned UCX$V_NO_SND_CHKSUM : 1; /* no send checksum calculation */
/*                                                                          */
/* Additional options, not kept in so_options.                              */
/*                                                                          */
            } UCX$R_OPT_BITS;
        } UCX$R_OPT_OVRLY;
    } ;
 
/*** MODULE $OPTDEF ***/
#define OPT$L_ADDRESS 4
#define OPT$C_SET_LENGTH 8
#define OPT$K_SET_LENGTH 8
#define OPT$C_GET_LENGTH 12
#define OPT$K_GET_LENGTH 12
struct OPTDEF {
    unsigned short int OPT$W_LENGTH;    /* length                           */
    unsigned short int OPT$W_NAME;      /* name                             */
    int *OPT$L_ADDR;                    /* address                          */
    int *OPT$L_RET_LENGTH;              /* address                          */
    } ;
 
/*** MODULE $RTENTRYDEF ***/
/*                                                                          */
/* We distinguish between routes to hosts and routes to networks,           */
/* preferring the former if available.  For each route we infer             */
/* the interface to use from the gateway address supplied when              */
/* the route was entered.  Routes that forward packets through              */
/* gateways are marked so that the output routines know to address the      */
/* gateway rather than the ultimate destination.                            */
/*                                                                          */
#define RT$M_RTF_UP 1
#define RT$M_RTF_GATEWAY 2
#define RT$M_RTF_HOST 4
#define RT$M_RTF_DYNAMIC 8
#define RT$M_RTF_MODIFIED 16
#define RT$C_LENGTH 52
#define RT$K_LENGTH 52
struct RTENTRYDEF {
    unsigned long int RT$L_HASH;        /* Hash link                        */
    union  {
        struct  {
            unsigned short int RT$W_DST_SIN_FAMILY; /* Address type         */
            unsigned short int RT$W_DST_SIN_PORT; /* Port number            */
            unsigned long int RT$L_DST_SIN_ADDR; /* Internet address        */
            char RT$T_DST_SIN_ZERO [8]; /* Unused space                     */
            } RT$R_DST_FIELDS;
        char RT$T_DST [16];             /* Destination SOCKADDR structure   */
        } RT$R_DST_OVRLY;
    union  {
        struct  {
            unsigned short int RT$W_GATEWAY_SIN_FAMILY; /* Address type     */
            unsigned short int RT$W_GATEWAY_SIN_PORT; /* Port number        */
            unsigned long int RT$L_GATEWAY_SIN_ADDR; /* Internet address    */
            char RT$T_GATEWAY_SIN_ZERO [8]; /* Unused space                 */
            } RT$R_GATEWAY_FIELDS;
        char RT$T_GATEWAY [16];         /* Gateway SOCKADDR structure       */
        } RT$R_GATEWAY_OVRLY;
    union  {
        unsigned short int RT$W_FLAGS;  /* up/down?, host/net               */
        struct  {
            unsigned RT$V_RTF_UP : 1;   /* route useable                    */
            unsigned RT$V_RTF_GATEWAY : 1; /* destination is a gateway      */
            unsigned RT$V_RTF_HOST : 1; /* host entry (net otherwise)       */
            unsigned RT$V_RTF_DYNAMIC : 1; /* created dynamically (by redirect) */
            unsigned RT$V_RTF_MODIFIED : 1; /* changed by redirect          */
            unsigned RT$V_fill_1 : 3;
            } RT$R_FLAGS_BITS;
        } RT$R_FLAGS_OVRLY;
    unsigned short int RT$W_REFCNT;     /* # held references                */
    unsigned long int RT$L_USE;         /* raw # packets forwarded          */
    unsigned long int RT$L_IFP;         /* pointer to the IFNET interface to use */
    unsigned long int RT$L_NEXT;        /* pointer to the next RTENTRY      */
    } ;
 
/*** MODULE $SIOCDEF ***/
#define FIONREAD -2147195265            /* Get # bytes to read              */
#define FIONBIO -2147195266             /* non block I/O                    */
#define FIOASYNC -2147195267            /* asynch I/O                       */
#define SIOCSHIWAT -2147192064          /* high water mark                  */
#define SIOCGHIWAT 1074033409           /* high water mark                  */
#define SIOCSLOWAT -2147192062          /* low water mark                   */
#define SIOCGLOWAT 1074033411           /* low water mark                   */
#define SIOCATMARK 1074033415           /* at OOB mark                      */
#define SIOCSPGRP -2147192056           /* Process group                    */
#define SIOCGPGRP 1074033417            /* Process group                    */
#define SIOCADDRT -2144046582           /* add RT                           */
#define SIOCDELRT -2144046581           /* delete RT                        */
#define SIOCGETRT -1070304725           /* get RT                           */
#define SIOCSIFADDR -2145359604         /* set IF address                   */
#define SIOCGIFADDR -1071617779         /* Get IF address                   */
#define SIOCSIFDSTADDR -2145359602      /* Destination addr                 */
#define SIOCGIFDSTADDR -1071617777      /* BDestination addr                */
#define SIOCSIFFLAGS -2145359600        /* IF flags                         */
#define SIOCGIFFLAGS -1071617775        /* IF flags                         */
#define SIOCGIFBRDADDR -1071617774      /* Broadcast addr                   */
#define SIOCSIFBRDADDR -2145359597      /* Broadcats addr                   */
#define SIOCGIFCONF -1073190636         /* IF configuration                 */
#define SIOCGIFNETMASK -1071617771      /* Network mask                     */
#define SIOCSIFNETMASK -2145359594      /* Network mask                     */
#define SIOCSARP -2145097442            /* set ARP                          */
#define SIOCGARP -1071355617            /* get ARP                          */
#define SIOCDARP -2145097440            /* delete ARP                       */
#define SIOCARPREQ -1071355608          /* ARP request                      */
#define SIOCENABLBACK -2145359583       /* enable loopback                  */
#define SIOCDISABLBACK -2145359582      /* disable loopback                 */
#define SIOCSTATE -1072273117           /* state                            */
 
/*** MODULE $SOCKETOPTDEF ***/
/*                                                                          */
/* Socket options data structure.                                           */
/*                                                                          */
#define SOCKOPT$M_DEBUG 1
#define SOCKOPT$M_ACCEPTCONN 2
#define SOCKOPT$M_REUSEADDR 4
#define SOCKOPT$M_KEEPALIVE 8
#define SOCKOPT$M_DONTROUTE 16
#define SOCKOPT$M_BROADCAST 32
#define SOCKOPT$M_USELOOPBACK 64
#define SOCKOPT$M_LINGER 128
#define SOCKOPT$M_OOBINLINE 256
#define SOCKOPT$M_DUMMYB_2 512
#define SOCKOPT$M_DUMMYB_3 1024
#define SOCKOPT$M_DUMMYB_4 2048
#define SOCKOPT$M_DUMMYB_5 4096
#define SOCKOPT$M_FULL_DUPLEX_CLOSE 8192
#define SOCKOPT$M_NO_RCV_CHKSUM 16384
#define SOCKOPT$M_NO_SND_CHKSUM 32768
#define SOCKOPT$M_NO_CHKSUM 49152       /* no checksum calculation          */
#define SOCKOPT$C_NO_CHKSUM 49152       /* no checksum calculation          */
/*                                                                          */
#define SOCKOPT$C_SNDBUF 4097           /* send buffer size                 */
#define SOCKOPT$C_RCVBUF 4098           /* receive buffer size              */
#define SOCKOPT$C_SNDLOWAT 4099         /* send low-water mark              */
#define SOCKOPT$C_RCVLOWAT 4100         /* receive low-water mark           */
#define SOCKOPT$C_SNDTIMEO 4101         /* send timeout                     */
#define SOCKOPT$C_RCVTIMEO 4102         /* receive timeout                  */
#define SOCKOPT$C_ERROR 4103            /* get error status and clear       */
#define SOCKOPT$C_TYPE 4104             /* get socket type                  */
#define SOCKOPT$C_SHARE 4105            /* shared between processes         */
#define SOCKOPT$C_CCL 4106              /* carriage control added           */
#define SOCKOPT$M_SNDBUF 4097           /* send buffer size                 */
#define SOCKOPT$M_RCVBUF 4098           /* receive buffer size              */
#define SOCKOPT$M_SNDLOWAT 4099         /* send low-water mark              */
#define SOCKOPT$M_RCVLOWAT 4100         /* receive low-water mark           */
#define SOCKOPT$M_SNDTIMEO 4101         /* send timeout                     */
#define SOCKOPT$M_RCVTIMEO 4102         /* receive timeout                  */
#define SOCKOPT$M_ERROR 4103            /* get error status and clear       */
#define SOCKOPT$M_TYPE 4104             /* get socket type                  */
#define SOCKOPT$M_SHARE 4105            /* shared between processes         */
#define SOCKOPT$M_CCL 4106              /* carriage control added           */
#define SOCKOPT$C_DEBUG 1               /* turn on event logging, not used  */
#define SOCKOPT$C_ACCEPTCONN 2          /* socket has had LISTEN            */
#define SOCKOPT$C_REUSEADDR 4           /* allow local address reuse        */
#define SOCKOPT$C_KEEPALIVE 8           /* keep connection alive            */
#define SOCKOPT$C_DONTROUTE 16          /* use only the interface addr      */
#define SOCKOPT$C_BROADCAST 32          /* allow broadcasting               */
#define SOCKOPT$C_USELOOPBACK 64        /* loopback interface, not used     */
#define SOCKOPT$C_LINGER 128            /* linger at close                  */
#define SOCKOPT$C_OOBINLINE 256         /* leave received OOB data in line  */
#define SOCKOPT$C_FULL_DUPLEX_CLOSE 8192 /* full duplex close               */
#define SOCKOPT$C_NO_RCV_CHKSUM 16384   /* no receive checksum calculation  */
#define SOCKOPT$C_NO_SND_CHKSUM 32768   /* no send checksum calculation     */
#define SOCKOPT$C_LENGTH 2
#define SOCKOPT$K_LENGTH 2
struct SOCKETOPTDEF {
    union  {                            /*                                  */
        unsigned short int SOCKOPT$W_OPTIONS; /* Socket options, see socket.h  */
        struct  {
/*                                                                          */
/* Socket options bits.                                                     */
/*                                                                          */
            unsigned SOCKOPT$V_DEBUG : 1; /* turn on event logging, not used */
            unsigned SOCKOPT$V_ACCEPTCONN : 1; /* socket has had LISTEN     */
            unsigned SOCKOPT$V_REUSEADDR : 1; /* allow local address reuse  */
            unsigned SOCKOPT$V_KEEPALIVE : 1; /* keep connection alive      */
            unsigned SOCKOPT$V_DONTROUTE : 1; /* use only the interface addr */
            unsigned SOCKOPT$V_BROADCAST : 1; /* allow broadcasting         */
            unsigned SOCKOPT$V_USELOOPBACK : 1; /* loopback interface, not used */
            unsigned SOCKOPT$V_LINGER : 1; /* linger at close               */
            unsigned SOCKOPT$V_OOBINLINE : 1; /* leave received OOB data in line  */
/*                                                                          */
/*                                                                          */
            unsigned SOCKOPT$V_DUMMYB_2 : 1; /* reserve space               */
            unsigned SOCKOPT$V_DUMMYB_3 : 1; /* reserve space               */
            unsigned SOCKOPT$V_DUMMYB_4 : 1; /* reserve space               */
            unsigned SOCKOPT$V_DUMMYB_5 : 1; /* reserve space               */
/*                                                                          */
            unsigned SOCKOPT$V_FULL_DUPLEX_CLOSE : 1; /* full duplex close  */
            unsigned SOCKOPT$V_NO_RCV_CHKSUM : 1; /* no receive checksum calculation */
            unsigned SOCKOPT$V_NO_SND_CHKSUM : 1; /* no send checksum calculation */
/* Additional options, not kept in so_options.                              */
/*                                                                          */
            } SOCKOPT$R_OPT_BITS;
        } SOCKOPT$R_OPT_OVRLY;
    } ;
 
/*** MODULE $INETSOCKOPTDEF ***/
/*                                                                          */
/* Socket options data structure.                                           */
/*                                                                          */
#define INET$M_DEBUG 1
#define INET$M_ACCEPTCONN 2
#define INET$M_REUSEADDR 4
#define INET$M_KEEPALIVE 8
#define INET$M_DONTROUTE 16
#define INET$M_BROADCAST 32
#define INET$M_USELOOPBACK 64
#define INET$M_LINGER 128
#define INET$M_OOBINLINE 256
#define INET$M_DUMMYB_2 512
#define INET$M_DUMMYB_3 1024
#define INET$M_DUMMYB_4 2048
#define INET$M_DUMMYB_5 4096
#define INET$M_FULL_DUPLEX_CLOSE 8192
#define INET$M_NO_RCV_CHKSUM 16384
#define INET$M_NO_SND_CHKSUM 32768
#define INET$M_NO_CHKSUM 49152          /* no checksum calculation          */
#define INET$C_NO_CHKSUM 49152          /* no checksum calculation          */
/*                                                                          */
#define INET$C_SNDBUF 4097              /* send buffer size                 */
#define INET$C_RCVBUF 4098              /* receive buffer size              */
#define INET$C_SNDLOWAT 4099            /* send low-water mark              */
#define INET$C_RCVLOWAT 4100            /* receive low-water mark           */
#define INET$C_SNDTIMEO 4101            /* send timeout                     */
#define INET$C_RCVTIMEO 4102            /* receive timeout                  */
#define INET$C_ERROR 4103               /* get error status and clear       */
#define INET$C_TYPE 4104                /* get socket type                  */
#define INET$C_SHARE 4105               /* Share                            */
#define INET$C_CCL 4106                 /* carriage control added           */
/*                                                                          */
#define INET$M_SNDBUF 4097              /* send buffer size                 */
#define INET$M_RCVBUF 4098              /* receive buffer size              */
#define INET$M_SNDLOWAT 4099            /* send low-water mark              */
#define INET$M_RCVLOWAT 4100            /* receive low-water mark           */
#define INET$M_SNDTIMEO 4101            /* send timeout                     */
#define INET$M_RCVTIMEO 4102            /* receive timeout                  */
#define INET$M_ERROR 4103               /* get error status and clear       */
#define INET$M_TYPE 4104                /* get socket type                  */
#define INET$M_SHARE 4105               /* Share                            */
#define INET$M_CCL 4106                 /* carriage control added           */
#define INET$C_DEBUG 1                  /* turn on event logging, not used  */
#define INET$C_ACCEPTCONN 2             /* socket has had LISTEN            */
#define INET$C_REUSEADDR 4              /* allow local address reuse        */
#define INET$C_KEEPALIVE 8              /* keep connection alive            */
#define INET$C_DONTROUTE 16             /* use only the interface addr      */
#define INET$C_BROADCAST 32             /* allow broadcasting               */
#define INET$C_USELOOPBACK 64           /* loopback interface, not used     */
#define INET$C_LINGER 128               /* linger at close                  */
#define INET$C_OOBINLINE 256            /* leave received OOB data in line  */
#define INET$C_FULL_DUPLEX_CLOSE 8192   /* full duplex close                */
#define INET$C_NO_RCV_CHKSUM 16384      /* no receive checksum calculation  */
#define INET$C_NO_SND_CHKSUM 32768      /* no send checksum calculation     */
#define INET$C_LENGTH 2
#define INET$K_LENGTH 2
struct INETSOCKOPTDEF {
    union  {                            /*                                  */
        unsigned short int INET$W_OPTIONS; /* Socket options, see socket.h  */
        struct  {
/*                                                                          */
/* Socket options bits.                                                     */
/*                                                                          */
            unsigned INET$V_DEBUG : 1;  /* turn on event logging, not used  */
            unsigned INET$V_ACCEPTCONN : 1; /* socket has had LISTEN        */
            unsigned INET$V_REUSEADDR : 1; /* allow local address reuse     */
            unsigned INET$V_KEEPALIVE : 1; /* keep connection alive         */
            unsigned INET$V_DONTROUTE : 1; /* use only the interface addr   */
            unsigned INET$V_BROADCAST : 1; /* allow broadcasting            */
            unsigned INET$V_USELOOPBACK : 1; /* loopback interface, not used */
            unsigned INET$V_LINGER : 1; /* linger at close                  */
            unsigned INET$V_OOBINLINE : 1; /* leave received OOB data in line  */
/*                                                                          */
/*                                                                          */
            unsigned INET$V_DUMMYB_2 : 1; /* reserve space                  */
            unsigned INET$V_DUMMYB_3 : 1; /* reserve space                  */
            unsigned INET$V_DUMMYB_4 : 1; /* reserve space                  */
            unsigned INET$V_DUMMYB_5 : 1; /* reserve space                  */
/*                                                                          */
            unsigned INET$V_FULL_DUPLEX_CLOSE : 1; /* full duplex close     */
            unsigned INET$V_NO_RCV_CHKSUM : 1; /* no receive checksum calculation */
            unsigned INET$V_NO_SND_CHKSUM : 1; /* no send checksum calculation */
/* Additional options, not kept in so_options.                              */
/*                                                                          */
            } INET$R_OPT_BITS;
        } INET$R_OPT_OVRLY;
    } ;
 
/*** MODULE $SOCKADDRDEF ***/
#define AF_UNSPEC 0                     /* unspecified socket family        */
#define AF_INET 2                       /* INET socket family               */
#define SA$C_LENGTH 16
#define SA$K_LENGTH 16
struct SOCKADDR {
    unsigned short int SA$W_FAMILY;     /* address family                   */
    char SA$T_DATA [14];                /* up to 14 bytes of address        */
    } ;
 
/*** MODULE $SOCKADDRINDEF ***/
#define SIN$C_LENGTH 16
#define SIN$K_LENGTH 16
struct SOCKADDRIN {
    unsigned short int SIN$W_FAMILY;    /* address family                   */
    unsigned short int SIN$W_PORT;      /* 2 bytes specifying a port        */
    unsigned long int SIN$L_ADDR;       /* 4 bytes specifying an IP address */
    char SIN$T_ZERO [8];                /* 8 bytes                          */
    } ;
 
/*** MODULE $INETACPSYMDEF ***/
/*+                                                                         */
/* Define ACP HOST/NET data base subroutine calls subfunction codes         */
/*                                                                          */
/*-                                                                         */
#define INETACP$C_ALIASES 1             /* aliases                          */
#define INETACP$C_TRANS 2               /* translate ASCII string in binary */
#define INETACP$C_HOSTENT 3             /* get back a HOSTENT               */
#define INETACP$C_NETENT 4              /* get back a NETENT                */
#define INETACP$C_HOSTENT_OFFSET 5      /* get back a HOSTENT               */
#define INETACP$C_NETENT_OFFSET 6       /* get back a NETENT                */
#define INETACPC$C_ALIASES 1            /* aliases                          */
#define INETACPC$C_TRANS 2              /* translate ASCII string in binary */
#define INETACPC$C_HOSTENT 3            /* get back a HOSTENT               */
#define INETACPC$C_NETENT 4             /* get back a NETENT                */
#define INETACPC$C_HOSTENT_OFFSET 5     /* get back a HOSTENT               */
#define INETACPC$C_NETENT_OFFSET 6      /* get back a NETENT                */
 
/*** MODULE $INETACPFSYMDEF ***/
/*+                                                                         */
/* Define ACP control subfunction codes                                     */
/*                                                                          */
/*-                                                                         */
#define INETACP_FUNC$C_GETHOSTBYNAME 1  /* Subroutine call of GET_HOST_BY_NAME */
#define INETACP_FUNC$C_GETHOSTBYADDR 2  /* Subroutine call of GET_HOST_BY_ADDR */
#define INETACP_FUNC$C_GETNETBYNAME 3   /* Subroutine call of GET_NET_BY_NAME */
#define INETACP_FUNC$C_GETNETBYADDR 4   /* Subroutine call of GET_NET_BY_ADDR  */
/*                                                                          */
 
/*** MODULE $NETENTDEF ***/
#define NET$C_LENGTH 16                 /*                                  */
#define NET$K_LENGTH 16                 /*                                  */
struct NETENTDEF {
    int *NET$L_N_NAME;                  /* pointer to the network name      */
    int *NET$L_N_ALIASES;               /* pointer to array of pointers to aliases */
    unsigned long int NET$L_N_ADDRTYPE; /* Network address type             */
    unsigned long int NET$L_N_NET;      /* Network address                  */
    } ;
/*                                                                          */
/* Structures returned by network                                           */
/* data base library.  All addresses                                        */
/* are supplied in host order, and                                          */
/* returned in network order (suitable                                      */
/* for use in system calls).                                                */
/*                                                                          */
 
/*** MODULE $HOSTENTDEF ***/
#define HOST$L_H_ADDR 16                /*                                  */
#define HOST$C_LENGTH 20                /*                                  */
#define HOST$K_LENGTH 20                /*                                  */
struct HOSTENTDEF {
    int *HOST$L_H_NAME;                 /* pointer to the host name         */
    int *HOST$L_H_ALIASES;              /* pointer to array of pointers to aliases */
    unsigned long int HOST$L_H_ADDRTYPE; /* Host address type               */
    unsigned long int HOST$L_H_LENGTH;  /* Length of address                */
    int *HOST$L_H_ADDR_LIST;            /* Pointer to array of pointers to addresses */
    } ;
/*
** UCX V3.0 XDR/RPC collection of header files.
**
** Modification history:
** Feb-25-1993 DR
**	Added PCNFSD program number and version
**	Deleted UCX$XXX routine declarations
**
** 14-Sep-1993	John Gemignani, Jr.
**		Undo the RPC$ host/network conversion procedure names.
**		Make the names conform to standard with a UCX$ prefix.
**	        These routines are now in the RPC library.
**
** 07-Feb-1994	John Gemignani, Jr.
**	        Remove inclusion of stdio.h.  This was needed for debugging
**		only and causes problems when building kernel code which
**		includes the RPC header (i.e. DNFC).
**
** 08-Feb-1994	John Gemignani, Jr.
**	        Change debug() macro to use printf() instead of fprintf(stdout, ...).
**
** 19-Mar-1994	John Gemignani, Jr.
**		Make header file C++ compliant.
**		Conditionalize debug() via RPCXDR_DEBUG.
**
** 06-Jun-1994	John Gemignani, Jr.
**		Make svc_fds visible.
*/

# ifndef _RPCXDR_LOADED
# define _RPCXDR_LOADED

# pragma nostandard

# ifdef __cplusplus
  extern "C" {
# endif /* __cplusplus */

#ifndef __IN_H
#include <in.h>		/* needed by svc.h */
#endif /* __IN_H */

#include <errno.h>
/*
** Constants from various countries of the world.
*/
#define NGROUPS 10		/* Number of gids */

# ifdef RPCXDR_DEBUG
/*
** Internal RPC debugging macro.  
*****This debug marco needs work, it is temporarily commented out to get
     the build going.  The stdio defined in here cased the DNFC driver
     can not be loaded on AXP.
*/

#define debug(string,p1) { \
	printf (string, p1); \
	printf ("\nline=%d, errno=%d\n", __LINE__, errno); \
	}
# endif /* RPCXDR_DEBUG */



/*
** RPC/XDR types (see rpc/types.h):
*/
/* @(#)types.h	9.1	11/4/88 */

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * Rpc additions to <sys/types.h>
 *
 *	History:
 *
 * 12-11-87	Robin L. and Larry C. and Ricky P.
 *	Added new kmalloc memory allocation to system.
 *
 * 12-18-87	Joe A.
 *	moved <sys/types> above kmalloc.h
 */

#ifndef __RPC_TYPES_H__
#define __RPC_TYPES_H__


#ifndef	KERNEL
#ifndef major		/* ouch! */
/*#include <sys/types.h>*/
/*
** <sys/types.h>
*/
#ifndef __SOCKET_TYPEDEFS
typedef unsigned char *caddr_t;
typedef unsigned long  u_long;
typedef unsigned short u_short;
#endif /* __SOCKET_TYPEDEFS */

typedef unsigned int   bool_t;
/* UNUSED typedef unsigned int   dev_t; */
/* UNUSED typedef unsigned int   ino_t; */
typedef unsigned int   u_int;

#ifndef __SOCKET
#ifndef __SOCKET_LOADED
struct timeval {
  unsigned int tv_sec;
  unsigned int tv_usec;
  };
#endif /* __SOCKET_LOADED */
#endif /* __SOCKET */
#endif
/*#include	<sys/kmalloc.h>*/
#else /* KERNEL */
#include	"../h/kmalloc.h"
#endif /* KERNEL */

#define	bool_t	int
#define	enum_t	int
#define	FALSE	0
#define	TRUE	1
#ifndef NULL
#define NULL 0
#endif
#define __dontcare__	-1

#ifdef UNDEF
#ifndef KERNEL
#define mem_alloc(dummy, dummy, bsize, dummy)	malloc(bsize)
#define mem_free(ptr, dummy)	free(ptr)
#else /* KERNEL */
#define mem_alloc(ptr, cast, bsize, type)	KM_ALLOC((ptr), cast, bsize, type, KM_NOARG)
#define mem_free(ptr, type)                     KM_FREE((ptr), type)
#define kmem_alloc(ptr, cast, bsize, type)	KM_ALLOC((ptr), cast, bsize, type, KM_CLEAR)
#define kmem_free(ptr, type)	                KM_FREE((ptr), type)
#endif /* KERNEL */
#endif /* UNDEF */

/** This is temporary solution for alpha port - DR */
#define mem_alloc(a, b, bsize, c)	malloc(bsize)
#define mem_free(ptr, a)	free(ptr)

#endif /* __RPC_TYPES_H__ */



/*      @(#)xdr.h	4.1     (ULTRIX)        7/2/90     */

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 *	Modification History
 *
 *	12 Jan 88 -- Fglover
 *		Merge netobj data structure for lock manager
 *
 *	13 Apr 89 -- jhw
 *		Merge of SUN 4.0 changes
 */


/*
 * xdr.h, External Data Representation Serialization Routines.
 *
 */
#ifndef __XDR_HEADER__
#define __XDR_HEADER__
#endif

/*
 * XDR provides a conventional way for converting between C data
 * types and an external bit-string representation.  Library supplied
 * routines provide for the conversion on built-in C data types.  These
 * routines and utility routines defined here are used to help implement
 * a type encode/decode routine for each user-defined type.
 *
 * Each data type provides a single procedure which takes two arguments:
 *
 *	bool_t
 *	xdrproc(xdrs, argresp)
 *		XDR *xdrs;
 *		<type> *argresp;
 *
 * xdrs is an instance of a XDR handle, to which or from which the data
 * type is to be converted.  argresp is a pointer to the structure to be
 * converted.  The XDR handle contains an operation field which indicates
 * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
 *
 * XDR_DECODE may allocate space if the pointer argresp is null.  This
 * data can be freed with the XDR_FREE operation.
 *
 * We write only one procedure per data type to make it easy
 * to keep the encode and decode procedures for a data type consistent.
 * In many cases the same code performs all operations on a user defined type,
 * because all the hard work is done in the component type routines.
 * decode as a series of calls on the nested data types.
 */

/*
 * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
 * stream.  XDR_DECODE causes the type to be extracted from the stream.
 * XDR_FREE can be used to release the space allocated by an XDR_DECODE
 * request.
 */
enum xdr_op {
	XDR_ENCODE=0,
	XDR_DECODE=1,
	XDR_FREE=2
};

/*
 * This is the number of bytes per unit of external data.
 */
#define BYTES_PER_XDR_UNIT	(4)
#define RNDUP(x)  ((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \
                    * BYTES_PER_XDR_UNIT)

/*
 * A xdrproc_t exists for each data type which is to be encoded or decoded.
 *
 * The second argument to the xdrproc_t is a pointer to an opaque pointer.
 * The opaque pointer generally points to a structure of the data type
 * to be decoded.  If this pointer is 0, then the type routines should
 * allocate dynamic storage of the appropriate size and return it.
 * bool_t (*xdrproc_t)(XDR *, caddr_t *);
 */
typedef	bool_t (*xdrproc_t)();

/*
 * The XDR handle.
 * Contains operation which is being applied to the stream,
 * an operations vector for the paticular implementation (e.g. see xdr_mem.c),
 * and two private fields for the use of the particular impelementation.
 */
typedef struct {
	enum xdr_op	x_op;		/* operation; fast additional param */
	struct xdr_ops {
		bool_t	(*x_getlong)();	/* get a long from underlying stream */
		bool_t	(*x_putlong)();	/* put a long to " */
		bool_t	(*x_getbytes)();/* get some bytes from " */
		bool_t	(*x_putbytes)();/* put some bytes to " */
		u_int	(*x_getpostn)();/* returns bytes off from beginning */
		bool_t  (*x_setpostn)();/* lets you reposition the stream */
		long *	(*x_inline)();	/* buf quick ptr to buffered data */
		void	(*x_destroy)();	/* free privates of this xdr_stream */
	} *x_ops;
	caddr_t 	x_public;	/* users' data */
	caddr_t		x_private;	/* pointer to private data */
	caddr_t 	x_base;		/* private used for position info */
	int		x_handy;	/* extra private word */
} XDR;

/*
 * Operations defined on a XDR handle
 *
 * XDR		*xdrs;
 * long		*longp;
 * caddr_t	 addr;
 * u_int	 len;
 * u_int	 pos;
 */
#define XDR_GETLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)

#define XDR_PUTLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)

#define XDR_GETBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)

#define XDR_PUTBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)

#define XDR_GETPOS(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define xdr_getpos(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)

#define XDR_SETPOS(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)

#define	XDR_INLINE(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define	xdr_inline(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)

#define	XDR_DESTROY(xdrs)				\
	if ((xdrs)->x_ops->x_destroy) 			\
		(*(xdrs)->x_ops->x_destroy)(xdrs)
#define	xdr_destroy(xdrs)				\
	if ((xdrs)->x_ops->x_destroy) 			\
		(*(xdrs)->x_ops->x_destroy)(xdrs)

/*
 * Support struct for discriminated unions.
 * You create an array of xdrdiscrim structures, terminated with
 * a entry with a null procedure pointer.  The xdr_union routine gets
 * the discriminant value and then searches the array of structures
 * for a matching value.  If a match is found the associated xdr routine
 * is called to handle that part of the union.  If there is
 * no match, then a default routine may be called.
 * If there is no match and no default routine it is an error.
 */
#define NULL_xdrproc_t ((xdrproc_t)0)
struct xdr_discrim {
	int	value;
	xdrproc_t proc;
};

/*
 * In-line routines for fast encode/decode of primitve data types.
 * Caveat emptor: these use single memory cycles to get the
 * data from the underlying buffer, and will fail to operate
 * properly if the data is not aligned.  The standard way to use these
 * is to say:
 *	if ((buf = XDR_INLINE(xdrs, count)) == NULL)
 *		return (FALSE);
 *	<<< macro calls >>>
 * where ``count'' is the number of bytes of data occupied
 * by the primitive data types.
 *
 * N.B. and frozen for all time: each data type here uses 4 bytes
 * of external representation.
 */

#define ntohl UCX$RPC_NTOHL
#define htonl UCX$RPC_HTONL
#define ntohs UCX$RPC_NTOHS
#define htons UCX$RPC_HTONS

#define IXDR_GET_LONG(buf)		ntohl(*buf++)
#define IXDR_PUT_LONG(buf, v)		(*buf++ = htonl(v))

#define IXDR_GET_BOOL(buf)		((bool_t)IXDR_GET_LONG(buf))
#define IXDR_GET_ENUM(buf, t)		((t)IXDR_GET_LONG(buf))
#define IXDR_GET_U_LONG(buf)		((u_long)IXDR_GET_LONG(buf))
#define IXDR_GET_SHORT(buf)		((short)IXDR_GET_LONG(buf))
#define IXDR_GET_U_SHORT(buf)		((u_short)IXDR_GET_LONG(buf))

#define IXDR_PUT_BOOL(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_ENUM(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_LONG(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_SHORT(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_SHORT(buf, v)	IXDR_PUT_LONG((buf), ((long)(v)))

/*
 * These are the "generic" xdr routines.
 */
extern bool_t	xdr_void();
extern bool_t	xdr_int();
extern bool_t	xdr_u_int();
extern bool_t	xdr_long();
extern bool_t	xdr_u_long();
extern bool_t	xdr_short();
extern bool_t	xdr_u_short();
extern bool_t	xdr_bool();
extern bool_t	xdr_enum();
extern bool_t	xdr_array();
extern bool_t	xdr_bytes();
extern bool_t	xdr_opaque();
extern bool_t	xdr_string();
extern bool_t	xdr_union();
#ifndef KERNEL
extern bool_t   xdr_char();
extern bool_t   xdr_u_char();
extern bool_t   xdr_vector();
extern bool_t   xdr_float();
extern bool_t   xdr_double();
extern bool_t   xdr_reference();
extern bool_t   xdr_pointer();
extern bool_t   xdr_wrapstring();
#endif /* !KERNEL */

/*
 * Common opaque bytes objects used by many rpc protocols;
 * Merged from sun's netobj.h
 */

#define MAX_NETOBJ_SZ 1024 
struct netobj {
	u_int	n_len;
	char	*n_bytes;
};
typedef struct netobj netobj;
extern bool_t   xdr_netobj();

/*
 * These are the public routines for the various implementations of
 * xdr streams.
 */
extern void   xdrmem_create();		/* XDR using memory buffers */
#ifndef KERNEL
extern void   xdrstdio_create();	/* XDR using stdio library */
extern void   xdrrec_create();		/* XDR pseudo records for tcp */
extern bool_t xdrrec_endofrecord();	/* make end of xdr record */
extern bool_t xdrrec_skiprecord();	/* move to begining of next record */
extern bool_t xdrrec_eof();		/* true iff no more input */
#else
extern void xdrmbuf_init();		/* XDR using kernel mbufs */
#endif /* !KERNEL */


/*	@(#)auth.h	9.1	(ULTRIX)	11/4/88	*/

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * auth.h, Authentication interface.
 *
 * The data structures are completely opaque to the client.  The client
 * is required to pass a AUTH * to routines that create rpc
 * "sessions".
 */


#define MAX_AUTH_BYTES	400


/*
 * Status returned from authentication check
 */
enum auth_stat {
	AUTH_OK=0,
	/*
	 * failed at remote end
	 */
	AUTH_BADCRED=1,			/* bogus credentials (seal broken) */
	AUTH_REJECTEDCRED=2,		/* client should begin new session */
	AUTH_BADVERF=3,			/* bogus verifier (seal broken) */
	AUTH_REJECTEDVERF=4,		/* verifier expired or was replayed */
	AUTH_TOOWEAK=5,			/* rejected due to security reasons */
	/*
	 * failed locally
	*/
	AUTH_INVALIDRESP=6,		/* bogus response verifier */
	AUTH_FAILED=7			/* some unknown reason */
};


union des_block {
	struct {
		u_long high;
		u_long low;
	} key;
	char c[8];
};


/*
 * Authentication info.  Opaque to client.
 */
struct opaque_auth {
	enum_t	oa_flavor;		/* flavor of auth */
	caddr_t	oa_base;		/* address of more auth stuff */
	u_int	oa_length;		/* not to exceed MAX_AUTH_BYTES */
};


/*
 * Auth handle, interface to client side authenticators.
 */
typedef struct {
	struct	opaque_auth	ah_cred;
	struct	opaque_auth	ah_verf;
	union	des_block	ah_key;
	struct auth_ops {
		void	(*ah_nextverf)();
		int	(*ah_marshal)();	/* nextverf & serialize */
		int	(*ah_validate)();	/* validate varifier */
		int	(*ah_refresh)();	/* refresh credentials */
		void	(*ah_destroy)();	/* destroy this structure */
	} *ah_ops;
	caddr_t ah_private;
} AUTH;


/*
 * Authentication ops.
 * The ops and the auth handle provide the interface to the authenticators.
 *
 * AUTH	*auth;
 * XDR	*xdrs;
 * struct opaque_auth verf;
 */
#define AUTH_NEXTVERF(auth)		\
		((*((auth)->ah_ops->ah_nextverf))(auth))
#define auth_nextverf(auth)		\
		((*((auth)->ah_ops->ah_nextverf))(auth))

#define AUTH_MARSHALL(auth, xdrs)	\
		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))
#define auth_marshall(auth, xdrs)	\
		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))

#define AUTH_VALIDATE(auth, verfp)	\
		((*((auth)->ah_ops->ah_validate))((auth), verfp))
#define auth_validate(auth, verfp)	\
		((*((auth)->ah_ops->ah_validate))((auth), verfp))

#define AUTH_REFRESH(auth)		\
		((*((auth)->ah_ops->ah_refresh))(auth))
#define auth_refresh(auth)		\
		((*((auth)->ah_ops->ah_refresh))(auth))

#define AUTH_DESTROY(auth)		\
		((*((auth)->ah_ops->ah_destroy))(auth))
#define auth_destroy(auth)		\
		((*((auth)->ah_ops->ah_destroy))(auth))


#if defined(__ALPHA) || defined(__cplusplus)
extern struct opaque_auth _null_auth;
#else
globalref struct opaque_auth _null_auth;
#endif /* __ALPHA || __cplusplus */


/*
 * These are the various implementations of client side authenticators.
 */

/*
 * Unix style authentication
 * AUTH *authunix_create(machname, uid, gid, len, aup_gids)
 *	char *machname;
 *	int uid;
 *	int gid;
 *	int len;
 *	int *aup_gids;
 */
#ifdef KERNEL
extern AUTH *authkern_create();		/* takes no parameters */
#else
extern AUTH *authunix_create();
extern AUTH *authunix_create_default();	/* takes no parameters */
extern AUTH *authnone_create();		/* takes no parameters */
#endif

#define	AUTH_NULL	0
#define	AUTH_UNIX	1		/* unix style (uid, gids) */
#define	AUTH_SHORT	2		/* short hand unix style */


/*	@(#)auth_unix.h	9.1	(ULTRIX)	11/4/88	*/

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * auth_unix.h, Protocol for UNIX style authentication parameters for RPC
 *
 */

/*
 * The system is very weak.  The client uses no encryption for  it
 * credentials and only sends null verifiers.  The server sends backs
 * null verifiers or optionally a verifier that suggests a new short hand
 * for the credentials.
 */

/* The machine name is part of a credential; it may not exceed 255 bytes */
#define MAX_MACHINE_NAME 255

/* gids compose part of a credential; there may not be more than 10 of them */
#define NGRPS 8

/*
 * Unix style credentials.
 */
struct authunix_parms {
	u_long	 aup_time;
	char	*aup_machname;
	int	 aup_uid;
	int	 aup_gid;
	u_int	 aup_len;
	int	*aup_gids;
};

extern bool_t xdr_authunix_parms();

/* 
 * If a response verifier has flavor AUTH_SHORT, 
 * then the body of the response verifier encapsulates the following structure;
 * again it is serialized in the obvious fashion.
 */
struct short_hand_verf {
	struct opaque_auth new_cred;
};


/*      @(#)clnt.h	4.1     (ULTRIX)        7/2/90     */

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */
/*	Change Log
 *	04/13/89	jhw	Added SUN 4.0 chnages
 */
#ifndef _CLNT_
#define _CLNT_
#endif

/*
 * Rpc calls return an enum clnt_stat.  This should be looked at more,
 * since each implementation is required to live with this (implementation
 * independent) list of errors.
 */
enum clnt_stat {
	RPC_SUCCESS=0,			/* call succeeded */
	/*
	 * local errors
	 */
	RPC_CANTENCODEARGS=1,		/* can't encode arguments */
	RPC_CANTDECODERES=2,		/* can't decode results */
	RPC_CANTSEND=3,			/* failure in sending call */
	RPC_CANTRECV=4,			/* failure in receiving result */
	RPC_TIMEDOUT=5,			/* call timed out */
	/*
	 * remote errors
	 */
	RPC_VERSMISMATCH=6,		/* rpc versions not compatible */
	RPC_AUTHERROR=7,		/* authentication error */
	RPC_PROGUNAVAIL=8,		/* program not available */
	RPC_PROGVERSMISMATCH=9,		/* program version mismatched */
	RPC_PROCUNAVAIL=10,		/* procedure unavailable */
	RPC_CANTDECODEARGS=11,		/* decode arguments error */
	RPC_SYSTEMERROR=12,		/* generic "other problem" */

	/*
	 * callrpc errors
	 */
	RPC_UNKNOWNHOST=13,		/* unknown host name */

	/*
	 * _ create errors
	 */
	RPC_PMAPFAILURE=14,		/* the pmapper failed in its call */
	RPC_PROGNOTREGISTERED=15,	/* remote program is not registered */
	/*
	 * unspecified error
	 */
	RPC_FAILED=16,
        RPC_UNKNOWNPROTO=17,            /* unkown protocol */
	RPC_INTR=18			/* interrupted */
};


/*
 * Error info.
 */
struct rpc_err {
	enum clnt_stat re_status;
	union {
		int RE_errno;		/* realated system error */
		enum auth_stat RE_why;	/* why the auth error occurred */
		struct {
			u_long low;	/* lowest verion supported */
			u_long high;	/* highest verion supported */
		} RE_vers;
		struct {		/* maybe meaningful if RPC_FAILED */
			long s1;
			long s2;
		} RE_lb;		/* life boot & debugging only */
	} ru;
#define	re_errno	ru.RE_errno
#define	re_why		ru.RE_why
#define	re_vers		ru.RE_vers
#define	re_lb		ru.RE_lb
};


/*
 * Client rpc handle.
 * Created by individual implementations, see e.g. clnt_udp.c.
 * Client is responsible for initializing auth, see e.g. auth_none.c.
 */
typedef struct {
	AUTH	*cl_auth;			/* authenticator */
	struct clnt_ops {
		enum clnt_stat	(*cl_call)();	/* call remote procedure */
		void		(*cl_abort)();	/* abort a call */
		void		(*cl_geterr)();	/* get specific error code */
		bool_t		(*cl_freeres)(); /* frees results */
		void		(*cl_destroy)();/* destroy this structure */
                bool_t          (*cl_control)();/* the ioctl() of rpc */
	} *cl_ops;
	caddr_t			cl_private;	/* private stuff */
	u_long			cl_xid;		/* transaction ID (optional) */
	                                        /* (used only for NFS) */
} CLIENT;


/*
 * client side rpc interface ops
 *
 * Parameter types are:
 *
 */

/*
 * enum clnt_stat
 * CLNT_CALL(rh, proc, xargs, argsp, xres, resp, timeout)
 * 	CLIENT *rh;
 *	u_long proc;
 *	xdrproc_t xargs;
 *	caddr_t argsp;
 *	xdrproc_t xres;
 *	caddr_t resp;
 *	struct timeval timeout;
 */
#define	CLNT_CALL(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))
#define	clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))

/*
 * void
 * CLNT_ABORT(rh);
 * 	CLIENT *rh;
 */
#define	CLNT_ABORT(rh)	((*(rh)->cl_ops->cl_abort)(rh))
#define	clnt_abort(rh)	((*(rh)->cl_ops->cl_abort)(rh))

/*
 * struct rpc_err
 * CLNT_GETERR(rh);
 * 	CLIENT *rh;
 */
#define	CLNT_GETERR(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
#define	clnt_geterr(rh,errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))


/*
 * bool_t
 * CLNT_FREERES(rh, xres, resp);
 * 	CLIENT *rh;
 *	xdrproc_t xres;
 *	caddr_t resp;
 */
#define	CLNT_FREERES(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
#define	clnt_freeres(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
/*
 * bool_t
 * CLNT_CONTROL(cl, request, info)
 *      CLIENT *cl;
 *      u_int request;
 *      char *info;
 */
#define CLNT_CONTROL(cl,rq,in) ((*(cl)->cl_ops->cl_control)(cl,rq,in))
#define clnt_control(cl,rq,in) ((*(cl)->cl_ops->cl_control)(cl,rq,in))

/*
 * control operations that apply to both udp and tcp transports
 */
#define CLSET_TIMEOUT       1   /* set timeout (timeval) */
#define CLGET_TIMEOUT       2   /* get timeout (timeval) */
#define CLGET_SERVER_ADDR   3   /* get server's address (sockaddr) */
/*
 * udp only control operations
 */
#define CLSET_RETRY_TIMEOUT 4   /* set retry timeout (timeval) */
#define CLGET_RETRY_TIMEOUT 5   /* get retry timeout (timeval) */
                                                                               

/*
 * void
 * CLNT_DESTROY(rh);
 * 	CLIENT *rh;
 */
#define	CLNT_DESTROY(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
#define	clnt_destroy(rh)	((*(rh)->cl_ops->cl_destroy)(rh))


/*
 * RPCTEST is a test program which is accessable on every rpc
 * transport/port.  It is used for testing, performance evaluation,
 * and network administration.
 */

#define RPCTEST_PROGRAM		((u_long)1)
#define RPCTEST_VERSION		((u_long)1)
#define RPCTEST_NULL_PROC	((u_long)2)
#define RPCTEST_NULL_BATCH_PROC	((u_long)3)

/*
 * By convention, procedure 0 takes null arguments and returns them
 */

#define NULLPROC ((u_long)0)

/*
 * Below are the client handle creation routines for the various
 * implementations of client side rpc.  They can return NULL if a 
 * creation failure occurs.
 */

#ifndef KERNEL
/*
 * Memory based rpc (for speed check and testing)
 * CLIENT *
 * clntraw_create(prog, vers)
 *	u_long prog;
 *	u_long vers;
 */
extern CLIENT *clntraw_create();

/*
 * Generic client creation routine. Supported protocols are "udp" and "tcp"
 */
extern CLIENT *
clnt_create(/*host, prog, vers, prot*/); /*
        char *host;     -- hostname
        u_long prog;    -- program number
        u_long vers;    -- version number
        char *prot;     -- protocol
*/
/*
 * TCP based rpc
 * CLIENT *
 * clnttcp_create(raddr, prog, vers, sockp, sendsz, recvsz)
 *	struct sockaddr_in *raddr;
 *	u_long prog;
 *	u_long version;
 *	register int *sockp;
 *	u_int sendsz;
 *	u_int recvsz;
 */
extern CLIENT *clnttcp_create();

/*
 * UDP based rpc.
 * CLIENT *
 * clntudp_create(raddr, program, version, wait, sockp)
 *	struct sockaddr_in *raddr;
 *	u_long program;
 *	u_long version;
 *	struct timeval wait;
 *	int *sockp;
 *
 * Same as above, but you specify max packet sizes.
 * CLIENT *
 * clntudp_bufcreate(raddr, program, version, wait, sockp, sendsz, recvsz)
 *	struct sockaddr_in *raddr;
 *	u_long program;
 *	u_long version;
 *	struct timeval wait;
 *	int *sockp;
 *	u_int sendsz;
 *	u_int recvsz;
 */
extern CLIENT *clntudp_create();
extern CLIENT *clntudp_bufcreate();

/* 
 * If a creation fails, the following allows the user to figure out why.
 */
struct rpc_createerr {
	enum clnt_stat cf_stat;
	struct rpc_err cf_error; /* useful when cf_stat == RPC_PMAPFAILURE */
};

#if defined(__ALPHA) || defined(__cplusplus)
extern struct rpc_createerr rpc_createerr;
#else
globalref struct rpc_createerr rpc_createerr;
#endif /* __ALPHA || __cplusplus */


#endif /* !KERNEL */

#ifdef KERNEL
/*
 * Kernel udp based rpc
 * CLIENT *
 * clntkudp_create(addr, pgm, vers)
 *	struct sockaddr_in *addr;
 *	u_long pgm;
 *	u_long vers;
 */
extern CLIENT *clntkudp_create();
#endif

#define UDPMSGSIZE	8800	/* rpc imposed limit on udp msg size */
#define RPCSMALLMSGSIZE	400	/* a more reasonable packet size */


/*	@(#)pmap_prot.h	9.1	(ULTRIX)	11/4/88	*/

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * pmap_prot.h
 * Protocol for the local binder service, or pmap.
 *
 *
 * The following procedures are supported by the protocol:
 *
 * PMAPPROC_NULL() returns ()
 * 	takes nothing, returns nothing
 *
 * PMAPPROC_SET(struct pmap) returns (bool_t)
 * PMAPPROC_SET_VMS(struct pmap_vms) returns (bool_t)
 * 	TRUE is success, FALSE is failure.  Registers the tuple
 *	[prog, vers, prot, port].
 *
 *
 * PMAPPROC_UNSET(struct pmap) returns (bool_t)
 * PMAPPROC_UNSET_VMS(struct pmap_vms) returns (bool_t)
 *	TRUE is success, FALSE is failure.  Un-registers pair
 *	[prog, vers].  prot and port are ignored.
 *
 * PMAPPROC_GETPORT(struct pmap) returns (long unsigned).
 *	0 is failure.  Otherwise returns the port number where the pair
 *	[prog, vers] is registered.  It may lie!
 *
 * PMAPPROC_DUMP()   RETURNS (struct pmaplist *)
 * PMAPPROC_DUMP_VMS RETURNS (struct pmaplist_vms *)
 *
 * PMAPPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
 * 	RETURNS (port, string<>);
 * usage: encapsulatedresults = PMAPPROC_CALLIT(prog, vers, proc, encapsulatedargs);
 * 	Calls the procedure on the local machine.  If it is not registered,
 *	this procedure is quite; ie it does not return error information!!!
 *	This procedure only is supported on rpc/udp and calls via
 *	rpc/udp.  This routine only passes null authentication parameters.
 *	This file has no interface to xdr routines for PMAPPROC_CALLIT.
 *
 * The service supports remote procedure calls on udp/ip or tcp/ip socket 111.
 */

#define PMAPPORT		((u_short)111)
#define PMAPPROG		((u_long)100000)
#define PMAPVERS		((u_long)2)
#define PMAPVERS_PROTO		((u_long)2)
#define PMAPVERS_ORIG		((u_long)1)
#define PMAPPROC_NULL		((u_long)0)
#define PMAPPROC_SET		((u_long)1)
#define PMAPPROC_UNSET		((u_long)2)
#define PMAPPROC_GETPORT	((u_long)3)
#define PMAPPROC_DUMP		((u_long)4)
#define PMAPPROC_CALLIT		((u_long)5)

#define NFSPROG 		((u_long)100003)
#define MOUNTPROG 		((u_long)100005)
#define PCNFSDPROG		((u_long)150001)
#define NFSVERS 		((u_long)2)
#define MOUNTVERS		((u_long)1) 
#define PCNFSDVERS		((u_long)1)

struct pmap {
	long unsigned pm_prog;
	long unsigned pm_vers;
	long unsigned pm_prot;
	long unsigned pm_port;
};

extern bool_t xdr_pmap();

struct pmaplist {
	struct pmap	 pml_map;
	struct pmaplist *pml_next;
};

extern bool_t xdr_pmaplist();

/******************* UCX FLAVOR *******************/
#define PMAPPROC_SET_VMS        ((u_long)100001)
#define PMAPPROC_UNSET_VMS      ((u_long)100002)
#define PMAPPROC_DUMP_VMS       ((u_long)100004)

struct pmap_vms {
	long unsigned pm_prog;
	long unsigned pm_vers;
	long unsigned pm_prot;
	long unsigned pm_port;
	long unsigned pm_pid;		/* UCX-specific */
};

extern bool_t xdr_pmap_vms();

struct pmaplist_vms {
	struct pmap_vms      pml_map;
	struct pmaplist_vms *pml_next;
};

extern bool_t xdr_pmaplist_vms();
/******************* UCX FLAVOR *******************/



/*	@(#)rpc_msg.h	4.1	(ULTRIX)	7/2/90	*/

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * rpc_msg.h
 * rpc message definition
 *
 */

#define RPC_MSG_VERSION		((u_long) 2)
#define RPC_SERVICE_PORT	((u_short) 2048)

/*
 * Bottom up definition of an rpc message.
 * NOTE: call and reply use the same overall stuct but
 * different parts of unions within it.
 */

enum msg_type {
	CALL=0,
	REPLY=1
};

enum reply_stat {
	MSG_ACCEPTED=0,
	MSG_DENIED=1
};

enum accept_stat {
	SUCCESS=0,
	PROG_UNAVAIL=1,
	PROG_MISMATCH=2,
	PROC_UNAVAIL=3,
	GARBAGE_ARGS=4,
	SYSTEM_ERR=5
};

enum reject_stat {
	RPC_MISMATCH=0,
	AUTH_ERROR=1
};

/*
 * Reply part of an rpc exchange
 */

/*
 * Reply to an rpc request that was accepted by the server.
 * Note: there could be an error even though the request was
 * accepted.
 */
struct accepted_reply {
	struct opaque_auth	ar_verf;
	enum accept_stat	ar_stat;
	union {
		struct {
			u_long	low;
			u_long	high;
		} AR_versions;
		struct {
			caddr_t	where;
			xdrproc_t proc;
		} AR_results;
		/* and many other null cases */
	} ru;
#define	ar_results	ru.AR_results
#define	ar_vers		ru.AR_versions
};

/*
 * Reply to an rpc request that was rejected by the server.
 */
struct rejected_reply {
	enum reject_stat rj_stat;
	union {
		struct {
			u_long low;
			u_long high;
		} RJ_versions;
		enum auth_stat RJ_why;  /* why authentication did not work */
	} ru;
#define	rj_vers	ru.RJ_versions
#define	rj_why	ru.RJ_why
};

/*
 * Body of a reply to an rpc request.
 */
struct reply_body {
	enum reply_stat rp_stat;
	union {
		struct accepted_reply RP_ar;
		struct rejected_reply RP_dr;
	} ru;
#define	rp_acpt	ru.RP_ar
#define	rp_rjct	ru.RP_dr
};

/*
 * Body of an rpc request call.
 */
struct call_body {
	u_long cb_rpcvers;	/* must be equal to two */
	u_long cb_prog;
	u_long cb_vers;
	u_long cb_proc;
	struct opaque_auth cb_cred;
	struct opaque_auth cb_verf; /* protocol specific - provided by client */
};

/*
 * The rpc message
 */
struct rpc_msg {
	u_long			rm_xid;
	enum msg_type		rm_direction;
	union {
		struct call_body RM_cmb;
		struct reply_body RM_rmb;
	} ru;
#define	rm_call		ru.RM_cmb
#define	rm_reply	ru.RM_rmb
};
#define	acpted_rply	ru.RM_rmb.ru.RP_ar
#define	rjcted_rply	ru.RM_rmb.ru.RP_dr


/*
 * XDR routine to handle a rpc message.
 * xdr_callmsg(xdrs, cmsg)
 * 	XDR *xdrs;
 * 	struct rpc_msg *cmsg;
 */
extern bool_t	xdr_callmsg();

/*
 * XDR routine to pre-serialize the static part of a rpc message.
 * xdr_callhdr(xdrs, cmsg)
 * 	XDR *xdrs;
 * 	struct rpc_msg *cmsg;
 */
extern bool_t	xdr_callhdr();

/*
 * XDR routine to handle a rpc reply.
 * xdr_replymsg(xdrs, rmsg)
 * 	XDR *xdrs;
 * 	struct rpc_msg *rmsg;
 */
extern bool_t	xdr_replymsg();

/*
 * Fills in the error part of a reply message.
 * _seterr_reply(msg, error)
 * 	struct rpc_msg *msg;
 * 	struct rpc_err *error;
 */
extern void	_seterr_reply();


/*	@(#)svc.h	4.2	(ULTRIX)	3/1/91	*/

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * svc.h, Server-side remote procedure call interface.
 *
 */

/*
 * This interface must manage two items concerning remote procedure calling:
 *
 * 1) An arbitrary number of transport connections upon which rpc requests
 * are received.  The two most notable transports are TCP and UDP;  they are
 * created and registered by routines in svc_tcp.c and svc_udp.c, respectively;
 * they in turn call xprt_register and xprt_unregister.
 *
 * 2) An arbitrary number of locally registered services.  Services are
 * described by the following four data: program number, version number,
 * "service dispatch" function, a transport handle, and a boolean that
 * indicates whether or not the exported program should be registered with a
 * local binder service;  if true the program's number and version and the
 * port number from the transport handle are registered with the binder.
 * These data are registered with the rpc svc system via svc_register.
 *
 * A service's dispatch function is called whenever an rpc request comes in
 * on a transport.  The request's program and version numbers must match
 * those of the registered service.  The dispatch function is passed two
 * parameters, struct svc_req * and SVCXPRT *, defined below.
 */

enum xprt_stat {
	XPRT_DIED,
	XPRT_MOREREQS,
	XPRT_IDLE
};

/*
 * Server side transport handle
 */
typedef struct {
#ifdef KERNEL
	struct socket	*xp_sock;
#else
	int		xp_sock;
#endif
	u_short		xp_port;	 /* associated port number */
	struct xp_ops {
	    bool_t	(*xp_recv)();	 /* receive incomming requests */
	    enum xprt_stat (*xp_stat)(); /* get transport status */
	    bool_t	(*xp_getargs)(); /* get arguments */
	    bool_t	(*xp_reply)();	 /* send reply */
	    bool_t	(*xp_freeargs)();/* free mem allocated for args */
	    void	(*xp_destroy)(); /* destroy this struct */
	} *xp_ops;
	int		xp_addrlen;	 /* length of remote address */
	struct sockaddr_in xp_raddr;	 /* remote address */
	struct opaque_auth xp_verf;	 /* raw response verifier */
	caddr_t		xp_p1;		 /* private */
	caddr_t		xp_p2;		 /* private */
} SVCXPRT;

/*
 *  Approved way of getting address of caller
 */
#define svc_getcaller(x) (&(x)->xp_raddr)

/*
 * Operations defined on an SVCXPRT handle
 *
 * SVCXPRT		*xprt;
 * struct rpc_msg	*msg;
 * xdrproc_t		 xargs;
 * caddr_t		 argsp;
 */
#define SVC_RECV(xprt, msg)				\
	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
#define svc_recv(xprt, msg)				\
	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))

#define SVC_STAT(xprt)					\
	(*(xprt)->xp_ops->xp_stat)(xprt)
#define svc_stat(xprt)					\
	(*(xprt)->xp_ops->xp_stat)(xprt)

#define SVC_GETARGS(xprt, xargs, argsp)			\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt, xargs, argsp)			\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))

#define SVC_REPLY(xprt, msg)				\
	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
#define svc_reply(xprt, msg)				\
	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))

#define SVC_FREEARGS(xprt, xargs, argsp)		\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
#define svc_freeargs(xprt, xargs, argsp)		\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))

#define SVC_DESTROY(xprt)				\
	(*(xprt)->xp_ops->xp_destroy)(xprt)
#define svc_destroy(xprt)				\
	(*(xprt)->xp_ops->xp_destroy)(xprt)


/*
 * Service request
 */
struct svc_req {
	u_long		rq_prog;	/* service program number */
	u_long		rq_vers;	/* service protocol version */
	u_long		rq_proc;	/* the desired procedure */
	struct opaque_auth rq_cred;	/* raw creds from the wire */
	caddr_t		rq_clntcred;	/* read only cooked cred */
	SVCXPRT	*rq_xprt;		/* associated transport */
};


/*
 * Service registration
 *
 * svc_register(xprt, prog, vers, dispatch, protocol)
 *	SVCXPRT *xprt;
 *	u_long prog;
 *	u_long vers;
 *	void (*dispatch)();
 *	int protocol;  /* like TCP or UDP, zero means do not register 
 */
extern bool_t	svc_register();

/*
 * Service un-registration
 *
 * svc_unregister(prog, vers)
 *	u_long prog;
 *	u_long vers;
 */
extern void	svc_unregister();

/*
 * Transport registration.
 *
 * xprt_register(xprt)
 *	SVCXPRT *xprt;
 */
extern void	xprt_register();

#ifndef KERNEL
/*
 * Transport un-register
 *
 * xprt_unregister(xprt)
 *	SVCXPRT *xprt;
 */
extern void	xprt_unregister();
#endif /* !KERNEL */


/*
 * When the service routine is called, it must first check to see if it
 * knows about the procedure;  if not, it should call svcerr_noproc
 * and return.  If so, it should deserialize its arguments via 
 * SVC_GETARGS (defined above).  If the deserialization does not work,
 * svcerr_decode should be called followed by a return.  Successful
 * decoding of the arguments should be followed the execution of the
 * procedure's code and a call to svc_sendreply.
 *
 * Also, if the service refuses to execute the procedure due to too-
 * weak authentication parameters, svcerr_weakauth should be called.
 * Note: do not confuse access-control failure with weak authentication!
 *
 * NB: In pure implementations of rpc, the caller always waits for a reply
 * msg.  This message is sent when svc_sendreply is called.  
 * Therefore pure service implementations should always call
 * svc_sendreply even if the function logically returns void;  use
 * xdr.h - xdr_void for the xdr routine.  HOWEVER, tcp based rpc allows
 * for the abuse of pure rpc via batched calling or pipelining.  In the
 * case of a batched call, svc_sendreply should NOT be called since
 * this would send a return message, which is what batching tries to avoid.
 * It is the service/protocol writer's responsibility to know which calls are
 * batched and which are not.  Warning: responding to batch calls may
 * deadlock the caller and server processes!
 */

extern bool_t  svc_sendreply();
extern void	svcerr_decode();
extern void	svcerr_weakauth();
extern void	svcerr_noproc();

/*
 * Lowest level dispatching -OR- who owns this process anyway.
 * Somebody has to wait for incoming requests and then call the correct
 * service routine.  The routine svc_run does infinite waiting; i.e.,
 * svc_run never returns.
 * Since another (co-existant) package may wish to selectively wait for
 * incoming calls or other events outside of the rpc architecture, the
 * routine svc_getreq is provided.  It must be passed readfds, the
 * "in-place" results of a select system call (see select, section 2).
 */

#ifndef KERNEL
/* dynamic; must be inspected before each call to select */
/*FIX #define svc_fds svc_fdset.fds_bits[0]    */

#ifndef __ALPHA
extern u_short /*FIX fd_set */ svc_fdset;
#endif /* __ALPHA */

/*
** First 32 file descriptors available.
*/
globalref int svc_fds;

/*
 * a small program implemented by the svc_rpc implementation itself;
 * also see clnt.h for protocol numbers.
 */
extern void rpctest_service();
#endif /* !KERNEL */

extern void	svc_getreq();
extern void	svc_run(); 	 /* never returns */

/*
 * Socket to use on svcxxx_create call to get default socket
 */
#define	RPC_ANYSOCK	-1

/*
 * These are the existing service side transport implementations
 */

#ifndef KERNEL
/*
 * Memory based rpc for testing and timing.
 */
extern SVCXPRT *svcraw_create();

/*
 * Udp based rpc.
 */
extern SVCXPRT *svcudp_create();
extern SVCXPRT *svcudp_bufcreate();

/*
 * Tcp based rpc.
 */
extern SVCXPRT *svctcp_create();

#else

/*
 * Kernel udp based rpc.
 */
extern SVCXPRT *svckudp_create();

/*
 * kernel-based RPC server duplicate transaction cache flag values
 */
#define DUP_BUSY	0x1	/* transaction in progress */
#define DUP_DONE	0x2	/* transaction was completed */
#define DUP_FAIL	0x4	/* transaction failed */

#endif /* !KERNEL */


/*	@(#)svc_auth.h	4.1	(ULTRIX)	7/2/90	*/

/************************************************************************
 *									*
 *			Copyright (c) 1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/*
 *	Portions of this software have been licensed to 
 *	Digital Equipment Company, Maynard, MA.
 *	Copyright (c) 1986 Sun Microsystems, Inc.  ALL RIGHTS RESERVED.
 */

/*
 * svc_auth.h, Service side of rpc authentication.
 * 
 */


/*
 * Server side authenticator
 */
extern enum auth_stat _authenticate();

# ifdef __cplusplus
  }
# endif /* __cplusplus */

# pragma standard

# endif /* _RPCXDR_LOADED */
#ifndef __UICDEF_LOADED
#define __UICDEF_LOADED	1

/*** MODULE $uicdef ***/
/*+                                                                         */
/*                                                                          */
/* Format of UIC - user identification code. May be either two part         */
/* group / member identifier, or a single uniform identifier.               */
/*                                                                          */
/*-                                                                         */
#define UIC$K_MAX_UIC 1073741823        /* Highest possible UIC             */
#define UIC$K_WILD_MEMBER 65535         /* Code for wild card member        */
#define UIC$K_WILD_GROUP 16383          /* Code for wild card group         */
#define UIC$K_UIC_FORMAT 0              /* UIC format code                  */
#define UIC$K_ID_FORMAT 2               /* ID format code                   */
#define UIC$K_FIRST_ID -2147418112      /* First general identifier         */
#define UIC$K_LAST_ID -1879048193       /* Last general identifier          */
#define UIC$K_MATCH_ALL -1              /* Match all identifiers            */
union uicdef {
    unsigned long int uic$l_uic;        /* Full longword                    */
#pragma nostandard
    variant_struct  {                   /* Group / member format            */
        unsigned uic$v_member : 16;     /* Member number                    */
        unsigned uic$v_group : 14;      /* Group number                     */
        unsigned uic$v_format : 2;      /* Format code                      */
        } uic$r_uic_form;
    variant_struct  {                   /* General identifier format        */
        unsigned uic$v_id_code : 28;    /* ID code                          */
        unsigned uic$v_fill_1 : 2;      /* Reserved ID bits                 */
        unsigned uic$v_fill_2 : 2;      /* Dummy to cover format code       */
        } uic$r_id_form;
    } ;
 
#pragma standard

#endif					/* __UICDEF_LOADED */
/********************************************************************************************************************************/
/* Created  6-NOV-1992 12:20:53 by VAX SDL V3.2-12     Source:  6-APR-1990 17:54:55 VWSRESD$:[UIS.SRC]UISENTRY.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE UISENTRY ***/
/*                                                                          */
/*  UIS$BEGIN_SEGMENT (vd_id)                                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*      vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*	seg_id.wlu.v = Segment ID                                           */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Begin a graphics segment.                                             */
/*                                                                          */
unsigned long int uis$begin_segment() ;
/*                                                                          */
/*  UIS$CIRCLE (vd_id, atb,center_x,center_y, xradius,                      */
/*			[start_deg],[end_deg])                              */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Attribute block number                                   */
/*      center_x.rf.r, center_y.rf.r = Center x,y coordinates (F floating)  */
/*	xradius.rf.r = Radius of the circle (x axis) (F floating)           */
/*	start_deg.rf.r = Degree at which arc starts (F floating, optional)  */
/*	end_deg.rf.r = Degree at which arc ends (F floating, optional)      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Draw the arc of a circle.                                             */
/*                                                                          */
int uis$circle() ;
/*                                                                          */
/*  UIS$CLOSE_WINDOW (wd_id)                                                */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Close window, default routine for DELETE menu option.                 */
/*    (calls SYS$EXIT)                                                      */
/*                                                                          */
int uis$close_window() ;
/*                                                                          */
/* UIS$COPY_OBJECT (obj_id, matrix, ia)                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = SEG or OTP ID                                        */
/*	matrix.rf.ra = Address of matrix                                    */
/*	atb.rl.r = Input attribute block value                              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      copy_id.wlu.v = Object id of newly created object                   */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Copy the sepcified object.                                            */
/*                                                                          */
unsigned long int uis$copy_object() ;
/*                                                                          */
/* uis$create_color_map (vcm_size, vcm_name, vmc_attributes)                */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vcm_size.rl.r = Size of virtual color map                           */
/*	vcm_name.rt.dx = (optional) VCM name descriptor                     */
/*	vcm_attributes.rlu.da = (optional) VCM attribute block              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	vcm_id.wlu.v = Virtual color map ID (returned in R0)                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Create a new virtual color map.                                     */
/*                                                                          */
unsigned long int uis$create_color_map() ;
/*                                                                          */
/* uis$create_color_map_seg (vcm_id, devnam: REF $BBLOCK,                   */
/* 					place_mode, place_data) =           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*  	vcm_id.rlu.r = Virtual color map ID                                 */
/*	devnam.rt.dx = Device name                                          */
/*	place_mode.rl.r = Placement mode                                    */
/*	place_data.rl.r = Placement data                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	cms_id.wlu.v =  Color map segment ID (returned in R0)               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Create color map segment and bind it to a virtual color map         */
/*                                                                          */
unsigned long int uis$create_color_map_seg() ;
/*                                                                          */
/*  UIS$CREATE_DISPLAY (x1,y1,x2,y2,width,height,vcm_id)                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	x1.rf.r = Minimum X world coordinate (F floating)                   */
/*	y1.rf.r = Minimum Y world coordinate (F floating)                   */
/*	x2.rf.r = Maximum X world coordinate (F floating)                   */
/*	y2.rf.r = Maximum Y world coordinate (F floating)                   */
/*	width.rf.r = Width of display in cms (F floating)                   */
/*	height.rf.r = Height of display in cms (F floating)                 */
/*	vcm_id.rlu.r = Virtual color map ID (optional)                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      vd_id.wlu.v = ID of newly create virtual display                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Create a virtual display                                              */
/*                                                                          */
unsigned long int uis$create_display() ;
/*                                                                          */
/*  UIS$CREATE_KB (devnam)                                                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	devnam.rt.dx = Device name descriptor                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	kb_id.wlu.v = Virtual keyboard ID (return value)                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Create a virtual keyboard                                             */
/*                                                                          */
unsigned long int uis$create_kb() ;
/*                                                                          */
/*  UIS$CREATE_TB                                                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*    devnam.rt.dx = Device name (SYS$WORKSTATION)                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*    tb_id.wlu.v = Returned tablet identifier                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*     Create tablet data block                                             */
/*                                                                          */
unsigned long int uis$create_tb() ;
/*                                                                          */
/*  UIS$CREATE_TERMINAL (termtype,[title],[attributes],devnam,[devlen],     */
/*			 [termattributes])                                  */
/*				                                            */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	termtype.rt.dx = Terminal type descriptor ('VT' or 'TK')            */
/*	title.rt.dx = Window title descriptor (optional)                    */
/*	attributes.rl.ra = Address of window attribute block                */
/*	termattributes.rl.ra = Address of terminal attribute block          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	devnam.wt.dx = Descriptor to return device name in                  */
/*	devlen.ww.r = Word to return device name length in                  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Create a terminal emulation window of the specified type.             */
/*                                                                          */
int uis$create_terminal() ;
/*                                                                          */
/* UIS$CREATE_TRANSFORMATION (vd_id,x1,y1,x2,y2,                            */
/* 				[vdx1,vdy1,vdx2,vdy2])                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	x1.rf.r, y1.rf.r = Lower left corner of new coordinate space        */
/*	x2.rf.r, y2.rf.r = Upper right corner of new coordinate space       */
/*	vdx1.rf.r, vdy1.rf.r = Lower left corner of virtual display (VD_ID) */
/*	vdx2.rf.r, vdy2.rf.r = Upper right corner of virtual display (VD_ID) */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	tr_id.wlu.v = Transformation ID (return value)                      */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Create alternate display transformation                               */
/*                                                                          */
unsigned long int uis$create_transformation() ;
/*                                                                          */
/* UIS$CREATE_WINDOW (vd_id,devnam,[title],[x1,y1,x2,y2],                   */
/*						[width,height],             */
/*						[attributes])               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display or pasteboard ID                      */
/*	devnam.rt.dx = Descriptor of physical display device                */
/*	title.rt.dx = Descriptor of window border title                     */
/*	x1.rf.r, y1.rf.r = One corner of the window rectangle (F floating)  */
/*	x2.rf.r, y2.rf.r = Other corner of the window rectangle (F floating) */
/*	width.rf.r, height.rf.r = Initial width,height of viewport in cms (F floating) */
/*	attributes.rl(f).ra = Address of window attributes block (WDPL$C_xxx) */
/*	                      the <data type> can be either longword or     */
/*					f_floating                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*       wd_id.wlu.v = Display window ID (return value)                     */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*       Create a display window to an existing virtual display             */
/*                                                                          */
unsigned long int uis$create_window() ;
/*                                                                          */
/* uis$delete_color_map (vcm_id): NOVALUE =                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vcm_id.rlu.r = Virtual color map ID                                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Delete a virtual color map.                                         */
/*                                                                          */
int uis$delete_color_map() ;
/*                                                                          */
/* uis$delete_color_map_seg (cms_id): NOVALUE =                             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	cms_id.rlu.r = Color map segment ID                                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Delete a color map segment.                                         */
/*                                                                          */
int uis$delete_color_map_seg() ;
/*                                                                          */
/*  UIS$DELETE_DISPLAY (vd_id)                                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Delete a virtual display.                                           */
/*                                                                          */
int uis$delete_display() ;
/*                                                                          */
/*  UIS$DELETE_KB (kb_id)                                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Delete a virtual keyboard.                                            */
/*                                                                          */
int uis$delete_kb() ;
/*                                                                          */
/*  UIS$DELETE_OBJECT (obj_id)                                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Segment or primitive ID                              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      End a graphics segment.                                             */
/*                                                                          */
int uis$delete_object() ;
/*                                                                          */
/*  UIS$DELETE_PRIVATE (obj_id)                                             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Segment or primitive ID                              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Deletes all private data assocated with the object.                 */
/*                                                                          */
int uis$delete_private() ;
/*                                                                          */
/* UIS$DELETE_TB (tb_id)                                                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	tb_id.rlu.r = device name (SYS$WORKSTATION)                         */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Delete tablet data block                                            */
/*                                                                          */
int uis$delete_tb() ;
/*                                                                          */
/*  UIS$DELETE_TRANSFORMATION (tr_id)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	tr_id.rlu.r = Transformation ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Delete a display transformation.                                    */
/*                                                                          */
int uis$delete_transformation() ;
/*                                                                          */
/*  UIS$DELETE_WINDOW (wd_id)                                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*   	Delete a display window to a virtual display.                       */
/*                                                                          */
int uis$delete_window() ;
/*                                                                          */
/*  UIS$DISABLE_DISPLAY_LIST (vd_id, display_flags)                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	display_flags.rlu.r = Mask of display list controls                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Disable keeping the display list for "animation" displays           */
/*                                                                          */
int uis$disable_display_list() ;
/*                                                                          */
/*  UIS$DISABLE_KB (kb_id)                                                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Disable a virtual keyboard.  (Detach the physical keyboard          */
/*    	from it.)                                                           */
/*                                                                          */
int uis$disable_kb() ;
/*                                                                          */
/* UIS$DISABLE_TB (tb_id)                                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	tb_id.rlu.r = Tablet identifier                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/* 	Release digitizing tablet                                           */
/*                                                                          */
int uis$disable_tb() ;
/*                                                                          */
/*  UIS$DISABLE_VIEWPORT_KB (wd_id)                                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Do not allow a viewport to have a keyboard associated with it.      */
/*                                                                          */
int uis$disable_viewport_kb() ;
/*                                                                          */
/*  UIS$ELLIPSE (vd_id, atb,center_x,center_y,xradius,yradius,[start_deg],[end_deg]) */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Attribute block number                                   */
/*      center_x.rf.r, center_y.rf.r = Center x,y coordinates (F floating)  */
/*	xradius.rf.r = Major axis radius of the ellipse (F floating)        */
/*	yradius.rf.r = Minor axis radius of the ellipse (F floating)        */
/*	start_deg.rf.r = Degree at which arc starts (F floating, optional)  */
/*	end_deg.rf.r = Degree at which arc ends (F floating, optional)      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Draw the arc of an ellipse.                                         */
/*                                                                          */
int uis$ellipse() ;
/*                                                                          */
/*  UIS$ENABLE_DISPLAY_LIST (vd_id, display_flags)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	display_flags.rlu.r = Mask of display list controls                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable keeping the display list (used after being disabled)         */
/*                                                                          */
int uis$enable_display_list() ;
/*                                                                          */
/*  UIS$ENABLE_KB (kb_id [,wd_id])                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*	wd_id.rlu.r = Display window ID (optional)                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable a virtual keyboard.  (Attach the physical keyboard           */
/*    	to it.)                                                             */
/*                                                                          */
int uis$enable_kb() ;
/*                                                                          */
/* UIS$ENABLE_TB (tb_id)                                                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	tb_id.rlu.r = Tablet ID                                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/* 	Make this current owner of digitizing                               */
/*                                                                          */
int uis$enable_tb() ;
/*                                                                          */
/*  UIS$ENABLE_VIEWPORT_KB (kb_id, wd_id)                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Allow a viewport to have a keyboard associated with it.             */
/*                                                                          */
int uis$enable_viewport_kb() ;
/*                                                                          */
/*  UIS$END_SEGMENT (vd_id)                                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	End a graphics segment.                                             */
/*                                                                          */
int uis$end_segment() ;
/*                                                                          */
/*  UIS$ERASE (vd_id, [x1,y1,x2,y2])                                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Address of virtual display ID                         */
/*	x1.rf.r, y1.rf.r = X,Y position of one rectangle corner (F floating) */
/*	x2.rf.r, y2.rf.r = X,Y position of other corner (F floating)        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none                                                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Erases the region specified by the given rectangle.                 */
/*                                                                          */
int uis$erase() ;
/*                                                                          */
/*  UIS$EXECUTE(vd_id, buflen, bufaddr)                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	buflen.rl.r = Length of binary stream in bytes                      */
/*	bufaddr.rlu.va = Address of binary stream                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Executes a binary generic encoding stream                           */
/*                                                                          */
int uis$execute() ;
/*                                                                          */
/*  UIS$EXECUTE_DISPLAY(buflen, bufaddr)                                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	buflen.rl.r = Length of binary stream in bytes                      */
/*	bufaddr.rbu.ra = Address of binary stream                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Creates a virtual display and executes a                            */
/*	binary generic encoding stream                                      */
/*                                                                          */
unsigned long int uis$execute_display() ;
/*                                                                          */
/* UIS$EXPAND_ICON (wd_id, [icon_wd_id,] [attributes])                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Window identifier for the viewport to be              */
/*		restored.                                                   */
/*	icon_wd_id.rlu.r = (Optional) Window identifier for the icon        */
/*		to be deleted.                                              */
/*	attributes.rlu(f).va = (Optional) Window attribute list for         */
/*		viewport placement.                                         */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*   	Get rid of the icon and restore the desired viewport from           */
/*   	its hidden state.                                                   */
/*                                                                          */
int uis$expand_icon() ;
/*                                                                          */
/*  UIS$EXTRACT_HEADER (obj_id [,[buflen, [bufaddr],                        */
/*			[retlen]])                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	buflen.rl.r = (optional) Address of user data buffer.               */
/*	bufaddr.rbu.ra = (optional) Address of user buffer.                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retlen.wl.r = (optional) Address to return length of private data buf. */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	This routine encodes the header and returns the                     */
/*	encoding in the specified buffer.                                   */
/*                                                                          */
int uis$extract_header() ;
/*                                                                          */
/*  UIS$EXTRACT_OBJECT (obj_id [,[buflen, [bufaddr],                        */
/*			[retlen]])                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = SEG or OTP ID                                        */
/*	buflen.rl.r = (optional) Address of user data buffer.               */
/*	bufaddr.rbu.ra = (optional) Address of user buffer.                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retlen.wl.r = (optional) Address to return length of private data buf. */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      This routine encodes the specified object and returns the           */
/*	encoding in the specified buffer.                                   */
/*                                                                          */
int uis$extract_object() ;
/*                                                                          */
/*  UIS$EXTRACT_PRIVATE(obj_id,[[buflen], [bufaddr], [retlen]])             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = SEG or OTP ID                                        */
/*	buflen.rl.r = (optional) Address of user data buffer.               */
/*	bufaddr.rbu.ra = (optional) Address of user buffer.                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retlen.wl.r = (optional) Address to return length of private data buf. */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Return private date from the specified object.                      */
/*                                                                          */
int uis$extract_private() ;
/*                                                                          */
/*  UIS$EXTRACT_REGION (vd_id [, x1, y1, x2, y2]                            */
/*			[,buflen] [,bufaddr] [,retlen])                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = VD ID                                                 */
/*	x1.rf.r,y1.rf.r,x2.rf.r,y2.rf.r = Bounds of rectangle               */
/*	buflen.rl.r = (optional) buffer length byte count                   */
/*	bufaddr.rbu.ra = (optional) buffer address                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retlen.wl.r = (optional) returned buffer byte count                 */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Fills the specified buffer with the UIS encoding                    */
/*    	for the specified region.                                           */
/*                                                                          */
int uis$extract_region() ;
/*                                                                          */
/*  UIS$EXTRACT_TRAILER (obj_id [,[buflen, [bufaddr],                       */
/*			[retlen]])                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	buflen.rl.r = (optional) Address of user data buffer.               */
/*	bufaddr.rbu.ra = (optional) Address of user buffer.                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retlen.wl.r = (optional) Address to return length of private data buf. */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	This routine encodes the trailer and returns the                    */
/*	encoding in the specified buffer.                                   */
/*                                                                          */
int uis$extract_trailer() ;
/*                                                                          */
/*  UIS$FIND_PRIMITIVE(vd_id, x1, y1, x2, y2,                               */
/*			[context], [extent_array])                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	x1.rf.r,y1.rf.r,x2.rf.r,y2.rf.r = Bounds of rectangle               */
/*	context.ml.r = (optional) context longword                          */
/*	extent.wlu.ra = (optional) Address of user extent array.            */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	obj_id.rlu.v = Object ID                                            */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Find the next primitive which intersects the specified rectangle.   */
/*                                                                          */
unsigned long int uis$find_primitive() ;
/*                                                                          */
/*  UIS$FIND_SEGMENT(vd_id, x1, y1, x2, y2,                                 */
/*			[context], [extent_array])                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	x1.rf.r,y1.rf.r,x2.rf.r,y2.rf.r = Bounds of rectangle               */
/*	context.ml.r = (optional) context longword                          */
/*	extent.wlu.ra = (optional) Address of user extent array.            */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	obj_id.rlu.v = Object ID                                            */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Find the next segment which intersects the specified rectangle.     */
/*                                                                          */
unsigned long int uis$find_segment() ;
/*                                                                          */
/*  UIS$GET_ABS_POINTER_POS (devnam, retx, rety)                            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	devnam.rt.dx = Device name descriptor                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wf.r, rety.wf.r = Address to return X,Y coordinates in cms     */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the current mouse position in absolute coordinates             */
/*                                                                          */
int uis$get_abs_pointer_pos() ;
/*  UIS$GET_ALIGNED_POSITION (vd_id, atb, retx,rety)                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Attribute block number                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wf.r, rety.wf.r = X,Y position (F floating)                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Get the current text position, which is used when writing           */
/*    	text.  The position refers to the upper left corner of the          */
/*    	text.                                                               */
/*                                                                          */
int uis$get_aligned_position() ;
/*                                                                          */
/*  UIS$GET_ARC_TYPE (vd_id, atb)                                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	arc_type.wlu.v = Arc type code (return value)                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the current arc type.                                          */
/*                                                                          */
unsigned long int uis$get_arc_type() ;
/*                                                                          */
/*  UIS$GET_BACKGROUND_INDEX (vd_id, atb)                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	index.wlu.v = Color map index (return value)                        */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the text and graphics background color index.                  */
/*                                                                          */
unsigned long int uis$get_background_index() ;
/*                                                                          */
/*  UIS$GET_BUTTONS (wd_id, retstate)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retstate.wlu.v = Address to return button state in                  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the current mouse button state.                                */
/*      Returns true/false if mouse is within the window                    */
/*                                                                          */
char uis$get_buttons() ;
/*                                                                          */
/*  UIS$GET_CHAR_ROTATION (vd_id, atb)                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	angle.wf.v = Current character rotation angle                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Sets the angle of the character relative to text path               */
/*                                                                          */
/*                                                                          */
float uis$get_char_rotation() ;
/*                                                                          */
/*  UIS$GET_CHAR_SIZE (vd_id, atb, char, width, height)                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	char.wt.dx = Character on which to base size                        */
/*	width.wf.r = Width of example character                             */
/*	height.wf.r = Height to make example character                      */
/*	boolean.wlu.v = Returned boolean value                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets an additional amount of text spacing.                          */
/*                                                                          */
char uis$get_char_size() ;
/*                                                                          */
/*  UIS$GET_CHAR_SLANT (vd_id, atb)                                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	angle.wf.r = Current character slant angle                          */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the slant of characters (0=rectangular characters)             */
/*                                                                          */
float uis$get_char_slant() ;
/*                                                                          */
/*  UIS$GET_CHAR_SPACING (vd_id, atb, dx, dy)                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	dx.wf.r = Additional X spacing factor (0 if none)                   */
/*	dy.wf.r = Additional Y spacing factor (0 if none)                   */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets additional amount of text spacing.                             */
/*                                                                          */
int uis$get_char_spacing() ;
/*                                                                          */
/*  UIS$GET_CLIP (vd_id, atb [,x1, y1, x2, y2])                             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	x1.wf.r, y1.wf.r = X,Y position of lower left corner (F floating)   */
/*	x2.wf.r, y2.wf.r = X,Y position of upper right corner (F floating)  */
/*	boolean.wl.v = returned boolean value                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets a user clipping rectangle.                                     */
/*                                                                          */
char uis$get_clip() ;
/*                                                                          */
/*  UIS$GET_COLOR (vd_id, index, retR, retG, retB [,wd_id])                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = Color map index                                        */
/*	wd_id.rlu.r = Display window ID (optional)                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retR.wf.r = Red color value                                         */
/*	retG.wf.r = Green color value                                       */
/*	retB.wf.r = Blue color value                                        */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the RGB color values from a color map.                         */
/*                                                                          */
int uis$get_color() ;
/*                                                                          */
/*  UIS$GET_COLORS (vd_id, index, count, R_vector, G_vector, B_vector [,wd_id]) */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = First color map index                                  */
/*	count.rl.r = Number of indices                                      */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	R_vector.wf.ra = Red color values                                   */
/*	G_vector.wf.ra = Green color values                                 */
/*	B_vector.wf.ra = Blue color values                                  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets multiple RGB color values from a color map.                    */
/*                                                                          */
int uis$get_colors() ;
/*                                                                          */
/*  UIS$GET_CURRENT_OBJECT (vd_id)                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/* 	obj_id.wlu.v = Segment or primitive ID                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get current graphics object id.                                     */
/*                                                                          */
unsigned long int uis$get_current_object() ;
/*                                                                          */
/*  UIS$GET_DISPLAY_SIZE (devnam, retwidth, retheight,                      */
/*				[retresolx,retresoly],                      */
/*				[retpwidth, retpheight])                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	devnam.rt.dx = Device name descriptor                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retwidth.wf.r, retheight.wf.r = Address to return width,height (F floating) */
/*	retresolx.wf.r, retresoly.wf.r = (Optional) Address to return X,Y   */
/*				resolution, in pixels/cm (F floating)       */
/*	retpwidth.wl.r = Address to return width,height in pixels           */
/*	retpheight.wl.r = Address to return width,height in pixels          */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the size of the physical display in cms                        */
/*                                                                          */
int uis$get_display_size() ;
/*                                                                          */
/*  UIS$GET_FILL_PATTERN (vd_id, atb,[index])                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	index.wl.r = Index of fill pattern                                  */
/*	boolean.wl.v = Returns true/false if the fill pattern               */
/*			is in the attribute block                           */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the fill pattern index.                                        */
/*                                                                          */
char uis$get_fill_pattern() ;
/*                                                                          */
/*  UIS$GET_FONT (vd_id, atb, bufferdesc, [length])                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	bufferdesc.wt.dx = Font ID buffer descriptor                        */
/*	length.ww.r = Length of string written into specified buffer        */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets a font from an attribute block.                                */
/*                                                                          */
int uis$get_font() ;
/*                                                                          */
/*  UIS$GET_FONT_ATTRIBUTES (font_id, ascender, descender, height           */
/*				[,maximum_width] [,item_list]               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	font_id.rt.dx = Font ID descriptor                                  */
/*	item_list.rlu.ra = an item list of fields to return                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	ascender.wl.r = ascender height                                     */
/*	descender.wl.r = descender height                                   */
/*	height.wl.r = global cell height                                    */
/*	maximum_width.wl.r = width of the widest character                  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets a font from an attribute block.                                */
/*                                                                          */
int uis$get_font_attributes() ;
/*                                                                          */
/*  UIS$GET_FONT_SIZE (fontid, text_string, retwidth,retheight)             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	fontid.rt.dx = Font ID string descriptor                            */
/*	text_string.rt.dx = Character string descriptor                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retwidth.wf.r, retheight.wf.r = Address to return width,height (F floating) */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the size of a font's characters in cms                         */
/*                                                                          */
int uis$get_font_size() ;
/*                                                                          */
/* uis$get_hw_color_info (devnam: REF $BBLOCK, type, indices, colors,       */
/*				maps, rbits, gbits, bbits,                  */
/*				ibits, res_indices, regen): NOVALUE =       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	devnam.rt.dx = Device name descriptor (SYS$WORKSTATION)             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	type.wl.r = Address of receiver of device type (optional)           */
/*	indices.wl.r = Number of entries or simultaneous colors. (opt)      */
/*	colors.wl.r = Number of possible colors (optional)                  */
/*	maps.wl.r = Number of hardware color maps. (optional)               */
/*	rbits.wl.r = Number of binary bits of precision for red (opt.)      */
/*	gbits.wl.r = Number of binary bits of precision for green (opt.)    */
/*	bbits.wl.r = Number of binary bits of precision for blue (opt.)     */
/*	ibits.wl.r = Number of binary bits of presision for intensity (opt.) */
/*	res_indices.wl.r = Number of entries in the hardware color map      */
/*				reserved for special use. (optional)        */
/*	regen.wl.r = Color regeneration characteristics. (optional)         */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Return information about hardware color characteristics.            */
/*                                                                          */
int uis$get_hw_color_info() ;
/*                                                                          */
/*  UIS$GET_IMAGING_PARAMETERS (vd_id, atb, [,thresholds,kernels])          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*      vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Input attribute block number                             */
/*      thresholds = Address of an array of 3 byte values                   */
/*      kernels = Address of a byte array containing the kernels            */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      status.wl.v = Returns true/false if mouse is within the window      */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Gets current imaging parameters used in WRITE_IMAGE                   */
/*                                                                          */
char uis$get_imaging_parameters() ;
/*                                                                          */
/*  UIS$GET_INTENSITIES (vd_id, index, count, I_vector [,wd_id])            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = First color map index                                  */
/*	count.rl.r = Number of indices                                      */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	I_vector.wf.ra = Achromatic intensity values                        */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets ultiple achromatic intensity values from a color map.          */
/*                                                                          */
int uis$get_intensities() ;
/*                                                                          */
/*  UIS$GET_INTENSITY (vd_id, index, retI [,wd_id])                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = Color map index                                        */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retI.wf.r = Achromatic intensity value                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the achromatic intensity value from a color map.               */
/*                                                                          */
int uis$get_intensity() ;
/*                                                                          */
/*  UIS$GET_KB_ATTRIBUTES (kb_id, [enable_items,]                           */
/*			[disable_items,] [click_volume])                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	enable_items.wlu.r = Mask of enabled characteristics (opt.)         */
/*	disable_items.wlu.r = Mask of disabled characteristics (opt.)       */
/*	click_volume.wl.r = Click volume level (opt.)                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Returns keyboard characteristics.                                   */
/*                                                                          */
int uis$get_kb_attributes() ;
/*                                                                          */
/*  UIS$GET_LEFT_MARGIN (vd_id, atb)                                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	x.wf.v = X coordiante of left margin                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the left margin for writing text.                              */
/*                                                                          */
float uis$get_left_margin() ;
/*                                                                          */
/*  UIS$GET_LINE_STYLE (vd_id, atb)                                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	style.wl.v = line style bitvector (return value)                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the default line style                                         */
/*                                                                          */
long int uis$get_line_style() ;
/*                                                                          */
/*  UIS$GET_LINE_WIDTH (vd_id, atb [,mode])                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	mode.wl.r  = (optional) line width specification mode               */
/*	width.wf.v = Line width                                             */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the default line width                                         */
/*                                                                          */
float uis$get_line_width() ;
/*                                                                          */
/*  UIS$GET_NEXT_OBJECT (obj_id, [flags])                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Object ID                                            */
/*	flags.rlu.r = (optional) Flags                                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	next_obj_id.wlu.r = ID of next object                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get the object id of the object following the specified object.     */
/*                                                                          */
unsigned long int uis$get_next_object() ;
/*                                                                          */
/*  UIS$GET_OBJECT_ATTRIBUTES (obj_id, [extent_array])                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Object ID                                            */
/*	extent.wf.ra = (optional) Address of user extent array.             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	obj_type.wl.v = Object type code                                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get the attributes of the specified object.                         */
/*                                                                          */
long int uis$get_object_attributes() ;
/*                                                                          */
/*  UIS$GET_PARENT_SEGMENT (vd_id)                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	parent_id.wlu.v = Parent segment ID                                 */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the root segment id.                                           */
/*                                                                          */
unsigned long int uis$get_parent_segment() ;
/*                                                                          */
/*  UIS$GET_PLANE_MASK (vd_id, atb)                                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual displau ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	plane_mask.rl.r = Returns the bitmaks of the planes to be written to */
/*                                                                          */
/*  DESCRITPION:                                                            */
/*                                                                          */
/*	Get the current plalne mask from the ATB                            */
/*                                                                          */
unsigned long int uis$get_plane_mask() ;
/*                                                                          */
/*   UIS$GET_POINTER_POSITION (vd_id, wd_id, retx, rety)                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wf.r, rety.wf.r = Address to return X,Y world coordinates      */
/*      status.wl.v = Returns true/false if mouse is within the window      */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the current mouse position in world coordinates                */
/*                                                                          */
char uis$get_pointer_position() ;
/*                                                                          */
/*  UIS$GET_POSITION (vd_id, retx,rety)                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wf.r, rety.wf.r = Address to return X,Y position (F floating)  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the current text position.  The position refers                */
/*    	to the baseline of the text.                                        */
/*                                                                          */
int uis$get_position() ;
/*                                                                          */
/*  UIS$GET_PREVIOUS_OBJECT (obj_id, [flags])                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Object ID                                            */
/*	flags.rlu.r = (optional) Flags                                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	previous_obj_id.wlu.v = ID of previous object                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get the object id of the object before the specified object.        */
/*                                                                          */
unsigned long int uis$get_previous_object() ;
/*                                                                          */
/*  UIS$GET_ROOT_SEGMENT (vd_id)                                            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	root_id.wlu.v = Root segment ID                                     */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the root segment id.                                           */
/*                                                                          */
unsigned long int uis$get_root_segment() ;
/*                                                                          */
/* UIS$GET_TB_INFO (devnam,retwidth, retheight,                             */
/*			   reresolx, retresoly,                             */
/*			   [retpwidth, retpheight])                         */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	devnam.rt.dx = Device name ID (SYS$WORKSTATION)                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retwidth.wf.r = Tablet width                                        */
/*	retheight.wf.r = Tablet height                                      */
/*	retresolx.wf.r = Tablet X resolution                                */
/*	retresoly.wf.r = Tablet Y resolution                                */
/*	retpwidth.wl.r = Tablet width in pixels (optional)                  */
/*	retpheight.wl.r = Tablet height in pixels (optional)                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/* 	Get tablet characteristics                                          */
/*                                                                          */
char uis$get_tb_info() ;
/*                                                                          */
/* UIS$GET_TB_POSITION (wd_id, retx, rety)                                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/* 	retx.wf.r = Address to return X position                            */
/* 	rety.wf.r = Address to return Y position                            */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/* 	Get tablet position                                                 */
/*                                                                          */
int uis$get_tb_position() ;
/*                                                                          */
/* UIS$GET_TEXT_FORMATTING (vd_id, atb)                                     */
/*                                                                          */
/* INPUTS:                                                                  */
/*                                                                          */
/* 	vd_id.rlu.r = Virtual Display ID                                    */
/* 	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/* OUTPUTS:                                                                 */
/*	                                                                    */
/*	mode.wl.v = Formatting mode (UIS$C_TEXT_FORMAT_xxxxx)               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get formatting mode (normal, justify, center)                       */
/*                                                                          */
long int uis$get_text_formatting() ;
/*                                                                          */
/* uis$get_text_margins (vd_id, atb, x, y, margin_length)                   */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	vd_id.rlu.r = Virtual Display ID                                    */
/* 	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/* 	x,y.wf.r = (optional) X and Y coordinate of starting position       */
/*	margin_length.wf.r = (optional) Distance to ending margin           */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get text margins used for text formatting.                          */
/*                                                                          */
int uis$get_text_margins() ;
/*                                                                          */
/*  UIS$GET_TEXT_PATH (vd_id, atb, major, minor)                            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	major.wl.r = Major text path                                        */
/*	minor.wl.r = Minor text path                                        */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the text paths.                                                */
/*                                                                          */
int uis$get_text_path() ;
/*                                                                          */
/*  UIS$GET_TEXT_SLOPE (vd_id, atb)                                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	angle.wf.v = Current text slope angle                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the angle of text slope                                        */
/*                                                                          */
float uis$get_text_slope() ;
/*                                                                          */
/* uis$get_vcm_id (vd_id) =                                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	vcm_id.wlu.v = Virtual Color map ID                                 */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Return the virtual color map ID for the given virtual display.      */
/*                                                                          */
unsigned long int uis$get_vcm_id() ;
/*                                                                          */
/*  UIS$GET_VIEWPORT_ICON (wd_id, icon_wd_id)                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	icon_wd_id.wlu.r = (optional) Address of variable to receive the    */
/*				icon's wd_id                                */
/*	boolean.wf.v = True, if window was shrunk to an icon, false         */
/*				otherwise.                                  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Returns a boolean value indicating whether the viewport has been    */
/*    	shrunk.  The wd_id for the viewport's icon is optionally returned,  */
/*    	if it exists.                                                       */
/*                                                                          */
char uis$get_viewport_icon() ;
/*  UIS$GET_VIEWPORT_POSITION (wd_id, retx, rety)                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wf.r, rety.wf.r = Address to return x,y (F floating cms)       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the absolute position of the viewport's lower left corner      */
/*    	as measured in cms from the lower left corner of the display.       */
/*                                                                          */
int uis$get_viewport_position() ;
/*                                                                          */
/*  UIS$GET_VIEWPORT_SIZE (wd_id, retwidth, retheight)                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retwidth.wf.r, retheight.wf.r = Address to return width,height (F floating) */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the size of the viewport in cms                                */
/*                                                                          */
int uis$get_viewport_size() ;
/*                                                                          */
/*  UIS$GET_VISIBILITY(vd_id, wd_id, [,x1, y1 [,x2 ,y2]])                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	x1.rf.r,y1.rf.r = World coordinates of one corner                   */
/*	x2.rf.r,y2.rf.r = World coordinates of other corner                 */
/*      boolean.wlu.v = Returns true/false visibility status                */
/*	                                                                    */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Returns whether the specified rectangle in the display              */
/*      window is completely visible or not.                                */
/*                                                                          */
char uis$get_visibility() ;
/*                                                                          */
/*  UIS$GET_WINDOW_ATTRIBUTES(wd_id)                                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	                                                                    */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	mask.wlu.v = Mask of window attributes (return value)               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Returns a mask containing the attributes of the specified           */
/*    	window.                                                             */
/*                                                                          */
unsigned long int uis$get_window_attributes() ;
/*                                                                          */
/*  UIS$GET_WINDOW_SIZE (vd_id, wd_id, x1,y1,x2,y2)                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	x1,y1,x2,y2.wf.r = Address to return WC bounds (F floating)         */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the window bounds in WC.                                       */
/*                                                                          */
int uis$get_window_size() ;
/*                                                                          */
/*  UIS$GET_WRITING_INDEX (vd_id, atb)                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	index.wl.v = Color map index (return value)                         */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the text and graphics writing color index.                     */
/*                                                                          */
long int uis$get_writing_index() ;
/*                                                                          */
/*  UIS$GET_WRITING_MODE (vd_id, atb)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	mode.wl.v = Number of the mode (return value)                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the text and graphics writing mode.                            */
/*                                                                          */
long int uis$get_writing_mode() ;
/*                                                                          */
/*  UIS$GET_WS_COLOR (vd_id, color_id, retR, retG, retB, [wd_id])           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	color_id.rl.r = WS color ID                                         */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retR.wf.r = Red color value                                         */
/*	retG.wf.r = Green color value                                       */
/*	retB.wf.r = Blue color value                                        */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the RGB color values for a workstation standard color.         */
/*                                                                          */
int uis$get_ws_color() ;
/*                                                                          */
/*  UIS$GET_WS_INTENSITY (vd_id, color_id, retI, [wd_id])                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	color_id.rl.r = WS color ID                                         */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retI.wf.r = Achromatic intensity value                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the achromatic intensity value for a workstation standard color. */
/*                                                                          */
int uis$get_ws_intensity() ;
/*                                                                          */
/*  UIS$HLS_to_RGB (H, L, S, R, G, B)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*  	h.rf.r = Hue of a color                                             */
/*	l.rf.r = Lightness of a color                                       */
/*	s.rf.r = Saturation of a color                                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      retr.wf.r = RED value                                               */
/*	retg.wf.r = GREEN value                                             */
/*	retb.wf.r = BLUE value                                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Convert HLS color to RGB color                                      */
/*                                                                          */
int uis$hls_to_rgb() ;
/*                                                                          */
/*  UIS$HSV_to_RGB (H, S, V, R, G, B)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*  	h.rf.r = Hue of a color                                             */
/*	s.rf.r = Saturation of a color                                      */
/*	v.rf.r = Value of a color                                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      retr.wf.r = RED value                                               */
/*	retg.wf.r = GREEN value                                             */
/*	retb.wf.r = BLUE value                                              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Convert HSV color to RGB color                                      */
/*                                                                          */
int uis$hsv_to_rgb() ;
/*                                                                          */
/*  UIS$IMAGE (vd_id, atb,x1,y1,x2,y2,                                      */
/*		rasterwidth,rasterheight,bitsperpixel,                      */
/*		rasteraddr)                                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Attribute block number                                   */
/*	x1.rf.r, y1.rf.r = X,Y position of one rectangle corner (F floating) */
/*	x2.rf.r, y2.rf.r = X,Y position of other corner (F floating)        */
/*	rasterwidth.rl.r = Width of image bitmap in pixels                  */
/*	rasterheight.rl.r = Height of image bitmap in pixels                */
/*	bitsperpixel.rl.r = Number of image bits which make up 1 "pixel"    */
/*	rasteraddr.rlu.ra = Address of natural image data                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Write a natural image bitmap into the specified virtual             */
/*    	display rectangle given by the two corners.  If the size            */
/*    	of the bitmap doesn't match the rectangle, scaling is done.         */
/*                                                                          */
int uis$image() ;
/*                                                                          */
/*  UIS$INSERT_OBJECT (obj_id)                                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Object ID                                            */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Moves the specified object to the current position                  */
/*      position in the display list.                                       */
/*                                                                          */
int uis$insert_object() ;
/*                                                                          */
/*  UIS$LINE (vd_id, atb,x1,y1[,x2,y2,...])                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Attribute block number                                   */
/*      x1.rf.r, y1.rf.r = x,y coordinates (F floating), repeated           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or disconnected lines                                    */
/*                                                                          */
int uis$line() ;
/*                                                                          */
/*  UIS$LINE_ARRAY (vd_id, atb, count,x_vector,y_vector)                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Attribute block number                                   */
/*	count.rl.r = Number of points                                       */
/*      x_vector.rf.ra = Address of array of x coordinates (F floating)     */
/*      y_vector.rf.ra = Address of array of y coordinates (F floating)     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or disconnected lines.                                   */
/*                                                                          */
int uis$line_array() ;
/*                                                                          */
/*  UIS$MEASURE_TEXT (vd_id, atb, text_string, retwidth,retheight           */
/*			[,ctllist, ctllen] [,posarray])                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = attribute block number number                            */
/*	text_string.rt.dx = Character string descriptor                     */
/*	ctllist.rlu.ra = control list array                                 */
/*	ctllen.rl.r = length of ctllist in longwords                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retwidth.wf.r, retheight.wf.r = Address to return width, height (F floating) */
/*	posarray.wf.ra = position array                                     */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the width and height of a text string in world coordinates     */
/*                                                                          */
int uis$measure_text() ;
/*                                                                          */
/*  UIS$MOVE_AREA (vd_id, x1,y1,x2,y2,new_x,new_y)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	x1.rf.r, y1.rf.r = X,Y position of one rectangle corner (F floating) */
/*	x2.rf.r, y2.rf.r = X,Y position of other corner (F floating)        */
/*	new_x.rf.r, new_y.rf.r = New X,Y origin for rectangle (F floating)  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Moves the region specified by the given rectangle to                */
/*      another place in the virtual display.                               */
/*                                                                          */
int uis$move_area() ;
/*                                                                          */
/*  UIS$MOVE_VIEWPORT (wd_id, attributes)                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	attributes.rl.ra = Display window attribute list                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Move a display viewport to another position on the physical display. */
/*                                                                          */
int uis$move_viewport() ;
/*                                                                          */
/*  UIS$MOVE_WINDOW (vd_id,wd_id,x1,y1,x2,y2)                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*	x1.rf.r, y1.rf.r = One corner of the window rectangle (F floating)  */
/*	x2.rf.r, y2.rf.r = Other corner of the window rectangle (F floating) */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Move a display window to another position in the virtual display.   */
/*                                                                          */
int uis$move_window() ;
/*                                                                          */
/*  UIS$NEW_TEXT_LINE (vd_id, atb)                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*  	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Attribute block number                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Format the current text line, and position to next text line        */
/*                                                                          */
int uis$new_text_line() ;
/*                                                                          */
/*  UIS$PLOT (vd_id, atb,x1,y1[,x2,y2,...])                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Attribute block number                                   */
/*      x1.rf.r, y1.rf.r = x,y coordinates (F floating), repeated           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or line(s)                                               */
/*                                                                          */
int uis$plot() ;
/*                                                                          */
/*  UIS$PLOT_ARRAY (vd_id, atb, count,x_vector,y_vector)                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*      atb.rl.r = Attribute block number                                   */
/*	count.rl.r = Number of points                                       */
/*      x_vector.rf.ra = Address of array of x coordinates (F floating)     */
/*      y_vector.rf.ra = Address of array of y coordinates (F floating)     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or line(s)                                               */
/*                                                                          */
int uis$plot_array() ;
/*                                                                          */
/*  UIS$POP_VIEWPORT (wd_id)                                                */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Pops the window to the top of the screen stacking order.            */
/*                                                                          */
int uis$pop_viewport() ;
/*                                                                          */
/*  UIS$PRESENT (major_version, minor_version, library_type)                */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/* 	major_version.wwu.r = major version number returned (optional)      */
/* 	minor_version.wwu.r = minor version number returned (optional)      */
/* 	library_type.wwu.r = UIS library type (native/UISX) returned (optional) */
/*      status.wlu.v = boolean value returned                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/* 	Returns true if UIS is installed on the system.                     */
/*                                                                          */
char uis$present() ;
/*                                                                          */
/*  UIS$PRIVATE (vd_id, facnum, buffer)                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = VD_ID or OBJ_ID                                      */
/*	facnum.rl.r = Address of facility number                            */
/*	buffer.dx.rx = Address of buffer descriptor.                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*   	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Write private data in buffer to last seg or otp.                    */
/*                                                                          */
int uis$private() ;
/*                                                                          */
/*  UIS$PUSH_VIEWPORT (wd_id)                                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Pushes the window to the bottom of the screen stacking order.       */
/*                                                                          */
int uis$push_viewport() ;
/*                                                                          */
/*  UIS$READ_CHAR (kb_id [,flags])                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*	flags.rlu.r = Flags longword                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	keybuf.wlu.v = Word key buffer (return value)                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Read a single character from the keyboard.                          */
/*                                                                          */
unsigned long int uis$read_char() ;
/*                                                                          */
/* UIS$RESIZE_WINDOW (vd_id, wd_id, [new_abs_x, new_abs_y,]                 */
/*		       [new_width, new_height,]                             */
/*		       [new_wc_x1, new_wc_y1, new_wc_x2, new_wc_y2])        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*    	new_abs_x.rf.r, new_abs_y.rf.r =  Exact X and Y of lower left       */
/*        	corner (in centimeters)                                     */
/*    	new_width.rf.r, new_height.rf.r = New width and height              */
/*    	new_wc_x1.rf.r, new_wc_y1.rf.r, new_wc_x2.rf.r, new_wc_y2.rf.r      */
/*    		= New world coordinates.                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*  	Change the size of the window.                                      */
/*                                                                          */
int uis$resize_window() ;
/*                                                                          */
/* uis$restore_cms_colors (cms_id): NOVALUE =                               */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	cms_id.rlu.r = Color map segment ID                                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Restore CMS colors to hardware                                      */
/*                                                                          */
int uis$restore_cms_colors() ;
/*                                                                          */
/*  UIS$SET_ADDOPT_AST (wd_id, astadr, astprm)                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.v = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable ASTs for additional options                                  */
/*                                                                          */
int uis$set_addopt_ast() ;
/*                                                                          */
/*  UIS$SET_ALIGNED_POSITION (vd_id, atb, x,y)                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Attribute block number                                   */
/*	x.rf.r, y.rf.r = X,Y position (F floating)                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Set the current text position, which is used when writing           */
/*    	text.  The position refers to the upper left corner of the          */
/*    	first character.                                                    */
/*                                                                          */
int uis$set_aligned_position() ;
/*                                                                          */
/*  UIS$SET_ARC_TYPE (vd_id, iatb, oatb, arc_type)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	arc_type.rl.r = Method to be used for closing arcs                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the default arc type.                                          */
/*                                                                          */
int uis$set_arc_type() ;
/*                                                                          */
/*  UIS$SET_BACKGROUND_INDEX (vd_id, iatb, oatb, index)                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	index.rl.r = Color map index                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the text and graphics background color index.                  */
/*                                                                          */
int uis$set_background_index() ;
/*                                                                          */
/*  UIS$SET_BUTTON_AST (vd_id, wd_id, [astadr, astprm,] [keybuf,]           */
/*			[x1,y1,x2,y2])                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*	x1.rf.r,y1.rf.r,x2.rf.r,y2.rf.r = Bounds of rectangle (F floating)  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	keybuf.wlu.r = Longword to receive button information               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Setup a region to intercept mouse button transitions                */
/*                                                                          */
int uis$set_button_ast() ;
/*                                                                          */
/*  UIS$SET_CHAR_ROTATION (vd_id, iatb, oatb, angle)                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	angle.rf.r = Character rotation angle                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the angle of the character relative to text path               */
/*                                                                          */
int uis$set_char_rotation() ;
/*                                                                          */
/*  UIS$SET_CHAR_SIZE (wd_id, iatb, oatb, char, width, height)              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display Window ID                                     */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	char.rt.dx = Character on which to base size                        */
/*	width.rf.r = Width of example character                             */
/*	height.rf.r = Height to make example character                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets an additional amount of text spacing.                          */
/*                                                                          */
int uis$set_char_size() ;
/*                                                                          */
/*  UIS$SET_CHAR_SLANT (vd_id, iatb, oatb, angle)                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Input attribute block number                            */
/*	angle.rf.r = Angle to set slant to                                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the slant of characters (to make italics)                      */
/*                                                                          */
int uis$set_char_slant() ;
/*                                                                          */
/*  UIS$SET_CHAR_SPACING (vd_id, iatb, oatb, dx,dy)                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	dx.rf.r = Additional X spacing factor (0 if none)                   */
/*	dy.rf.r = Additional Y spacing factor (0 if none)                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets an additional amount of text spacing.                          */
/*                                                                          */
int uis$set_char_spacing() ;
/*                                                                          */
/*  UIS$SET_CLIP (vd_id, iatb,oatb [,x1,y1,x2,y2])                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	x1.rf.r, y1.rf.r = X,Y position of lower left corner (F floating)   */
/*	x2.rf.r, y2.rf.r = X,Y position of upper right corner (F floating)  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets a user clipping rectangle.                                     */
/*                                                                          */
int uis$set_clip() ;
/*                                                                          */
/*  UIS$SET_CLOSE_AST (wd_id, astadr, astprm)                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable close notification ASTs                                      */
/*                                                                          */
int uis$set_close_ast() ;
/*                                                                          */
/*  UIS$SET_COLOR (vd_id, index, R, G, B)                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = Color map index                                        */
/*	R.rf.r = Red color value                                            */
/*	G.rf.r = Green color value                                          */
/*	B.rf.r = Blue color value                                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the RGB color values into a color map.                         */
/*                                                                          */
int uis$set_color() ;
/*                                                                          */
/*  UIS$SET_COLORS (vd_id, index, count, R_vector, G_vector, B_vector)      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rlu.r = First color map index                                 */
/*	count.rlu.r = Number of indices                                     */
/*	R_vector.rf.ra = Red color values                                   */
/*	G_vector.rf.ra = Green color values                                 */
/*	B_vector.rf.ra = Blue color values                                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets multiple RGB color values into a color map.                    */
/*                                                                          */
int uis$set_colors() ;
/*                                                                          */
/*  UIS$SET_EXPAND_ICON_AST (wd_id, [astadr,] [astprm])                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = (optional) Address of user AST routine              */
/*	astprm.rlu.r = (optional) User AST parameter                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable an AST which will be sent when the user requests, via the    */
/*    	viewport options menu, that the icon should be restored to a        */
/*    	viewport.  The application cannot disable the abiltiy to restore    */
/*    	viewports from icons; it may reinstate the default behavior by      */
/*    	specifying UIS$C_DEFAULT_EXPAND as the astadr.                      */
/*                                                                          */
/*                                                                          */
int uis$set_expand_icon_ast() ;
/*                                                                          */
/*  UIS$SET_FILL_PATTERN (vd_id, iatb,oatb, index)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	index.rl.r = Index of fill pattern                                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the fill pattern index.                                        */
/*                                                                          */
int uis$set_fill_pattern() ;
/*                                                                          */
/*  UIS$SET_FONT (vd_id, iatb, oatb, font_id)                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	font_id.rt.dx = Font ID string descriptor                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Associates a font with an attribute block.                          */
/*                                                                          */
int uis$set_font() ;
/*                                                                          */
/*  UIS$SET_GAIN_KB_AST (kb_id, astadr, astprm)                             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual display ID                                    */
/*	astadr.rzem.r = AST routine address for gaining kbd                 */
/*	astprm.rlu.r = AST parameter                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable gain keyboard notification ASTs                              */
/*                                                                          */
int uis$set_gain_kb_ast() ;
/*  UIS$SET_IMAGING_PARAMETERS (vd_id, iatb, oatb, thresholds, kernels)     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*      vd_id.rlu.r = Virtual display ID                                     */
/*      iatb.rl.r = Input attribute block number                            */
/*      oatb.rl.r = Output attribute block number                           */
/*      thresholds = (optional) Address of an array of 3 byte values        */
/*      kernels = (optional) Address of a byte array containing the kernels */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Sets current imaging parameters used in WRITE_IMAGE                   */
/*                                                                          */
int uis$set_imaging_parameters() ;
/*                                                                          */
/*  UIS$SET_INSERTION_POSITION (obj_id, flags)                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = Virtual display ID or object ID                      */
/*	flags.rlu.r = (optionsl) flags longword                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Set the current object position, which is used when writing         */
/*      new object in the display list.                                     */
/*                                                                          */
int uis$set_insertion_position() ;
/*                                                                          */
/*  UIS$SET_INTENSITIES (vd_id, index, count, I_vector)                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = First color map index                                  */
/*	count.rl.r = Number of indices                                      */
/*	I_vector.rf.ra = Achromatic intensity values                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Sets multiple achromatic intensity values into a color map.         */
/*                                                                          */
int uis$set_intensities() ;
/*                                                                          */
/*  UIS$SET_INTENSITY (vd_id, index, I)                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	index.rl.r = Color map index                                        */
/*	I.rf.r = Achromatic intensity value                                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the achromatic intensity value into a color map.               */
/*                                                                          */
int uis$set_intensity() ;
/*                                                                          */
/*  UIS$SET_KB_AST (kb_id, astadr, astprm, keybuf)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	keybuf.wlu.r = Longword to receive button information               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Specify single-character keyboard ASTs                              */
/*                                                                          */
int uis$set_kb_ast() ;
/*                                                                          */
/*  UIS$SET_KB_ATTRIBUTES (kb_id, [enable_items],                           */
/*			[disable_items], [click_volume])                    */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*	enable_items.rlu.r = Mask of characteristics to be enabled          */
/*	disable_items.rlu.r = Mask of characteristics to be disabled        */
/*	click_volume.rl.r = Click volume level                              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Modify keyboard characteristics.                                    */
/*                                                                          */
int uis$set_kb_attributes() ;
/*                                                                          */
/*	UIS$SET_KB_COMPOSE2(kb_id [,table,tablelen])                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Keyboard ID                                           */
/*	table.rl.ra,tablelen.rw.r = address of buffer and its length        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Load a 2-stroke compose table                                       */
/*                                                                          */
/*                                                                          */
int uis$set_kb_compose2() ;
/*                                                                          */
/*	UIS$SET_KB_COMPOSE3(kb_id [,table,tablelen])                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Keyboard ID                                           */
/*	table.rl.ra,tablelen.rw.r = address of buffer and its length        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Load a 3-stroke compose table                                       */
/*                                                                          */
int uis$set_kb_compose3() ;
/*                                                                          */
/*	UIS$SET_KB_KEYTABLE(kb_id [,table,tablelen])                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rl.r = Keyboard ID                                            */
/*	table.rl.ra,tablelen.rw.r = address of buffer and its length        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Load a keyboard mapping table                                       */
/*                                                                          */
/*                                                                          */
int uis$set_kb_keytable() ;
/*                                                                          */
/*  UIS$SET_LEFT_MARGIN (vd_id, iatb, oatb, x)                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	x.rf.r =  Position of left margin                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Sets the left margin for writing text.                              */
/*                                                                          */
int uis$set_left_margin() ;
/*                                                                          */
/*  UIS$SET_LINE_STYLE (vd_id, iatb, oatb, style)                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r  = Input attribute block number                           */
/*	oatb.rl.r = Output attribute block number                           */
/*	style.rl.r = 32-bit bitvector whose bits control drawing            */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the default line style                                         */
/*                                                                          */
int uis$set_line_style() ;
/*                                                                          */
/*  UIS$SET_LINE_WIDTH (vd_id, iatb, oatb, width [,mode])                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	width.rf.r = Width of lines (1.0 is normal)                         */
/*	mode.rl.r = Pixel/world coordinate indicator                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the default line width                                         */
/*                                                                          */
int uis$set_line_width() ;
/*                                                                          */
/*  UIS$SET_LOSE_KB_AST (kb_id [,astadr, astprm])                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual display ID                                    */
/*	astadr.rzem.r = AST routine address for losting kbd                 */
/*	astprm.rlu.r = AST parameter                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable lost keyboard notification ASTs                              */
/*                                                                          */
int uis$set_lose_kb_ast() ;
/*                                                                          */
/*  UIS$SET_MOVE_INFO_AST (wd_id, [astadr, astprm])                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Enable move notification ASTs                                       */
/*                                                                          */
int uis$set_move_info_ast() ;
/*                                                                          */
/*  UIS$SET_PLANE_MASK (vd_id, iatb, oatb, plane_mask)                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rul.r = Virtual display ID                                    */
/* 	iatb.rl.r = Input attribute block number                            */
/* 	oatb.rl.r = Output attribute block number                           */
/*	plane_mask.rlu.r = mask of the planes to be written to              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Specify the planes to be wirtten to.                                */
/*  	                                                                    */
int uis$set_plane_mask() ;
/*                                                                          */
/*  UIS$SET_POINTER_AST (vd_id, wd_id, [astadr], [astprm],                  */
/*			[x1,y1,x2,y2],                                      */
/*			[exitastadr], [exitastprm])                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*	x1.rf.r,y1.rf.r,x2.rf.r,y2.rf.r = Bounds of rectangle (F floating)  */
/*	exitastadr.rzem.r = Exit AST address                                */
/*	exitastprm.rlu.r = Exit AST parameter                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Setup a region to intercept mouse movement                          */
/*                                                                          */
int uis$set_pointer_ast() ;
/*                                                                          */
/*  UIS$SET_POINTER_PATTERN (vd_id, wd_id, [pattern1, nullarg,              */
/*			activex, activey,]                                  */
/*			[x1,y1,x2,y2], [flags])                             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*	pattern_array.rwu.ra = 16x16 pixel bitmap describing the cursor pattern */
/*	pattern_count.rlu.r = number of patterns                            */
/*	activex,activey.rl.r = Offset from upper left of mouse to hot spot  */
/*	x1.rf.r,y1.rf.r,x2.rf.r,y2.rf.r = Bounds of rectangle (F floating)  */
/*	flags.rlu.r = bit 0 set means bind cursor to rectangle              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Setup a cursor pattern region.                                      */
/*                                                                          */
int uis$set_pointer_pattern() ;
/*                                                                          */
/*  UIS$SET_POINTER_POSITION (vd_id, wd_id, x, y)                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/* 	wd_id.rlu.r = Display window ID                                     */
/*	x.rf.r = New X coordinate                                           */
/*	y.rf.r = New Y coordinate                                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*    	status.wl.v = Returns true/false if position is set.                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*  	Specifies a new current pointer position in world                   */
/*    	coordinates.  It is only effective if the specified                 */
/*    	position is visible.                                                */
/*                                                                          */
/*                                                                          */
char uis$set_pointer_position() ;
/*                                                                          */
/*  UIS$SET_POSITION (vd_id, x,y)                                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	x.rf.r, y.rf.r = X,Y position (F floating)                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Set the current text position, which is used when writing           */
/*      text.   The position refers to the alignment point (baseline)       */
/*      of the first character.                                             */
/*                                                                          */
int uis$set_position() ;
/*                                                                          */
/* UIS$SET_RESIZE_AST (vd_id, wd_id, [astadr,] [astprm], [new_abs_x,        */
/*		       new_abs_y,] [new_width, new_height,] [new_wc_x1,     */
/*		       new_wc_y1, new_wc_x2, new_wc_y2])                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = Address of user AST routine                         */
/*	astprm.rlu.r = User AST parameter                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*    	new_abs_x.wf.r, new_abs_y.wf.r =  Exact X and Y of lower left       */
/*        	corner (in centimeters)                                     */
/*    	new_width.wf.r, new_height.wf.r = New width and height              */
/*    	new_wc_x1.wf.r, new_wc_y1.wf.r, new_wc_x2.wf.r, new_wc_y2.wf.r      */
/*    		= New world coordinates.                                    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*  	Enable or disable a resize AST.                                     */
/*                                                                          */
int uis$set_resize_ast() ;
/*                                                                          */
/*  UIS$RGB_to_HLS (R, G, B, H, L, S)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*      r.rf.r = RED value                                                  */
/*	g.rf.r = GREEN value                                                */
/*	b.rf.r = BLUE value                                                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*  	reth.wf.r = Hue of a color                                          */
/*	retl.wf.r = Lightness of a color                                    */
/*	rets.wf.r = Saturation of a color                                   */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Convert RGB color to HLS color                                      */
/*                                                                          */
int uis$rgb_to_hls() ;
/*                                                                          */
/*  UIS$RGB_to_HSV (R, G, B, H, S, V)                                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*      r.rf.r = RED value                                                  */
/*	g.rf.r = GREEN value                                                */
/*	b.rf.r = BLUE value                                                 */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*  	reth.wf.r = Hue of a color                                          */
/*	retl.wf.r = Lightness of a color                                    */
/*	rets.wf.r = Saturation of a color                                   */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Convert RGB color to HSV color                                      */
/*                                                                          */
int uis$rgb_to_hsv() ;
/*                                                                          */
/*  UIS$SET_SHRINK_TO_ICON_AST (wd_id, [astadr,] [astprm])                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = (optional) Address of user AST routine              */
/*	astprm.rlu.r = (optional) User AST parameter                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Enable an AST which will be sent when the user requests, via the    */
/*      viewport options menu, that the viewport should be shrunk to a      */
/*      icon.  The application can disable the abiltiy to shrink a          */
/*      viewport by specifying only the wd_id argument or specifying        */
/*      0 as the ASTADR.  It may reinstate the default behavior by          */
/*      specifying UIS$C_DEFAULT_SHRINK_TO_ICON as the astadr.              */
/*                                                                          */
/*                                                                          */
int uis$set_shrink_to_icon_ast() ;
/*                                                                          */
/* UIS$SET_TB_AST (tb_id [,data_astadr] [,data_astprm]                      */
/*			  [,x_pos][,y_pos]                                  */
/*			  [,data_x1][,data_y1][,data_x2][,data_y2]          */
/*			  [,button_astadr] [,button_astprm]                 */
/*			  [,button_keybuf])                                 */
/* 	                                                                    */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	tb_id.rlu.r = Tablet identifier                                     */
/* 	data_astadr.rzem.r = AST routine for digitizer                      */
/*	data_astprm.rlu.r = AST parameter                                   */
/* 	data_x1.rf.r,data_y1.rf.r = Lower left corner of the data or        */
/*				    digitizer region on tablet              */
/*	data_x2.rf.r,data_y2.rf.r = Upper right corner                      */
/* 	button_astadr.rzem.r = AST routine use when a button is pressed     */
/*	button_astprm.rlu.r = AST parameter.                                */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/* 	x_pos.wf.r,y_pos.wf.r = Absolute device coordinate pair.            */
/* 	button_keybuf.wlu.r =  Button information address.                  */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/* 	Enable/disable data digitizing ASTs                                 */
/*                                                                          */
int uis$set_tb_ast() ;
/*                                                                          */
/* uis$set_text_formatting (vd_id, iatb, oatb, mode)                        */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	vd_id.rlu.r = Virtual Display ID                                    */
/* 	iatb.rl.r = Input attribute block number                            */
/* 	oatb.rl.r = Output attribute block number                           */
/* 	mode.rl.r = Formatting mode                                         */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*     	Set formatting mode (normal, justify, center)                       */
/*                                                                          */
int uis$set_text_formatting() ;
/*                                                                          */
/* uis$set_text_margins (vd_id, iatb, oatb, x, y, margin_length)            */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	vd_id.rlu.r = Virtual Display ID                                    */
/* 	iatb.rl.r = Input attribute block number                            */
/* 	oatb.rl.r = Output attribute block number                           */
/* 	x.rf.r,y.rf.r = X and Y coordinate of starting position             */
/*	margin_length.rf.r = Distance along text line to ending margin      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*     	Set text margins to use for text formatting.                        */
/*                                                                          */
int uis$set_text_margins() ;
/*                                                                          */
/*  UIS$SET_TEXT_PATH (vd_id, iatb, oatb, major, minor)                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	major.rl.r = Major text path                                        */
/*	minor.rl.r = Minor text path (optional)                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the text paths.                                                */
/*                                                                          */
int uis$set_text_path() ;
/*                                                                          */
/*  UIS$SET_TEXT_SLOPE (vd_id, iatb, oatb, angle)                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	angle.rf.r = Current text slope angle                               */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Input attribute block number                            */
/*	angle.rf.r = Angle to set slant to                                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the slope of text lines                                        */
/*                                                                          */
int uis$set_text_slope() ;
/*                                                                          */
/*  UIS$SET_VP_TITLE (wd_id, text_string)                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Window display ID                                     */
/*	text_string.rt.dx = Banner title to be made                         */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Places a string of up to 63 characters in the window banner         */
/*	and redraws the border                                              */
/*                                                                          */
int uis$set_vp_title() ;
/*                                                                          */
/*  UIS$SET_WRITING_INDEX (vd_id, iatb, oatb, index)                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	index.rl.r = Color map index                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the text and graphics writing color index.                     */
/*                                                                          */
int uis$set_writing_index() ;
/*                                                                          */
/*  UIS$SET_WRITING_MODE (vd_id, iatb, oatb, mode)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	mode.rl.r = Number of the mode                                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the text and graphics writing mode.                            */
/*                                                                          */
int uis$set_writing_mode() ;
/*                                                                          */
/*  UIS$SETUP                                                               */
/*                                                                          */
/*    Create the Workstation Options Menu.                                  */
/*                                                                          */
/*      Inputs : None                                                       */
/*                                                                          */
/*      Outputs : None                                                      */
/*                                                                          */
int uis$setup() ;
/*                                                                          */
/* UIS$SHRINK_TO_ICON (wd_id, [icon_wd_id,] [ icon_flags,]                  */
/*				[icon_name,] [attributes])                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID for shrunk viewport.                */
/*	icon_wd_id.rlu.r = (optional) Display window ID for icon.           */
/* 	icon_flags.rlu.r = (optional) Flags to indicate if UIS should       */
/*		handle the viewport's keyboard or the icon's body.          */
/* 	icon_name.rt.dx = (optional) Text to be used as icon name.          */
/*    	attributes.rlu.ra, icon_abs_y.rf.r =  (optional) Window             */
/*        	attribute list for icon.                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*  	If a wd_id for an icon is passed to uis$shrink_to_icon then the wdb */
/*  	for the icon and viewport are modified so that they point to each   */
/*  	other and the icon bit is set in the icon's wdb. Otherwise, (If no  */
/*  	icon wd_id was given) the desired viewport is moved off the         */
/* 	physical display and an icon window is created to represent the     */
/*  	viewport.                                                           */
/*                                                                          */
int uis$shrink_to_icon() ;
/*                                                                          */
/*  UIS$SOUND_BELL (devnam, [bell_volume])                                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	devnam.rt.dx = Device name descriptor                               */
/*	bell_volume.rl.r = Bell volume level (optional)                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sound keyboard bell.                                                */
/*                                                                          */
int uis$sound_bell() ;
/*                                                                          */
/*  UIS$SOUND_CLICK (kb_id, [click_volume])                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	devnam.rt.dx = Device name descriptor                               */
/*	click_volume.rl.r = Click volume level (optional)                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Sound key click.                                                    */
/*                                                                          */
int uis$sound_click() ;
/*                                                                          */
/*  UIS$TEST_KB (kb_id)                                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	kb_id.rlu.r = Virtual keyboard ID                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      status.wl.v = Returned status                                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Test if a virtual keyboard is active.                               */
/*                                                                          */
char uis$test_kb() ;
/*                                                                          */
/*  UIS$TEXT (vd_id, atb, text_string [,x,y] [,ctllist,ctllen])             */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	atb.rl.r = Attribute block number                                   */
/*	text_string.rt.dx = Text string descriptor                          */
/*	x.rf.r, y.rf.r = Optional X,Y starting position (F floating)        */
/*	ctllist.rl.ra = control list array                                  */
/*	ctllen.rl.r = control list length in longwords                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Write text to display                                               */
/*                                                                          */
int uis$text() ;
/*                                                                          */
/*  UIS$TRANSFORM_OBJECT (obj_id, matrix, ia)                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	obj_id.rlu.r = SEG or OTP ID                                        */
/*	matrix.rf.ra = Address of matrix                                    */
/*	atb.rl.r = Input attribute block value                              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Translate, scale and rotate object.                                 */
/*                                                                          */
int uis$transform_object() ;
/*                                                                           */
/*  UIS$WRITE_IMAGE (vd_id, atb,x1,y1,x2,y2,                                 */
/*              rasterwidth,rasterheight,bitsperpixel,                       */
/*              bufferaddr [,rotation] [,encoding,length])                   */
/*                                                                           */
/*  INPUTS:                                                                 */
/*                                                                           */
/*      vd_id.rlu.r = Virtual display ID                                      */
/*      atb.rl.r = Attribute block number                                    */
/*      x1.rf.r, y1.rf.r = X,Y position of one rectangle corner (F floating) */
/*      x2.rf.r, y2.rf.r = X,Y position of other corner (F floating)         */
/*      rasterwidth.rl.r = Width of image bitmap in pixels                   */
/*      rasterheight.rl.r = Height of image bitmap in pixels                 */
/*      bitsperpixel.rl.r = Number of image bits which make up 1 "pixel"     */
/*      bufferaddr.ra.v = Address of image data in bitmap                    */
/*      rotation.rl.r = (optional) rotation in degrees                       */
/*      encoding.rb.r = (optional) CCITT encoding info                       */
/*      length.rl.r = length of buffer in bytes                              */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    Write a natural image bitmap into the specified virtual                */
/*    display rectangle given by the two corners.  If the size               */
/*    of the bitmap doesn't match the rectangle, scaling is done.            */
/*                                                                          */
int uis$write_image() ;
/*                                                                          */
/*  UISDC$ALLOCATE_DOP(WD_ID,SIZE,ATB)                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	size.ml.r = Size of variable portion of drawing operation           */
/*	atb.rl.r = Atribute block number                                    */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	dop.rlu.v = Returned DOP value                                      */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Allocate a DOP driver drawing packet                                */
/*                                                                          */
int *uisdc$allocate_dop() ;
/*                                                                          */
/*  UISDC$CIRCLE (wd_id, atb,center_x,center_y,xradius,                     */
/*			[start_deg],[end_deg])                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*      atb.rl.r = Attribute block number                                   */
/*      center_x.rl.r, center_y.rl.r = Center x,y coordinates               */
/*	xradius.rl.r = Radius of the circle (x axis)                        */
/*	start_deg.rf.r = Degree at which arc starts (F floating, optional)  */
/*	end_deg.rf.r = Degree at which arc ends (F floating, optional)      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Draw the arc of a circle.                                           */
/*                                                                          */
int uisdc$circle() ;
/*                                                                          */
/*  UISDC$ELLIPSE (wd_id, atb,center_x,center_y,xradius,yradius,            */
/*				[start_deg],[end_deg])                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*      atb.rl.r = Attribute block number                                   */
/*      center_x.rl.r, center_y.rl.r = Center x,y coordinates               */
/*	xradius.rl.r = Major axis radius of the ellipse                     */
/*	yradius.rl.r = Minor axis radius of the ellipse                     */
/*	start_deg.rf.r = Degree at which arc starts (F floating, optional)  */
/*	end_deg.rf.r = Degree at which arc ends (F floating, optional)      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Draw the arc of an ellipse.                                         */
/*                                                                          */
int uisdc$ellipse() ;
/*                                                                          */
/*  UISDC$ERASE (wd_id, [x1,y1,x2,y2])                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	x1.rl.r, y1.rl.r = X,Y position of one rectangle corner             */
/*	x2.rl.r, y2.rl.r = X,Y position of other corner                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Erases the region specified by the given rectangle.                 */
/*                                                                          */
int uisdc$erase() ;
/*                                                                          */
/*  UISDC$EXECUTE_DOP_ASYNCH(WD_ID,DOP,IOSB)                                */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID.                                    */
/*	dop.rbu.ra = array of bytes containing DOP                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	iosb.wqu.r = I/O status block                                       */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Insert a DOP on the drawing queue of a window                       */
/*                                                                          */
int uisdc$execute_dop_asynch() ;
/*                                                                          */
/*  UISDC$EXECUTE_DOP_SYNCH(WD_ID,DOP)                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID.                                    */
/*	dop.rbu.ra = array of bytes containing DOP                          */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*  	Insert a DOP on the drawing queue of a window                       */
/*	and wait for completion.                                            */
/*                                                                          */
int uisdc$execute_dop_synch() ;
/*                                                                          */
/*  UISDC$GET_ALIGNED_POSITION (wd_id, atb, retx,rety)                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Attribute block number number                            */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wl.r, rety.wl.r = Address to return X,Y position               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the current "alignment" text position.                         */
/*                                                                          */
int uisdc$get_aligned_position() ;
/*                                                                          */
/*  UISDC$GET_CHAR_SIZE (wd_id, iatb, char, width, height)                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	char.wt.dx = Character on which to base size                        */
/*	width.wl.r = Width of example character                             */
/*	height.wl.r = Height to make example character                      */
/*	boolean.wlu.v = Indicates status of char. scaling                   */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets an additional amount of text spacing.                          */
/*                                                                          */
char uisdc$get_char_size() ;
/*  UISDC$GET_CLIP (wd_id, atb [,x1, y1, x2, y2])                           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	x1.wl.r, y1.wl.r = X,Y position of lower left corner                */
/*	x2.wl.r, y2.wl.r = X,Y position of upper right corner               */
/*	boolean.wlu.v = If clipping enabled then TRUE is returned           */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets a user clipping rectangle.                                     */
/*                                                                          */
char uisdc$get_clip() ;
/*  UISDC$GET_LEFT_MARGIN (wd_id, atb)                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	x.wl.v = X coordinate of left margin (return value)                 */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the left margin for writing text.                              */
/*                                                                          */
long int uisdc$get_left_margin() ;
/*                                                                          */
/*  UISDC$GET_POINTER_POSITION (wd_id, retx, rety)                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wl.r, rety.wl.r = Address to return X,Y pixel coordinates      */
/*  	status.wl.v = Returns true/false if mouse is within the window      */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the current mouse position in viewport relative pixel          */
/*      coordinates.                                                        */
/*                                                                          */
char uisdc$get_pointer_position() ;
/*                                                                          */
/*  UISDC$GET_POSITION (wd_id, retx,rety)                                   */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retx.wl.r, rety.wl.r = Address to return X,Y position               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Gets the current baseline text position.                            */
/*                                                                          */
int uisdc$get_position() ;
/*                                                                          */
/* uisdc$get_text_margins (wd_id, atb, x, y, margin_length)                 */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	wd_id.rlu.r = Window ID                                             */
/* 	atb.rl.r = Input attribute block number                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/* 	x,y.wl.r = (optional) X and Y coordinate of starting position       */
/*	margin_length.wl.r = (optional) Distance to ending margin           */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Get text margins used for text formatting.                          */
/*                                                                          */
int uisdc$get_text_margins() ;
/*                                                                          */
/*  UISDC$GET_VISIBILITY(wd_id, [,x1, y1 [,x2 ,y2])                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	x1.rl.r,y1.rl.r = World coordinates of one corner                   */
/*	x2.rl.r,y2.rl.r = World coordinates of other corner                 */
/*	                                                                    */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	boolean.wlu.v = Returns true/false visibility status                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Returns whether the specified rectangle in the display              */
/*    	window is completely visible or not.                                */
/*                                                                          */
char uisdc$get_visibility() ;
/*                                                                          */
/*  UISDC$IMAGE (wd_id, atb,x1,y1,x2,y2,                                    */
/*		rasterwidth,rasterheight,bitsperpixel,                      */
/*		rasteraddr)                                                 */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Attribute block number                                   */
/*	x1.rl.r, y1.rl.r = X,Y position of one rectangle corner             */
/*	x2.rl.r, y2.rl.r = X,Y position of other corner                     */
/*	rasterwidth.rl.r = Width of image bitmap in pixels                  */
/*	rasterheight.rl.r = Height of image bitmap in pixels                */
/*	bitsperpixel.rl.r = Number of image bits which make up 1 "pixel"    */
/*     	rasteraddr.rlu.ra = Address of natural image data                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*     	Write a natural image bitmap into the specified virtual             */
/*      display rectangle given by the two corners.  If the size            */
/*      of the bitmap doesn't match the rectangle, scaling is done.         */
/*                                                                          */
int uisdc$image() ;
/*                                                                          */
/*  UISDC$LINE (wd_id, atb,x1,y1[,x2,y2,...])                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*      atb.rl.r = Attribute block number                                   */
/*      x1.rl.r, y1.rl.r = x,y coordinates, repeated                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Plot point or disconnected lines                                    */
/*                                                                          */
int uisdc$line() ;
/*                                                                          */
/*  UISDC$LINE_ARRAY (wd_id, atb, count,x_vector,y_vector)                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*      atb.rl.r = Attribute block number                                   */
/*	count.rl.r = Number of points                                       */
/*      x_vector.rf.ra = Address of array of x coordinates                  */
/*      y_vector.rf.ra = Address of array of y coordinates                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or disconnected lines                                    */
/*                                                                          */
int uisdc$line_array() ;
/*                                                                          */
/*  UISDC$LOAD_BITMAP(WD_ID,BITMAP_ADR,BITMAP_LEN,BITMAP_WIDTH,BITS_PER_PIXEL) */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	bitmap_adr.r.ra = Bitmap address                                    */
/*	bitmap_len.rl.r = Bitmap length                                     */
/*	bitmap_width.rl.r = Width of bitmap                                 */
/*	bits_per_pixel.rl.r = Address of # that defines # bit/pixel         */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	bitmap_id.wlu.v = Bitmap identifier.                                */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Load a bitmap into offscreen memory for use as a fill pattern,      */
/*	line style, image, or font.                                         */
/*                                                                          */
unsigned long int uisdc$load_bitmap() ;
/*                                                                          */
/*  UISDC$MEASURE_TEXT (wd_id, atb, text_string, retwidth,retheight         */
/*			[,ctllist, ctllen] [,posarray])                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = attribute block number number                            */
/*	text_string.rt.dx = Character string descriptor                     */
/*	ctllist.rlu.ra = control list array                                 */
/*	ctllen.rl.r = length of ctllist in longwords                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	retwidth.wl.r, retheight.wl.r = Address to return width,height      */
/*	posarray.wl.ra = position array                                     */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Gets the width and height of a text string in pixels                */
/*                                                                          */
int uisdc$measure_text() ;
/*                                                                          */
/*  UISDC$MOVE_AREA (wd_id, x1,y1,x2,y2,new_x,new_y)                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	x1.rl.r, y1.rl.r = X,Y position of one rectangle corner             */
/*	x2.rl.r, y2.rl.r = X,Y position of other corner                     */
/*	new_x.rl.r, new_y.rl.r = New X,Y origin for rectangle               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Moves the region specified by the given rectangle to                */
/*    	another place in the display window.                                */
/*                                                                          */
int uisdc$move_area() ;
/*                                                                          */
/*  UISDC$NEW_TEXT_LINE (wd_id, atb)                                        */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Attribute block number                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Format the current text line, and position to next text line        */
/*                                                                          */
int uisdc$new_text_line() ;
/*                                                                          */
/*  UISDC$PLOT (wd_id, atb,x1,y1[,x2,y2,...])                               */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*      atb.rl.r = Attribute block number                                   */
/*      x1.rl.r, y1.rl.r = x,y coordinates, repeated                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or line(s)                                               */
/*                                                                          */
int uisdc$plot() ;
/*                                                                          */
/*  UISDC$PLOT_ARRAY (wd_id, atb, count,x_vector,y_vector)                  */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*      atb.rl.r = Attribute block number                                   */
/*	count.rl.r = Number of points                                       */
/*      x_vector.rf.ra = Address of array of x coordinates                  */
/*      y_vector.rf.ra = Address of array of y coordinates                  */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Plot point or line(s)                                               */
/*                                                                          */
int uisdc$plot_array() ;
/*                                                                          */
/*  UISDC$QUEUE_DOP(WD_ID,DOP)                                              */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	dop.rbu.ra = Address of array of bytes that contain DOP's           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*	Insert a DOP on the drawing queue of a window                       */
/*                                                                          */
int uisdc$queue_dop() ;
/*                                                                          */
/*  UISDC$READ_IMAGE (wd_id,x1,y1,x2,y2,                                    */
/*		rasterwidth,rasterheight,bitsperpixel,                      */
/*		rasteraddr,buffer_size)                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	x1.rl.r, y1.rl.r = X,Y position of one rectangle corner             */
/*	x2.rl.r, y2.rl.r = X,Y position of other corner                     */
/*	rasteraddr.wbu.ra = Image buffer                                    */
/*	buffer_size.rl.r = Size of image buffer                             */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	rasterwidth.wl.r = Width of image bitmap in pixels                  */
/*	rasterheight.wl.r = Height of image bitmap in pixels                */
/*	bitsperpixel.wl.r = Number of image bits which make up 1 "pixel"    */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Reads an image bitmap into the specified device coordinate          */
/*      rectangle given by the two corners.                                 */
/*                                                                          */
int uisdc$read_image() ;
/*                                                                          */
/*  UISDC$SET_ALIGNED_POSITION (wd_id, atb, x,y)                            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Attribute block number                                   */
/*	x.rl.r, y.rl.r = X,Y position                                       */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Set the current text position, which is used when writing           */
/*      text.  The position refers to the upper left corner of the          */
/*      first character.                                                    */
/*                                                                          */
int uisdc$set_aligned_position() ;
/*                                                                          */
/*  UISDC$SET_BUTTON_AST (wd_id, [astadr, astprm] [,keybuf]                 */
/*			[,x1,y1,x2,y2])                                     */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*	x1.rl.r,y1.rl.r,x2.rl.r,y2.rl.r = Bounds of rectangle               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	keybuf.wlu.r = Longword to receive button information               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Setup a region to intercept mouse button transitions                */
/*                                                                          */
int uisdc$set_button_ast() ;
/*                                                                          */
/*  UISDC$SET_CHAR_SIZE (vd_id, iatb, oatb, char, width, height)            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	vd_id.rlu.r = Virtual display ID                                    */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	char.rt.dx = Character on which to base size                        */
/*	width.rl.r = Width of example character                             */
/*	height.rl.r = Height to make example character                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets an additional amount of text spacing.                          */
/*                                                                          */
int uisdc$set_char_size() ;
/*                                                                          */
/*  UISDC$SET_CLIP (wd_id, iatb, oatb [,x1,y1,x2,y2])                       */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	x1.rl.r, y1.rl.r = X,Y position of lower left corner                */
/*	x2.rl.r, y2.rl.r = X,Y position of upper right corner               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Sets a user clipping rectangle.                                     */
/*                                                                          */
int uisdc$set_clip() ;
/*                                                                          */
/*  UISDC$SET_LEFT_MARGIN (wd_id, iatb, oatb, x)                            */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	iatb.rl.r = Input attribute block number                            */
/*	oatb.rl.r = Output attribute block number                           */
/*	x.rl.r =  Position of left margin                                   */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Sets the left margin for writing text.                              */
/*                                                                          */
int uisdc$set_left_margin() ;
/*                                                                          */
/*  UISDC$SET_POINTER_AST (wd_id, [astadr], [astprm],                       */
/*			[x1,y1,x2,y2],                                      */
/*			[exitastadr], [exitastprm])                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	astadr.rzem.r = AST routine address                                 */
/*	astprm.rlu.r = AST parameter                                        */
/*	x1.rl.r,y1.rl.r,x2.rl.r,y2.rl.r = Bounds of rectangle               */
/*	exitastadr.rzem.r = Exit AST address                                */
/*	exitastprm.rlu.r = Exit AST parameter                               */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Setup a region to intercept mouse movement                          */
/*                                                                          */
int uisdc$set_pointer_ast() ;
/*                                                                          */
/*  UISDC$SET_POINTER_PATTERN (wd_id, [pattern1, nullarg, activex, activey,] */
/*			[x1,y1,x2,y2])                                      */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	pattern1.rwu.ra = 16x16 pixel bitmap describing the cursor pattern  */
/*	nullarg. = reserved to Digital                                      */
/*	activex,activey.rl.r = Offset from upper left of mouse to hot spot  */
/*	x1.rl.r,y1.rl.r,x2.rl.r,y2.rl.r = Bounds of rectangle (integer)     */
/*	flags.rlu.r = Flags longword                                        */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Setup a cursor pattern region.                                      */
/*                                                                          */
int uisdc$set_pointer_pattern() ;
/*                                                                          */
/*  UISDC$SET_POINTER_POSITION (wd_id, x, y)                                */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	wd_id.rlu.r = Display window ID                                     */
/*	x.rl.r = New X coordinate                                           */
/*	y.rl.r = New Y coordinate                                           */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*      boolean.wlu.v = Returns true/false if position is set.              */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Specifies a new current pointer position in pixel                   */
/*      coordinates.  It is only effective if the specified                 */
/*      position is visible.                                                */
/*                                                                          */
char uisdc$set_pointer_position() ;
/*                                                                          */
/*  UISDC$SET_POSITION (wd_id, x,y)                                         */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	x.rl.r, y.rl.r = X,Y position                                       */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*    	Set the current text position, which is used when writing           */
/*    	text.   The position refers to the alignment point (baseline)       */
/*    	of the first character.                                             */
/*                                                                          */
int uisdc$set_position() ;
/*                                                                          */
/* uisdc$set_text_margins (wd_id, iatb, oatb, x, y, margin_length)          */
/*                                                                          */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/* 	wd_id.rlu.r = Window  Display ID                                    */
/* 	iatb.rl.r = Input attribute block number                            */
/* 	oatb.rl.r = Output attribute block number                           */
/* 	x,y.rl.r = X and Y coordinate of starting position                  */
/*	margin_length.rl.r = Distance along text line to ending margin      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Set text margins to use for text formatting.                        */
/*                                                                          */
/* Inputs:                                                                  */
/*                                                                          */
int uisdc$set_text_margins() ;
/*                                                                          */
/*  UISDC$TEXT (wd_id, atb, text_string [,x,y] [,ctllist,ctllen])           */
/*                                                                          */
/*  INPUTS:                                                                 */
/*                                                                          */
/*	wd_id.rlu.r = Display window ID                                     */
/*	atb.rl.r = Attribute block number                                   */
/*	text_string.rt.dx = Text string descriptor                          */
/*	x.rl.r, y.rl.r = Optional X,Y starting position                     */
/*	ctllist.r.ra = control list array                                   */
/*	ctllen.rl.r = control list length in longwords                      */
/*                                                                          */
/*  OUTPUTS:                                                                */
/*                                                                          */
/*	none.                                                               */
/*                                                                          */
/*  DESCRIPTION:                                                            */
/*                                                                          */
/*      Write text to display                                               */
/*                                                                          */
int uisdc$text() ;
/********************************************************************************************************************************/
/* Created  6-NOV-1992 13:31:56 by VAX SDL V3.2-12     Source:  6-NOV-1992 13:31:52 VWSRESD$:[UIS.OBJ]UISMSG.SDL;2 */
/********************************************************************************************************************************/
 
/*** MODULE $UISDEF ***/
#define UIS$_FACILITY 412
#define UIS$_BAD_VD 27033612
#define UIS$_NODEV 27033620
#define UIS$_INSFARG 27033628
#define UIS$_BAD_OPCODE 27033636
#define UIS$_BAD_ATB 27033640
#define UIS$_NO_FONT 27033650
#define UIS$_BAD_FONT 27033658
#define UIS$_UNSUP_FONT 27033666
#define UIS$_NODEFFONT 27033674
#define UIS$_VAFONTERR 27033682
#define UIS$_NOTVAFONT 27033690
#define UIS$_BAD_DISP 27033700
#define UIS$_TOODEEP 27033708
#define UIS$_BAD_WD 27033716
#define UIS$_NOURG 27033720
#define UIS$_BADTITLE 27033732
#define UIS$_BADWDPL 27033740
#define UIS$_VPTOOSMALL 27033748
#define UIS$_BAD_TR 27033756
#define UIS$_BAD_VOLUME 27033762
#define UIS$_BAD_OBJ_ID 27033772
#define UIS$_BAD_KB 27033780
#define UIS$_NO_KB 27033788
#define UIS$_FONT_TOO_BIG 27033796
#define UIS$_BAD_ICON_WD 27033800
#define UIS$_SHRINK_ICON 27033808
#define UIS$_NO_END 27033816
#define UIS$_IN_SEG 27033826
#define UIS$_NO_INSERT 27033832
#define UIS$_BUF_FULL 27033842
#define UIS$_NO_DEL 27033848
#define UIS$_BAD_TEXT_ITEM 27033858
#define UIS$_BAD_DOP 27033868
#define UIS$_BAD_VER 27033876
#define UIS$_BAD_VCM 27033884
#define UIS$_BAD_CMS 27033892
#define UIS$_BAD_VCM_SIZE 27033900
#define UIS$_BAD_VCM_INDEX 27033908
#define UIS$_BAD_VCM_NAME 27033916
#define UIS$_BAD_VCM_ATTR 27033924
#define UIS$_VCM_EXISTS 27033930
#define UIS$_VCM_ACTIVE 27033938
#define UIS$_CMS_ACTIVE 27033946
#define UIS$_VCM_BOUND 27033954
#define UIS$_CMS_CREATE_ERR 27033964
#define UIS$_BAD_COLOR_VALUE 27033970
#define UIS$_VCM_NOTBOUND 27033978
#define UIS$_BAD_TB 27033988
#define UIS$_NO_TABLET 27033996
#define UIS$_DIGIT_ACTIVE 27034004
#define UIS$_BAD_STRING 27034008
#define UIS$_FONT_TOO_SMALL 27034018
#define UIS$_FONT_EXISTS 27034026
#define UIS$_NOT_USER_FONT 27034034
#define UIS$_KERN_NOT_ALLOW 27034042
#define UIS$_FONT_NOT_FOUND 27034050
#define UIS$_UN_SUPPORT 27034060
#define UIS$_FNT_BANNER 27034065
#define UIS$_FNT_CHOICE 27034073
#define UIS$_FNT_TEXT 27034081
#define UIS$_FNT_ICON 27034089
#define UIS$_WO_EXIT 27034097
#define UIS$_WO_PUSH 27034105
#define UIS$_WO_POP 27034113
#define UIS$_WO_RESIZE 27034121
#define UIS$_WO_SHRINK 27034129
#define UIS$_WO_CLOSE 27034137
#define UIS$_WO_BANNER 27034145
#define UIS$_WO_ADDOPT 27034153
#define UIS$_ICN_NAME 27034161
/********************************************************************************************************************************/
/* Created  6-NOV-1992 12:20:14 by VAX SDL V3.2-12     Source: 11-APR-1990 12:39:36 VWSRESD$:[UIS.SRC]UISUSRDEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $UISUSRDEF IDENT X-92 ***/
#define uis$c_lib_native_uis 0
#define uis$c_lib_uisx 1
#define uis$c_efn_synch 30
#define UIS$C_TEXT8 8
#define UIS$C_TEXT16 16
#define UIS$C_TEXT_END_OF_LIST 0
#define UIS$C_TEXT_NOP 1
#define UIS$C_TEXT_SAVE_POSITION 2
#define UIS$C_TEXT_RESTORE_POSITION 3
#define UIS$C_TEXT_NEW_LINE 4
#define UIS$C_TEXT_WRITE 5
#define UIS$C_TEXT_ATB 6
#define UIS$C_TEXT_IGNORE 7
#define UIS$C_TEXT_HPOS_RELATIVE 8
#define UIS$C_TEXT_HPOS_ABSOLUTE 9
#define UIS$C_TEXT_TAB_RELATIVE 10
#define UIS$C_TEXT_TAB_ABSOLUTE 11
#define UIS$C_TEXT_VPOS_RELATIVE 12
#define UIS$C_TEXT_VPOS_ABSOLUTE 13
#define UIS$C_TEXT_MAX_OPERATION 14
#define UIS$C_TEXT_PATH_RIGHT 1
#define UIS$C_TEXT_PATH_LEFT 2
#define UIS$C_TEXT_PATH_DOWN 3
#define UIS$C_TEXT_PATH_UP 4
#define UIS$C_TEXT_FORMAT_NOJUSTIFY 0
#define UIS$C_TEXT_FORMAT_LEFT 1
#define UIS$C_TEXT_FORMAT_RIGHT 2
#define UIS$C_TEXT_FORMAT_JUSTIFY 3
#define UIS$C_TEXT_FORMAT_CENTER 4
#define UIS$C_WIDTH_PIXELS 0
#define UIS$C_WIDTH_WORLD 1
#define UIS$C_TERM_END_OF_LIST 0
#define UIS$C_TERM_COLOR 1
#define UIS$C_TERM_LENGTH 2
#define UIS$C_TERM_WIDTH 3
#define UIS$C_TERM_KB_ATTRIB 4
#define UIS$C_TERM_TYPE 5
#define UIS$C_TERM_OPTIONS_1 6
#define UIS$C_TERM_OPTIONS_2 7
#define UIS$C_TERM_OPTIONS_3 8
#define UIS$C_TERM_OPTIONS_4 9
#define UIS$C_TERM_OPTIONS_5 10
#define UIS$M_TERM_NOKB_BIND 1
#define UIS$M_TERM_NOKB_CREATE 2
struct TERM_KB_ATTRIB_BITS {
    unsigned UIS$V_TERM_NOKB_BIND : 1;
    unsigned UIS$V_TERM_NOKB_CREATE : 1;
    unsigned UIS$V_fill_0 : 6;
    } ;
#define UIS$C_FNT_END_OF_LIST 0
#define UIS$C_FNT_FIRST_CHAR 1
#define UIS$C_FNT_LAST_CHAR 2
#define UIS$C_FNT_FIXED 3
#define UIS$C_FNT_WIDTH 4
#define UIS$C_FNT_WYSIWYG 5
#define UIS$C_FNT_CELLEQRAST 6
#define UIS$C_FNT_VA_FONT 7
#define UIS$C_FNT_FONT_ID 8
#define UIS$C_FNT_WYS_CHEIGHT 9
#define UIS$C_FNT_WYS_ASCENDER 10
#define UIS$C_FNT_WYS_DECENDER 11
#define UIS$C_FNT_WYS_MAX_WIDTH 12
#define UIS$C_FNT_AVERAGE_GUT 13
#define UIS$C_FNT_GUTPERPIX_X 14
#define UIS$C_FNT_GUTPERPIX_Y 15
#define UIS$C_FNT_USER_FONT 16
#define UIS$C_FNT_MAX_REQUEST 17
#define UIS$M_FNTSIZ_WYSIWYG 1
struct GET_FONT_SIZE_BITS {
    unsigned UIS$V_FNTSIZ_WYSIWYG : 1;
    unsigned UIS$V_fill_1 : 7;
    } ;
#define UIS$C_MODE_TRAN 1
#define UIS$C_MODE_COPY 2
#define UIS$C_MODE_COMP 3
#define UIS$C_MODE_COPYN 4
#define UIS$C_MODE_OVER 5
#define UIS$C_MODE_OVERN 6
#define UIS$C_MODE_REPL 7
#define UIS$C_MODE_REPLN 8
#define UIS$C_MODE_ERAS 9
#define UIS$C_MODE_ERASN 10
#define UIS$C_MODE_BIS 11
#define UIS$C_MODE_BIC 12
#define UIS$C_MODE_BISN 13
#define UIS$C_MODE_BICN 14
#define UIS$C_MODE_XOR 15
#define UIS$C_ARC_OPEN 0
#define UIS$C_ARC_PIE 1
#define UIS$C_ARC_CHORD 2
#define PATT$C_BACKGROUND 1
#define PATT$C_FOREGROUND 2
#define PATT$C_VERT1_1 3
#define PATT$C_VERT1_3 4
#define PATT$C_VERT2_2 5
#define PATT$C_VERT3_1 6
#define PATT$C_VERT1_7 7
#define PATT$C_VERT2_6 8
#define PATT$C_VERT4_4 9
#define PATT$C_VERT6_2 10
#define PATT$C_HORIZ1_1 11
#define PATT$C_HORIZ1_3 12
#define PATT$C_HORIZ2_2 13
#define PATT$C_HORIZ3_1 14
#define PATT$C_HORIZ1_7 15
#define PATT$C_HORIZ2_6 16
#define PATT$C_HORIZ4_4 17
#define PATT$C_HORIZ6_2 18
#define PATT$C_GRID4 19
#define PATT$C_GRID8 20
#define PATT$C_UPDIAG1_3 21
#define PATT$C_UPDIAG2_2 22
#define PATT$C_UPDIAG3_1 23
#define PATT$C_UPDIAG1_7 24
#define PATT$C_UPDIAG2_6 25
#define PATT$C_UPDIAG4_4 26
#define PATT$C_UPDIAG6_2 27
#define PATT$C_DOWNDIAG1_3 28
#define PATT$C_DOWNDIAG2_2 29
#define PATT$C_DOWNDIAG3_1 30
#define PATT$C_DOWNDIAG1_7 31
#define PATT$C_DOWNDIAG2_6 32
#define PATT$C_DOWNDIAG4_4 33
#define PATT$C_DOWNDIAG6_2 34
#define PATT$C_BRICK_HORIZ 35
#define PATT$C_BRICK_VERT 36
#define PATT$C_BRICK_DOWNDIAG 37
#define PATT$C_BRICK_UPDIAG 38
#define PATT$C_GREY4_16D 39
#define PATT$C_GREY12_16D 40
#define PATT$C_BASKET_WEAVE 41
#define PATT$C_SCALE_DOWN 42
#define PATT$C_SCALE_UP 43
#define PATT$C_SCALE_RIGHT 44
#define PATT$C_SCALE_LEFT 45
#define PATT$C_FILLER6 46
#define PATT$C_FILLER7 47
#define PATT$C_GREY1_16 48
#define PATT$C_GREY2_16 49
#define PATT$C_GREY3_16 50
#define PATT$C_GREY4_16 51
#define PATT$C_GREY5_16 52
#define PATT$C_GREY6_16 53
#define PATT$C_GREY7_16 54
#define PATT$C_GREY8_16 55
#define PATT$C_GREY9_16 56
#define PATT$C_GREY10_16 57
#define PATT$C_GREY11_16 58
#define PATT$C_GREY12_16 59
#define PATT$C_GREY13_16 60
#define PATT$C_GREY14_16 61
#define PATT$C_GREY15_16 62
#define PATT$C_MAX_PATTERN 63
#define UIS$C_UNENCODED 1
#define UIS$C_CCITT_3_1D 2
#define UIS$C_CCITT_3_2D 3
#define UIS$C_CCITT_4_2D 4
#define WDPL$C_END_OF_LIST 0
#define WDPL$C_PLACEMENT 1
#define WDPL$C_ASSOC_WD 2
#define WDPL$C_WC_POS_X 3
#define WDPL$C_WC_POS_Y 4
#define WDPL$C_ABS_POS_X 5
#define WDPL$C_ABS_POS_Y 6
#define WDPL$C_ATTRIBUTES 7
#define WDPL$C_MAX_CODE 8
#define WDPL$M_TOP 1
#define WDPL$M_BOTTOM 2
#define WDPL$M_LEFT 4
#define WDPL$M_RIGHT 8
#define WDPL$M_INVISIBLE 16
#define WDPL$M_CENTER 32
#define WDPL$M_MAX_PLACEMENT 64
struct placement_bits {
    unsigned WDPL$V_TOP : 1;
    unsigned WDPL$V_BOTTOM : 1;
    unsigned WDPL$V_LEFT : 1;
    unsigned WDPL$V_RIGHT : 1;
    unsigned WDPL$V_INVISIBLE : 1;
    unsigned WDPL$V_CENTER : 1;
    unsigned WDPL$V_MAX_PLACEMENT : 1;
    unsigned WDPL$V_fill_2 : 1;
    } ;
#define WDPL$M_FILLER1 1
#define WDPL$M_NOBANNER 2
#define WDPL$M_NOBORDER 4
#define WDPL$M_NOMENU_ICON 8
#define WDPL$M_NOKB_ICON 16
#define WDPL$M_ALIGNED 32
#define WDPL$M_MAX_ATTRIBUTE 64
struct attribute_bits {
    unsigned WDPL$V_FILLER1 : 1;
    unsigned WDPL$V_NOBANNER : 1;
    unsigned WDPL$V_NOBORDER : 1;
    unsigned WDPL$V_NOMENU_ICON : 1;
    unsigned WDPL$V_NOKB_ICON : 1;
    unsigned WDPL$V_ALIGNED : 1;
    unsigned WDPL$V_MAX_ATTRIBUTE : 1;
    unsigned WDPL$V_fill_3 : 1;
    } ;
#define UIS$M_KB_AUTORPT 1
#define UIS$M_KB_KEYCLICK 2
#define UIS$M_KB_UDF6 4
#define UIS$M_KB_UDF11 8
#define UIS$M_KB_UDF17 16
#define UIS$M_KB_HELPDO 32
#define UIS$M_KB_UDE1 64
#define UIS$M_KB_ARROW 128
#define UIS$M_KB_KEYPAD 256
#define UIS$M_KB_DUMMY 512
#define UIS$M_KB_COMPOSE_LOCK 1024
#define UIS$M_KB_UDMAIN 2048
#define UIS$M_KB_UDCOMPOSE 4096
#define UIS$M_KB_UDTAB_RETURN 8192
#define UIS$M_KB_UDDELETE 16384
#define UIS$M_MAX_KB_ATTRIBUTE 32768
struct KB_ATTRIBUTE_BITS {
    unsigned UIS$V_KB_AUTORPT : 1;      /* Keyboard autorepeat              */
    unsigned UIS$V_KB_KEYCLICK : 1;     /* Keyclick                         */
    unsigned UIS$V_KB_UDF6 : 1;         /* Function keys F6-F10             */
    unsigned UIS$V_KB_UDF11 : 1;        /* Function keys F11-F14            */
    unsigned UIS$V_KB_UDF17 : 1;        /* Function keys F17-F20            */
    unsigned UIS$V_KB_HELPDO : 1;       /* Function keys for HELP and DO    */
    unsigned UIS$V_KB_UDE1 : 1;         /* Function keys E1-E6 (editing pad) */
    unsigned UIS$V_KB_ARROW : 1;        /* Arrow function keys              */
    unsigned UIS$V_KB_KEYPAD : 1;       /* Numeric keypad keys              */
    unsigned UIS$V_KB_DUMMY : 1;        /* Force to match with VWSSYSDEF    */
    unsigned UIS$V_KB_COMPOSE_LOCK : 1; /* Compose as LOCK key *INTERNAL USE ONLY* */
    unsigned UIS$V_KB_UDMAIN : 1;       /* Main keyboard array              */
    unsigned UIS$V_KB_UDCOMPOSE : 1;    /* Compose key up/down              */
    unsigned UIS$V_KB_UDTAB_RETURN : 1; /* Tab and Return keys up/down      */
    unsigned UIS$V_KB_UDDELETE : 1;     /* Delete key up/down               */
    unsigned UIS$V_MAX_KB_ATTRIBUTE : 1; /* First undefined bit             */
    } ;
#define UIS$M_KEY_COMPOSE 134217728
#define UIS$M_KEY_SHIFT 268435456
#define UIS$M_KEY_CTRL 536870912
#define UIS$M_KEY_LOCK 1073741824
#define UIS$M_KEY_DOWN -2147483648
struct kb_state_bits {
    unsigned short int UIS$W_KEY_CODE;
    unsigned UIS$V_KEY_FILLER : 11;
    unsigned UIS$V_KEY_COMPOSE : 1;
    unsigned UIS$V_KEY_SHIFT : 1;
    unsigned UIS$V_KEY_CTRL : 1;
    unsigned UIS$V_KEY_LOCK : 1;
    unsigned UIS$V_KEY_DOWN : 1;
    } ;
#define UIS$C_POINTER_BUTTON_1 400
#define UIS$C_POINTER_BUTTON_2 401
#define UIS$C_POINTER_BUTTON_3 402
#define UIS$C_POINTER_BUTTON_4 403
#define UIS$M_POINTER_BUTTON_3 1
#define UIS$M_POINTER_BUTTON_2 2
#define UIS$M_POINTER_BUTTON_1 4
#define UIS$M_POINTER_BUTTON_4 8
struct button_names {
    unsigned UIS$V_POINTER_BUTTON_3 : 1;
    unsigned UIS$V_POINTER_BUTTON_2 : 1;
    unsigned UIS$V_POINTER_BUTTON_1 : 1;
    unsigned UIS$V_POINTER_BUTTON_4 : 1;
    unsigned UIS$V_fill_4 : 4;
    } ;
#define UIS$M_NOWAIT 1
struct read_char_flags {
    unsigned UIS$V_NOWAIT : 1;
    unsigned UIS$V_fill_5 : 7;
    } ;
#define UIS$M_BIND_POINTER 1
struct pointer_pattern_flags {
    unsigned UIS$V_BIND_POINTER : 1;
    unsigned UIS$V_fill_6 : 7;
    } ;
#define UIS$C_OBJECT_SEGMENT 1
#define UIS$C_OBJECT_PLOT 2
#define UIS$C_OBJECT_TEXT 3
#define UIS$C_OBJECT_ELLIPSE 4
#define UIS$C_OBJECT_IMAGE 5
#define UIS$C_OBJECT_NEW_TEXT_LINE 6
#define UIS$C_OBJECT_LINE 7
#define UIS$C_OBJECT_COMPRESSED_IMAGE 8
#define UIS$m_filler1 1
#define UIS$m_filler2 2
#define UIS$m_filler3 4
#define UIS$M_DL_UPDATE_WINDOW 8
#define UIS$M_DL_MODIFY_LIST 16
#define UIS$M_DL_ENHANCE_LIST 32
struct display_list_mask {
    unsigned UIS$v_filler1 : 1;
    unsigned UIS$v_filler2 : 1;
    unsigned UIS$v_filler3 : 1;
    unsigned UIS$V_DL_UPDATE_WINDOW : 1;
    unsigned UIS$V_DL_MODIFY_LIST : 1;
    unsigned UIS$V_DL_ENHANCE_LIST : 1;
    unsigned UIS$V_fill_7 : 2;
    } ;
#define UIS$M_DL_SAME_SEGMENT 1
struct get_object_mask {
    unsigned UIS$V_DL_SAME_SEGMENT : 1;
    unsigned UIS$V_fill_8 : 7;
    } ;
#define UIS$M_DL_INSERT_AT_BEGIN 1
#define UIS$M_DL_INSERT_AFTER_OBJECT 2
#define UIS$M_DL_INSERT_BEFORE_OBJECT 4
struct insertion_mask {
    unsigned UIS$V_DL_INSERT_AT_BEGIN : 1;
    unsigned UIS$V_DL_INSERT_AFTER_OBJECT : 1;
    unsigned UIS$V_DL_INSERT_BEFORE_OBJECT : 1;
    unsigned UIS$V_fill_9 : 5;
    } ;
#define GER$C_SET_WRITING_MODE 1
#define GER$C_SET_WRITING_INDEX 2
#define GER$C_SET_BACKGROUND_INDEX 3
#define GER$C_SET_CHAR_SPACING 4
#define GER$C_SET_CHAR_SLANT 5
#define GER$C_SET_TEXT_SLOPE 6
#define GER$C_SET_TEXT_PATH 7
#define GER$C_SET_CHAR_TEXTURE 8
#define GER$C_SET_CHAR_UNDERSCORE 9
#define GER$C_SET_CHAR_BLINKING 10
#define GER$C_SET_TEXT_FORMATTING 11
#define GER$C_SET_CHAR_ROTATION 12
#define GER$C_SET_TEXT_MARGINS 13
#define GER$C_SET_LINE_WIDTH 14
#define GER$C_SET_LINE_STYLE 15
#define GER$C_SET_MARKER 16
#define GER$C_SET_FONT 17
#define GER$C_DEFINE_FONT 18
#define GER$C_TEXT 19
#define GER$C_filler5 20
#define GER$C_SET_POSITION 21
#define GER$C_NEW_TEXT_LINE 22
#define GER$C_PLOT 23
#define GER$C_MARKER 24
#define GER$C_ELLIPSE 25
#define GER$C_SET_ARC_TYPE 26
#define GER$C_OPEN_CURVE 27
#define GER$C_CLOSED_CURVE 28
#define GER$C_IMAGE 29
#define GER$C_PRIVATE 30
#define GER$C_BEGIN 31
#define GER$C_END 32
#define GER$C_ALIGN_POSITION 33
#define GER$C_BEGIN_DISPLAY 34
#define GER$C_END_DISPLAY 35
#define GER$C_VERSION 36
#define GER$C_SET_FILL_PATTERN 37
#define GER$C_SET_CLIP 38
#define GER$C_SET_CHAR_ENCODING 39
#define GER$C_FILLER2 40
#define GER$C_FILLER3 41
#define GER$C_SET_CHAR_SIZE 42
#define GER$C_IDENTIFICATION 43
#define GER$C_DATE 44
#define GER$C_NOP 45
#define GER$C_FILLER4 46
#define GER$C_SET_COLORS 47
#define GER$C_SET_INTENSITIES 48
#define GER$C_PRIVATE_ECO 49
#define GER$C_CREATE_COLOR_MAP 50
#define GER$C_DISPLAY_EXTENTS 51
#define GER$C_LINE 52
#define GER$C_SET_IMAGING_PARAMETERS 53
#define GER$C_WRITE_IMAGE 54
#define GER$C_SET_PLANE_MASK 55
#define GER$C_MAX_OPCODE 56
#define GER$K_LENGTH_DIFF -4
#define GER$S_ATTRIBUTE_HEADER 4
#define GER$M_CHAR_SIZE_FILLER1 1
#define GER$M_CHAR_SIZE_X 2
#define GER$M_CHAR_SIZE_Y 4
#define GER$M_CHAR_SIZE_FILLER_2 8
#define GER$M_CHAR_SIZE_ENABLE 1
#define GER$M_CHAR_SIZE_DEF_X 2
#define GER$M_CHAR_SIZE_DEF_Y 4
#define GER$M_CHAR_SIZE_DEF_CHAR 8
#define GER$S_OUTPUT_HEADER 2
#define GER$S_new_text_line 0
#define GER$M_COLOR_MAP_RESIDENT 1
#define GER$m_unused1_map 2
#define GER$M_COLOR_MAP_NO_BIND 4
#define GER$m_unused2_map 65528
#define GER$M_COLOR_MAP_SHARE 65536
#define GER$M_COLOR_MAP_SYSTEM 131072
#define GER$S_end_display 0
struct binary_encodings {
    short int GER$W_TYPE;
    short int GER$W_LENGTH;
    union  {
        long int GER$L_EXTRA_LENGTH;
        struct  {
            short int GER$W_SET_IATB;
            short int GER$W_SET_OATB;
            union  {
                struct  {
                    short int GER$W_ARC_TYPE;
                    } GER$r_arc_type;
                struct  {
                    short int GER$W_BACKGROUND_INDEX;
                    } GER$r_background_index;
                struct  {
                    short int GER$W_CHAR_BLINK_MODE;
                    } GER$r_char_blink;
                struct  {
                    short int GER$W_CHAR_ENCODING_TYPE;
                    } GER$r_char_encoding;
                struct  {
                    float GER$F_CHAR_ROTATION_ANGLE;
                    } GER$r_char_rotation;
                struct  {
                    union  {
                        short int GER$W_CHAR_SIZE_FLAGS;
                        struct  {
                            unsigned GER$V_CHAR_SIZE_FILLER1 : 1;
                            unsigned GER$V_CHAR_SIZE_X : 1;
                            unsigned GER$V_CHAR_SIZE_Y : 1;
                            unsigned GER$V_CHAR_SIZE_FILLER_2 : 1;
                            unsigned GER$V_fill_10 : 4;
                            } GER$r_char_size_obsolete;
                        struct  {
                            unsigned GER$V_CHAR_SIZE_ENABLE : 1;
                            unsigned GER$V_CHAR_SIZE_DEF_X : 1;
                            unsigned GER$V_CHAR_SIZE_DEF_Y : 1;
                            unsigned GER$V_CHAR_SIZE_DEF_CHAR : 1;
                            unsigned GER$V_fill_11 : 4;
                            } GER$r_char_size_bits;
                        } GER$r_char_size_flag_union;
                    short int GER$W_CHAR_SIZE_EXAMPLE;
                    float GER$F_CHAR_SIZE_WIDTH;
                    float GER$F_CHAR_SIZE_HEIGHT;
                    } GER$r_char_size;
                struct  {
                    float GER$F_CHAR_SLANT_ANGLE;
                    } GER$r_char_slant;
                struct  {
                    float GER$F_CHAR_SPACE_DX;
                    float GER$F_CHAR_SPACE_DY;
                    } GER$r_char_spacing;
                struct  {
                    short int GER$W_CHAR_UNDERSCORE_MODE;
                    } GER$r_char_underscore;
                struct  {
                    short int GER$W_CLIP_FLAGS;
                    float GER$F_CLIP_X1;
                    float GER$F_CLIP_Y1;
                    float GER$F_CLIP_X2;
                    float GER$F_CLIP_Y2;
                    } GER$r_clip;
                struct  {
                    short int GER$W_COLOR_COUNT;
                    short int GER$W_COLOR_INDEX;
                    char GER$G_COLOR_VALUES [];
                    } GER$r_color;
                struct  {
                    short int GER$W_FILL_FLAGS;
                    short int GER$W_FILL_INDEX;
                    } GER$r_fill_pattern;
                struct  {
                    short int GER$W_FONT_ID_LENGTH;
                    char GER$G_FONT_ID_STRING [];
                    } GER$r_font;
                struct  {
                    short int GER$W_INTENSITY_COUNT;
                    short int GER$W_INTENSITY_INDEX;
                    char GER$G_INTENSITY_VALUES [];
                    } GER$r_intensity;
                struct  {
                    long int GER$L_LINE_STYLE;
                    } GER$r_line_style;
                struct  {
                    float GER$F_LINE_WIDTH_NC;
                    float GER$F_LINE_WIDTH_DC;
                    short int GER$W_LINE_WIDTH_MODE;
                    } GER$r_line_width;
                struct  {
                    short int GER$W_MARKER_TYPE;
                    } GER$r_marker_type;
                struct  {
                    short int GER$W_TEXT_FORMAT_MODE;
                    } GER$r_text_format;
                struct  {
                    float GER$F_TEXT_MARGIN_X;
                    float GER$F_TEXT_MARGIN_Y;
                    float GER$F_TEXT_MARGIN_DISTANCE;
                    } GER$r_text_margins;
                struct  {
                    short int GER$W_TEXT_PATH_MAJOR;
                    short int GER$W_TEXT_PATH_MINOR;
                    } GER$r_text_path;
                struct  {
                    float GER$F_TEXT_SLOPE_ANGLE;
                    } GER$r_text_slope;
                struct  {
                    short int GER$W_WRITING_MODE;
                    } GER$r_writing_mode;
                struct  {
                    short int GER$W_WRITING_INDEX;
                    } GER$r_writing_index;
                struct  {
                    char GER$B_IMAGING_KERNELS [100];
                    char GER$B_IMAGING_THRESHOLD [4];
                    } GER$r_set_imaging_parameters;
                struct  {
                    long int GER$L_PLANE_MASK;
                    } GER$r_plane_mask;
                } GER$r_attribute_union;
            } GER$r_set_attribute_encodings;
        struct  {
            short int GER$W_OUTPUT_ATB;
            union  {
                struct  {
                    float GER$F_ELLIPSE_X;
                    float GER$F_ELLIPSE_Y;
                    float GER$F_ELLIPSE_WIDTH;
                    float GER$F_ELLIPSE_HEIGHT;
                    float GER$F_ELLIPSE_START_DEG;
                    float GER$F_ELLIPSE_END_DEG;
                    } GER$r_ellipse;
                struct  {
                    float GER$F_IMAGE_X1;
                    float GER$F_IMAGE_Y1;
                    float GER$F_IMAGE_X2;
                    float GER$F_IMAGE_Y2;
                    short int GER$W_IMAGE_WIDTH;
                    short int GER$W_IMAGE_HEIGHT;
                    short int GER$W_IMAGE_BPP;
                    long int GER$L_IMAGE_SIZE;
                    char GER$G_IMAGE_DATA [];
                    } GER$r_image;
                struct  {
                    float GER$F_COMPRESSED_IMAGE_X1;
                    float GER$F_COMPRESSED_IMAGE_Y1;
                    float GER$F_COMPRESSED_IMAGE_X2;
                    float GER$F_COMPRESSED_IMAGE_Y2;
                    long int GER$L_COMPRESSED_IMAGE_WIDTH;
                    long int GER$L_COMPRESSED_IMAGE_HEIGHT;
                    long int GER$L_COMPRESSED_IMAGE_BPP;
                    long int GER$L_COMPRESSED_IMAGE_SIZE;
                    long int GER$L_COMPRESSED_IMAGE_ROTATION;
                    short int GER$W_COMPRESSED_IMAGE_K_VALUE;
                    long int GER$L_COMPRESSED_IMAGE_ENCODE;
                    char GER$G_COMPRESSED_IMAGE_DATA [];
                    } GER$r_compressed_image;
                struct  {
                    short int GER$W_LINE_COUNT;
                    char GER$G_LINE_DATA [];
                    } GER$r_line;
                struct  {
                    float GER$F_MARKER_X;
                    float GER$F_MARKER_Y;
                    } GER$r_marker;
                struct  {
                    short int GER$W_PLOT_COUNT;
                    char GER$G_PLOT_DATA [];
                    } GER$r_plot;
                struct  {
                    short int GER$W_TEXT_ENCODING;
                    short int GER$W_TEXT_LENGTH;
                    char GER$G_TEXT_DATA [];
                    } GER$r_text;
                } GER$r_output_union;
            } GER$r_output_encodings;
        struct  {
            union  {
                struct  {
                    short int GER$W_ALIGN_POS_ATB;
                    float GER$F_ALIGN_POS_X;
                    float GER$F_ALIGN_POS_Y;
                    } GER$r_align_position;
                struct  {
                    float GER$F_DISPLAY_WC_MINX;
                    float GER$F_DISPLAY_WC_MINY;
                    float GER$F_DISPLAY_WC_MAXX;
                    float GER$F_DISPLAY_WC_MAXY;
                    float GER$F_DISPLAY_WIDTH;
                    float GER$F_DISPLAY_HEIGHT;
                    } GER$r_begin_display;
                struct  {
                    union  {
                        long int GER$L_COLOR_MAP_ATTRIBUTES;
                        struct  {
                            unsigned GER$V_COLOR_MAP_RESIDENT : 1;
                            unsigned GER$v_unused1_map : 1;
                            unsigned GER$V_COLOR_MAP_NO_BIND : 1;
                            unsigned GER$v_unused2_map : 13;
                            unsigned GER$V_COLOR_MAP_SHARE : 1;
                            unsigned GER$V_COLOR_MAP_SYSTEM : 1;
                            unsigned GER$V_fill_12 : 6;
                            } GER$r_attr_flags;
                        } GER$r_attr_union;
                    short int GER$W_COLOR_MAP_NAME_SIZE;
                    short int GER$W_COLOR_MAP_SIZE;
                    char GER$T_COLOR_MAP_NAME [15];
                    } GER$r_create_color_map;
                struct  {
                    short int GER$W_DATE_LENGTH;
                    char GER$T_DATE_STRING [];
                    } GER$r_date;
                struct  {
                    float GER$F_EXTENT_MINX;
                    float GER$F_EXTENT_MINY;
                    float GER$F_EXTENT_MAXX;
                    float GER$F_EXTENT_MAXY;
                    } GER$r_display_extents;
                struct  {
                    short int GER$W_IDENTIFICATION_LENGTH;
                    char GER$T_IDENTIFICATION_STRING [];
                    } GER$r_identification;
                struct  {
                    short int GER$W_PRIVATE_FACNUM;
                    short int GER$W_PRIVATE_LENGTH;
                    char GER$G_PRIVATE_DATA [];
                    } GER$r_private;
                struct  {
                    short int GER$W_PRIVATE_ECO_FACNUM;
                    short int GER$W_PRIVATE_ECO_MAJOR;
                    short int GER$W_PRIVATE_ECO_MINOR;
                    short int GER$W_PRIVATE_ECO_ECO;
                    } GER$r_private_eco;
                struct  {
                    float GER$F_TEXT_POS_X;
                    float GER$F_TEXT_POS_Y;
                    } GER$r_set_position;
                struct  {
                    short int GER$W_VERSION_MAJOR;
                    short int GER$W_VERSION_MINOR;
                    short int GER$W_VERSION_ECO;
                    } GER$r_version;
                } GER$r_misc_union;
            } GER$r_misc_encodings;
        } GER$r_value_area_union;
    } ;
#define GER$C_MAJOR_VERSION 3
#define GER$C_MINOR_VERSION 0
#define GER$S_SMALL_HEADER 4
#define GER$S_LARGE_HEADER 8
#define UIS$C_WS_BCOLOR 0
#define UIS$C_WS_FCOLOR 1
#define UIS$C_WS_BLACK 2
#define UIS$C_WS_WHITE 3
#define UIS$C_WS_RED 4
#define UIS$C_WS_GREEN 5
#define UIS$C_WS_BLUE 6
#define UIS$C_WS_CYAN 7
#define UIS$C_WS_YELLOW 8
#define UIS$C_WS_MAGENTA 9
#define UIS$C_WS_GREY25 10
#define UIS$C_WS_GREY50 11
#define UIS$C_WS_GREY75 12
#define UIS$C_MAX_COLOR_ID 13
#define UIS$C_WS_WSG_FG -1
#define UIS$C_WS_WSG_BG -2
#define UIS$C_WS_TERM_FG -3
#define UIS$C_WS_TERM_BG -4
#define UIS$C_WS_CURSOR_FG -5
#define UIS$C_WS_CURSOR_BG -6
#define UIS$C_MIN_COLOR_ID -7
#define UIS$C_COLOR_BASED 1
#define UIS$C_COLOR_GENERAL 2
#define UIS$C_COLOR_EXACT 3
#define UIS$C_DEV_MONO 1
#define UIS$C_DEV_INTENSITY 2
#define UIS$C_DEV_COLOR 3
#define UIS$C_DEV_NONRETRO 1
#define UIS$C_DEV_RETRO 2
#define UIS$C_COLOR_UNDEFINED 49280
#define UIS$C_DEFAULT_RESIZE -1
#define UIS$C_DEFAULT_CLOSE -1
#define UIS$C_DEFAULT_SHRINK_TO_ICON -1
#define UIS$C_DEFAULT_EXPAND_ICON -1
#define UIS$M_ICON_DEF_KB 1
#define UIS$M_ICON_DEF_BODY 2
struct shrink_to_icon_bits {
    unsigned UIS$V_ICON_DEF_KB : 1;
    unsigned UIS$V_ICON_DEF_BODY : 1;
    unsigned UIS$V_fill_13 : 6;
    } ;
#define VCMAL$C_END_OF_LIST 0
#define VCMAL$C_ATTRIBUTES 1
#define VCMAL$C_PARENT_VCM 2
#define VCMAL$C_PARENT_BASE 3
#define VCMAL$C_MAX_CODE 4
#define VCMAL$M_RESIDENT 1
#define VCMAL$M_SUBMAP 2
#define VCMAL$M_NO_BIND 4
#define VCMAL$M_PRCPRM 8
#define VCMAL$M_PERM 16
#define VCMAL$M_DEFAULT 32
#define VCMAL$m_atrfil6 64
#define VCMAL$m_atrfil7 128
#define VCMAL$m_atrfil8 256
#define VCMAL$m_atrfil9 512
#define VCMAL$m_atrfila 1024
#define VCMAL$m_atrfilb 2048
#define VCMAL$m_atrfilc 4096
#define VCMAL$m_atrfild 8192
#define VCMAL$m_atrfile 16384
#define VCMAL$m_atrfilf 32768
#define VCMAL$M_SHARE 65536
#define VCMAL$M_SYSTEM 131072
#define VCMAL$m_namfil2 262144
#define VCMAL$m_namfil3 524288
#define VCMAL$m_namfil4 1048576
#define VCMAL$m_namfil5 2097152
#define VCMAL$m_namfil6 4194304
#define VCMAL$m_namfil7 8388608
#define VCMAL$m_namfil8 16777216
#define VCMAL$m_namfil9 33554432
#define VCMAL$m_namfila 67108864
#define VCMAL$m_namfilb 134217728
#define VCMAL$m_namfilc 268435456
#define VCMAL$m_namfild 536870912
#define VCMAL$m_namfile 1073741824
#define VCMAL$m_namfilf -2147483648
struct vcm_attribute_bits {
    union  {
        union  {
            unsigned short int VCMAL$w_attr_flags;
            unsigned short int VCMAL$w_name_flags;
            struct  {
                unsigned VCMAL$V_RESIDENT : 1;
                unsigned VCMAL$V_SUBMAP : 1;
                unsigned VCMAL$V_NO_BIND : 1;
                unsigned VCMAL$V_PRCPRM : 1;
                unsigned VCMAL$V_PERM : 1;
                unsigned VCMAL$V_DEFAULT : 1;
                unsigned VCMAL$v_atrfil6 : 1;
                unsigned VCMAL$v_atrfil7 : 1;
                unsigned VCMAL$v_atrfil8 : 1;
                unsigned VCMAL$v_atrfil9 : 1;
                unsigned VCMAL$v_atrfila : 1;
                unsigned VCMAL$v_atrfilb : 1;
                unsigned VCMAL$v_atrfilc : 1;
                unsigned VCMAL$v_atrfild : 1;
                unsigned VCMAL$v_atrfile : 1;
                unsigned VCMAL$v_atrfilf : 1;
                unsigned VCMAL$V_SHARE : 1;
                unsigned VCMAL$V_SYSTEM : 1;
                unsigned VCMAL$v_namfil2 : 1;
                unsigned VCMAL$v_namfil3 : 1;
                unsigned VCMAL$v_namfil4 : 1;
                unsigned VCMAL$v_namfil5 : 1;
                unsigned VCMAL$v_namfil6 : 1;
                unsigned VCMAL$v_namfil7 : 1;
                unsigned VCMAL$v_namfil8 : 1;
                unsigned VCMAL$v_namfil9 : 1;
                unsigned VCMAL$v_namfila : 1;
                unsigned VCMAL$v_namfilb : 1;
                unsigned VCMAL$v_namfilc : 1;
                unsigned VCMAL$v_namfild : 1;
                unsigned VCMAL$v_namfile : 1;
                unsigned VCMAL$v_namfilf : 1;
                } VCMAL$r_attr_flags_bits;
            } VCMAL$r_attr_flags_union;
        } VCMAL$r_vcm_attributes_union;
    } ;
#ifndef __UNIXIO_LOADED
#define __UNIXIO_LOADED	1

/*	UNIXIO - V3.0 - Prototypes for UNIX emulation functions	*/

#pragma nostandard
#include stdio
#include stat
#pragma standard

int	access	(char *file_spec, int mode);
int	close	(int file_desc);
int	creat	(char *file_spec, unsigned int mode, ...);
int	delete	(const char *file_spec);
int	dup	(int file_desc);
int	dup2	(int file_desc1, int file_desc2);
int	fstat	(int file_desc, stat_t *buffer);
char   *getname	(int file_desc, char *buffer, ...);
int	isapipe	(int file_desc);
int	isatty	(int file_desc);
int	lseek	(int file_desc, int offset, int direction);
char   *mktemp	(char *template);
int	read	(int file_desc, void *buffer, int nbytes);
int	rename	(const char *old_file_spec, const char *new_file_spec);
int	open	(char *file_spec, int flags, unsigned int mode, ...);
int	stat	(char *file_spec, stat_t *buffer);
char   *ttyname	(void);
int	write	(int file_desc, void *buffer, int nbytes);


#endif					/* __UNIXIO_LOADED */
#ifndef __UNIXLIB_LOADED
#define __UNIXLIB_LOADED	1

/*	UNIXLIB - V3.0 - Prototypes for UNIX emulation functions	*/

#pragma nostandard

#undef ecvt
#undef fcvt
#undef gcvt

#pragma standard

char *ecvt( double value, int ndigit, int *decpt, int *sign);
char *fcvt( double value, int ndigit, int *decpt, int *sign);
char *gcvt( double value, int ndigit, char *buffer);

char *getcwd( char *buffer, unsigned int size, ...);

unsigned int gedgid( void);
unsigned int getegid( void);

char *getenv( const char *name);

#pragma nostandard
#ifdef CC$VAXCSHR
#define environ (*vaxc$ga_environ)
globalref char **environ;	/* Only minimally supported */
#else
extern char noshare **environ;	/* Only minimally supported */
#endif
#pragma standard

unsigned int geteuid( void);

unsigned int getgid( void);

int getpid( void);

int getppid( void);

unsigned int getuid( void);

int setgid( unsigned int);

int setuid( unsigned int);

#if defined(CC$mixed_float) || defined(CC$VAXCSHR)
/* 
 * CC$gfloat's definition was modified so that it's defined when
 * g_float is in effect, and undefined otherwise.  The following
 * makes the new behavior compatible with the old.
 */
#ifndef CC$gfloat
#define CC$gfloat
#endif

#if CC$gfloat
char *vaxc$gecvt(double value, int ndigit, int *decpt, int *sign);

char *vaxc$gfcvt(double value, int ndigit, int *decpt, int *sign);

char *vaxc$ggcvt(double value, int ndigit, char *buffer);

#define ecvt vaxc$gecvt
#define fcvt vaxc$gfcvt
#define gcvt vaxc$ggcvt

#else
char *vaxc$decvt(double value, int ndigit, int *decpt, int *sign);

char *vaxc$dfcvt(double value, int ndigit, int *decpt, int *sign);

char *vaxc$dgcvt(double value, int ndigit, char *buffer);

#define ecvt vaxc$decvt
#define fcvt vaxc$dfcvt
#define gcvt vaxc$dgcvt

#endif
#endif

#endif					/* __UNIXLIB_LOADED */
#ifndef __USGDEF_LOADED
#define __USGDEF_LOADED	1

/*** MODULE $usgdef ***/
/*+                                                                         */
/* Disk usage accounting file produced by ANALYZE/DISK_STRUCTURE utility.   */
/*-                                                                         */
#define USG$K_IDENT 1                   /* Identification record            */
#define USG$K_FILE 2                    /* File record                      */
#define USG$K_IDENT_LEN 61              /* Length of IDENT record           */
#define USG$C_IDENT_LEN 61              /* Length of IDENT record           */
struct usgdef {
    unsigned char usg$b_type;           /* Record type                      */
    unsigned long int usg$l_serialnum;  /* Pack serial number               */
    char usg$t_strucname [12];          /* Volume set name                  */
    char usg$t_volname [12];            /* Volume name                      */
    char usg$t_ownername [12];          /* Volume owner name                */
    char usg$t_format [12];             /* Volume format type               */
/* *** Preceding same as home block ***                                     */
    unsigned int usg$q_time [2];        /* Time usage file created          */
    } ;
#define USG$K_FILE_LEN 423              /* Maximum length of FILE record    */
#define USG$C_FILE_LEN 423              /* Maximum length of FILE record    */
struct usgdef1 {
    char usgdef$$_fill_1;
#pragma nostandard
    variant_union  {
        unsigned long int usg$l_fileowner; /* File owner UIC                */
        variant_struct  {
            unsigned short int usg$w_uicmember; /* UIC member number        */
            unsigned short int usg$w_uicgroup; /* UIC group number          */
            } usg$r_fileowner_fields;
        } usg$r_fileowner_overlay;
    unsigned long int usg$l_allocated;  /* Blocks allocated, including headers  */
    unsigned long int usg$l_used;       /* Blocks used                      */
    unsigned short int usg$w_dir_len;   /* Length of directory string       */
    unsigned short int usg$w_spec_len;  /* Length of complete file specification  */
    char usg$t_filespec [406];          /* File spec "[dir]nam.typ;ver"     */
    } ;
 
#pragma standard

#endif					/* __USGDEF_LOADED */
#ifndef __USRIDEF_LOADED
#define __USRIDEF_LOADED	1

/*** MODULE $usridef ***/
/*                                                                          */
/* User image bit definitions                                               */
/*                                                                          */
/*                                                                          */
#define USRI$M_DBG_MAPPED 1
union usridef {
#pragma nostandard
    variant_struct  {
        unsigned usri$v_dbg_mapped : 1; /* Debugger is now mapped           */
        unsigned usri$v_fill_7 : 7;
        } usri$r_usri_bits;
    } ;
 
#pragma standard

#endif					/* __USRIDEF_LOADED */
/*
 * COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1990. ALL RIGHTS RESERVED.
 *
 * THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 * ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 * INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 * COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 * OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 * TRANSFERRED. 
 *
 * THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 * AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 * CORPORATION.
 *
 * DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 * SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
 */

#ifndef _UTC_H
#define _UTC_H

#include <time.h>

#ifndef _UTC_T_
#define _UTC_T_
typedef struct utc
{
    char char_array[16];
} utc_t;
#endif /* _UTC_T_ */

enum utc_cmptype {
    utc_lessThan,
    utc_equalTo,
    utc_greaterThan,
    utc_indeterminate
};

#ifndef _TIMESPEC_T_
#define _TIMESPEC_T_
typedef struct timespec {
    unsigned long tv_sec;
    long tv_nsec;
} timespec_t;
#endif

#ifndef _RELTIMESPEC_T_
#define _RELTIMESPEC_T_
typedef struct reltimespec
{
    long tv_sec;
    long tv_nsec;
} reltimespec_t;
#endif

#ifdef __STDC__
int utc_gettime(utc_t *utc);
int utc_bintime(timespec_t *timesp, timespec_t *inaccsp, long *tdf, utc_t *utc);
int utc_mkbintime(utc_t *utc, timespec_t *timesp,  timespec_t *inaccsp,
                  long tdf);
int utc_binreltime(reltimespec_t *timesp, timespec_t *inaccsp, utc_t *utc);
int utc_mkbinreltime(utc_t *utc, reltimespec_t *timesp, timespec_t *inaccsp);
int utc_localtime(struct tm *timetm, long *tns, struct tm *inacctm,
		  long *ins, utc_t *utc);
int utc_mklocaltime(utc_t *utc, struct tm *timetm, long tns,
		    struct tm *inacctm, long ins);
int utc_localzone(char *tzname, int tzlen, long *tdf, int *isdst, utc_t *utc);
int utc_anyzone(char *tzname, int tzlen, long *tdf, int *isdst, utc_t *utc);
int utc_gmtzone(char *tzname, int tzlen, long *tdf, int *isdst, utc_t *utc);
int utc_gmtime(struct tm *timetm, long *tns, struct tm *inacctm, long *ins,
               utc_t *utc);
int utc_mkgmtime(utc_t *utc, struct tm *timetm, long tns, struct tm *inacctm,
                 long ins);
int utc_anytime(struct tm *timetm, long *tns, struct tm *inacctm, long *ins,
                long *tdf, utc_t *utc);
int utc_mkanytime(utc_t *utc, struct tm *timetm, long tns, struct tm *inacctm,
                  long ins, long tdf);
int utc_reltime(struct tm *timetm, long *tns, struct tm *inacctm, long *ins,
                utc_t *utc);
int utc_mkreltime(utc_t *utc, struct tm *timetm, long tns, struct tm *inacctm,
                  long ins);
int utc_addtime(utc_t *result, utc_t *utc1, utc_t *utc2);
int utc_subtime(utc_t *result, utc_t *utc1, utc_t *utc2);
int utc_multime(utc_t *result, utc_t *utc1, long factor);
int utc_mulftime(utc_t *result, utc_t *utc1, double factor);
int utc_cmpmidtime(enum utc_cmptype *relation, utc_t *utc1, utc_t *utc2);
int utc_cmpintervaltime(enum utc_cmptype *relation, utc_t *utc1, utc_t *utc2);
int utc_boundtime(utc_t *result, utc_t *utclp, utc_t *utchp);
int utc_spantime(utc_t *result, utc_t *utc1, utc_t *utc2);
int utc_pointtime(utc_t *utclp, utc_t *utcmp, *utc_hp, utc_t *utc);
int utc_getusertime(utc_t *utc);
int utc_ascgmtime(char *cp, int stringlen, utc_t *utc);
int utc_asclocaltime(char *cp, int stringlen, utc_t *utc);
int utc_ascanytime(char *cp, int stringlen, int tdf, utc_t *utc);
int utc_ascreltime(char *cp, int stringlen, utc_t *utc);
int utc_mkasctime(utc_t *utc, char *cp);
int utc_mkascreltime(utc_t *utc, char *cp);
#else
int utc_gettime();
int utc_bintime();
int utc_mkbintime();
int utc_binreltime();
int utc_mkbinreltime();
int utc_localtime();
int utc_mklocaltime();
int utc_mkgmtime();
int utc_anytime();
int utc_mkanytime();
int utc_reltime();
int utc_mkreltime();
int utc_addtime();
int utc_subtime();
int utc_multime();
int utc_mulftime();
int utc_cmpmidtime();
int utc_cmpintervaltime();
int utc_boundtime();
int utc_spantime();
int utc_pointtime();
int utc_getusertime();
int utc_ascgmtime();
int utc_asclocaltime();
int utc_ascanytime();
int utc_ascreltime();
int utc_mkasctime();
int utc_mkascreltime();
#endif /* __STDC__ */
                                                             
#endif /* _UTC_H */
#ifndef __VARARGS_LOADED
#define __VARARGS_LOADED	1

/*	VARARGS - V3.0	*/

/*
 * Definitions for access to variable length argument lists
 */

#ifdef __STDARG_LOADED
#undef __STDARG_LOADED
#pragma NOSTANDARD
#undef va_start
#undef va_arg
#undef va_end
#pragma STANDARD
#else
typedef char *	va_list;
#endif

#define va_dcl			int	va_alist;
#define va_count(count)		vaxc$va_count (&count)
#define va_start_1(ap, offset)	ap = (va_list) ((int) &va_alist + (offset))

#define va_start(ap)		ap = (va_list) &va_alist
#define va_arg(ap, type)	(ap = (va_list) ((int) ap + ((sizeof (type) + 3) & ~3)), \
 * (type *) ((int) ap - ((sizeof (type) + 3) & ~3)))
#define va_end(ap)		ap = (va_list) 0

#endif					/* __VARARGS_LOADED */
/**/
/******************************************************************************/
/**                                                                          **/
/**  Copyright (c) 1992                                                      **/
/**  by DIGITAL Equipment Corporation, Maynard, Mass.                        **/
/**                                                                          **/
/**  This software is furnished under a license and may be used and  copied  **/
/**  only  in  accordance  with  the  terms  of  such  license and with the  **/
/**  inclusion of the above copyright notice.  This software or  any  other  **/
/**  copies  thereof may not be provided or otherwise made available to any  **/
/**  other person.  No title to and ownership of  the  software  is  hereby  **/
/**  transferred.                                                            **/
/**                                                                          **/
/**  The information in this software is subject to change  without  notice  **/
/**  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  **/
/**  Corporation.                                                            **/
/**                                                                          **/
/**  DIGITAL assumes no responsibility for the use or  reliability  of  its  **/
/**  software on equipment which is not supplied by DIGITAL.                 **/
/**                                                                          **/
/******************************************************************************/
/********************************************************************************************************************************/
/* Created  6-NOV-1992 12:19:53 by VAX SDL V3.2-12     Source:  6-NOV-1992 12:15:54 VWSRESD$:[VWSDEF.OBJ]VWSSYSDEF.SDL;1 */
/********************************************************************************************************************************/
 
/*** MODULE $DOPDEF IDENT X-11 ***/
/*                                                                          */
/* Device Output Primitive (DOP)                                            */
/*                                                                          */
#define DOP$M_DELETE_BITMAP 1
#define DOP$M_SYSTEM_DOP 2
#define DOP$M_NO_RETURN 4
#define DOP$M_IGNORE 8
#define DOP$C_DRAW_LINES 1              /* Draw line(s), or polygon         */
#define DOP$C_DRAW_POINTS 2             /* Draw point                       */
#define DOP$C_FILL_POLYGON 3            /* Draw a filled polygon            */
#define DOP$C_FILL_POINT 4              /* Fill a point from a pattern      */
#define DOP$C_FILL_LINES 5              /* Fill a given line                */
#define DOP$C_DRAW_FIXED_TEXT 6         /* Draw text using a specified fixed spaced font */
#define DOP$C_DRAW_VAR_TEXT 7           /* Draw text using a variable speced font */
#define DOP$C_DRAW_COMPLEX_LINE 8       /* Draw a complex line with different end points */
#define DOP$C_EXPAN1 9                  /* Reserved to DIGITAL              */
#define DOP$C_EXPAN2 10                 /* Reserved to DIGITAL              */
#define DOP$C_EXPAN3 11                 /* Reserved to DIGITAL              */
#define DOP$C_EXPAN4 12                 /* Reserved to DIGITAL              */
#define DOP$C_EXPAN5 13                 /* Reserved to DIGITAL              */
#define DOP$C_EXPAN6 14                 /* Reserved to DIGITAL              */
#define DOP$C_EXPAN7 15                 /* Reserved to DIGITAL              */
#define DOP$C_EXPAN8 16                 /* Reserved to DIGITAL              */
#define DOP$C_DRAW_IMAGE 17             /* Draw image (w/ decompression & scaling) */
#define DOP$C_MOVE_ROTATE_AREA 18       /* Move area with rotation and scaling */
#define DOP$C_MOVE_AREA 19              /* Move area within a viewport      */
#define DOP$C_SCROLL_AREA 20            /* Move area in a viewport and fill vacated area with background */
#define DOP$C_STOP 21                   /* Stop removing entries from this request queue */
#define DOP$C_START 22                  /* Start removing entries from the specified DOP queue */
#define DOP$C_DELETE_BITMAP 23          /* Delete an offscreen bitmap       */
#define DOP$C_SUSPEND 24                /* Do not remove any more DOPs from this queue until the queue is resumed */
#define DOP$C_RESUME 25                 /* Resume processing DOPs on the specified queue */
#define DOP$C_MAX_ITEM_TYPE 26          /* (Maximum type code)              */
#define DOP$C_COMPARE_START 48          /* Offset to start of packet compare */
#define DOP$C_COMMON_LENGTH 68          /* Length of the Common block       */
#define DOP$C_TEXT_LENGTH 76            /* Length of this unique block      */
#define DOP$C_PLOT_LENGTH 78            /* Length of this unique block      */
#define DOP$C_LENGTH 78                 /* Length of Common block plus Unique block */
struct DOP_STRUCTURE {                  /* Device output primatives         */
    struct DOP_STRUCTURE *DOP$A_FLINK;  /* Forward link                     */
    struct DOP_STRUCTURE *DOP$A_BLINK;  /* Backward link                    */
    short int DOP$W_SIZE;               /* Size of structure                */
    char DOP$B_TYPE;                    /* Type of structure                */
    char DOP$B_SUB_TYPE;                /* Sub type of structure            */
    long int DOP$L_DEC_RESERVED;        /* Reserved to DIGITAL              */
    long int DOP$L_DEC_RESERVED2;       /* Reserved to DIGITAL              */
    long int DOP$L_USER_RESERVED;       /* Reserved to user                 */
    union  {
        unsigned short int DOP$W_FLAGS; /* Flags word                       */
        struct  {
            struct  {
                unsigned DOP$V_DELETE_BITMAP : 1; /* Delete the offscreen source bitmap */
                unsigned DOP$V_SYSTEM_DOP : 1; /* Return DOP to the system-wide DOP queue */
                unsigned DOP$V_NO_RETURN : 1; /* Don't return this DOP to the return queues */
                unsigned DOP$V_IGNORE : 1; /* DOP returned by VPS for freeing */
                unsigned DOP$V_fill_2 : 4;
                } DOP$R_FLAG_BITS;
            } DOP$r_fill_1;
        } DOP$r_fill_0;
    short int DOP$W_OP_COUNT;           /* Number of operations in packet   */
    short int DOP$W_ITEM_TYPE;          /* Item type                        */
/*                                                                          */
/* Note: there is code that depends on the order of this list. Do not change it without code changes */
/*                                                                          */
    short int DOP$W_MODE;               /* Hardware writing mode            */
    union  {
        int DOP$Q_MASK_AND_INDEX [2];
        struct  {
            long int DOP$L_MASK;        /* Plane mask                       */
            long int DOP$L_SOURCE_INDEX; /* Source index                    */
            } DOP$r_fill_4;
        } DOP$r_fill_3;
    union  {
        int DOP$Q_COLORS [2];
        struct  {
            long int DOP$L_FCOLOR;      /* Foreground color index           */
            long int DOP$L_BCOLOR;      /* Background color index           */
            } DOP$r_fill_6;
        } DOP$r_fill_5;
    union  {
        int DOP$Q_BITMAP_INFO [2];
        struct  {
            unsigned long int DOP$L_BITMAP_ID; /* Bitmap ID or 0 if operation is not source bitmap relative */
            long int DOP$L_BITMAP_GLYPHS; /* Bitmap back in store address   */
            } DOP$r_fill_8;
        } DOP$r_fill_7;
    union  {
        int DOP$Q_MAX_AND_DELTA [2];
        struct  {
            short int DOP$W_VP_MAX_X;   /* Viewport relative device coordinate max x */
            short int DOP$W_VP_MAX_Y;   /* Viewport relative device coordinate max y */
            short int DOP$W_DELTA_X;    /* Delta from viewport lower left to clipping rectangle lower left */
            short int DOP$W_DELTA_Y;    /* Delta from viewport lower left to clipping rectangle lower left */
            } DOP$r_fill_10;
        } DOP$r_fill_9;
    short int DOP$W_VP_MIN_X;           /* Viewport relative device coordinate min x */
    short int DOP$W_VP_MIN_Y;           /* Viewport relative device coordinate min y */
    union  {                            /* Unique block                     */
        struct  {                       /* Unique block for DRAW_FIXED_TEXT and DRAW_VAR_TEXT */
            short int DOP$W_TEXT_HEIGHT; /* The cell height (constant per font) */
            short int DOP$W_TEXT_WIDTH; /* The width of all of the text cells if fixed text or 0 */
            short int DOP$W_TEXT_STARTING_X; /* Text                        */
            short int DOP$W_TEXT_STARTING_Y; /* Starting position           */
            } DOP$R_TEXT_ARGS;
        struct  {                       /* Unique block for DRAW_POINTS, DRAW_LINES, FILL_POINTS and FILL_POLYGON */
            short int DOP$W_PLOT_FILL_WIDTH; /* Width of fill pattern in bits */
            short int DOP$W_PLOT_FILL_HEIGHT; /* Height of fill pattern in bits */
            short int DOP$W_PLOT_FILL_PATTERN_X; /* Address of bitmap fill pattern */
            short int DOP$W_PLOT_FILL_PATTERN_Y; /* ...                     */
            short int DOP$W_PLOT_LINE_WIDTH; /* Line width for DRAW_LINES   */
            } DOP$R_PLOT_ARGS;
        struct  {                       /* Unique block for MOVE_AREA, SCROLL_AREA, and MOVE_ROTATE_AREA */
            long int DOP$L_MOVE_SMOOTH; /* Timing information for smooth scroll in SCROLL_AREA */
            } DOP$R_MOVE_ARGS;
        struct  {                       /* Unique block for STOP, START, SUSPEND, and RESUME */
            unsigned long int DOP$L_DRIVER_VP_ID; /* Driver viewport ID     */
            } DOP$R_STOP_ARGS;
        } DOP$R_ARGS;
    } ;
/*                                                                          */
/* Variable block for DRAW_POINTS and FILL_POINT                            */
/*                                                                          */
#define DOP_POINT$C_LENGTH 4            /* Length of this variable block    */
struct DOP_POINT_ARRAY {
    short int DOP_POINT$W_X;            /* X coordinate of the point to draw */
    short int DOP_POINT$W_Y;            /* Y coordinate of the point to draw */
    }  ;
/*                                                                          */
/* Variable block for DRAW_COLORED_POINTS                                   */
/*                                                                          */
#define DOP_C_POINT$C_LENGTH 6          /* Length of this variable block    */
struct DOP_C_POINT_ARRAY {
    short int DOP_C_POINT$W_X;          /* X coordinate of the point to draw */
    short int DOP_C_POINT$W_Y;          /* Y coordinate of the point to draw */
    short int DOP_C_POINT$W_COLOR;      /* Writing index (color)            */
    }  ;
/*                                                                          */
/* Variable block for DRAW_LINES and FILL_LINES                             */
/*                                                                          */
#define DOP_LINE$C_LENGTH 8             /* Length of this variable block    */
struct DOP_LINE_ARRAY {
    short int DOP_LINE$W_X1;            /* X coordinate of the starting point of the line */
    short int DOP_LINE$W_Y1;            /* Y coordinate of the starting point of the line */
    short int DOP_LINE$W_X2;            /* X coordinate of the ending point of the line */
    short int DOP_LINE$W_Y2;            /* Y coordinate of the ending point of the line */
    }  ;
/*                                                                          */
/* Variable block for DRAW_FIXED_TEXT                                       */
/*                                                                          */
#define DOP_FTEXT$C_LENGTH 4            /* Length of this variable block    */
struct DOP_FTEXT_ARRAY {
    short int DOP_FTEXT$W_OFFSET_X;     /* X coordinate of the offset into the font where the character is located */
    short int DOP_FTEXT$W_OFFSET_Y;     /* Y coordinate of the offset into the font where the character is located */
    }  ;
/*                                                                          */
/* Variable block for DRAW_VARIABLE_TEXT                                    */
/*                                                                          */
#define DOP_VTEXT$C_LENGTH 6            /* Length of this variable block    */
struct DOP_VTEXT_ARRAY {
    short int DOP_VTEXT$W_OFFSET_X;     /* X coordinate of the offset into the font where the character is located */
    short int DOP_VTEXT$W_OFFSET_Y;     /* Y coordinate of the offset into the font where the character is located */
    short int DOP_VTEXT$W_WIDTH;        /* Width of specified character     */
    }  ;
/*                                                                          */
/* Variable block for FILL_POLYGON                                          */
/*                                                                          */
#define DOP_POLY$C_LENGTH 16            /* Length of this variable block    */
struct DOP_POLY_ARRAY {
/* Define the line that defines the left edge                               */
    short int DOP_POLY$W_LEFT_X1;       /* X coordinate of the starting point of the line */
    short int DOP_POLY$W_LEFT_Y1;       /* Y coordinate of the starting point of the line */
    short int DOP_POLY$W_LEFT_X2;       /* X coordinate of the ending point of the line */
    short int DOP_POLY$W_LEFT_Y2;       /* Y coordinate of the ending point of the line */
/* Define the line that defines the right edge                              */
    short int DOP_POLY$W_RIGHT_X1;      /* X coordinate of the starting point of the line */
    short int DOP_POLY$W_RIGHT_Y1;      /* Y coordinate of the starting point of the line */
    short int DOP_POLY$W_RIGHT_X2;      /* X coordinate of the ending point of the line */
    short int DOP_POLY$W_RIGHT_Y2;      /* Y coordinate of the ending point of the line */
    }  ;
/*                                                                          */
/* Variable block for DRAW_IMAGE                                            */
/*                                                                          */
#define DOP_IMAGE$c_NONE 1              /* NOT compressed                   */
#define DOP_IMAGE$c_G3_1D 2             /* Compression is Group 3 One Dimensional */
#define DOP_IMAGE$c_G3_2D 3             /* Compression is Group 3 Two Dimensional */
#define DOP_IMAGE$c_G4_2D 4             /* Compression is Group 4 Two Dimensional */
#define DOP_IMAGE$M_MIRROR 1
#define DOP_IMAGE$C_LENGTH 40           /* Length of this variable block    */
struct DOP_IMAGE_ARRAY {
    long int DOP_IMAGE$L_BUFFER_ADDRESS; /* Address of Image buffer         */
    long int DOP_IMAGE$L_BUFFER_SIZE;   /* The image buffer size            */
    short int DOP_IMAGE$W_WIDTH;        /* The width of the image in pixels */
    short int DOP_IMAGE$W_HEIGHT;       /* The height of the image in pixels */
    short int DOP_IMAGE$W_ROTATION;     /* Degrees rotation of the displayed image */
    char DOP_IMAGE$B_ENCODING;          /* CCITT compression type used      */
    char DOP_IMAGE$B_K_VALUE;           /* K Value for G3_2D Compression    */
    long int DOP_IMAGE$L_ENCODING_OPTIONS; /* Other encoding options        */
    short int DOP_IMAGE$W_WINDOW_TOP_X; /* Upper right corner of displayable rectangle */
    short int DOP_IMAGE$W_WINDOW_TOP_Y; /* Upper right corner of displayable rectangle */
    short int DOP_IMAGE$W_WINDOW_BOTTOM_X; /* Lower left corner of displayable rectangle */
    short int DOP_IMAGE$W_WINDOW_BOTTOM_Y; /* Lower left corner of displayable rectangle */
    char DOP_IMAGE$B_XM;                /* M in X scaling M:N ratio         */
    char DOP_IMAGE$B_XN;                /* N in X scaling M:N ratio         */
    char DOP_IMAGE$B_YM;                /* M in Y scaling M:N ratio         */
    char DOP_IMAGE$B_YN;                /* N in Y scaling M:N ratio         */
    long int DOP_IMAGE$L_KERNELS_ADDRESS; /* Address of convolution kernels */
    char DOP_IMAGE$B_THRESHOLD_1;       /* Convolution threshold 1          */
    char DOP_IMAGE$B_THRESHOLD_2;       /* Convolution threshold 2          */
    char DOP_IMAGE$B_THRESHOLD_3;       /* Convolution threshold 3          */
    union  {
        char DOP_IMAGE$B_FLAGS;         /* Scaling/Display Options          */
        struct  {
            struct  {
                unsigned DOP_IMAGE$V_MIRROR : 1; /* Mirror image across Y axis */
                unsigned DOP_IMAGE$V_fill_13 : 7;
                } DOP_IMAGE$R_FLAG_BITS;
            } DOP_IMAGE$r_fill_12;
        } DOP_IMAGE$r_fill_11;
    }  ;
/*                                                                          */
/* Variable block for MOVE_AREA and SCROLL_AREA                             */
/*                                                                          */
#define DOP_MOVE$C_LENGTH 14            /* Length of this variable block    */
struct DOP_MOVE_ARRAY {
    short int DOP_MOVE$W_FILLER;        /* Filler to allow overlaying with the TPB */
/* Define the source area                                                   */
    short int DOP_MOVE$W_X_SOURCE;      /* X coordinate of the lower left corner in absolute device coordinates */
    short int DOP_MOVE$W_Y_SOURCE;      /* Y coordinate of the lower left corner in absolute device coordinates */
    short int DOP_MOVE$W_WIDTH;         /* Width in device coordinates      */
    short int DOP_MOVE$W_HEIGHT;        /* Height in device coordinates     */
/* Define the target area (same size as source)                             */
    short int DOP_MOVE$W_X_TARGET;      /* X coordinate of the lower left corner in absolute device coordinates */
    short int DOP_MOVE$W_Y_TARGET;      /* Y coordinate of the lower left corner in absolute device coordinates */
    }  ;
/*                                                                          */
/* Variable block for MOVE/ROTATE AREA and DRAW COMPLEX LINE                */
/*                                                                          */
/* All changes to DOP_MOVE_R_ARRAY must also be reflected below in DOP_MVR_ARRAY */
/*                                                                          */
#define DOP_MOVE_R$C_LENGTH 26          /* Length of this variable block    */
struct DOP_MOVE_R_ARRAY {
    short int DOP_MOVE_R$W_FILLER;      /* Filler to allow overlaying with the TPB */
    short int DOP_MOVE_R$W_X_SOURCE;    /* Lower left corner x in absolute device coordinates */
    short int DOP_MOVE_R$W_Y_SOURCE;    /* Lower left corner y in absolute device coordinates */
    short int DOP_MOVE_R$W_WIDTH;       /* Width in device coordinates      */
    short int DOP_MOVE_R$W_HEIGHT;      /* Height in device coordinates     */
    short int DOP_MOVE_R$W_X_TARGET;    /* Lower left corner x of bitmap target */
    short int DOP_MOVE_R$W_Y_TARGET;    /* Lower left corner y of bitmap target */
/* Target vector 1 traces the source in the x direction and is used         */
/*  to rotate the source rectangle to a target parallelogram                */
    short int DOP_MOVE_R$W_X_TARGET_VEC1; /* X of end point of target vector 1 */
    short int DOP_MOVE_R$W_Y_TARGET_VEC1; /* Y of end point of target vector 1 */
    short int DOP_MOVE_R$W_L_TARGET_VEC1; /* Length of target vector 1 used for scaling in x */
/*  (if eql to source width then no scaling)                                */
/* Target vector 2 traces the source in the y direction for rotation and is */
/*  used to rotate the source rectangle to a target parallelogram           */
    short int DOP_MOVE_R$W_X_TARGET_VEC2; /* X of end point of target vector 2 */
    short int DOP_MOVE_R$W_Y_TARGET_VEC2; /* Y of end point of target vector 2 */
    short int DOP_MOVE_R$W_L_TARGET_VEC2; /* Length of target vector 2 used for scaling in y */
/*  (if eql to source height then no scaling)                               */
    }  ;
/*                                                                          */
/* Synonym for MOVE_ROTATE_AREA to keep SDA's FORMAT/TYPE=DOP_MVR happy     */
/* All changes to DOP_MOVE_R_ARRAY must also be reflected here!             */
/*                                                                          */
#define DOP_MVR$C_LENGTH 26             /* Length of this variable block    */
struct DOP_MVR_ARRAY {
    short int DOP_MVR$W_FILLER;         /* Filler to allow overlaying with the TPB */
    short int DOP_MVR$W_X_SOURCE;       /* Lower left corner x in absolute device coordinates */
    short int DOP_MVR$W_Y_SOURCE;       /* Lower left corner y in absolute device coordinates */
    short int DOP_MVR$W_WIDTH;          /* Width in device coordinates      */
    short int DOP_MVR$W_HEIGHT;         /* Height in device coordinates     */
    short int DOP_MVR$W_X_TARGET;       /* Lower left corner x of bitmap target */
    short int DOP_MVR$W_Y_TARGET;       /* Lower left corner y of bitmap target */
/* Target vector 1 traces the source in the x direction and is used         */
/*  to rotate the source rectangle to a target parallelogram                */
    short int DOP_MVR$W_X_TARGET_VEC1;  /* X of end point of target vector 1 */
    short int DOP_MVR$W_Y_TARGET_VEC1;  /* Y of end point of target vector 1 */
    short int DOP_MVR$W_L_TARGET_VEC1;  /* Length of target vector 1 used for scaling in x */
/*  (if eql to source width then no scaling)                                */
/* Target vector 2 traces the source in the y direction for rotation and is */
/*  used to rotate the source rectangle to a target parallelogram           */
    short int DOP_MVR$W_X_TARGET_VEC2;  /* X of end point of target vector 2 */
    short int DOP_MVR$W_Y_TARGET_VEC2;  /* Y of end point of target vector 2 */
    short int DOP_MVR$W_L_TARGET_VEC2;  /* Length of target vector 2 used for scaling in y */
/*  (if eql to source height then no scaling)                               */
    }  ;
 
/*** MODULE $fntdef IDENT V3-8D1 ***/
#define fnt$k_major_version 3
#define fnt$k_minor_version 7
#define fnt$c_gut_per_inch 7200
#define fnt$m_fixed 1
#define fnt$m_celleqrast 2
#define fnt$m_nokerning 4
#define fnt$m_wysiwyg 8
#define fnt$m_qvss 16
#define fnt$m_qdss 32
#define fnt$m_user_font 64
#define fnt$m_procperm 128
#define fnt$k_check1 1819044162
#define fnt$k_check2 2036625226
#define fnt$c_length 256
struct fnt_structure {
    int *fnt$a_flink;
    int *fnt$a_blink;
    short int fnt$w_size;
    char fnt$b_type;
    char fnt$b_subtype;
    int *fnt$a_qd_pos;
    int *fnt$a_qd_font_ids;
    union  {
        short int fnt$w_flags;
        struct  {
            unsigned fnt$v_fixed : 1;
            unsigned fnt$v_celleqrast : 1;
            unsigned fnt$v_nokerning : 1;
            unsigned fnt$v_wysiwyg : 1;
            unsigned fnt$v_qvss : 1;
            unsigned fnt$v_qdss : 1;
            unsigned fnt$v_user_font : 1;
            unsigned fnt$v_procperm : 1;
            } fnt$r_flags_structure;
        } fnt$r_flags_union;
    unsigned short int fnt$w_font_id_length;
    char fnt$t_font_id [56];
    int *fnt$a_widths;
    int *fnt$a_cwidths;
    long int fnt$l_array;
    long int fnt$l_font_size;
    long int fnt$l_gutperpix_x;
    long int fnt$l_gutperpix_y;
    unsigned short int fnt$w_fc;
    unsigned short int fnt$w_lc;
    long int fnt$l_cell_height;
    long int fnt$l_baseline;
    long int fnt$l_cell_width;
    long int fnt$l_und_x;
    long int fnt$l_und_xo;
    long int fnt$l_und_y;
    long int fnt$l_und_yo;
    long int fnt$l_str_x;
    long int fnt$l_str_xo;
    long int fnt$l_str_y;
    long int fnt$l_str_yo;
    long int fnt$l_sub_xo;
    long int fnt$l_sub_yo;
    long int fnt$l_super_xo;
    long int fnt$l_super_yo;
    short int fnt$w_vws_fvers_major;
    short int fnt$w_vws_fvers_minor;
    short int fnt$w_cfff_fvers_major;
    short int fnt$w_cfff_fvers_minor;
    long int fnt$l_check1;
    long int fnt$l_check2;
    short int fnt$w_max_cell_width;
    short int fnt$w_widest_glyph;
    short int fnt$w_average_width_gut;
    short int fnt$w_wys_baseline_err;
    short int fnt$w_wys_cheight_err;
    short int fnt$w_wys_max_cell_err;
    int *fnt$a_wys_err_gut;
    int *fnt$a_qdfnt_base;
    int *fnt$a_qdfnt_0;
    int *fnt$a_qdfnt_1;
    int *fnt$a_qdfnt_2;
    int *fnt$a_qdfnt_3;
    int *fnt$a_qdfnt_4;
    int *fnt$a_qdfnt_5;
    int *fnt$a_qdfnt_6;
    int *fnt$a_qdfnt_7;
    int *fnt$a_ard;
    short int fnt$w_qd_user_chan [8];
    } ;
#define gly$c_length 12
struct gly_structure {
    long int gly$l_cell_width;
    short int gly$w_align_x;
    short int gly$w_align_y;
    short int gly$w_raster_width;
    short int gly$w_raster_height;
    char gly$g_bitmap;
    } ;
#define qgbd$c_length 16
struct qgbd_structure {
    long int qgbd$l_fid;
    int *qgbd$a_gblock;
    long int qgbd$l_height;
    long int qgbd$l_gb_size;
    } ;
#define fntid$c_length 30
struct fntid_structure {
    char fntid$t_owner [2];
    char fntid$t_name [6];
    char fntid$t_modifiers [6];
    char fntid$t_pitch;
    char fntid$t_point_size [2];
    char fntid$t_char_set [2];
    char fntid$t_indiv_char [2];
    char fntid$t_rotation [3];
    char fntid$t_formatting;
    char fntid$t_resolution;
    char fntid$t_filler1 [2];
    char fntid$t_filler2 [2];
    } ;
 
/*** MODULE $ftdef IDENT X0.6 ***/
/* THIS IS THE SAME AS FNTDEF2.SDL, EXCEPT THAT ALL REFERENCES TO "FNT"     */
/* ARE REPLACED WITH "FT", TO AVOID CONFLICTS WITH FNTDEF.SDL               */
/*                                                                          */
/*			  Copyright (c) 1984 by                             */
/*	      DIGITAL EQUIPMENT CORPORATION, Maynard, Mass.                 */
/*                                                                          */
/*This software is furnished under a license and may be used and  copied    */
/*only  in  accordance  with  the  terms  of  such  license and with the    */
/*inclusion of the above copyright notice.  This software or  any  other    */
/*copies  thereof may not be provided or otherwise made available to any    */
/*other person.  No title to and ownership of  the  software  is  hereby    */
/*transferred.                                                              */
/*                                                                          */
/*The information in this software is subject to change  without  notice    */
/*and  should  not  be  construed  as  a commitment by DIGITAL EQUIPMENT    */
/*CORPORATION.                                                              */
/*                                                                          */
/*DIGITAL assumes no responsibility for the use or  reliability  of  its    */
/*software on equipment which is not supplied by DIGITAL.                   */
/*                                                                          */
/*++                                                                        */
/*FACILITY: DEC Standard Font File Format                                   */
/*                                                                          */
/*ABSTRACT: Data structures for accessing the DEC Standard Font File Format */
/*                                                                          */
/*                                                                          */
/*ENVIRONMENT: Transportable                                                */
/*                                                                          */
/*AUTHOR: Bill Laurune (BL)	 CREATION DATE: 29 June 1984                */
/*                                                                          */
/*MODIFIED BY:                                                              */
/*                                                                          */
/*12-JULY-1984	X0.1	RWF	Add copyright notice                        */
/*23-JULY-1984	X0.2	BL	Update to 20-July-1984 spec,                */
/*				remove bitfield FILL so as to generate      */
/*				proper C code, shorten some variable names  */
/*07-AUG-1984	X0.3	RWF	Remove forward_slant and no_space           */
/*07-SEP-1984   X0.4    RWF	Definitive version                          */
/*10-SEP-1984   X0.5	RWF	Change seg$ to sub$                         */
/*10-SEP-1984	X0.6	BL	Remove _pointer, add parameter_size constants, */
/*				change vertical_size to UNSIGNED, rename    */
/*				char_param_size constant, add fnt$c_trailer_size, */
/*				ascender & descender made signed values     */
/*--                                                                        */
#define ft$c_gut_per_inch 7200
#define ft$c_current_format_version 1
#define ft$c_trailer_size 8
#define ft$m_directory_only 1
#define ft$m_self_contained 2
#define ft$m_dimensions_only 4
#define ft$m_expanded_rasters 8
#define ft$m_compressed_rasters 16
#define ft$m_ident_orient 32
#define ft$m_wysiwyg 64
#define ft$m_large_values 128
#define ft$m_generic 1
#define ft$m_roman 2
#define ft$m_gothic 4
#define ft$m_italic 8
#define ft$m_slant 16
#define ft$m_monospaced 32
#define ft$m_shadow 64
#define ft$m_outline 128
#define ft$m_inline 256
#define ft$m_contour 512
#define ft$m_connecting_script 1024
#define ft$m_nonconnecting_script 2048
#define ft$m_reverse 4096
#define ft$m_serif 8192
#define ft$m_underlined_font 16384
#define ft$m_overlined_font 32768
#define ft$m_struck_through 65536
#define ft$c_ultra_light 4
#define ft$c_extra_light 7
#define ft$c_thin 10
#define ft$c_semi_light 13
#define ft$c_regular_weight 16
#define ft$c_medium_weight 19
#define ft$c_semi_bold 22
#define ft$c_bold 25
#define ft$c_extra_bold 28
#define ft$c_heavy 28
#define ft$c_black 31
#define ft$c_ultra_bold 31
#define ft$c_ultra_heavy 31
#define ft$c_ultra_expanded 4
#define ft$c_extra_expanded 7
#define ft$c_expanded 10
#define ft$c_semi_expanded 13
#define ft$c_regular_prop 16
#define ft$c_medium_prop 19
#define ft$c_semi_condensed 22
#define ft$c_condensed 25
#define ft$c_extra_condensed 28
#define ft$c_ultra_condensed 31
#define ft$c_generic_device 0
#define ft$c_xp12_toning 1
#define ft$c_xp24_toning 1
#define ft$c_ln03_toning 2
#define ft$m_inside_box 1
#define ft$m_celleqrast 2
#define ft$c_header_length 480
struct ft_structure {
    unsigned long int ft$l_byte_count;
    char ft$t_font_align_string [4];
    unsigned short int ft$w_major_version;
    unsigned short int ft$w_variant;
    unsigned short int ft$w_font_file_id_length;
    unsigned short int ft$w_font_file_id_reserved;
    unsigned long int ft$a_font_file_id;
    char ft$t_font_file_id [64];
    unsigned long int ft$l_revision_number;
    unsigned short int ft$w_year;
    unsigned short int ft$w_month;
    unsigned short int ft$w_day;
    unsigned short int ft$w_hour;
    unsigned short int ft$w_minute;
    unsigned short int ft$w_second;
    unsigned long int ft$l_font_attrib_length;
    unsigned long int ft$a_font_attrib;
    unsigned long int ft$l_font_parameters_length;
    unsigned long int ft$a_font_parameters;
    unsigned long int ft$l_char_directory_length;
    unsigned long int ft$a_char_directory;
    unsigned long int ft$l_subset_tables_length;
    unsigned long int ft$a_subset_tables;
    unsigned long int ft$l_future_info_length;
    unsigned long int ft$a_future_info;
    unsigned long int ft$l_string_pool_length;
    unsigned long int ft$a_string_pool;
    unsigned long int ft$l_kerning_info_length;
    unsigned long int ft$a_kerning_info;
    unsigned long int ft$l_char_definitions_length;
    unsigned long int ft$a_char_definitions;
    unsigned long int ft$l_first_character;
    unsigned long int ft$l_last_character;
    unsigned long int ft$l_less_than_locator;
    unsigned long int ft$l_greater_than_locator;
    unsigned long int ft$l_error_locator;
    unsigned long int ft$l_extension_count;
    unsigned long int ft$l_extension_use;
    unsigned long int ft$l_space_encoding;
    struct  {
        unsigned ft$v_directory_only : 1;
        unsigned ft$v_self_contained : 1;
        unsigned ft$v_dimensions_only : 1;
        unsigned ft$v_expanded_rasters : 1;
        unsigned ft$v_compressed_rasters : 1;
        unsigned ft$v_ident_orient : 1;
        unsigned ft$v_wysiwyg : 1;
        unsigned ft$v_large_values : 1;
        unsigned ft$v_unused_org_flags : 24;
        } ft$l_organization_flags;
    unsigned long int ft$l_parameters_size;
    unsigned long int ft$l_infile_locators;
    unsigned long int ft$l_null_locators;
    unsigned long int ft$l_character_definitions;
    unsigned long int ft$l_alternate_blocks;
    unsigned long int ft$l_raster_count;
    unsigned long int ft$l_compressed_raster_count;
    unsigned long int ft$l_portrait_byte_count;
    unsigned long int ft$l_landscape_byte_count;
    unsigned long int ft$l_mixed_byte_count;
    unsigned long int ft$l_portrait_compressed;
    unsigned long int ft$l_landscape_compressed;
    unsigned long int ft$l_mixed_compressed;
    struct  {
        unsigned ft$v_generic : 1;
        unsigned ft$v_roman : 1;
        unsigned ft$v_gothic : 1;
        unsigned ft$v_italic : 1;
        unsigned ft$v_slant : 1;
        unsigned ft$v_monospaced : 1;
        unsigned ft$v_shadow : 1;
        unsigned ft$v_outline : 1;
        unsigned ft$v_inline : 1;
        unsigned ft$v_contour : 1;
        unsigned ft$v_connecting_script : 1;
        unsigned ft$v_nonconnecting_script : 1;
        unsigned ft$v_reverse : 1;
        unsigned ft$v_serif : 1;
        unsigned ft$v_underlined_font : 1;
        unsigned ft$v_overlined_font : 1;
        unsigned ft$v_struck_through : 1;
        unsigned ft$v_unused_fontid_flags : 15;
        } ft$l_fontat_flags;
    unsigned short int ft$w_char_set_length;
    unsigned short int ft$w_char_set_reserved;
    unsigned long int ft$a_char_set;
    unsigned short int ft$w_family_id_length;
    unsigned short int ft$w_family_id_reserved;
    unsigned long int ft$a_family_id;
    unsigned short int ft$w_family_name_length;
    unsigned short int ft$w_family_name_reserved;
    unsigned long int ft$a_family_name;
    unsigned short int ft$w_font_id_length;
    unsigned short int ft$w_font_id_reserved;
    unsigned long int ft$a_font_id;
    unsigned short int ft$w_category_length;
    unsigned short int ft$w_category_reserved;
    unsigned long int ft$a_category;
    unsigned short int ft$w_description_length;
    unsigned short int ft$w_description_reserved;
    unsigned long int ft$a_description;
    unsigned short int ft$w_type_size_whole;
    unsigned short int ft$w_type_size_fraction;
    unsigned long int ft$l_character_width;
    unsigned long int ft$l_resolution;
    unsigned long int ft$l_font_weight;
    unsigned long int ft$l_horizontal_proportion;
    short int ft$w_width_fract_num;
    short int ft$w_width_fract_denom;
    unsigned short int ft$w_aspect_ratio_x;
    unsigned short int ft$w_aspect_ratio_y;
    short int ft$w_up_vector_opposite;
    short int ft$w_up_vector_adjacent;
    unsigned long int ft$l_device;
    unsigned short int ft$w_foundry_length;
    unsigned short int ft$w_foundry_reserved;
    unsigned long int ft$a_foundry;
    unsigned short int ft$w_designer_length;
    unsigned short int ft$w_designer_reserved;
    unsigned long int ft$a_designer;
    struct  {
        unsigned ft$v_inside_box : 1;
        unsigned ft$v_celleqrast : 1;
        unsigned ft$v_unused_param_flags : 30;
        } ft$l_font_parameter_flags;
    long int ft$l_underline_offset;
    unsigned long int ft$l_underline_thickness;
    long int ft$l_strikethru_offset;
    unsigned long int ft$l_strikethru_thickness;
    long int ft$l_overline_offset;
    unsigned long int ft$l_overline_thickness;
    short int ft$w_slant_opposite;
    short int ft$w_slant_adjacent;
    short int ft$w_shadow_offset_opposite;
    short int ft$w_shadow_offset_adjacent;
    long int ft$l_superscript_vertical;
    long int ft$l_superscript_horizontal;
    long int ft$l_subscript_vertical;
    long int ft$l_subscript_horizontal;
    unsigned long int ft$l_center_line;
    unsigned long int ft$l_minimum_space;
    unsigned long int ft$l_maximum_space;
    unsigned long int ft$l_space_width;
    unsigned long int ft$l_em_space;
    unsigned long int ft$l_en_space;
    unsigned long int ft$l_thin_space;
    unsigned long int ft$l_digit_space;
    long int ft$l_top_line;
    long int ft$l_floating_accent_line;
    long int ft$l_half_line;
    unsigned long int ft$l_vertical_size;
    long int ft$l_ascender;
    long int ft$l_descender;
    unsigned long int ft$l_cap_h_height;
    unsigned long int ft$l_small_x_height;
    long int ft$l_top_leading;
    long int ft$l_bottom_leading;
    } ;
struct subset_tables {
    unsigned long int sub$l_font_subset_count;
    unsigned long int sub$l_font_subset_dscs;
    } ;
struct future_information {
    unsigned long int ftr$l_data_length;
    unsigned long int ftr$l_data_type;
    } ;
#define krn$c_sectored_kerning 0
struct kerning_structure {
    unsigned long int krn$l_total_size;
    unsigned long int krn$l_kerning_format;
    struct  {
        unsigned short int krn$w_number_of_sets;
        unsigned short int krn$w_number_of_sectors;
        short int krn$w_kerning_values;
        } krn$r_kerning_data;
    } ;
#define gly$m_no_raster 256
#define gly$m_right_align 512
#define gly$m_left_align 1024
#define gly$m_no_underline 2048
#define gly$m_no_overline 4096
#define gly$m_no_thruline 8192
#define gly$m_punctuation 16384
#define gly$m_inside_box 32768
#define gly$m_complete 65536
#define gly$m_alternate 268435456
#define gly$m_extension_index 536870912
#define gly$m_alternate_exists 1073741824
#define gly$m_flag -2147483648
#define gly$c_parameters_size 16
struct glyph_structure {
    struct  {
        unsigned gly$b_kerning_index : 8;
        unsigned gly$v_no_raster : 1;
        unsigned gly$v_right_align : 1;
        unsigned gly$v_left_align : 1;
        unsigned gly$v_no_underline : 1;
        unsigned gly$v_no_overline : 1;
        unsigned gly$v_no_thruline : 1;
        unsigned gly$v_punctuation : 1;
        unsigned gly$v_inside_box : 1;
        unsigned gly$v_complete : 1;
        unsigned gly$v_unused_glyph_flags : 11;
        unsigned gly$v_alternate : 1;
        unsigned gly$v_extension_index : 1;
        unsigned gly$v_alternate_exists : 1;
        unsigned gly$v_flag : 1;
        } gly$l_glyph_flags;
    long int gly$l_width;
    long int gly$l_left_bearing;
    long int gly$l_baseline;
    } ;
#define cras$c_parameters_size 12
struct compressed_raster {
    unsigned char cras$b_orientation;
    unsigned char cras$b_type1;
    unsigned char cras$b_type2;
    unsigned char cras$b_unused;
    unsigned short int cras$w_rows;
    unsigned short int cras$w_columns;
    unsigned short int cras$w_rows_pointer;
    unsigned short int cras$w_counts;
    unsigned char cras$b_counts_vector;
    } ;
#define ras$c_parameters_size 8
#define ras$c_p 0
#define ras$c_lm 1
#define ras$c_pm 2
#define ras$c_li 3
#define ras$c_pmi 4
#define ras$c_pi 6
#define ras$c_l 5
#define ras$c_lmi 7
#define ras$c_expanded 129
#define ras$c_compress 0
#define ras$c_nibbles 0
#define ras$c_bytes 1
struct expanded_raster {
    unsigned char ras$b_orientation;
    unsigned char ras$b_type1;
    unsigned char ras$b_type2;
    unsigned char ras$b_unused;
    unsigned short int ras$w_rows;
    unsigned short int ras$w_columns;
    unsigned char ras$b_raster;
    } ;
 
/*** MODULE $qvbdef ***/
/*                                                                          */
/* QVSS driver SETMODE function modifier codes                              */
/*                                                                          */
#define io$c_qv_enakb 2                 /* Enable/disable keyboard ASTs     */
#define io$c_qv_enabutton 3             /* Enable/disable mouse button ASTs */
#define io$c_qv_mousemov 4              /* Enable/disable mouse movement ASTs */
#define io$c_qv_setcursor 5             /* Set hardware cursor pattern      */
#define io$c_qv_enauser 6               /* Add entry to user's list         */
#define io$c_qv_enafnkey 7              /* Enable function key              */
#define io$c_qv_sound 8                 /* Enable BELL or KEYCLICK          */
#define io$c_qv_initialize 9            /* Initialize QVSS screen (remove operator) */
#define io$c_qv_modifykb 10             /* Modify keyboard characteristics  */
#define io$c_qv_modifysys 11            /* Modify system wide characteristics */
#define io$c_qv_altappl 12              /* Set up for alternate window application. */
#define io$c_qv_simulate 13             /* Simulate an event                */
#define io$c_qv_push 14                 /* Push an entry on a list          */
#define io$c_qv_pop 15                  /* Pop an entry on a list           */
#define io$c_qv_load_key_table 16       /* Load a keyboard table            */
#define io$c_qv_use_default_table 17    /* Use a system default table       */
#define io$c_qv_load_compose_table 18   /* Load a compose sequence table    */
#define io$c_qv_enable_digitizing 19    /* digitize region                  */
#define io$c_qv_load_compose_lock_table 20 /* Reserved to Digital           */
/*                                                                          */
/* QDSS Driver SETMODE Function codes                                       */
/*                                                                          */
#define io$c_QD_STOP 512                /* Stop one viewport                */
#define io$c_QD_START 513               /* Start one viewport               */
#define io$c_QD_SET_VIEWPORT_REGIONS 514 /* Setup a new set of regions for this viewport */
#define io$c_QD_EXECUTE_DEFERRED 515    /* start the drawing operations that are on the deferred */
#define io$c_QD_DELETE_DEFERRED 516     /* remove any remaining entries from the deferred list */
#define io$c_QD_LOAD_BITMAP 517         /* Load a source bitmap             */
#define io$c_QD_SET_COLOR 518           /* set a color map entry            */
#define io$c_QD_COLOR_CHAR 519          /* set COLOR characteristics        */
#define io$c_QD_RESUME_VP 520           /* Resume a suspended viewport      */
#define io$c_QD_SUSPEND_VP 521          /* Suspend a viewport               */
#define io$c_QD_HOLD 522                /* HOLD SCREEN THE SYSTEM           */
#define io$c_QD_NO_HOLD 523             /* RESUME THE SCREEN ACTIVITY       */
#define io$c_AV_SET_KERNEL_SET 524      /* Assign a default Kernel Set, AVSS specific */
#define io$c_QD_LOAD_FONT 517
/*                                                                          */
/* QVSS Driver Sensemode function codes                                     */
/*                                                                          */
#define IO$c_qv_getsys 1                /* Get QVB address                  */
#define IO$c_qv_getkb_info 2            /* Get Keyboard characteristics     */
#define IO$c_qv_get_entries 3           /* Get number of entries on a list  */
#define IO$c_qv_wait_hold 4             /* wait for hold screen to be released */
/*                                                                          */
/* QVSS Driver Sensemode function codes                                     */
/*                                                                          */
#define IO$c_qd_get_viewport_id 512     /* Get new viewport_id              */
#define IO$c_QD_GET_FREE_DOPS 513       /* Wait for free dop's              */
#define IO$c_QD_DEFERRED_HOLD 514       /* COMPLETES WHEN DEFERRED QUEUE HOLDS */
/* DOP PROCESSING                                                           */
#define IO$c_QD_GET_COLOR 515           /* READ THE COLORMAP INTO A BUFFER  */
#define IO$c_QD_OCCLUDED_SUSPEND 516    /* COMPLETES WHEN A DOP THAT IS MARKED NO_OCCLUSION */
/* IS EXECUTED AND THERE IS OCCLUSION.                                      */
#define IO$c_AV_GET_KERNEL_SET 517      /* Get a default Kernel Set, AVSS specific */
/*                                                                          */
/* QVSS submodifier codes                                                   */
/*                                                                          */
#define io$m_qv_last 65536
#define io$m_qv_delete 131072
#define io$m_qv_purg_tah 262144
#define io$m_qv_cycle 524288
#define io$m_qv_active 1048576
#define io$m_qv_load_default 2097152
#define io$m_qv_use_default 4194304
#define io$m_qv_two_plane_cursor 8388608
#define io$m_qv_bind 16777216
#define io$m_qv_pasthru 33554432
struct qv_submodifiers1 {
    unsigned io$v_fill_1 : 16;          /* Skip major function code (16 bits) */
    unsigned io$v_qv_last : 1;          /* * Put AST entry at bottom of list */
    unsigned io$v_qv_delete : 1;        /* * Delete entry in list           */
    unsigned io$v_qv_purg_tah : 1;      /* * Purge typeahead buffer         */
    unsigned io$v_qv_cycle : 1;         /* * Cycle list                     */
    unsigned io$v_qv_active : 1;        /* * Make current entry active      */
    unsigned io$v_qv_load_default : 1;  /* * Load system default            */
    unsigned io$v_qv_use_default : 1;   /* * Use system default             */
    unsigned io$v_qv_two_plane_cursor : 1; /* * INDICATE THAT THIS IS A TWO PLANE CURSOR */
    unsigned io$v_qv_bind : 1;          /* * Bind cursor to region          */
    unsigned io$v_qv_pasthru : 1;       /* * Pasthru scan codes w/no ascii trans */
    unsigned io$v_fill_14 : 6;
    } ;
#define io$m_qv_keys 65536
#define io$m_qv_compose2 131072
#define io$m_qv_compose3 262144
struct qv_submodifiers2 {
    unsigned io$v_fill_2 : 16;          /* Skip major function code (16 bits) */
    unsigned io$v_qv_keys : 1;          /* * Load keyboard table            */
    unsigned io$v_qv_compose2 : 1;      /* * Load two-stroke compose table  */
    unsigned io$v_qv_compose3 : 1;      /* * Load three-stroke compose table */
    unsigned io$v_fill_15 : 5;
    } ;
/*                                                                          */
/* READ AND WRITE FUNCTION CODES                                            */
/*                                                                          */
#define IO$_qdread 58
#define IO$_qdwrite 59
#define IO$_qdinsert_dop 60
/*                                                                          */
/* QDSS readpblk subodifiers                                                */
/*                                                                          */
struct qd_readpblkmod {
    unsigned io$v_fill_3 : 6;           /* Skip major function code (irp$v_fmod bits) */
    unsigned io$v_fill_16 : 2;
    } ;
/*                                                                          */
/* QDSS writepblk subodifiers                                               */
/*                                                                          */
#define io$m_qd_Insert_dop 64
#define io$m_qd_now 128
struct qd_writepblkmod {
    unsigned io$v_fill_4 : 6;           /* Skip major function code (irp$v_fmod bits) */
    unsigned io$v_qd_Insert_dop : 1;    /* This QIO is an insert onto the request queue */
    unsigned io$v_qd_now : 1;           /* Execute this DOP now in non-viewport cordinates */
    } ;
/*                                                                          */
/* QDSS SETMODE SUBMODIFIERS                                                */
/*                                                                          */
#define io$m_qd_intensity 65536
#define io$m_qd_reserved_colors 131072
struct qd_set_color_mod {
    unsigned io$v_fill_5 : 16;          /* skip function code               */
    unsigned io$v_qd_intensity : 1;     /* set_color specifies intensity values */
    unsigned io$v_qd_reserved_colors : 1; /* set reserved colors            */
    unsigned io$v_fill_17 : 6;
    } ;
/*                                                                          */
/* QDSS LOAD BITMAP SUBMODIFIERS                                            */
/*                                                                          */
#define io$m_qd_system_wide 65536
struct qd_load_bitmap_mod {
    unsigned io$v_fill_6 : 16;          /* skip function code               */
    unsigned io$v_qd_system_wide : 1;   /* indicate that this is a system wide bitmap */
/* and should remain for the life of the system                             */
    unsigned io$v_fill_18 : 7;
    } ;
/*                                                                          */
/* reserved color definitions                                               */
/*                                                                          */
#define IO$C_QD_TWO_COLOR_CURSOR 1      /* Setup a two color cursor         */
/*                                                                          */
/* keyboard characteristics definitions                                     */
/*                                                                          */
/*   Note:  V_DRIVER module V_-MISC.MAR assumes the order of these bits.    */
/*                                                                          */
#define QV$M_KEY_AUTORPT 1
#define QV$M_KEY_KEYCLICK 2
#define QV$M_KEY_UDF6 4
#define QV$M_KEY_UDF11 8
#define QV$M_KEY_UDF17 16
#define QV$M_KEY_UDHELPDO 32
#define QV$M_KEY_UDE1 64
#define QV$M_KEY_UDARROW 128
#define QV$M_KEY_UDNUMKEY 256
#define QV$M_KEY_SCRSAV 512
#define QV$M_KEY_COMPOSE_LOCK 1024
#define QV$M_KEY_UDMAIN 2048
#define QV$M_KEY_UDCOMPOSE 4096
#define QV$M_KEY_UDTAB_RETURN 8192
#define QV$M_KEY_UDDELETE 16384
#define QV$k_number_of_key_bits 15      /* Length of mask                   */
struct KBD_DEFINITIONS {
    unsigned QV$V_KEY_AUTORPT : 1;      /* Keyboard autorepeat              */
    unsigned QV$V_KEY_KEYCLICK : 1;     /* Keyclick                         */
    unsigned QV$V_KEY_UDF6 : 1;         /* keys F6-F10 generate up/down transitions */
    unsigned QV$V_KEY_UDF11 : 1;        /* keys F11-F14 generate up/down transitions */
    unsigned QV$V_KEY_UDF17 : 1;        /* keys F17-F20 generate up/down transitions */
    unsigned QV$V_KEY_UDHELPDO : 1;     /* keys HELP and DO generate up/down transitions */
    unsigned QV$V_KEY_UDE1 : 1;         /* keys E1-E6 generate up/down transitions */
    unsigned QV$V_KEY_UDARROW : 1;      /* Arrow keys generate up/down transitions */
    unsigned QV$V_KEY_UDNUMKEY : 1;     /* Numeric keypad keys generate up/down transitions */
    unsigned QV$V_KEY_SCRSAV : 1;       /* Place holder, *** DO NOT USE *** */
    unsigned QV$V_KEY_COMPOSE_LOCK : 1; /* Compose key LOCKs alternate table */
    unsigned QV$V_KEY_UDMAIN : 1;       /* Main keyboard array up/down transitions */
    unsigned QV$V_KEY_UDCOMPOSE : 1;    /* Compose key generates up/down transitions */
    unsigned QV$V_KEY_UDTAB_RETURN : 1; /* Tab and Return keys generate up/down transitions */
    unsigned QV$V_KEY_UDDELETE : 1;     /* Delete key generates up/down transitions */
    unsigned QV$V_fill_19 : 1;
    } ;
/*                                                                          */
/* System characteristics definitions                                       */
/*                                                                          */
#define qv$m_sys_autorpt 1
#define qv$m_sys_keyclick 2
#define qv$m_sys_udf6 4
#define qv$m_sys_udf11 8
#define qv$m_sys_udf17 16
#define qv$m_sys_udhelpdo 32
#define qv$m_sys_ude1 64
#define qv$m_sys_udarrow 128
#define qv$m_sys_udnumkey 256
#define qv$m_sys_scrsav 512
#define qv$m_sys_compose_lock 1024
#define qv$m_sys_udmain 2048
#define qv$m_sys_udcompose 4096
#define qv$m_sys_udtab_return 8192
#define qv$m_sys_uddelete 16384
struct sys_definitions {
    unsigned qv$v_sys_autorpt : 1;      /* Keyboard autorepeat              */
    unsigned qv$v_sys_keyclick : 1;     /* Keyclick                         */
    unsigned qv$v_sys_udf6 : 1;         /* keys F6-F10 generate up/down transitions */
    unsigned qv$v_sys_udf11 : 1;        /* keys F11-F14 generate up/down transitions */
    unsigned qv$v_sys_udf17 : 1;        /* keys F17-F20 generate up/down transitions */
    unsigned qv$v_sys_udhelpdo : 1;     /* keys HELP and DO generate up/down transitions */
    unsigned qv$v_sys_ude1 : 1;         /* keys E1-E6 generate up/down transitions */
    unsigned qv$v_sys_udarrow : 1;      /* Arrow keys generate up/down transitions */
    unsigned qv$v_sys_udnumkey : 1;     /* Numeric keypad keys generate up/down transitions */
    unsigned qv$v_sys_scrsav : 1;       /* Disable video output if no input activity */
    unsigned qv$v_sys_compose_lock : 1; /* Compose key LOCKs alternate table */
    unsigned qv$v_sys_udmain : 1;       /* Main KB array up/down transitions */
    unsigned qv$v_sys_udcompose : 1;    /* Compose KB array up/down transitions */
    unsigned qv$v_sys_udtab_return : 1; /* Tab and Return KB array up/down transition */
    unsigned qv$v_sys_uddelete : 1;     /* Delete KB array up/down transitions */
    unsigned qv$v_fill_20 : 1;
    } ;
/*                                                                          */
/* Function key definitions and misc.                                       */
/*                                                                          */
#define qv$m_key_f1 1
#define qv$m_key_f2 2
#define qv$m_key_f3 4
#define qv$m_key_f4 8
#define qv$m_key_f5 16
#define qv$m_sound_bell 32
#define qv$m_sound_click 64
#define qv$m_but_uptodown 128
#define qv$m_but_position 256
struct qv_definitions {
    unsigned qv$v_key_f1 : 1;           /* Function key 1 specified         */
    unsigned qv$v_key_f2 : 1;           /* Function key 2 specified         */
    unsigned qv$v_key_f3 : 1;           /* Function key 3 specified         */
    unsigned qv$v_key_f4 : 1;           /* Function key 4 specified         */
    unsigned qv$v_key_f5 : 1;           /* Function key 5 specified         */
    unsigned qv$v_sound_bell : 1;       /* Sound bell                       */
    unsigned qv$v_sound_click : 1;      /* Keyclick                         */
    unsigned qv$v_but_uptodown : 1;     /* button characteristic            */
    unsigned qv$v_but_position : 1;     /* deliver button position          */
    unsigned qv$v_fill_21 : 7;
    } ;
/*                                                                          */
/* Pointer characteristics definitions                                      */
/*                                                                          */
#define qv$m_ptr_left_hand 1
#define qv$m_ptr_invert_stylus 2
struct pointer_definitions {
    unsigned qv$v_ptr_left_hand : 1;    /* Treat puck or mouse as left handed. */
    unsigned qv$v_ptr_invert_stylus : 1; /* Switch buttons on stylus.       */
    unsigned qv$v_fill_22 : 6;
    } ;
/*                                                                          */
/* Mouse button key definitions and F1 - F5 definitions.                    */
/*                                                                          */
#define qv$m_button_3 1
#define qv$m_button_2 2
#define qv$m_button_1 4
#define qv$m_button_4 8
struct button_definitions {
    unsigned qv$v_button_3 : 1;         /* Mouse button 3 specifiec         */
    unsigned qv$v_button_2 : 1;         /* Mouse button 2 specified         */
    unsigned qv$v_button_1 : 1;         /* Mouse button 1 specified         */
    unsigned qv$v_button_4 : 1;         /* Mouse button 4 specified         */
    unsigned qv$v_fill_23 : 4;
    } ;
#define key$c_select 400
#define key$c_button_1 400
#define key$c_button_2 401
#define key$c_button_3 402
#define key$c_button_4 403
#define key$c_f1 281
#define key$c_f2 282
#define key$c_f3 283
#define key$c_f4 284
#define key$c_f5 285
/*                                                                          */
/* QVSS common driver status block                                          */
/*                                                                          */
#define qvb$m_vps_busy 1
#define qvb$m_vaxmate 2
#define qvb$m_tablet 4
#define qvb$m_stylus 8
#define qvb$m_hold_active 16
#define qvb$c_length 256                /* Length of structure              */
struct qvb_common_structure {
    unsigned long int qvb$l_videosize;  /* size in bytes of video memory (QVSS specific) */
    unsigned long int qvb$l_videoaddr;  /* system address of video memory (QVSS specific) */
    unsigned long int qvb$l_mapsize;    /* size in entries of physical map (QVSS specific) */
    unsigned long int qvb$l_mapaddr;    /* address of video map (QVSS specific) */
    unsigned long int qvb$l_context;    /* QBE pointer (QVSS specific)      */
    unsigned long int qvb$l_csr;        /* CSR                              */
    unsigned short int qvb$w_mous_xpix; /* mouse, x position                */
    unsigned short int qvb$w_mous_ypix; /* mouse, y position                */
    unsigned short int qvb$w_width;     /* maximum size of screen, horizontal */
    unsigned short int qvb$w_height;    /* maximum size of screen, vertical */
    unsigned short int qvb$w_x_resol;   /* bits per inch, horizontal        */
    unsigned short int qvb$w_y_resol;   /* bits per inch, vertical          */
    long int qvb$l_mous_xabs;           /* Mouse position on infinite coordinate space (signed) */
    long int qvb$l_mous_yabs;           /* (used to get relative motion when H/W cursor not used) */
    unsigned long int qvb$l_main_videosize; /* size in bytes of video memory allocated to windowing system (QVSS specific) */
    unsigned long int qvb$l_main_videoaddr; /* system addr of video memory allocated to windowing system (QVSS specific) */
    unsigned long int qvb$l_main_mapsize; /* size in entries of windowing system map (QVSS specific) */
    unsigned long int qvb$l_main_mapaddr; /* system address of windowing system scan map table (QVSS specific) */
    unsigned short int qvb$w_main_mapmin; /* Entry number of lowest map cell last updated (QVSS specific) */
    unsigned short int qvb$w_main_mapmax; /* entry number of highest map cell last updated (QVSS specific) */
    unsigned long int qvb$l_characteristics; /* Current system wide windowing characteristics. */
    unsigned short int qvb$w_scrsav_timout; /* Current screen saver timout value. */
    unsigned short int qvb$w_buttons;   /* *** This field no longer supported. */
    unsigned short int qvb$w_keyclick_volume; /* Default keyclick volume    */
    unsigned short int qvb$w_tablet_xpix; /* tablet, x position             */
    unsigned short int qvb$w_tablet_ypix; /* tablet, y position             */
    unsigned short int qvb$w_tablet_width; /* maximum size of tablet, horizontal */
    unsigned short int qvb$w_tablet_height; /* maximum size of tablet, vertical */
    unsigned short int qvb$w_but_status; /* Status of buttons               */
    unsigned char qvb$b_bits_per_pixel; /* Number of bits per pixel         */
    char qvb$b_device_type;
    union  {
        unsigned short int qvb$w_flags; /* Internal flags                   */
        struct  {
            unsigned qvb$v_vps_busy : 1; /* VPS currently modify scan map   */
            unsigned qvb$v_vaxmate : 1; /* QVSS style, No scan line present */
            unsigned qvb$v_tablet : 1;  /* Tablet is present (0=mouse)      */
            unsigned qvb$v_stylus : 1;  /* Stylus is present (0=puck)       */
            unsigned qvb$v_hold_active : 1; /* is hold active now           */
            unsigned qvb$v_fill_24 : 3;
            } qvb$r_flag_bits;
        } qvb$r_qv_flags_overlay;
    unsigned char qvb$B_Cursor_planes;  /* The number of planes in the h/w cursor */
    unsigned char qvb$b_spare_b_1;
    unsigned short int qvb$w_spare_w_1;
    unsigned short int qvb$w_tablet_xsize; /*Width of tablet in centimeters */
    unsigned short int qvb$w_tablet_ysize; /*Height of tablet in centimeters */
    float qvb$f_tablet_xratio;          /*X ratio of screen to tablet (floating) */
    float qvb$f_tablet_yratio;          /*Y ratio of screen to tablet       */
    unsigned long int qvb$l_unit_number; /* unit number of this device      */
    unsigned long int qvb$l_pointer_setup; /* Pointer characteristics       */
    unsigned short int qvb$w_hold_defer_cnt; /* the hold_screen defer count should be */
/* incremented and decremented with ADAWI instructions.                     */
/*256 bytes common,                                                         */
/*256 bytes qdss = 512 total qvb                                            */
    } ;
#define qvb$c_qvss 0
#define qvb$c_qdss 1
#define qvb$c_avss 2
/*                                                                          */
/* QDSS specific driver status                                              */
/*                                                                          */
#define QDB$c_length 356                /* Length of structure              */
struct QVB_QDSS_STRUCTURE {
    char QVBDEF$$_QD_COMMON_FILL [256];
    unsigned long int QDB$L_SYSVP;      /* system wide viewport id          */
    unsigned short int QDB$W_ON_SCREEN_X; /* ON SCREEN X POSITION           */
    unsigned short int QDB$W_ON_SCREEN_Y; /*                                */
    unsigned short int QDB$W_ON_SCREEN_WIDTH; /* WIDTH AND HEIGHT OF ON SCREEN PORTION */
    unsigned short int QDB$W_ON_SCREEN_HEIGHT; /*                           */
    unsigned short int QDB$W_SCROLL_X;  /* SCROLL AREA X,Y,WIDTH AND HEIGHT */
    unsigned short int QDB$W_SCROLL_Y;
    unsigned short int QDB$W_SCROLL_WIDTH;
    unsigned short int QDB$W_SCROLL_HEIGHT;
    unsigned short int QDB$W_FREE_1_X;  /* LARGEST FREE BLOCK               */
    unsigned short int QDB$W_FREE_1_Y;
    unsigned short int QDB$W_FREE_1_WIDTH;
    unsigned short int QDB$W_FREE_1_HEIGHT;
    unsigned short int QDB$W_FREE_2_X;  /* SECOND LARGEST FREE BLOCK        */
    unsigned short int QDB$W_FREE_2_Y;
    unsigned short int QDB$W_FREE_2_WIDTH;
    unsigned short int QDB$W_FREE_2_HEIGHT;
    unsigned short int QDB$W_FREE_3_X;  /* SMALLEST FREE BLOCK              */
    unsigned short int QDB$W_FREE_3_Y;
    unsigned short int QDB$W_FREE_3_WIDTH;
    unsigned short int QDB$W_FREE_3_HEIGHT;
    unsigned short int QDB$W_FONT_X;    /* FONT STORAGE BLOCK               */
    unsigned short int QDB$W_FONT_Y;
    unsigned short int QDB$W_FONT_WIDTH;
    unsigned short int QDB$W_FONT_HEIGHT;
    unsigned short int QDB$W_CLIP_SAVE_X; /* CLIPPING SAVE AREA             */
    unsigned short int QDB$W_CLIP_SAVE_Y;
    unsigned short int QDB$W_CLIP_SAVE_WIDTH;
    unsigned short int QDB$W_CLIP_SAVE_HEIGHT;
    unsigned long int QDB$L_COLOR_INDICES; /*COLOR MAP SIZE                 */
    unsigned long int QDB$L_COLOR_COLORS; /*MAXIMUM POSSIBLE COLORS         */
    unsigned long int QDB$L_COLOR_RBITS; /*NUMBER OF BITS OF PRECESION FOR RED */
    unsigned long int QDB$L_COLOR_GBITS; /*NUMBER OF BITS OF PRECESION FOR GREEN */
    unsigned long int QDB$L_COLOR_BBITS; /*NUMBER OF BITS OF PRECESION FOR BLUE */
    unsigned long int QDB$L_COLOR_IBITS; /*NUMBER OF BITS OF INTENSITY PRESESION */
    unsigned long int QDB$L_COLOR_RES_INDICES; /*NUMBER OF RESERVED ENTRIES */
    unsigned long int QDB$L_COLOR_REGEN; /*COLOR REGENERATION CHARACTERISTICS */
    unsigned long int QDB$L_COLOR_MAPS; /* ALWAYS 1 FOR QDSS                */
    unsigned long int QDB$L_COLOR_INTENSITY_FLAG; /* 1= SYSTEM SETUP FOR INTENSITY VALUES */
/* 0= RGB EXPECTED                                                          */
/* Equals QDB$C_LENGTH                                                      */
    } ;
/*+                                                                         */
/*	This data structure defines the AVB, the system info block for the AVSS. */
/*-                                                                         */
#define AVB$C_FCC 1                     /* FIFO Control Chip (FCC)          */
#define AVB$C_RICOH 1                   /* RICOH Compression Chip           */
#define AVB$C_Scalution 1               /* Scalution Chip                   */
#define AVB$C_AVSS_Scroll 1             /* AVSS Specific Scroll Engine      */
#define AVB$C_Length 628                /* Length of AVB (Including QVB & QDB) */
struct QVB_AVSS_Structure {
    char QVBDEF$$_AV_Common_Fill [256];
    char QVBDEF$$_AV_QDSS_Fill [356];
    short int AVB$W_Interface;          /* Hardware Interface To Dragon     */
    short int AVB$W_Decompression;      /* Decompression Hardware           */
    short int AVB$W_Scaling;            /* Scaling Hardware                 */
    short int AVB$W_Scrolling;          /* Scrolling Hardware               */
    char AVB$B_Spare_B_1;               /* Spare Byte 1                     */
    char AVB$B_Spare_B_2;               /* Spare Byte 2                     */
    short int AVB$W_Spare_W_1;          /* Spare Word 1                     */
    long int AVB$L_Spare_L_1;           /* Spare Longword 1                 */
    } ;
 
/*** MODULE $REQDEF ***/
/*                                                                          */
/* QDSS REQUEST QUEUE DEFINITIONS                                           */
/*                                                                          */
#define REQ$K_RETURN_OFFSET 8           /* RETURN QUEUE OFFSET              */
/*                                                                          */
#define REQ$K_length 32                 /* Length of structure              */
struct REQ_structure {
    unsigned long int REQ$L_REQUEST_FLINK; /* PENDING DRAWING OPERATION QUEUE HEADER */
    unsigned long int REQ$L_REQUEST_BLINK;
/* The following fields must match the RET structure exactly!               */
/*                                                                          */
    unsigned long int REQ$L_RETURN_FLINK; /* ENTRIES RETURNED TO THE PROCESS */
    unsigned long int REQ$L_RETURN_BLINK;
    unsigned long int REQ$L_RETURN_LARGE_FLINK; /* RETURN THE LARGE PACKETS TO THIS QUEUE */
    unsigned long int REQ$L_RETURN_LARGE_BLINK; /* RETURN THE LARGE PACKETS TO THIS QUEUE */
    unsigned short int REQ$W_SMALL_DOP_SIZE; /* MAXIMUM SIZE OF A SMALL DOP */
    unsigned short int REQ$W_LARGE_DOP_SIZE; /* MAXIMUM SIZE OF A LARGE DOP */
    long int REQ$L_APPLICATION_RESERVED; /* APPLICATION SPECIFIC FIELD      */
    } ;
 
/*** MODULE $RETDEF ***/
/*                                                                          */
/* QDSS RETURN QUEUE DEFINITIONS                                            */
/*                                                                          */
#define RET$K_length 24                 /* Length of structure              */
struct RET_structure {
    unsigned long int RET$L_SMALL_FLINK; /* ENTRIES RETURNED TO THE PROCESS */
    unsigned long int RET$L_SMALL_BLINK;
    unsigned long int RET$L_LARGE_FLINK; /* RETURN THE LARGE PACKETS TO THIS QUEUE */
    unsigned long int RET$L_LARGE_BLINK; /* RETURN THE LARGE PACKETS TO THIS QUEUE */
    unsigned short int RET$W_SMALL_DOP_SIZE; /* MAXIMUM SIZE OF A SMALL DOP */
    unsigned short int RET$W_LARGE_DOP_SIZE; /* MAXIMUM SIZE OF A LARGE DOP */
    long int RET$L_APPLICATION_RESERVED; /* APPLICATION SPECIFIC FIELD      */
    } ;
 
/*** MODULE $URDDEF ***/
/*                                                                          */
/* REGION DESCRIPTOR                                                        */
/*                                                                          */
#define URD$C_length 12                 /* Length of structure              */
struct URD_structure {
    unsigned short int URD$W_X_MIN;     /* MINIMUM VIEWPORT RELATIVE X VALUE FOR THIS REGION */
    unsigned short int URD$W_Y_MIN;     /* MINIMUM VIEWPORT RELATIVE Y VALUE FOR THIS REGION */
    unsigned short int URD$W_X_MAX;     /* MAXIMUM VIEWPORT RELATIVE X VALUE FOR THIS REGION */
    unsigned short int URD$W_Y_MAX;     /* MAXIMUM VIEWPORT RELATIVE Y VALUE FOR THIS REGION */
    unsigned short int URD$W_X_BASE;    /* BASE X IN DEVICE RELATIVE CORDINATES */
    unsigned short int URD$W_Y_BASE;    /* BASE Y IN DEVICE RELATIVE CORDINATES */
    } ;
/*                                                                          */
/* Writing mode definitons. Most of these values MUST agree with the VIPER definitions. */
/*                                                                          */
 
/*** MODULE $WRITDEF ***/
#define WRIT$M_COMP_MASK_1 16
#define WRIT$M_COMP_MASK_2 32
#define WRIT$M_NO_SRC_COMP 64
#define WRIT$M_RES_DIS 128
#define WRIT$M_SPARE 256
#define WRIT$M_USE_MASK_2 512
#define WRIT$C_ZEROES 0                 /* All resulting bits are set to 0  */
#define WRIT$C_DSON 1                   /* The destination is OR'd with source index, then the result is negated */
#define WRIT$C_DNSA 2                   /* The destination is negated, then ANDed with the source index */
#define WRIT$C_DN 3                     /* The destination is negated       */
#define WRIT$C_DSNA 4                   /* The source index is negated, then ANDed with the destination */
#define WRIT$C_SN 5                     /* The source index is negated      */
#define WRIT$C_DSX 6                    /* The destination is XORed with the source index */
#define WRIT$C_DSAN 7                   /* The destination is ANDed with the source index, then the result is negated */
#define WRIT$C_DSA 8                    /* The destination is ANDed with the source index */
#define WRIT$C_DSXN 9                   /* The destination is XORed with the source index, then the result is negated */
#define WRIT$C_S 10                     /* The result is equal to the source index */
#define WRIT$C_DNSO 11                  /* The destination is negated, then ORed with the source index */
#define WRIT$C_D 12                     /* The result is equal to the destination */
#define WRIT$C_DSNO 13                  /* The source index is negated, then ORed with the destination */
#define WRIT$C_DSO 14                   /* The destination is ORed with the source index */
#define WRIT$C_ONES 15                  /* All resulting bits are set to 1  */
struct WRIT_STRUCTURE {
    struct  {
        unsigned WRIT$V_FUNC : 4;       /* VIPER LUF function               */
        unsigned WRIT$V_COMP_MASK_1 : 1; /* 0 = use mask 1 / 1 = use complement of mask 1 (VIPER bit) */
        unsigned WRIT$V_COMP_MASK_2 : 1; /* 0 = use mask 2 / 1 = use complement of mask 2 (VIPER bit) */
        unsigned WRIT$V_NO_SRC_COMP : 1; /* 0 = use the complement of the source / 1 = use the source (VIPER bit) */
        unsigned WRIT$V_RES_DIS : 1;    /* Disable resolution mode logic (VIPER bit) */
        unsigned WRIT$V_SPARE : 1;      /* Spare modifier bit               */
        unsigned WRIT$V_USE_MASK_2 : 1; /* Place the data from the source cycle into mask 2 */
        unsigned WRIT$V_fill_25 : 6;
        } WRIT$R_LUF;
/* VIPER LUF function codes                                                 */
    } ;
 
/*** MODULE $tpbdef IDENT V3-03 ***/
#define tpb$M_Unused 63
#define tpb$M_Compress 64
#define tpb$M_Decompress 128
#define tpb$c_unknown 0
#define tpb$c_bitmap_xfr 1
#define tpb$c_source_only 2
#define tpb$c_bitmap_xfr_rotate 3
#define tpb$c_source_length 10
#define tpb$c_bitmap_xfr_length 14
#define tpb$c_length 26
struct tpb_structure {
    union  {
        char tpb$b_type;
        struct  {
            struct  {
                unsigned tpb$V_Unused : 6;
                unsigned tpb$V_Compress : 1;
                unsigned tpb$V_Decompress : 1;
                } tpb$R_Type_Bits;
            } tpb$r_fill_27;
        } tpb$r_fill_26;
    char tpb$b_size;
    short int tpb$w_x_source;
    short int tpb$w_y_source;
    short int tpb$w_width;
    short int tpb$w_height;
    short int tpb$w_x_target;
    short int tpb$w_y_target;
    short int tpb$w_x_target_vec1;
    short int tpb$w_y_target_vec1;
    short int tpb$w_l_target_vec1;
    short int tpb$w_x_target_vec2;
    short int tpb$w_y_target_vec2;
    short int tpb$w_l_target_vec2;
    } ;
 
/*** MODULE $M_T_STRPTDEF ***/
/*                                                                          */
/* This macro defines the values for the mouse and tablet self-test report. */
/*                                                                          */
#define M_T_STR$M_REVISION 15
#define M_T_STR$M_SELF_TEST 32
#define M_T_STR$M_TABLET_POSITION 64
#define M_T_STR$M_FRAME_SYNC 128
#define M_T_STR$M_DEVICE 15
#define M_T_STR$K_OK 0                  /* No errors                        */
#define M_T_STR$K_STYLUS 17             /* Stylus connected                 */
#define M_T_STR$K_NO_PTR 19             /* No puck or stylus connected      */
#define M_T_STR$K_ERROR 32              /* All errors are greater than or equal to this */
#define M_T_STR$K_AD 58                 /* Analog or digital error          */
#define M_T_STR$K_BTN_DWN 61            /* Button down                      */
#define M_T_STR$K_CS 62                 /* RAM or ROM checksum error        */
#define M_T_STR$M_R 1
#define M_T_STR$M_M 2
#define M_T_STR$M_L 4
#define M_T_STR$M_M_BUTTONS 7
#define M_T_STR$M_PROXIMITY 1
#define M_T_STR$M_B1 2
#define M_T_STR$M_B2 4
#define M_T_STR$M_B3 8
#define M_T_STR$M_B4 16
#define M_T_STR$M_T_BUTTONS 30
#define M_T_STR$K_LENGTH 4
#define M_T_STR$K_MOUSE_ID 2            /* Mouse device ID                  */
#define M_T_STR$K_TABLET_ID 4           /* Tablet ID                        */
struct M_T_STRPTDEF {
    union  {
        unsigned char M_T_STR$B_BYTE_1;
        struct  {
            struct  {
                unsigned M_T_STR$V_REVISION : 4; /* Revision number         */
                unsigned M_T_STR$V_B04 : 1; /* Unused bit                   */
                unsigned M_T_STR$V_SELF_TEST : 1; /* Self test indicator (1 = self-test) */
                unsigned M_T_STR$V_TABLET_POSITION : 1; /* Tablet position report */
                unsigned M_T_STR$V_FRAME_SYNC : 1; /* Frame synchronization */
                } M_T_STR$R_BYTE_1_BITS;
            } M_T_STR$r_fill_29;
        } M_T_STR$r_fill_28;
    union  {
        unsigned char M_T_STR$B_ID_CODE; /* ID code                         */
        struct  {
            struct  {
                unsigned M_T_STR$V_DEVICE : 4; /* Device type ID            */
                unsigned M_T_STR$V_MFGR : 4; /* Manufacturer location ID    */
                } M_T_STR$R_BYTE_2_BITS;
            } M_T_STR$r_fill_31;
        } M_T_STR$r_fill_30;
    unsigned char M_T_STR$B_STATUS;     /* Status                           */
    union  {
        unsigned char M_T_STR$B_BUTTON_CODE; /* Button code                 */
        struct  {
            unsigned M_T_STR$V_R : 1;   /* Right button                     */
            unsigned M_T_STR$V_M : 1;   /* Middle button                    */
            unsigned M_T_STR$V_L : 1;   /* Left button                      */
            unsigned M_T_STR$V_fill_32 : 5;
            } M_T_STR$R_EACH_M_BUTTON;
        struct  {
            unsigned M_T_STR$V_M_BUTTONS : 3; /* Mask, etc. for extracting all mouse buttons at once */
            unsigned M_T_STR$V_fill_33 : 5;
            } M_T_STR$R_ALL_M_BUTTONS;
        struct  {
            unsigned M_T_STR$V_PROXIMITY : 1; /* Proximity                  */
            unsigned M_T_STR$V_B1 : 1;  /* Button 1                         */
            unsigned M_T_STR$V_B2 : 1;  /* Button 2                         */
            unsigned M_T_STR$V_B3 : 1;  /* Button 3                         */
            unsigned M_T_STR$V_B4 : 1;  /* Button 4                         */
            unsigned M_T_STR$V_fill_34 : 3;
            } M_T_STR$R_EACH_T_BUTTON;
        struct  {
            unsigned M_T_STR$V_SKIP : 1; /* Skip over proximity bit         */
            unsigned M_T_STR$V_T_BUTTONS : 4; /* Mask, etc. for extracting all tablet buttons at once */
            unsigned M_T_STR$V_fill_35 : 3;
            } M_T_STR$R_ALL_T_BUTTONS;
        } M_T_STR$R_BUTTON_OVERLAY;
    } ;
 
/*** MODULE $M_RPTDEF ***/
#define M_RPT$M_R 1
#define M_RPT$M_M 2
#define M_RPT$M_L 4
#define M_RPT$M_SY 8
#define M_RPT$M_SX 16
#define M_RPT$M_B5_6 32
#define M_RPT$M_FRAME_SYNC 64
#define M_RPT$M_M_BUTTONS 7
#define M_RPT$M_DISP_BITS 127
#define M_RPT$K_LENGTH 3
struct M_RPTDEF {
    union  {
        unsigned char M_RPT$B_BYTE_1;
        struct  {
            unsigned M_RPT$V_R : 1;     /* Right button                     */
            unsigned M_RPT$V_M : 1;     /* Middle button                    */
            unsigned M_RPT$V_L : 1;     /* Left button                      */
            unsigned M_RPT$V_SY : 1;    /* Y sign bit (1 = +, 0 = -)        */
            unsigned M_RPT$V_SX : 1;    /* X sign bit (1 = +, 0 = -)        */
            unsigned M_RPT$V_B5_6 : 1;  /* Must be zero                     */
            unsigned M_RPT$V_FRAME_SYNC : 1; /* Frame synchronization       */
            unsigned M_RPT$V_fill_36 : 1;
            } M_RPT$R_BYTE_1_BITS;
        struct  {
            unsigned M_RPT$V_M_BUTTONS : 3; /* Mask, etc. for extracting all mouse buttons at once */
            unsigned M_RPT$V_fill_37 : 5;
            } M_RPT$R_ALL_M_BUTTONS;
        } M_RPT$R_BYTE_1_OVERLAY;
    union  {
        struct  {
            unsigned char M_RPT$B_X_DISP;
            unsigned char M_RPT$B_Y_DISP;
            } M_RPT$R_BYTES;
        struct  {
            unsigned M_RPT$V_DISP_BITS : 7; /* Bits in X and Y displacement that are significant */
            unsigned M_RPT$V_fill_38 : 1;
            } M_RPT$R_DISP_BITS;
        } M_RPT$R_DISP_BYTES;
    } ;
 
/*** MODULE $T_RPTDEF ***/
#define T_RPT$M_PROXIMITY 1
#define T_RPT$M_B1 2
#define T_RPT$M_B2 4
#define T_RPT$M_B3 8
#define T_RPT$M_B4 16
#define T_RPT$M_SELF_TEST 32
#define T_RPT$M_TABLET_POSITION 64
#define T_RPT$M_FRAME_SYNC 128
#define T_RPT$M_T_BUTTONS 30
#define T_RPT$K_LENGTH 5
#define T_RPT$M_POSITION 63
struct T_RPTDEF {
    union  {
        unsigned char T_RPT$B_BYTE_1;
        struct  {
            unsigned T_RPT$V_PROXIMITY : 1; /* Proximity                    */
            unsigned T_RPT$V_B1 : 1;    /* Button 1                         */
            unsigned T_RPT$V_B2 : 1;    /* Button 2                         */
            unsigned T_RPT$V_B3 : 1;    /* Button 3                         */
            unsigned T_RPT$V_B4 : 1;    /* Button 4                         */
            unsigned T_RPT$V_SELF_TEST : 1; /* Self test indicator (must be zero) */
            unsigned T_RPT$V_TABLET_POSITION : 1; /* Tablet position report */
            unsigned T_RPT$V_FRAME_SYNC : 1; /* Frame synchronization       */
            } T_RPT$R_BYTE_1_BITS;
        struct  {
            unsigned T_RPT$V_SKIP : 1;  /* Skip over proximity bit          */
            unsigned T_RPT$V_T_BUTTONS : 4; /* Mask, etc. for extracting all tablet buttons at once */
            unsigned T_RPT$V_fill_39 : 3;
            } T_RPT$R_ALL_T_BUTTONS;
        } T_RPT$R_BYTE_1_OVERLAY;
    unsigned char T_RPT$B_X_LO;
    unsigned char T_RPT$B_X_HI;
    unsigned char T_RPT$B_Y_LO;
    unsigned char T_RPT$B_Y_HI;
    struct  {
        unsigned T_RPT$V_POSITION : 6;  /* Bits in X and Y position bytes that are significant */
        unsigned T_RPT$V_fill_40 : 2;
        } T_RPT$R_T_POSITION;
    } ;
 
/*** MODULE $LK201DEF IDENT X-3 ***/
/*                                                                          */
/* LK201 keyboard constants.                                                */
/*                                                                          */
#define LK201$K_LIGHT_ON 19             /* Turn a light on.                 */
#define LK201$K_LIGHT_OFF 17            /* Turn a light off.                */
#define LK201$K_LIGHT1 129
#define LK201$K_LIGHT2 130
#define LK201$K_LIGHT3 132
#define LK201$K_LIGHT4 136
#define LK201$K_ALL 143                 /* All lights                       */
#define LK201$K_SET_DEFAULTS 211        /* Reinstate defaults               */
#define LK201$K_ENABLE_BELL 35          /* Enable bell, set volume          */
#define LK201$K_BELL 167                /* Sound bell                       */
#define LK201$K_DISABLE_KEYCLICK 153    /* Disable keyclick                 */
#define LK201$K_ENABLE_KEYCLICK 27      /* Enable keyclick, set volume      */
#define LK201$K_CLICK 159               /* Sound keyclick                   */
#define LK201$K_AUTORPT_ON 227          /* Turn on autorepeat.              */
#define LK201$K_AUTORPT_OFF 225         /* Turn off autorepeat.             */
#define LK201$M_TYPE 1
#define LK201$M_MODE 6
#define LK201$M_DIVISION 120
#define LK201$M_LAST_PARAMETER 128
#define LK201$K_DOWN_ONLY 0
#define LK201$K_AUTO_REPEAT_DOWN 2
#define LK201$K_UP_DOWN 6
#define LK201$K_MAIN_KEYBOARD 8         /* 48 graphic keys, spacebar        */
#define LK201$K_NUMERIC_KEYPAD 16       /* Numeric keypad                   */
#define LK201$K_DELETE_DIVISION 24      /* Delete key division              */
#define LK201$K_RET_TAB 32              /* Return and Tab                   */
#define LK201$K_LOCK_COMPOSE 40         /* Lock and Compose                 */
#define LK201$K_SHIFT_CTRL 48           /* Shift and Control                */
#define LK201$K_HORIZ_CURSORS 56        /* Horizontal cursors               */
#define LK201$K_VERT_CURSORS 64         /* Vertical cursors                 */
#define LK201$K_EDIT 72                 /* Editing keys                     */
#define LK201$K_FK_1_5 80               /* Function keys 1 - 5              */
#define LK201$K_FK_6_10 88              /* Function keys 6 - 10             */
#define LK201$K_FK_11_14 96             /* Function keys 11- 14             */
#define LK201$K_FK_15_16 104            /* Function keys 15 (Help) and 16(D0) */
#define LK201$K_FK_17_20 112            /* Functions keys 17 - 20           */
#define LK201$K_RATE_SET 120            /* Set auto-repeat rate             */
#define LK201$K_KB_HW_ID 0
#define LK201$K_KB_FW_ID 1
#define LK201$K_PWR_UP_KEY_DOWN_ERROR 61
#define LK201$K_PRW_UP_STEST_ERROR 62
/*                                                                          */
#define LK201$K_G99 86                  /* 86                               */
#define LK201$K_G00 87                  /* 87                               */
#define LK201$K_G01 88                  /* 88                               */
#define LK201$K_G02 89                  /* 89                               */
#define LK201$K_G03 90                  /* 90                               */
/* 91                                                                       */
/* 92                                                                       */
/* 93                                                                       */
/* 94                                                                       */
/* 95                                                                       */
/* 96                                                                       */
/* 97                                                                       */
/* 98                                                                       */
/* 99                                                                       */
#define LK201$K_G05 100                 /* 100                              */
#define LK201$K_G06 101                 /* 101                              */
#define LK201$K_G07 102                 /* 102                              */
#define LK201$K_G08 103                 /* 103                              */
#define LK201$K_G09 104                 /* 104                              */
/* 105                                                                      */
/* 106                                                                      */
/* 107                                                                      */
/* 108                                                                      */
/* 109                                                                      */
/* 110                                                                      */
/* 111                                                                      */
/* 112                                                                      */
#define LK201$K_G11 113                 /* 113                              */
#define LK201$K_G12 114                 /* 114                              */
#define LK201$K_G13 115                 /* 115                              */
#define LK201$K_G14 116                 /* 116                              */
/* 117                                                                      */
/* 118                                                                      */
/* 119                                                                      */
/* 120                                                                      */
/* 121                                                                      */
/* 122                                                                      */
/* 123                                                                      */
#define LK201$K_G15 124                 /* 124                              */
#define LK201$K_G16 125                 /* 125                              */
/* 126                                                                      */
/* 127                                                                      */
#define LK201$K_G20 128                 /* 128                              */
#define LK201$K_G21 129                 /* 129                              */
#define LK201$K_G22 130                 /* 130                              */
#define LK201$K_G23 131                 /* 131                              */
/* 132                                                                      */
/* 133                                                                      */
/* 134                                                                      */
/* 135                                                                      */
/* 136                                                                      */
/* 137                                                                      */
#define LK201$K_E16 138                 /* 138                              */
#define LK201$K_E17 139                 /* 139                              */
#define LK201$K_E18 140                 /* 140                              */
#define LK201$K_D16 141                 /* 141                              */
#define LK201$K_D17 142                 /* 142                              */
#define LK201$K_D18 143                 /* 143                              */
/* 144                                                                      */
/* 145                                                                      */
#define LK201$K_A20 146                 /* 146                              */
/* 147                                                                      */
#define LK201$K_A22 148                 /* 148                              */
#define LK201$K_A23 149                 /* 149                              */
#define LK201$K_B20 150                 /* 150                              */
#define LK201$K_B21 151                 /* 151                              */
#define LK201$K_B22 152                 /* 152                              */
#define LK201$K_C20 153                 /* 153                              */
#define LK201$K_C21 154                 /* 154                              */
#define LK201$K_C22 155                 /* 155                              */
#define LK201$K_C23 156                 /* 156                              */
#define LK201$K_D20 157                 /* 157                              */
#define LK201$K_D21 158                 /* 158                              */
#define LK201$K_D22 159                 /* 159                              */
#define LK201$K_D23 160                 /* 160                              */
#define LK201$K_E20 161                 /* 161                              */
#define LK201$K_E21 162                 /* 162                              */
#define LK201$K_E22 163                 /* 163                              */
#define LK201$K_E23 164                 /* 164                              */
/* 165                                                                      */
/* 166                                                                      */
#define LK201$K_B16 167                 /* 167                              */
#define LK201$K_B18 168                 /* 168                              */
#define LK201$K_B17 169                 /* 169                              */
#define LK201$K_C17 170                 /* 170                              */
/* 171                                                                      */
/* 172                                                                      */
/* 173                                                                      */
#define LK201$K_B11 174                 /* 174                              */
#define LK201$K_C99 175                 /* 175                              */
#define LK201$K_C00 176                 /* 176                              */
#define LK201$K_A99 177                 /* 177                              */
/* 178                                                                      */
#define LK201$K_ALL_UP 179              /* 179                              */
#define LK201$K_METRONOME 180           /* 180                              */
#define LK201$K_OUTPUT_ERROR 181        /* 181                              */
#define LK201$K_INPUT_ERROR 182         /* 182                              */
#define LK201$K_KBD_LOCKED_ACK 183      /* 183                              */
#define LK201$K_TEST_MODE_ACK 184       /* 184                              */
#define LK201$K_KEY_DOWN_PREFIX 185     /* 185                              */
#define LK201$K_MODE_CHANGE_ACK 186     /* 186                              */
/* 187                                                                      */
#define LK201$K_E13 188                 /* 188                              */
#define LK201$K_C13 189                 /* 189                              */
#define LK201$K_D00 190                 /* 190                              */
#define LK201$K_E00 191                 /* 191                              */
#define LK201$K_E01 192                 /* 192                              */
#define LK201$K_D01 193                 /* 193                              */
#define LK201$K_C01 194                 /* 194                              */
#define LK201$K_B01 195                 /* 195                              */
/* 196                                                                      */
#define LK201$K_E02 197                 /* 197                              */
#define LK201$K_D02 198                 /* 198                              */
#define LK201$K_C02 199                 /* 199                              */
#define LK201$K_B02 200                 /* 200                              */
#define LK201$K_B00 201                 /* 201                              */
/* 202                                                                      */
#define LK201$K_E03 203                 /* 203                              */
#define LK201$K_D03 204                 /* 204                              */
#define LK201$K_C03 205                 /* 205                              */
#define LK201$K_B03 206                 /* 206                              */
/* 207                                                                      */
#define LK201$K_E04 208                 /* 208                              */
#define LK201$K_D04 209                 /* 209                              */
#define LK201$K_C04 210                 /* 210                              */
#define LK201$K_B04 211                 /* 211                              */
#define LK201$K_A01 212                 /* 212                              */
/* 213                                                                      */
#define LK201$K_E05 214                 /* 214                              */
#define LK201$K_D05 215                 /* 215                              */
#define LK201$K_C05 216                 /* 216                              */
#define LK201$K_B05 217                 /* 217                              */
/* 218                                                                      */
#define LK201$K_E06 219                 /* 219                              */
#define LK201$K_D06 220                 /* 220                              */
#define LK201$K_C06 221                 /* 221                              */
#define LK201$K_B06 222                 /* 222                              */
/* 223                                                                      */
#define LK201$K_E07 224                 /* 224                              */
#define LK201$K_D07 225                 /* 225                              */
#define LK201$K_C07 226                 /* 226                              */
#define LK201$K_B07 227                 /* 227                              */
/* 228                                                                      */
#define LK201$K_E08 229                 /* 229                              */
#define LK201$K_D08 230                 /* 230                              */
#define LK201$K_C08 231                 /* 231                              */
#define LK201$K_B08 232                 /* 232                              */
/* 233                                                                      */
#define LK201$K_E09 234                 /* 234                              */
#define LK201$K_D09 235                 /* 235                              */
#define LK201$K_C09 236                 /* 236                              */
#define LK201$K_B09 237                 /* 237                              */
/* 238                                                                      */
#define LK201$K_E10 239                 /* 239                              */
#define LK201$K_D10 240                 /* 240                              */
/* 241                                                                      */
#define LK201$K_C10 242                 /* 242                              */
#define LK201$K_B10 243                 /* 243                              */
/* 244                                                                      */
#define LK201$K_E12 245                 /* 245                              */
#define LK201$K_D12 246                 /* 246                              */
#define LK201$K_C12 247                 /* 247                              */
/* 248                                                                      */
#define LK201$K_E11 249                 /* 249                              */
#define LK201$K_D11 250                 /* 250                              */
#define LK201$K_C11 251                 /* 251                              */
#define LK201$K_A02 212
#define LK201$K_A03 212
#define LK201$K_A04 212
#define LK201$K_A05 212
#define LK201$K_A06 212
#define LK201$K_A07 212
#define LK201$K_A08 212
#define LK201$K_A09 212
#define LK201$K_B99 174
/*                                                                          */
#define LK201$K_A 194
#define LK201$K_B 217
#define LK201$K_C 206
#define LK201$K_D 205
#define LK201$K_E 204
#define LK201$K_F 210
#define LK201$K_G 216
#define LK201$K_H 221
#define LK201$K_I 230
#define LK201$K_J 226
#define LK201$K_K 231
#define LK201$K_L 236
#define LK201$K_M 227
#define LK201$K_N 222
#define LK201$K_O 235
#define LK201$K_P 240
#define LK201$K_Q 193
#define LK201$K_R 209
#define LK201$K_S 205
#define LK201$K_T 215
#define LK201$K_U 225
#define LK201$K_V 210
#define LK201$K_W 198
#define LK201$K_X 200
#define LK201$K_Y 220
#define LK201$K_Z 195
#define LK201$K_SPACE 212               /* SP                               */
#define LK201$K_EXCLAMATION_POINT 192   /* !                                */
#define LK201$K_DOUBLE_QUOTE 251        /* "                                */
#define LK201$K_NUMBER_SIGN 214         /* #                                */
#define LK201$K_DOLLAR_SIGN 208         /* $                                */
#define LK201$K_PERCENT_SIGN 214        /* %                                */
#define LK201$K_AMPERSAND 224           /* &                                */
#define LK201$K_QUOTE 251               /* '                                */
#define LK201$K_LEFT_PAREN 234          /* (                                */
#define LK201$K_RIGHT_PAREN 239         /* )                                */
#define LK201$K_ASTERISK 229            /* *                                */
#define LK201$K_PLUS_SIGN 245           /* +                                */
#define LK201$K_COMMA_CHAR 232          /* ,                                */
#define LK201$K_DASH 249                /* -                                */
#define LK201$K_DOT 237                 /* .                                */
#define LK201$K_SLASH 243               /* /                                */
#define LK201$K_ZERO 239                /* 0                                */
#define LK201$K_ONE 192                 /* 1                                */
#define LK201$K_TWO 197                 /* 2                                */
#define LK201$K_THREE 203               /* 3                                */
#define LK201$K_FOUR 208                /* 4                                */
#define LK201$K_FIVE 214                /* 5                                */
#define LK201$K_SIX 219                 /* 6                                */
#define LK201$K_SEVEN 224               /* 7                                */
#define LK201$K_EIGHT 229               /* 8                                */
#define LK201$K_NINE 234                /* 9                                */
#define LK201$K_COLON 242               /* :                                */
#define LK201$K_SEMICOLON 242           /* ;                                */
#define LK201$K_LESS_THAN 201           /* <                                */
#define LK201$K_EQUAL 245               /* =                                */
#define LK201$K_GREATER_THAN 201        /* >                                */
#define LK201$K_QUESTION_MARK 243       /* ?                                */
#define LK201$K_AT_SIGN 197             /* @                                */
#define LK201$K_LEFT_BRACKET 250        /* [                                */
#define LK201$K_BACKSLASH 247           /* \                                */
#define LK201$K_RIGHT_BRACKET 246       /* ]                                */
#define LK201$K_CARET 219               /* ^                                */
#define LK201$K_UNDERLINE 249           /* _                                */
#define LK201$K_GRAVE_ACCENT 191        /* `                                */
#define LK201$K_LEFT_BRACE 250          /* left curly brace                 */
#define LK201$K_VERTICAL_LINE 247       /* |                                */
#define LK201$K_RIGHT_BRACE 246         /* right curly brace                */
#define LK201$K_TILDE 191               /* ~                                */
#define LK201$K_DELETE 188              /* DEL                              */
#define LK201$K_RETURN 189
#define LK201$K_TAB 190
#define LK201$K_SHIFT 174
#define LK201$K_CTRL 175
#define LK201$K_LOCK 176
#define LK201$K_COMPOSE 177
/*                                                                          */
#define LK201$K_PF1 161
#define LK201$K_PF2 162
#define LK201$K_PF3 163
#define LK201$K_PF4 164
#define LK201$K_KP0 146
#define LK201$K_KP1 150
#define LK201$K_KP2 151
#define LK201$K_KP3 152
#define LK201$K_KP4 153
#define LK201$K_KP5 154
#define LK201$K_KP6 155
#define LK201$K_KP7 157
#define LK201$K_KP8 158
#define LK201$K_KP9 159
#define LK201$K_ENTER 149
#define LK201$K_MINUS 160
#define LK201$K_COMMA 156
#define LK201$K_PERIOD 148
/*                                                                          */
#define LK201$K_UP 170
#define LK201$K_DOWN 169
#define LK201$K_LEFT 167
#define LK201$K_RIGHT 168
/*                                                                          */
#define LK201$K_F1 86
#define LK201$K_F2 87
#define LK201$K_F3 88
#define LK201$K_F4 89
#define LK201$K_F5 90
#define LK201$K_F6 100
#define LK201$K_F7 101
#define LK201$K_F8 102
#define LK201$K_F9 103
#define LK201$K_F10 104
#define LK201$K_F11 113
#define LK201$K_F12 114
#define LK201$K_F13 115
#define LK201$K_F14 116
#define LK201$K_F15 124
#define LK201$K_F16 125
#define LK201$K_F17 128
#define LK201$K_F18 129
#define LK201$K_F19 130
#define LK201$K_F20 131
/*                                                                          */
#define LK201$K_HELP 124
#define LK201$K_DO 125
/*                                                                          */
#define LK201$K_E1 138
#define LK201$K_E2 139
#define LK201$K_E3 140
#define LK201$K_E4 141
#define LK201$K_E5 142
#define LK201$K_E6 143
/*                                                                          */
#define LK201$K_FIND 138
#define LK201$K_INSERT_HERE 139
#define LK201$K_REMOVE 140
#define LK201$K_SELECT 141
#define LK201$K_PREV_SCREEN 142
#define LK201$K_NEXT_SCREEN 143
struct LK201 {
    struct  {
        unsigned LK201$V_TYPE : 1;      /* Mode set type                    */
        unsigned LK201$V_MODE : 2;      /* Mode or ON/OFF                   */
        unsigned LK201$V_DIVISION : 4;  /* Representation/division/rate change */
        unsigned LK201$V_LAST_PARAMETER : 1; /* Last parameter flag         */
        } LK201$R_COMMAND_FIELDS;
/* LK201 keycode constants. These symbols represent the keycodes returned by the LK201. The names are the same as the related */
/* SMG$K_TRM_name names except for the letters. In the case of the letters, the name is just the letter since uppercase and lower */
/* generate the same value for the key.                                     */
/*                                                                          */
/*                                                                          */
/* These symbols are used to identify each key by its position on any LK201. Also included are the special status codes. */
/*                                                                          */
/* These symbols correspond to the North American keyboard.                 */
/*                                                                          */
/* Keypad keys                                                              */
/*                                                                          */
/* Cursor positioning keys                                                  */
/*                                                                          */
/* Function keys                                                            */
/*                                                                          */
/* Synonyms for function keys                                               */
/*                                                                          */
/* Editing keys                                                             */
/*                                                                          */
/* Synonyms for editing keys                                                */
/*                                                                          */
    } ;
#ifndef __XAB_LOADED
#define __XAB_LOADED	1
#pragma nostandard

/*	XAB - V3.0	*/

/* Include all of the definitions for different types of XAB blocks */
#include XABALLDEF
#include XABCXFDEF
#include XABCXRDEF
#include XABDATDEF
#include XABDEF
#include XABFHCDEF
#include XABITMDEF
#include XABJNLDEF
#include XABKEYDEF
#include XABPRODEF
#include XABRDTDEF
#include XABRUDEF
#include XABSUMDEF
#include XABTRMDEF

#pragma standard
#endif					/* __XAB_LOADED */
#ifndef __XABALLDEF_LOADED
#define __XABALLDEF_LOADED	1
#pragma nostandard

/*** MODULE $xaballdef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        allocation xab definitions                                        */
/*                $xaballdef                                                */
/*                                                                          */
/*                                                                          */
/*+++++*****                                                                */
/*  the fields thru bkz cannot be rearranged due to                         */
/*  their commonality with fab                                              */
#define XAB$C_ALL 20                    /* xaball id code                   */
#define XAB$M_HRD 1
#define XAB$M_ONC 2
#define XAB$M_CBT 32
#define XAB$M_CTG 128
#define XAB$C_ANY 0                     /* any allocation o.k.              */
#define XAB$C_CYL 1                     /* cylinder boundary                */
#define XAB$C_LBN 2                     /* allocate at specified lbn        */
#define XAB$C_VBN 3                     /* allocate near specified vbn      */
#define XAB$C_RFI 4                     /* allocate near related file       */
#define XAB$K_ALLLEN 32                 /* length of xaball                 */
#define XAB$C_ALLLEN 32                 /* length of xaball                 */
struct XABALL {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    variant_union  {
        unsigned char xab$b_aop;        /* allocation options               */
        variant_struct  {
            unsigned xab$v_hrd : 1;     /* fail if requested alignment impossible  */
            unsigned xab$v_onc : 1;     /* locate allocated space within a cylinder  */
            unsigned xaballdef$$_fill_5 : 3; /* (spares)                    */
            unsigned xab$v_cbt : 1;     /* contiguous alllocation, best try  */
            unsigned xaballdef$$_fill_6 : 1; /* spare                       */
            unsigned xab$v_ctg : 1;     /* contiguous allocation            */
            } xab$r_aop_bits;
        } xab$r_aop_overlay;
    unsigned char xab$b_aln;            /* alignment type                   */
    unsigned short int xab$w_vol;       /* relative volume no. for allocation  */
/* (not applicable if aln = vbn or rfi)                                     */
    unsigned long int xab$l_loc;        /* allocation location              */
    unsigned long int xab$l_alq;        /* allocation quantity              */
    unsigned short int xab$w_deq;       /* default allocation quantity      */
    unsigned char xab$b_bkz;		/* bucket size used with the relative and indexed files */
    unsigned char xab$b_aid;            /* area id number                   */
    variant_union  {
        unsigned short int xab$w_rfi [3]; /* related file id                */
        variant_struct  {
            unsigned short int xab$w_rfi0; /* file number                   */
            unsigned short int xab$w_rfi2; /* seq number                    */
            unsigned short int xab$w_rfi4; /* rev number                    */
            } xab$r_rfi_fields;
        } xab$r_rfi_overlay;
    short int xaballdef$$_fill_8;       /* (spare)                          */
    } ;

/* These are tradtional macros that should be hand-maintained for compatibility */
#define XAB$V_HRD	0		/* fail if requestd alignmt cannot be performed */
#define XAB$V_ONC	1		/* locate space on cylinder boundary */
#define XAB$V_CBT	5		/* contiguous allocation, best try */
#define XAB$V_CTG	7		/* contiguous allocation */
/* Note: if you wish to access the xab$w_rfi field defined in the struct,
 * #undef this macro in your code */
#define xab$w_rfi	xab$w_rfi0


globalref struct XABALL cc$rms_xaball;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABALLDEF_LOADED */
#ifndef __XABCXFDEF_LOADED
#define __XABCXFDEF_LOADED	1

/*** MODULE $xabcxfdef ***/
/*                                                                          */
/*        RMS Context XAB associated with the FAB                           */
/*                $xabcxfdef                                                */
/*                                                                          */
/*                                                                          */
#define XAB$C_CXF 32                    /* XABCXF id code                   */
#define XAB$M_CXFRST 1
#define XAB$K_CXFLEN 60                 /* length of xab type CXF           */
#define XAB$C_CXFLEN 60                 /* length of xab type CXF           */
struct XABCXF {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
/*                                                                          */
/*        Following in common with the CXR block, too.                      */
/*        Do not rearrange without changing both.                           */
/*                                                                          */
    unsigned long int xab$l_cxfsts;     /* Status of the last file operation.  */
    unsigned long int xab$l_cxfstv;     /* Status Value of the last file operation.  */
/*                                                                          */
/* Top four bits of the options longword are reserved for the XABCXR.  These  */
/* bits describe the version of the key buffer.                             */
/*                                                                          */
    variant_union  {
        unsigned long int xab$l_cxfcop; /* Context Options.                 */
        variant_struct  {
            unsigned xab$v_cxfrst : 1;  /* Restore file state - use context blk as input.  */
            unsigned xab$v_fill_15 : 7;
            } xab$r_cxfcop_bits;
        } xab$r_cxfcop_overlay;
    unsigned long int xab$l_cxfbkp;     /* Bookkeeping bits                 */
    unsigned short int xab$w_cxfifi;    /* Internal File Identifier         */
    unsigned char xab$b_cxfver;         /* prologue version num             */
    char xabcxfdef$$_fill_5;            /* spare to longword align commonality  */
    long int xabcxfdef$$_fill_6;        /* spare                            */
/*                                                                          */
/*        Up Till now in common with XABCXR, too.                           */
/*                                                                          */
/*        The following fields correspond to those in the FAB or IFB        */
/*        They should not be rearranged as their order is assumed for       */
/*        purposes of moving large chunks of data rather than a byte        */
/*        or word at a time.  Note: ASSUME is used in the actual code       */
/*                                                                          */
    unsigned short int xab$w_cxfdeq;    /* Default extention quantity       */
    unsigned char xab$b_cxffac;         /* File access                      */
    unsigned char xab$b_cxfshr;         /* File Sharing                     */
    unsigned short int xab$w_cxfrte;    /* (Not used)                       */
    char xabcxfdef$$_fill_7;            /* spare                            */
    unsigned char xab$b_cxforg;         /* file organization                */
    unsigned short int xab$w_cxfgbc;    /* global buffer count              */
    unsigned char xab$b_cxfrtv;         /* retrieval window                 */
    char xabcxfdef$$_fill_8;
    long int xabcxfdef$$_fill_9 [4];    /* spares                           */
    } ;
 

#endif					/* __XABCXFDEF_LOADED */
#ifndef __XABCXRDEF_LOADED
#define __XABCXRDEF_LOADED	1

/*** MODULE $xabcxrdef ***/
/*                                                                          */
/*        RMS Context XAB associated with the RAB                           */
/*                $xabcxrdef                                                */
/*                                                                          */
/*                                                                          */
#define XAB$C_CXR 33                    /* XABCXR id code                   */
#define XAB$M_CXRRST 1
#define XAB$C_CXB_VER1 1
#define XAB$C_CXRBLEN 512               /* Length of CXRBUF (bytes)         */
#define XAB$K_CXRLEN 84                 /* Length of XAB type CXR           */
#define XAB$C_CXRLEN 84                 /* Length of XAB type CXR           */
struct XABCXR {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
/*                                                                          */
/*        Following in common with the CXF block, too.                      */
/*        Do not rearrange without changing it.                             */
/*                                                                          */
    unsigned long int xab$l_cxrsts;     /* Status of the last record operation.  */
    unsigned long int xab$l_cxrstv;     /* Status Value of the last record operation.  */
    variant_union  {
        unsigned long int xab$l_cxrcop; /* Context Options.                 */
        variant_struct  {
            unsigned xab$v_cxrrst : 1;  /* Restore file/record state - use context blk as input.  */
            unsigned xabcxrdef$$_fill_5 : 27;
            unsigned xab$v_cxrbver : 4; /* Version of Key buffer            */
            } xab$r_cxrcop_bits;
        } xab$r_cxrcop_overlay;
    unsigned long int xab$l_cxrbkp;     /* Bookkeeping bits                 */
    unsigned short int xab$w_cxrisi;    /* Internal Record Identifier       */
    unsigned char xab$b_cxrver;         /* prologue version num.            */
    char xabcxrdef$$_fill_6;            /* spare to longword align commonality  */
    long int xabcxrdef$$_fill_7;        /* spare                            */
/*                                                                          */
/*        Up Till now in common with XABCXF, too.                           */
/*                                                                          */
/*                                                                          */
/*        The following elements are arranged such that large amounts of    */
/*        data can be moved at a time rather than words or bytes.  Do not   */
/*        rearrange them without this consideration in mind.                */
/*                                                                          */
/*	  The following elements are stream dependent regardless of file org. */
/*                                                                          */
    unsigned char xab$b_cxrmbf;         /* Multibuffer count                */
    unsigned char xab$b_cxrmbc;         /* Multiblock count                 */
    unsigned short int xab$w_cxrbfz;    /* sz in byte of CXRBUF             */
/*                                                                          */
/*	The following elements are necessary for saving the NRP context for */
/*	Sequential and Relative files.                                      */
/*                                                                          */
    unsigned long int xab$l_cxrvbn;     /* NRP VBN                          */
    unsigned short int xab$w_cxroff;    /* NRP offset in VBN                */
    unsigned short int xab$w_fill_8;    /* mbz - longword align             */
/*                                                                          */
/*	The following elements are necessary for saving the NRP context for */
/*	ISAM files.                                                         */
/*                                                                          */
    unsigned long int xab$l_cxrpos0;    /* Primary Positioning RFA          */
    unsigned short int xab$w_cxrpos4;
    short int xabcxrdef$$_fill_9;       /* Spare MBZ                        */
    unsigned long int xab$l_cxrcur0;    /* Current Positioning RFA          */
    unsigned short int xab$w_cxrcur4;
    short int xabcxrdef$$_fill_10;      /* Spare MBZ                        */
    unsigned long int xab$l_cxrsid0;    /* SIDR positioning RFA             */
    unsigned short int xab$w_cxrsid4;
    short int xabcxrdef$$_fill_11;      /* Spare MBZ                        */
    unsigned short int xab$w_cxrcnt;    /* SIDR array count                 */
    unsigned char xab$b_cxrkref;        /* Cur Key of Reference             */
    unsigned char xab$b_cxrklen;        /* Length of key                    */
    char *xab$l_cxrbuf;			/* address of key buf               */
    long int xabcxrdef$$_fill_12 [2];   /* Spares                           */
    } ;

#endif					/* __XABCXRDEF_LOADED */
#ifndef __XABDATDEF_LOADED
#define __XABDATDEF_LOADED	1
#pragma nostandard
/*	XABDAT -- Date and Time Extended Attribute Block Definitions	*/

/* Macros produced from STARLET */

/*** MODULE $xabdatdef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        date/time xab definitions                                         */
/*                $xabdatdef                                                */
/*                                                                          */
#define XAB$C_DAT 18                    /* xabdat id code                   */
#define XAB$K_DATLEN_V2 36              /* Version 2 XABDAT length          */
#define XAB$C_DATLEN_V2 36              /* Version 2 XABDAT length          */
#define XAB$K_DATLEN 44			/* length of XABDAT                 */
#define XAB$C_DATLEN 44                 /* length of XABDAT                 */

/* The STARLET definition of XABDAT is nearly useless.  This is a hand
 * built version */
struct	XABDAT	{
    unsigned char xab$b_cod;
    unsigned char xab$b_bln;
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    unsigned short xab$w_rvn;		/* revision number */
    unsigned	: 16;			/* spare */
   struct {int :32, :32;} xab$q_rdt;	/* revision date and time */
   struct {int :32, :32;} xab$q_cdt;	/* creation date and time */
   struct {int :32, :32;} xab$q_edt;	/* expiration date and time */
   struct {int :32, :32;} xab$q_bdt;	/* backup date and time */
};

globalref struct XABDAT cc$rms_xabdat;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABDATDEF_LOADED */
#ifndef __XABDEF_LOADED
#define __XABDEF_LOADED	1

/*** MODULE $xabdef ***/
/*                                                                          */
/*         definitions for all xabs                                         */
/*                $xabdef                                                   */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*  the first four fields are shared in common between all xabs             */
/*  and hence are defined only once                                         */
/*  (the only exception is that the spare word may be used by some xabs)    */
/*                                                                          */
struct XAB {
    unsigned char xab$b_cod;            /* xab id code                      */
    unsigned char xab$b_bln;            /* block length                     */
    short int xabdef$$_fill_1;          /* (spare)                          */
    char *xab$l_nxt;			/* xab chain link                   */
/*WITH POSSIBLE EXCEPTION OF SPARE FIELD                                    */
    unsigned short int xab$w_rvn;
    short int xabdef$$_fill_2;
    variant_union  {
        int xab$q_rdt [2];
        variant_struct  {
            unsigned long int xab$l_rdt0;
            long int xab$l_rdt4;
/*COMMON AMONG DAT AND RDT XABS                                             */
            } xab$r_rdt_fields;
        } xab$r_rdt_overlay;
    } ;
struct XABDEF1 {
    char xabdef$$_fill_3 [8];
    char xabdef$$_fill_4;               /*THESE FIELDS WILL BE DEFINED LATER  */
    char xabdef$$_fill_5;
    short int xabdef$$_fill_6;
    long int xabdef$$_fill_7;
    long int xabdef$$_fill_8;
    short int xabdef$$_fill_9;
    unsigned char xab$b_bkz;            /*COMMON TO FHC AND ALQ XABS        */
    } ;
#define XAB$C_CXT_VER1 1                /* RMS Context Extraction version 1 */
 

#endif					/* __XABDEF_LOADED */
#ifndef __XABFHCDEF_LOADED
#define __XABFHCDEF_LOADED	1
#pragma nostandard

/*** MODULE $xabfhcdef ***/
/*++                                                                        */
/*        file header characteristics xab definitions                       */
/*                $xabfhcdef                                                */
/*                                                                          */
/*+++++*****                                                                */
/*  the fields of this xab cannot be rearranged since                       */
/*  they correspond to an on-disk structure                                 */
/*                                                                          */
#define XAB$C_FHC 29                    /* xabfhc id code                   */
#define XAB$M_FTN 1
#define XAB$M_CR 2
#define XAB$M_PRN 4
#define XAB$M_BLK 8
#define XAB$K_FHCLEN 44                 /* length of xabfhc                 */
#define XAB$C_FHCLEN 44                 /* length of xabfhc                 */
struct XABFHC {
    unsigned char xab$b_cod;			
    unsigned char xab$b_bln;			
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    unsigned char xab$b_rfo;            /* record format and file org       */
    variant_union  {
        unsigned char xab$b_atr;        /* record attributes                */
        variant_struct  {
            unsigned xab$v_ftn : 1;     /* fortran carriage-ctl             */
            unsigned xab$v_cr : 1;      /* lf-record-cr carriage ctl        */
            unsigned xab$v_prn : 1;     /* print-file carriage ctl          */
            unsigned xab$v_blk : 1;     /* records don't cross block boundaries  */
            unsigned xab$v_fill_11 : 4;
            } xab$r_fill_10;
        } xab$r_fill_9;
    unsigned short int xab$w_lrl;       /* longest record's length          */
    variant_union  {
        unsigned long int xab$l_hbk;    /* hi vbn allocated                 */
/* (n.b. reversed on disk!)                                                 */
        variant_struct  {
            unsigned short int xab$w_hbk0;
            unsigned short int xab$w_hbk2;
            } xab$r_hbk_fields;
        } xab$r_hbk_overlay;
    variant_union  {
        unsigned long int xab$l_ebk;    /* eof vbn                          */
/* (n.b. reversed on disk)                                                  */
        variant_struct  {
            unsigned short int xab$w_ebk0;
            unsigned short int xab$w_ebk2;
            } xab$r_ebk_fields;
        } xab$r_ebk_overlay;
    unsigned short int xab$w_ffb;       /* first free byte in eof block     */
    unsigned char xab$b_bkz;		/* bucket size */
    unsigned char xab$b_hsz;            /* header size for vfc              */
    unsigned short int xab$w_mrz;       /* max record size                  */
    unsigned short int xab$w_dxq;       /* default extend quantity          */
    unsigned short int xab$w_gbc;       /* global buffer count              */
    char xabfhcdef$$_fill_6 [8];        /* spares (pad to last word)        */
    unsigned short int xab$w_verlimit;  /* version limit for file.          */
/*-----*****                                                                */
    unsigned long int xab$l_sbn;        /* starting lbn if contiguous       */
    } ;

globalref struct XABFHC cc$rms_xabfhc;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABFHCDEF_LOADED */
#ifndef __XABITMDEF_LOADED
#define __XABITMDEF_LOADED	1

/*** MODULE $xabitmdef ***/
/*++                                                                        */
/*                                                                          */
/*        Item XAB definitions                                              */
/*                                                                          */
/*                                                                          */
#define XAB$C_ITM 36                    /* xabitm id code                   */
/* The following set of flags exactly mimic the FCHDEF flags defined in STARLET. */
/* They are here to provide an unsupported interface to the UCHAR longword maintained */
/* by the file system.                                                      */
/*                                                                          */
#define XAB$M_WASCONTIG 1
#define XAB$M_NOBACKUP 2
#define XAB$M_WRITEBACK 4
#define XAB$M_READCHECK 8
#define XAB$M_WRITCHECK 16
#define XAB$M_CONTIGB 32
#define XAB$M_LOCKED 64
#define XAB$M_CONTIG 128
#define XAB$M_RESERVED1 256
#define XAB$M_RESERVED2 512
#define XAB$M_RESERVED3 1024
#define XAB$M_BADACL 2048
#define XAB$M_SPOOL 4096
#define XAB$M_DIRECTORY 8192
#define XAB$M_BADBLOCK 16384
#define XAB$M_MARKDEL 32768
#define XAB$M_NOCHARGE 65536
#define XAB$M_ERASE 131072
struct UCHAR_FLAGS {                    /* mimics $FCHDEF                   */
    unsigned xab$v_wascontig : 1;
    unsigned xab$v_nobackup : 1;
    unsigned xab$v_writeback : 1;
    unsigned xab$v_readcheck : 1;
    unsigned xab$v_writcheck : 1;
    unsigned xab$v_contigb : 1;
    unsigned xab$v_locked : 1;
    unsigned xab$v_contig : 1;
    unsigned xab$v_reserved1 : 1;
    unsigned xab$v_reserved2 : 1;
    unsigned xab$v_reserved3 : 1;
    unsigned xab$v_badacl : 1;
    unsigned xab$v_spool : 1;
    unsigned xab$v_directory : 1;
    unsigned xab$v_badblock : 1;
    unsigned xab$v_markdel : 1;
    unsigned xab$v_nocharge : 1;
    unsigned xab$v_erase : 1;
    unsigned xab$v_fill_17 : 6;
    } ;
#define XAB$_NET_BUFFER_SIZE 1          /* (sense) 	negociated buffer size */
#define XAB$_NET_BLOCK_COUNT 2          /* (set,sense)	requested block count */
#define XAB$_NET_REMOTE_SYSTEM 3        /* (sense) 	remote system type  */
#define XAB$_NET_REMOTE_FILE_SYSTEM 4   /* (sense) 	remote file system type */
#define XAB$_NET_EXTPROT 5              /* (set,sense) 	actual extended protection */
#define XAB$_NET_SYSCAP_LOCAL 6         /* (sense) 	DAP SYSCAP of local system */
#define XAB$_NET_SYSCAP_REMOTE 7        /* (sense) 	DAP SYSCAP of remote system */
#define XAB$_NET_DAPVER_LOCAL 8         /* (sense) 	DAP version - local system */
#define XAB$_NET_DAPVER_REMOTE 9        /* (sense) 	DAP version - remote system */
#define XAB$_NET_LINK_TIMEOUT 10        /* (set,sense)	logical link timeout (seconds)  */
#define XAB$_NET_DATA_CRC_ENABLE 11     /* (set,sense)	DAP level CRC       */
#define XAB$_NET_LINK_CACHE_ENABLE 12   /* (set,sense)	Logical link cache enable */
/*		,NET_DATA_COMPRESSION		/* (set,sense)	do data compression (FUTURE)  */
#define XAB$K_NET_MIN 1
#define XAB$K_NET_MAX 12
#define XAB$_STAT_ENABLE 64             /* (set,sense)	Read statistics enable */
#define XAB$K_STAT_MIN 64
#define XAB$K_STAT_MAX 64
#define XAB$_UCHAR 128                  /* (sense)	Read file characteristics (obsolete) */
#define XAB$_UCHAR_WASCONTIG 129        /* (sense)	FCH$V_WASCONTIG     */
#define XAB$_UCHAR_NOBACKUP 130         /* (set,sense)	FCH$V_NOBACKUP      */
#define XAB$_UCHAR_WRITEBACK 131        /* (sense)	FCH$V_WRITEBACK     */
#define XAB$_UCHAR_READCHECK 132        /* (set,sense)	FCH$V_READCHECK     */
#define XAB$_UCHAR_WRITECHECK 133       /* (set,sense)	FCH$V_WRITECHECK    */
#define XAB$_UCHAR_CONTIGB 134          /* (set,sense)	FCH$V_CONTIGB       */
#define XAB$_UCHAR_LOCKED 135           /* (set,sense)	FCH$V_LOCKED        */
#define XAB$_UCHAR_CONTIG 136           /* (sense)	FCH$V_CONTIG        */
#define XAB$_UCHAR_BADACL 137           /* (sense)	FCH$V_BADACL        */
#define XAB$_UCHAR_SPOOL 138            /* (sense)	FCH$V_SPOOL         */
#define XAB$_UCHAR_DIRECTORY 139        /* (sense)	FCH$V_DIRECTORY     */
#define XAB$_UCHAR_BADBLOCK 140         /* (sense)	FCH$V_BADBLOCK      */
#define XAB$_UCHAR_MARKDEL 141          /* (sense)	FCH$V_BADBLOCK      */
#define XAB$_UCHAR_NOCHARGE 142         /* (sense)	FCH$V_NOCHARGE      */
#define XAB$_UCHAR_ERASE 143            /* (set,sense)	FCH$V_ERASE         */
#define XAB$K_UCHAR_MIN 128
#define XAB$K_UCHAR_MAX 143
#define XAB$_STORED_SEMANTICS 192       /* (set,sense)	Stored semantics of the file */
#define XAB$_ACCESS_SEMANTICS 193       /* (set,sense)	Access semantics of the file */
#define XAB$_RMS_EXTENSION 194          /* (set,sense)	Required RMS processing extension */
#define XAB$K_XLATE_MIN 192
#define XAB$K_XLATE_MAX 194
#define XAB$C_SEMANTICS_MAX_LEN 64      /* max length for stored or access semantics */
#define XAB$K_SEMANTICS_MAX_LEN 64      /* max length for stored or access semantics */
#define XAB$_MULTIBUFFER_COUNT 256      /* (set-only)  Multibuffer count (not limited to 127) */
/*  legal only on $CONNECT                                                  */
#define XAB$K_MISC_MIN 256
#define XAB$K_MISC_MAX 256
#define XAB$K_SENSEMODE 1
#define XAB$K_SETMODE 2
#define XAB$K_ITMLEN 32
#define XAB$C_ITMLEN 32
struct XABITM {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    char *xab$l_itemlist;		/* Address of the item list         */
/* In the user interface, item codes are arbitrary integer values, so       */
/* we may as well allow logical groups to have contiguous codes, with       */
/* room for expansion (to allow table driven code).                         */
    unsigned char xab$b_mode;           /* must be either SETMODE or SENSEMODE */
    char xab$b_itm_fill1 [3];           /* Reserved space for future definition */
    long int xab$l_itm_fill2 [4];       /* Reserved space for future definition */
    } ;
#define XAB$K_DISABLE 0
#define XAB$K_ENABLE 1
#define XAB$K_RT11 1
#define XAB$K_RSTS 2
#define XAB$K_RSX11S 3
#define XAB$K_RSX11M 4
#define XAB$K_RSX11D 5
#define XAB$K_IAS 6
#define XAB$K_VAXVMS 7
#define XAB$K_TOPS20 8
#define XAB$K_TOPS10 9
#define XAB$K_RTS8 10
#define XAB$K_OS8 11
#define XAB$K_RSX11MP 12
#define XAB$K_COPOS11 13
#define XAB$K_P_OS 14
#define XAB$K_VAXELN 15
#define XAB$K_CPM 16
#define XAB$K_MS_DOS 17
#define XAB$K_ULTRIX_32 18
#define XAB$K_ULTRIX_11 19
#define XAB$K_RMS11 1
#define XAB$K_RMS20 2
#define XAB$K_RMS32 3
#define XAB$K_FCS11 4
#define XAB$K_RT11FS 5
#define XAB$K_NO_FS 6
#define XAB$K_TOPS20FS 7
#define XAB$K_TOPS10FS 8
#define XAB$K_OS8FS 9
#define XAB$K_RMS32S 10
#define XAB$K_CPMFS 11
#define XAB$K_MS_DOSFS 12
#define XAB$K_ULTRIX32_FS 13
#define XAB$K_ULTRIX11_FS 14
#define XAB$M_NET_NOREAD 1
#define XAB$M_NET_NOWRITE 2
#define XAB$M_NET_NOEXECUTE 4
#define XAB$M_NET_NODELETE 8
#define XAB$M_NET_NOAPPEND 16
#define XAB$M_NET_NODIRECTORY 32
#define XAB$M_NET_NOUPDATE 64
#define XAB$M_NET_NOCHANGE 128
#define XAB$M_NET_NOEXTEND 256
struct XABNETEXTPROT {
    variant_union  {
        unsigned short int xab$w_system_acc;
        variant_struct  {
            unsigned xab$v_net_noread : 1;
            unsigned xab$v_net_nowrite : 1;
            unsigned xab$v_net_noexecute : 1;
            unsigned xab$v_net_nodelete : 1;
            unsigned xab$v_net_noappend : 1;
            unsigned xab$v_net_nodirectory : 1;
            unsigned xab$v_net_noupdate : 1;
            unsigned xab$v_net_nochange : 1;
            unsigned xab$v_net_noextend : 1;
            unsigned xab$v_fill_20 : 7;
            } xab$r_fill_19;
        } xab$r_fill_18;
    unsigned short int xab$w_owner_acc;
    unsigned short int xab$w_group_acc;
    unsigned short int xab$w_world_acc;
    } ;
struct XABNETDAPVER {
    unsigned char xab$b_ver_dap;
    unsigned char xab$b_ver_eco;
    unsigned char xab$b_ver_cus;
    unsigned char xab$b_ver_dsv;
    unsigned char xab$b_ver_csv;
    } ;
struct XABNETCAPDEF {
    unsigned xab$v_cap_filall : 1;
    unsigned xab$v_cap_seqorg : 1;
    unsigned xab$v_cap_relorg : 1;
    unsigned xab$v_cap_fill_21 : 1;
    unsigned xab$v_cap_extend : 1;
    unsigned xab$v_cap_seqfil : 1;
    unsigned xab$v_cap_ranrrn : 1;
    unsigned xab$v_cap_ranvbn : 1;
    unsigned xab$v_cap_rankey : 1;
    unsigned xab$v_cap_fill_22 : 1;
    unsigned xab$v_cap_ranrfa : 1;
    unsigned xab$v_cap_idxorg : 1;
    unsigned xab$v_cap_swmode : 1;
    unsigned xab$v_cap_append : 1;
    unsigned xab$v_cap_submit : 1;
    unsigned xab$v_cap_fill_23 : 1;
    unsigned xab$v_cap_mds : 1;
    unsigned xab$v_cap_display : 1;
    unsigned xab$v_cap_msgblk : 1;
    unsigned xab$v_cap_unrblk : 1;
    unsigned xab$v_cap_bigblk : 1;
    unsigned xab$v_cap_dapcrc : 1;
    unsigned xab$v_cap_keyxab : 1;
    unsigned xab$v_cap_allxab : 1;
    unsigned xab$v_cap_sumxab : 1;
    unsigned xab$v_cap_directory : 1;
    unsigned xab$v_cap_timxab : 1;
    unsigned xab$v_cap_proxab : 1;
    unsigned xab$v_cap_fill_24 : 1;
    unsigned xab$v_cap_fopspl : 1;
    unsigned xab$v_cap_fopscf : 1;
    unsigned xab$v_cap_fopdlt : 1;
    unsigned xab$v_cap_fill_26 : 1;
    unsigned xab$v_cap_seqrac : 1;
    unsigned xab$v_cap_fill_27 : 1;
    unsigned xab$v_cap_bitopt : 1;
    unsigned xab$v_cap_warning : 1;
    unsigned xab$v_cap_rename : 1;
    unsigned xab$v_cap_wildcard : 1;
    unsigned xab$v_cap_gngopt : 1;
    unsigned xab$v_cap_nammsg : 1;
    unsigned xab$v_cap_segmsg : 1;
    unsigned xab$v_cap_chgattcls : 1;
    unsigned xab$v_cap_chgtimcls : 1;
    unsigned xab$v_cap_chgprocls : 1;
    unsigned xab$v_cap_chgnamcls : 1;
    unsigned xab$v_cap_modattcre : 1;
    unsigned xab$v_cap_nam3part : 1;
    unsigned xab$v_cap_chgattren : 1;
    unsigned xab$v_cap_chgtimren : 1;
    unsigned xab$v_cap_chgproren : 1;
    unsigned xab$v_cap_ctlblkcnt : 1;
    unsigned xab$v_cap_octalver : 1;
    unsigned xab$v_fill_21 : 3;
    } ;
#define XAB$S_BUFFER_SIZE 4
#define XAB$S_NETWORK_BLOCK_COUNT 4
#define XAB$S_REMOTE_SYSTEM 4
#define XAB$S_REMOTE_FILE_SYSTEM 4
#define XAB$S_EXTPROT_LOCAL 8
#define XAB$S_EXTPROT_REMOTE 8
#define XAB$S_CAPABIL_LOCAL 8
#define XAB$S_CAPABIL_REMOTE 8
#define XAB$S_DAPVER_LOCAL 5
#define XAB$S_DAPVER_REMOTE 5
#define XAB$S_CACHE_TMO 4
 

#endif					/* __XABITMDEF_LOADED */
#ifndef __XABJNLDEF_LOADED
#define __XABJNLDEF_LOADED	1

/*** MODULE $xabjnldef ***/
/*++                                                                        */
/*                                                                          */
/*        Journal XAB definitions                                           */
/*                $xabjnldef                                                */
/*                                                                          */
/*                                                                          */
#define XAB$C_JNL 34                    /* xabjnl id code                   */
#define XAB$C_JNL_TYPE_NONE 0
#define XAB$C_AI 1                      /* AI journal                       */
#define XAB$C_BI 2                      /* BI journal                       */
#define XAB$C_AT 3                      /* AT journal                       */
#define XAB$C_RU_DEFAULT 4              /* default RU volume                */
#define XAB$M_JOURNAL_DISABLED 1
#define XAB$M_BACKUP_DONE 2
#define XAB$K_JNLLEN 80
#define XAB$C_JNLLEN 80
struct XABJNL {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    unsigned char xab$b_xabjnl_type;    /* type of $XABJNL                  */
    char xabjnldef$$_fill_5;
    variant_union  {
        unsigned short int xab$w_jnl_flags; /* journal flags (from ACE$W_RMSJNL_FLAGS) */
        variant_struct  {
            unsigned xab$v_journal_disabled : 1; /* journaling disabled by BACKUP (AI/BI/AT) */
            unsigned xab$v_backup_done : 1; /* Backup done since last $OPEN */
            unsigned xab$v_fill_16 : 6;
            } xab$r_jnl_flags_bits;
        } xab$r_jnl_flags_overlay;
    struct FAB *xab$l_jnl_fab;		/* address of journal file FAB      */
    char *xab$l_volnam_buf;		/* address of journal volume name buffer */
    unsigned short int xab$w_volnam_siz; /* size of journal volume name buffer */
    unsigned short int xab$w_volnam_len; /* return length of journal volume name */
    unsigned int xab$q_jnl_verify_cdate [2]; /* journal file creation date (from ACE$Q_CDATE) */
/* (to match with journal file's creation date)                             */
    unsigned long int xab$l_jnlidx;     /* Journal stream index within journal file */
    unsigned long int xab$l_backup_seqno; /* Backup sequence number.        */
    unsigned int xab$q_jnl_mod_time [2]; /* Timestamp of last backup or last journal */
/* entry recovered.                                                         */
    long int xabjnldef$$_fill_7;
    long int xabjnldef$$_fill_8;
    long int xabjnldef$$_fill_9;
    long int xabjnldef$$_fill_10;
    long int xabjnldef$$_fill_11;
    long int xabjnldef$$_fill_12;
    long int xabjnldef$$_fill_13;
    long int xabjnldef$$_fill_14;
    } ;
 

#endif					/* __XABJNLDEF_LOADED */
#ifndef __XABKEYDEF_LOADED
#define __XABKEYDEF_LOADED	1
#pragma nostandard

/*** MODULE $xabkeydef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        key definition xab field definitions                              */
/*                $xabkeydef                                                */
/*                                                                          */
/*                                                                          */
#define XAB$C_KEY 21                    /* xabkey id code                   */
#define XAB$M_DUP 1
#define XAB$M_CHG 2
#define XAB$M_NUL 4
#define XAB$M_IDX_NCMPR 8
#define XAB$M_KEY_NCMPR 64
#define XAB$M_DAT_NCMPR 128
#define XAB$C_STG 0                     /* string                           */
#define XAB$C_IN2 1                     /* signed 15 bit integer (2 bytes)  */
#define XAB$C_BN2 2                     /* 2 byte binary                    */
#define XAB$C_IN4 3                     /* signed 31 bit integer (4 bytes)  */
#define XAB$C_BN4 4                     /* 4 byte binary                    */
#define XAB$C_PAC 5                     /* packed decimal (1-16 bytes)      */
#define XAB$C_IN8 6                     /* signed 63 bit integer (4 bytes)  */
#define XAB$C_BN8 7                     /* 8 byte binary                    */
#define XAB$C_COL 8                     /* collated                         */
#define XAB$C_MAX_ASCEND 8              /* maximum ascending type           */
#define XAB$C_DSTG 32                   /* descending string                */
#define XAB$C_DIN2 33                   /*     "      signed word           */
#define XAB$C_DBN2 34                   /*     "      unsigned word         */
#define XAB$C_DIN4 35                   /*     "      signed longword       */
#define XAB$C_DBN4 36                   /*     "      unsigned longword     */
#define XAB$C_DPAC 37                   /*     "      packed decimal        */
#define XAB$C_DIN8 38                   /*     "      signed quadword       */
#define XAB$C_DBN8 39                   /*     "      unsigned quadword     */
#define XAB$C_DCOL 40                   /*     "      collated              */
#define XAB$C_MAXDTP 40                 /* max. legal data type             */
#define XAB$K_KEYLEN_V2 64              /* old xabkey length                */
#define XAB$C_KEYLEN_V2 64              /* old xabkey length                */
/*                                                                          */
#define XAB$C_PRG3 3                    /* Prologue version three           */
#define XAB$C_PRG2 2                    /* Prologue version two             */
#define XAB$C_PRG1 1                    /* Prologue versoin one             */
#define XAB$K_KEYLEN_V4 76              /* xabkey length until V5           */
#define XAB$C_KEYLEN_V4 76              /* xabkey length until V5           */
#define XAB$K_KEYLEN 100                /* xabkey length for V5             */
#define XAB$C_KEYLEN 100                /* xabkey length for V5             */
/*--                                                                        */
struct XABKEY {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char	*xab$l_nxt;		/* Next XAB address in chain */
/*                                                                          */
/* the field layout of the key xab is such that it matchs as                */
/* closely as possible the layout of a key decriptor in the                 */
/* index file prologue. this is so the contents may be moved                */
/* between the two structures as efficiently as possible.                   */
/*                                                                          */
    unsigned char xab$b_ian;            /* index level area number          */
    unsigned char xab$b_lan;            /* lowest index level area number   */
    unsigned char xab$b_dan;            /* data level area number           */
    unsigned char xab$b_lvl;            /* level of root bucket             */
    unsigned char xab$b_ibs;            /* size of index buckets in virtual blocks  */
    unsigned char xab$b_dbs;            /* size of data buckets in virtual blocks  */
    unsigned long int xab$l_rvb;        /* root bucket start vbn            */
    variant_union  {
        unsigned char xab$b_flg;        /* key option flags                 */
        variant_struct  {
            unsigned xab$v_dup : 1;     /* duplicate key values allowed     */
            unsigned xab$v_chg : 1;     /* alt key only --key field may change on update  */
            unsigned xab$v_nul : 1;     /* alt key only --null key value enable  */
            unsigned xab$v_idx_ncmpr : 1; /* indicate index records for given key are not compressed  */
            unsigned xabkeydef$$_fill_5 : 2; /* spare                       */
            unsigned xab$v_key_ncmpr : 1; /* indicates key is not compressed in data record  */
            unsigned xab$v_fill_14 : 1;
            } xab$r_flg_bits0;
        variant_struct  {
            unsigned xabkeydef$$_fill_6 : 1; /* space over dup              */
            unsigned xabkeydef$$_fill_7 : 2; /* spare                       */
            unsigned xabkeydef$$_fill_8 : 1; /* space over idx_ncmpr        */
            unsigned xabkeydef$$_fill_9 : 2; /* spare                       */
            unsigned xabkeydef$$_fill_10 : 1; /* space over key_ncmpr       */
            unsigned xab$v_dat_ncmpr : 1; /* data record is not compressed  */
            } xab$r_flg_bits1;
        } xab$r_flg_overlay;
    unsigned char xab$b_dtp;            /* key field data type              */
    unsigned char xab$b_nsg;            /* number of key segments           */
    unsigned char xab$b_nul;            /* nul key character                */
    unsigned char xab$b_tks;            /* total key field size (bytes)     */
    unsigned char xab$b_ref;            /* key of reference (0=prim key,    */
/* 1-254 = alternate keys)                                                  */
    unsigned short int xab$w_mrl;       /* minimun record length to contain key field  */
    unsigned short int xab$w_ifl;       /* index bucket fill size (bytes)   */
    unsigned short int xab$w_dfl;       /* data bucket fil size (bytes)     */
    variant_union  {
        unsigned short int xab$w_pos [8]; /* key field record offset positions  */
        variant_struct  {
            unsigned short int xab$w_pos0; /* segment 0                     */
            unsigned short int xab$w_pos1; /* segment 1                     */
            unsigned short int xab$w_pos2; /* segment 2                     */
            unsigned short int xab$w_pos3; /* segment 3                     */
            unsigned short int xab$w_pos4; /* segment 4                     */
            unsigned short int xab$w_pos5; /* segment 5                     */
            unsigned short int xab$w_pos6; /* segment 6                     */
            unsigned short int xab$w_pos7; /* segment 7                     */
            } xab$r_pos_fields;
        } xab$r_pos_overlay;
    variant_union  {
        unsigned char xab$b_siz [8];    /* key field segment sizes          */
        variant_struct  {
            unsigned char xab$b_siz0;   /* segment 0                        */
            unsigned char xab$b_siz1;   /* segment 1                        */
            unsigned char xab$b_siz2;   /* segment 2                        */
            unsigned char xab$b_siz3;   /* segment 3                        */
            unsigned char xab$b_siz4;   /* segment 4                        */
            unsigned char xab$b_siz5;   /* segment 5                        */
            unsigned char xab$b_siz6;   /* segment 6                        */
            unsigned char xab$b_siz7;   /* segment 7                        */
            } xab$r_siz_fields;
        } xab$r_siz_overlay;
    short int xabkeydef$$_fill_11;      /* spare                            */
/*                                                                          */
/* the positions of the above fields are dictated by the key descriptor     */
/* record layout in the index file prologue.                                */
/*                                                                          */
    char *xab$l_knm;			/* key name buffer address */
    unsigned long int xab$l_dvb;        /* first data bucket start vbn      */
/* Additions for prologue 3 files                                           */
/*                                                                          */
    variant_union  {
        unsigned char xab$b_typ [8];    /* key field segment types          */
        variant_struct  {
            unsigned char xab$b_typ0;   /* segment 0                        */
            unsigned char xab$b_typ1;   /* segment 1                        */
            unsigned char xab$b_typ2;   /* segment 2                        */
            unsigned char xab$b_typ3;   /* segment 3                        */
            unsigned char xab$b_typ4;   /* segment 4                        */
            unsigned char xab$b_typ5;   /* segment 5                        */
            unsigned char xab$b_typ6;   /* segment 6                        */
            unsigned char xab$b_typ7;   /* segment 7                        */
            } xab$r_typ_fields;
        } xab$r_typ_overlay;
    unsigned char xab$b_prolog;         /* indicate prologue version desired (primary key only)  */
    char xabkeydef$$_fill_12;           /* spare                            */
    short int xabkeydef$$_fill_13;      /* spare                            */
    void *xab$l_coltbl;			/* address of collate table         */
    unsigned long int xab$l_colsiz;	/* size of collate table            */
    char *xab$l_colnam;			/* name of collate table            */
    long int xabkeydef$$_fill_14;       /* spare                            */
    long int xabkeydef$$_fill_15;       /* spare                            */
    long int xabkeydef$$_fill_16;       /* spare                            */
/*++                                                                        */
    } ;
 
/* These are tradtional macros that should be hand-maintained for compatibility */
#define XAB$V_DUP	0		/* duplicate key value allowed */
#define XAB$V_CHG	1		/* may change on update (alternate keys only) */
#define XAB$V_NUL	2		/* null key value enable (alternate keys only) */
#define XAB$V_IDX_NCMPR	3		/* indicates index records are not compressed */
#define XAB$V_KEY_NCMPR	6		/* indicates primary key is not compressed */
#define XAB$V_DAT_NCMPR	7		/* indicated data record is not compressed */
/* Note: if you wish to access these field as defined in the struct,
 * #undef these macros in your code */
#define xab$w_pos	xab$w_pos0
#define xab$b_siz 	xab$b_siz0			
#define xab$b_typ	xab$b_typ0			

globalref struct XABKEY cc$rms_xabkey;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABKEYDEF_LOADED */
#ifndef __XABPRODEF_LOADED
#define __XABPRODEF_LOADED	1
#pragma nostandard

/*** MODULE $xabprodef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        protection xab field definitions                                  */
/*                $xabprodef                                                */
/*                                                                          */
/*                                                                          */
#define XAB$C_PRO 19                    /* xabpro id code                   */
#define XAB$M_NOREAD 1
#define XAB$M_NOWRITE 2
#define XAB$M_NOEXE 4
#define XAB$M_NODEL 8
union xabprodef {
    variant_struct  {
        unsigned xab$v_noread : 1;      /* deny read access                 */
        unsigned xab$v_nowrite : 1;     /* deny write access                */
        unsigned xab$v_noexe : 1;       /* deny execution access            */
        unsigned xab$v_nodel : 1;       /* deny delete access               */
        unsigned xab$v_fill_12 : 4;
        } xab$r_xabprodef_bits;
    } ;
#define XAB$M_PROPAGATE 1
#define XAB$K_PROLEN_V3 16              /* V3a xabpro length                */
#define XAB$C_PROLEN_V3 16              /* V3a xabpro length                */
#define XAB$K_PROLEN 88                 /* xabpro length                    */
#define XAB$C_PROLEN 88                 /* xabpro length                    */
struct XABPRO {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    variant_union  {
        unsigned short int xab$w_pro;   /* protection mask                  */
        variant_struct  {
            unsigned xab$v_sys : 4;     /* system                           */
            unsigned xab$v_own : 4;     /* owner                            */
            unsigned xab$v_grp : 4;     /* group                            */
            unsigned xab$v_wld : 4;     /* world                            */
            } xab$r_pro_bits;
        } xab$r_pro_overlay;
    unsigned char xab$b_mtacc;          /* Magtape access control char.     */
    variant_union  {
        unsigned char xab$b_prot_opt;   /* XABPRO options field             */
        variant_struct  {
            unsigned xab$v_propagate : 1; /* Propagate security attributes on $ENTER and $RENAME */
            unsigned xab$v_fill_13 : 7;
            } xab$r_prot_opt_fields;
        } xab$r_prot_opt_overlay;
    variant_union  {
        unsigned long int xab$l_uic;    /* uic code                         */
        variant_struct  {
            unsigned short int xab$w_mbm; /* member code                    */
            unsigned short int xab$w_grp; /* group code                     */
            } xab$r_uic_fields;
        } xab$r_uic_overlay;
    variant_union  {                    /* RWED/mode protection for file    */
    struct {int :32, :32;} xab$q_prot_mode; /* eventually may be a quadword     */
        variant_struct  {
            unsigned char xab$b_prot_mode; /* but currently only a byte     */
            } xab$r_prot_mode_fields;
        } xab$r_prot_mode_overlay;
    char *xab$l_aclbuf;			/* address of user's ACL buffer     */
    unsigned short int xab$w_aclsiz;    /* size of user's ACL buffer        */
    unsigned short int xab$w_acllen;    /* return length of entire ACL      */
    unsigned long int xab$l_aclctx;     /* ACL context field                */
    unsigned long int xab$l_aclsts;     /* ACL return err status            */
    long int xabprodef$$_fill_10;       /* spare                            */
    long int xabprodef$$_fill_11;       /* spare                            */
    long int xabprodef$$_fill_12;       /* spare                            */
    long int xabprodef$$_fill_13;       /* spare                            */
    long int xabprodef$$_fill_14;       /* spare                            */
    long int xabprodef$$_fill_15;       /* spare                            */
    long int xabprodef$$_fill_16;       /* spare                            */
    long int xabprodef$$_fill_17;       /* spare                            */
    long int xabprodef$$_fill_18;       /* spare                            */
    long int xabprodef$$_fill_19;       /* spare                            */
    long int xabprodef$$_fill_20;       /* spare                            */
    long int xabprodef$$_fill_21;       /* spare                            */
    } ;

/* These are tradtional macros that should be hand-maintained for compatibility */
#define XAB$V_SYS	0		/* system */
#define XAB$S_SYS	4
#define XAB$V_OWN	4		/* owner */
#define XAB$S_OWN	4
#define XAB$V_GRP	8		/* group */
#define XAB$S_GRP	4
#define XAB$V_WLD	12		/* world */
#define XAB$S_WLD	4
#define XAB$V_NOREAD	0		/* deny read access */
#define XAB$V_NOWRITE	1		/* deny write access */
#define XAB$V_NOEXE	2		/* deny execution access */
#define XAB$V_NODEL	3		/* deny delete access */
#define XAB$V_PROPOGATE	0		/* propogate security attributes on $ENTER and $RENAME */
#define XAB$M_PROPOGATE	(1 << XAB$V_PROPOGATE)

globalref struct XABPRO cc$rms_xabpro;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABPRODEF_LOADED */
#ifndef __XABRDTDEF_LOADED
#define __XABRDTDEF_LOADED	1
#pragma nostandard

/*** MODULE $xabrdtdef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        revision date/time xab definitions                                */
/*                $xabrdtdef                                                */
#define XAB$C_RDT 30                    /* xabrdt id code                   */
#define XAB$K_RDTLEN 20                 /* length of rdt xab                */
#define XAB$C_RDTLEN 20                 /* length of rdt xab                */
struct XABRDT {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    unsigned short xab$w_rvn;		/* revision number */
    short int xabrdtdef$$_fill_6;       /* spare                            */
    struct {int :32, :32;} xab$q_rdt;	/* revision date and time */
    } ;

globalref struct XABRDT cc$rms_xabrdt;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABRDTDEF_LOADED */
#ifndef __XABRUDEF_LOADED
#define __XABRUDEF_LOADED	1

/*** MODULE $xabrudef ***/
/*++                                                                        */
/*                                                                          */
/*        Recovery Unit XAB definitions                                     */
/*                $xabrudef                                                 */
/*                                                                          */
/*                                                                          */
#define XAB$C_RU 35                     /* xabru id code                    */
#define XAB$M_NOJOIN 1
#define XAB$K_RULEN 48
#define XAB$C_RULEN 48
struct XABRU {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    variant_union  {
        unsigned short int xab$w_ru_flags; /* Flags                         */
        variant_struct  {
            unsigned xab$v_nojoin : 1;  /* Do not join any recovery unit    */
            unsigned xab$v_fill_22 : 7;
            } xab$r_ru_flags_bits;
        } xab$r_ru_flags_overlay;
    short int xabrudef$$_fill_5;
    unsigned long int xab$l_ru_handle;  /* RU handle to join (input field)  */
    unsigned long int xab$l_ru_handle_joined; /* RU handle joined (output field) */
    long int xabrudef$$_fill_7;
    long int xabrudef$$_fill_8;
    long int xabrudef$$_fill_9;
    long int xabrudef$$_fill_10;
    long int xabrudef$$_fill_11;
    long int xabrudef$$_fill_12;
    long int xabrudef$$_fill_13;
    } ;

#endif					/* __XABRUDEF_LOADED */
#ifndef __XABSUMDEF_LOADED
#define __XABSUMDEF_LOADED	1
#pragma nostandard

/*** MODULE $xabsumdef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        summary xab field definitions                                     */
/*                $xabsumdef                                                */
/*                                                                          */
/*                                                                          */
#define XAB$C_SUM 22                    /* xabsum id code                   */
#define XAB$K_SUMLEN 12                 /* xabsum length                    */
#define XAB$C_SUMLEN 12                 /* xabsum length                    */
struct XABSUM {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    unsigned char xab$b_noa;            /* number of defined areas for index file  */
    unsigned char xab$b_nok;            /* number of defined keys for index file  */
    unsigned short int xab$w_pvn;       /* prologue version number (relative and index files)  */
    } ;
 

globalref struct XABSUM cc$rms_xabsum;	/* Declare initialized prototype data structures */

#pragma standard
#endif					/* __XABSUMDEF_LOADED */
#ifndef __XABTRMDEF_LOADED
#define __XABTRMDEF_LOADED	1
#pragma nostandard

/*** MODULE $xabtrmdef ***/
/*--                                                                        */
/*++                                                                        */
/*                                                                          */
/*        terminal control xab field definitions                            */
/*                $xabtrmdef                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
#define XAB$C_TRM 31                    /*XABTRM ID CODE                    */
#define XAB$K_TRMLEN 36                 /* length of xab of type terminal control  */
#define XAB$C_TRMLEN 36                 /* length of xab of type terminal control  */
struct XABTRM {
    unsigned char xab$b_cod;		
    unsigned char xab$b_bln;		
    unsigned	: 16;			/* spare */
    char *xab$l_nxt;			/* Next XAB in chain */
    char *xab$l_itmlst;			/* item list address                */
    unsigned short int xab$w_itmlst_len; /* item list length                */
    short int xabtrmdef$$_fill_5;       /* spare                            */
    long int xabtrmdef$$_fill_6;        /* spare                            */
    long int xabtrmdef$$_fill_7;        /* spare                            */
    long int xabtrmdef$$_fill_8;        /* spare                            */
    long int xabtrmdef$$_fill_9;        /* spare                            */
    long int xabtrmdef$$_fill_10;       /* spare                            */
    } ;
 
globalref	struct XABTRM	cc$rms_xabtrm;	/* declare initialized prototype data structure */

#pragma standard
#endif					/* __XABTRMDEF_LOADED */
/********************************************************************************************************************************/
/* Created 25-MAY-1990 18:44:13 by VAX SDL V3.2-10     Source:  9-JAN-1990 10:51:43 DECW$LIBSRESD:[DPSBINDINGS.SRC]XDPS$DPSXCLIEN */
/********************************************************************************************************************************/
/*  XDPS$DPSXCLIENT.SDL                                                     */
/**************************************************************************** */
/*                                                                          * */
/*  COPYRIGHT (c) 1989 BY                                                   * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                           * */
/*  ALL RIGHTS RESERVED                                                     * */
/*                                                                          * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  * */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  * */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  * */
/*  TRANSFERRED.                                                            * */
/*                                                                          * */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  * */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  * */
/*  CORPORATION.                                                            * */
/*                                                                          * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 * */
/*                                                                          * */
/**************************************************************************** */
 
/*** MODULE XDPS$DPSXCLIENT IDENT Version 1 ***/
/* XDPS$DPSFRIENDS.SDL                                                      */
/***************************************************************************** */
/**                                                                          * */
/**                         COPYRIGHT (c) 1989 BY                            * */
/**             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                * */
/**                         ALL RIGHTS RESERVED                              * */
/**                                                                          * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  * */
/**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  * */
/**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  * */
/**  TRANSFERRED.                                                            * */
/**                                                                          * */
/** THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO  CHANGE  WITHOUT  NOTICE  * */
/**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  * */
/**  CORPORATION.                                                            * */
/**                                                                          * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 * */
/**                                                                          * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/*=== CONSTANTS ===                                                         */
/*                                                                          */
/* TokenType values, used to specify the format of numeric values           */
/* for the system on which the client library is built. See DPS language    */
/* reference manual                                                         */
/*                                                                          */
#define DPS$C_HI_IEEE 128
#define DPS$C_LO_IEEE 129
#define DPS$C_HI_NATIVE 130
#define DPS$C_LO_NATIVE 131
/*                                                                          */
/* DPS_DEF_TOKENTYPE is the specification code for the form of binary       */
/* object sequences generated by PSWrap. The C code generated by pswrap     */
/* references this name. DPS_DEF_TOKENTYPE is system-dependent.             */
/* XDPS$C_DPS_DEF_TOKEN_TYPE is set equal to DPS_LO_NATIVE for VMS systems. */
/* The value DPS_DEF_TOKENTYPE is used by some private DPS code so it is    */
/* also defined here for completeness.                                      */
/*                                                                          */
#define DPS$C_DEF_TOKEN_TYPE 131
#define DPS_DEF_TOKENTYPE 131
/*                                                                          */
/* --- binary object sequence support ---                                   */
/*                                                                          */
/* Object attributes & types: Values for attributedTypes                    */
/*                                                                          */
#define DPS$C_LITERAL 0
#define DPS$C_EXEC 128
/*                                                                          */
/* Attribute masks                                                          */
/*                                                                          */
#define DPS$C_STRING 5
#define DPS$C_NULL 0
#define DPS$C_INT 1
#define DPS$C_REAL 2
#define DPS$C_NAME 3
#define DPS$C_BOOL 4
#define DPS$C_IMMEDIATE 6
#define DPS$C_ARRAY 7
#define DPS$C_MARK 8
/*                                                                          */
/* Type values                                                              */
/*                                                                          */
/* Object sequence constants                                                */
/*                                                                          */
#define DPS$C_HEADER_SIZE 4
#define DPS$C_EXT_HEADER_SIZE 8
/*                                                                          */
/*=== TYPES ===                                                             */
/*                                                                          */
/*                                                                          */
/* Defines the 3 possible encodings of PostScript language programs.        */
/*                                                                          */
#define dps$c_ascii 0
#define dps$c_bin_obj_seq 1
#define dps$c_encoded_tokens 2
typedef unsigned long int dps$program_encoding;
/*                                                                          */
/* Defines the 2 possible encodings for user names in the                   */
/* dps_binObjSeq and dps_encodedTokens forms of PostScript language         */
/* programs.                                                                */
/*                                                                          */
#define dps$c_indexed 0
#define dps$c_strings 1
typedef unsigned long int dps$name_encoding;
/*                                                                          */
/* Enumerates the C data types that can be used to describe wrap            */
/* parameters.                                                              */
/*                                                                          */
#define dps$c_tboolean 0
#define dps$c_tchar 1
#define dps$c_tuchar 2
#define dps$c_tfloat 3
#define dps$c_tdouble 4
#define dps$c_tshort 5
#define dps$c_tushort 6
#define dps$c_tint 7
#define dps$c_tuint 8
#define dps$c_tlong 9
#define dps$c_tulong 10
typedef unsigned long int dps$defined_type;
/*                                                                          */
#define dps$c_pr_size 52
typedef struct _dps$procs_rec {
    int (*dps$a_cr_text_proc)();
    int (*dps$a_pr_bin_obj_seq_write)();
    int (*dps$a_pr_write_typed_object_array)();
    int (*dps$a_pr_write_string_chars)();
    int (*dps$a_pr_write_data)();
    int (*dps$a_pr_write_postscript)();
    int (*dps$a_pr_flush_context)();
    int (*dps$a_pr_reset_context)();
    int (*dps$a_pr_update_name_map)();
    int (*dps$a_pr_await_return_values)();
    int (*dps$a_pr_interrupt)();
    int (*dps$a_pr_destroy_context)();
    int (*dps$a_pr_wait_context)();
    } dps$procs_rec;
typedef dps$procs_rec *dps$procs_ptr;
/*                                                                          */
/* A DPSResultsRec defines one of the formal result args of a wrapped       */
/* procedure.  The 'type' field specifies the formal type of the            */
/* return value. The 'count' field specifies the number of values           */
/* expected (this supports array formals). The 'value' field points         */
/* to the location of the first value; the storage beginning there          */
/* must have room for count values of type.   If 'count' == -1, then        */
/* 'value' points to a scalar (single) result arg.                          */
/*                                                                          */
/* typedef struct {                                                         */
/*    DPSDefinedType type;                                                  */
/*    int count;                                                            */
/*    char *value;                                                          */
/* } DPSResultsRec, *DPSResults;                                            */
/*                                                                          */
#define dps$c_rr_size 12
typedef struct _dps$results_rec {
    dps$defined_type dps$l_rr_type;
    long int dps$l_rr_count;
    char *dps$a_rr_value;
    } dps$results_rec;
typedef dps$results_rec *dps$results_ptr;
/*                                                                          */
/* The DPSSpaceProcsRec may be extended to include system-specific items    */
/*                                                                          */
/* typedef struct {                                                         */
/*    void (*DestroySpace)();                                               */
/*   } DPSSpaceProcsRec, *DPSSpaceProcs;                                    */
/*                                                                          */
#define dps$c_spr_size 4
typedef struct _dps$space_pr_rec {
    int (*dps$a_spr_destroy_space)();
    } dps$space_pr_rec;
typedef dps$space_pr_rec *dps$space_procs_ptr;
/*                                                                          */
/* A DPSSpaceRec provides a representation of a space.                      */
/* The DPSSpaceRec may be extended to include system-specific items.        */
/* BEWARE an implementation of the DPS client library is also likely to     */
/* extend the DPSSpaceRec to include implementation-dependent information   */
/* in additional fields.                                                    */
/*                                                                          */
/* typedef struct {                                                         */
/*    DPSSpaceProcs procs;                                                  */
/* } DPSSpaceRec, *DPSSpace;                                                */
/*                                                                          */
#define dps$c_sr_size 4
typedef struct _dps$space_rec {
    dps$space_procs_ptr dps$a_sr_procs;
    } dps$space_rec;
typedef dps$space_rec *dps$space_ptr;
/*                                                                          */
/* A DPSContextRec provides a representation of a context.                  */
/*                                                                          */
/* The 'priv' field is provided for use by application code. It is          */
/* initialized to NULL and is not touched thereafter by the client          */
/* library implementation.                                                  */
/* 	                                                                    */
/* The 'space' field is the space to which the context belongs.  The        */
/* 'programEncoding' and 'nameEncoding' fields describe the encodings       */
/* preferred by the context (server). The values in these fields are        */
/* established when the DPSContext is created and cannot be changed         */
/* therafter. The 'procs' field points to a vector of procedures            */
/* (in a DPSProcsRec) that implement the context operations.                */
/*                                                                          */
/* The 'textProc' and 'errorProc' are called by the client library          */
/* implementation to dispose of ascii text and errors, respectively, that   */
/* the PostScript interpreter produces.                                     */
/*                                                                          */
/* The 'resultTableLength' and 'resultTable' fields define the number, type */
/* and location of values expected back from the PostScript interpreter.    */
/* They should be set up before writing any PostScript language that        */
/* may return values.                                                       */
/*                                                                          */
/* The chainParent field is non-NIL if this context automatically receives  */
/* a copy of any PostScript language sent to the referenced (parent) context. */
/*                                                                          */
/* The chainChild field is non-NIL if this context automatically sends      */
/* a copy of any PostScript language it receives to the referenced (child)  */
/* context.                                                                 */
/*                                                                          */
/* NOTE the client library implementation extends the DPSContextRec to      */
/* include implementation-dependent information in additional fields.       */
/*                                                                          */
/* You may read the fields of a DPSContextRec directly, but you should      */
/* never modify them directly. Use the macros provided for that purpose.    */
/*                                                                          */
/* typedef struct _t_DPSContextRec {                                        */
/*   char *priv;                                                            */
/*   DPSSpace space;                                                        */
/*   DPSProgramEncoding programEncoding;                                    */
/*   DPSNameEncoding nameEncoding;                                          */
/*   DPSProcs procs;                                                        */
/*   void (*textProc)();                                                    */
/*   void (*errorProc)();                                                   */
/*   DPSResults resultTable;                                                */
/*   unsigned int resultTableLength;                                        */
/*   struct _t_DPSContextRec *chainParent, *chainChild;                     */
/* } DPSContextRec, *DPSContext;                                            */
#define dps$c_cr_size 44
typedef struct _dps$context_rec {
    char *dps$a_cr_priv;
    dps$space_ptr dps$a_cr_space;
    dps$program_encoding dps$l_cr_program_encoding;
    dps$name_encoding dps$l_cr_name_encoding;
    dps$procs_ptr dps$a_cr_procs;
    int (*dps$a_cr_text_proc)();
    int (*dps$a_cr_error_proc)();
    dps$results_ptr dps$a_cr_result_table;
    unsigned long int dps$l_cr_result_table_length;
    struct _dps$context_rec *dps$a_cr_chain_parent;
    struct _dps$context_rec *dps$a_cr_chain_child;
    } dps$context_rec;
typedef dps$context_rec *dps$context_ptr;
/*                                                                          */
/* -- binary object sequence support --                                     */
/*                                                                          */
/* unsigned rep. of -1                                                      */
#define DPS$C_SYS_NAME 65535
/*                                                                          */
/* boolean, int, string, name and array                                     */
/*                                                                          */
#define dps$c_bog_size 8
struct dps$bin_obj_gen {
    unsigned char dps$b_bog_attributed_type;
    unsigned char dps$b_bog_tag;
    unsigned short int dps$w_bog_length;
    long int dps$l_bog_val;
    } ;
/*                                                                          */
/* Float                                                                    */
/*                                                                          */
#define dps$c_bor_size 8
struct dps$bin_obj_real {
    unsigned char dps$b_bor_attributed_type;
    unsigned char dps$b_bor_tag;
    unsigned short int dps$w_bor_length;
    float dps$f_bor_real_val;
    } ;
#define dps$c_borec_size 8
struct dps$bin_obj_rec {
    unsigned char dps$b_borec_attributed_type;
    unsigned char dps$b_borec_tag;
    unsigned short int dps$w_borec_length;
    union  {
        long int dps$l_borec_integer_val;
        float dps$f_borec_real_val;
        long int dps$l_borec_name_val;
        long int dps$l_borec_string_val;
        long int dps$l_borec_array_val;
        } dps$r_borec_val;
    } ;
typedef struct dps$bin_obj_rec *dps$bin_obj_rec_ptr;
#define dps$c_bosr_size 8
struct dps$bin_obj_seq {
    unsigned char dps$b_bosr_token_type;
    unsigned char dps$b_bosr_n_top_elements;
    unsigned short int dps$w_bosr_length;
    dps$bin_obj_rec_ptr dps$a_bosr_objects [1];
    } ;
typedef struct dps$bin_obj_seq *dps$bin_obj_seq_rec_ptr;
#define dps$c_ebosr_size 12
struct dps$extbinobjseq {
    unsigned char dps$b_ebosr_token_type;
    unsigned char dps$b_ebosr_escape;
    unsigned short int dps$w_bosr_n_top_elements;
    unsigned long int dps$l_ebosr_length;
    dps$bin_obj_rec_ptr dps$a_ebosr_objects [1];
    } ;
typedef struct dps$extbinobjseq *dps$extended_bin_obj_seq_rec_ptr;
/*                                                                          */
/*=== PROCEDURES ===                                                        */
/*                                                                          */
/*                                                                          */
/* dps$await_return_values(dpscontext_struc);                               */
/*                                                                          */
/* dpscontext_struc.rr.r = dps context structure                            */
/*                                                                          */
void dps$await_return_values() ;
/*                                                                          */
/* dps$update_name_map(dpscontext_struc);                                   */
/*                                                                          */
/* dpscontext_struc.rr.r = dps context structure                            */
/*                                                                          */
void dps$update_name_map() ;
/*                                                                          */
/* dps$bin_obj_seq_write(dpscontext_struc, postscript_data, length)         */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  postscript_data.rt.dx = postscript data                                 */
/*  length.rl.r = data length                                               */
/*                                                                          */
void dps$bin_obj_seq_write() ;
/*                                                                          */
/* dpscontext_struc = dps$priv_current_context();                           */
/*                                                                          */
/* dpscontext_struc.wr.r = dps context structure                            */
/*                                                                          */
dps$context_ptr dps$priv_current_context() ;
/*                                                                          */
/* dps$write_string_chars(dpscontext_struc, postscript_data, length)        */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  postscript_data.rt.dx = postscript data                                 */
/*  length.rl.r = data length                                               */
/*                                                                          */
void dps$write_string_chars() ;
/*                                                                          */
/* dps$write_typed_object_array(                                            */
/*           dpscontext_struc, postscript_data_type, postscript_data, length) */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  postscript_data_type.rlu.r = postscript data type from dps$defined_type */
/*  postscript_data.rt.dx = postscript data array                           */
/*  length.rl.r = data length                                               */
/*                                                                          */
void dps$write_typed_object_array() ;
/*                                                                          */
/* dps$set_result_table(                                                    */
/*           dpscontext_struc, context_result_table, length)                */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  context_result_table.rlu.r = result table in context structure          */
/*  length.rl.r = table length                                              */
/*                                                                          */
void dps$set_result_table() ;
/*                                                                          */
/* Support for user names                                                   */
/*                                                                          */
/*                                                                          */
/* This routine assigns indices to the given user names. It is              */
/* called once for each wrapped procedure. The parameters 'nNames' and      */
/* 'names' define an array of strings which are the user names. The         */
/* parameter 'indices' is an array of (int *) which are the locations       */
/* in which to store the indices. The caller must ensure that the string    */
/* pointers remain valid after the return.                                  */
/*                                                                          */
/* As a storage optimization, DPSMapNames will interpret a NIL              */
/* value in the names array as the previous valid string in                 */
/* the name array. Effectively, if names[n] == NIL, DPSMapNames             */
/* will decrement n until names[] is non-NIL and use that string.           */
/* names[0] must be non-NIL.                                                */
/*                                                                          */
/* dps$map_names(                                                           */
/*           dpscontext_struc, num_names, names_aray, indices_array)        */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  num_names.rl.r = number of elements in the name array                   */
/*  names_array.rt.dx = array of names separated by commas                  */
/*  indices_array.wl.r = array of integers                                  */
/*                                                                          */
void dps$map_names() ;
/*                                                                          */
/*                                                                          */
/* This routine returns the text for the user name with the given index.    */
/* The string returned is owned by the library (treat it as readonly).      */
/*                                                                          */
/* dps$name_from_index(index, user_name)                                    */
/*                                                                          */
/*  index.rl.r = user name index                                            */
/*  user_name.wt.dx = user name returned                                    */
/*                                                                          */
void dps$name_from_index() ;
/* XDPS$DPSCLIENT.SDL                                                       */
/***************************************************************************** */
/**                                                                          * */
/**                         COPYRIGHT (c) 1989 BY                            * */
/**             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                * */
/**                         ALL RIGHTS RESERVED                              * */
/**                                                                          * */
/**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  * */
/**  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  * */
/**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  * */
/**  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  * */
/**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  * */
/**  TRANSFERRED.                                                            * */
/**                                                                          * */
/** THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO  CHANGE  WITHOUT  NOTICE  * */
/**  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  * */
/**  CORPORATION.                                                            * */
/**                                                                          * */
/**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  * */
/**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 * */
/**                                                                          * */
/***************************************************************************** */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*=== TYPES ===                                                             */
/*                                                                          */
typedef long int dps$error_code;
/*                                                                          */
/*  Standard error codes (type DPSErrorCode)                                */
/*  These are intended to be used with dpsexcept.h                          */
/*  System-specific extensions can be made. Codes 1000 through 1099 are     */
/*  reserved for use by Adobe.                                              */
/*                                                                          */
/* The error codes passed to a DPSErrorProc:                                */
/*                                                                          */
/* dps_err_ps identifies standard PostScript language interpreter           */
/* errors. The arg1 argument to the errorProc is the address of the         */
/* binary object sequence sent by the handleerror (or resynchandleerror)    */
/* operator to report the error. The sequence has 1 object, which is an     */
/* array of 4 objects. See the language extensions document for details     */
/* on the contents of this sequence. arg2 is the number of bytes in the     */
/* entire binary object sequence.                                           */
/*                                                                          */
/* dps_err_nameTooLong flags user names that are too long. 128 chars        */
/* is the maximum length for PostScript language names. The name and its    */
/* length are passed as arg1 and arg2 to the error proc.                    */
/*                                                                          */
/* dps_err_resultTagCheck flags erroneous result tags, most likely          */
/* due to erroneous explicit use of the printobject operator. The           */
/* pointer to the binary object sequence and its length are passed          */
/* as arg1 and arg2 to the error proc. There is one object in the           */
/* sequence.                                                                */
/*                                                                          */
/* dps_err_resultTypeCheck flags incompatible result types. A pointer       */
/* to the offending binary object is passed as arg1; arg2 is unused.        */
/*                                                                          */
/* dps_err_invalidContext flags an invalid DPSContext argument. An          */
/* attempt to send PostScript language code to a context that has           */
/* terminated is the most likely cause of this error. arg1 to the           */
/* DPSErrorProc is the context id (see the fork operator); arg2 is          */
/* unused.                                                                  */
/*                                                                          */
#define dps$c_err_ps 1000
#define dps$c_err_name_too_long 1001
#define dps$c_err_result_tag_check 1002
#define dps$c_err_result_type_check 1003
#define dps$c_err_invalid_context 1004
/*                                                                          */
/* Call-back procedure to handle text from the PostScript interpreter.      */
/* 'buf' contains 'count' bytes of ASCII text.                              */
/*                                                                          */
typedef void (*dps$text_proc)();
/*                                                                          */
/* Call-back procedure to report errors from the PostScript interpreter.    */
/* The meaning of arg1 and arg2 depend on 'errorCode', as described above.  */
/* See dps$default_error_proc, below.                                       */
/*                                                                          */
typedef void (*dps$error_proc)();
/*                                                                          */
/*=== PROCEDURES ===                                                        */
/*                                                                          */
/*                                                                          */
/*  dps$default_error_proc(dpscontext_struc, error_code, arg1, arg2)        */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*   error_code.rl.r = error code to be processed                           */
/*   arg1.r.lu.r = error_codes argument                                     */
/*   arg2.r.lu.r = error_codes argument                                     */
/*                                                                          */
/* A sample DPSErrorProc for handling errors from the PostScript interpreter. */
/* The meaning of arg1 and arg2 depend on 'errorCode'. See DPSErrorCode,    */
/* above.                                                                   */
/*                                                                          */
/* DPSDefaultErrorProc formulates a text message and passes it to the       */
/* text backstop proc (see DPSSetTextBackstop).                             */
/*                                                                          */
/* If errorCode == dps_err_ps AND the application had previously caused     */
/* resyncstart to be executed by ctxt, DPSDefaultErrorProc calls            */
/* RAISE(dps_err_ps, ctxt) after invoking the text backstop proc.           */
/* DPSDefaultErrorProc is the only procedure in the Display PostScript      */
/* library that calls RAISE, and it calls RAISE only in the case outlined   */
/* above.                                                                   */
/*                                                                          */
/* When DPSDefaultErrorProc is used as a context's errorProc, the exception */
/* to report dps_err_ps can be raised by any of the procedures in the Display */
/* PostScript library, even ones invoked to deal with other contexts. Note  */
/* therefore that wraps might raise this exception. Applications that use   */
/* resyncstart must be prepared to handle exceptions.                       */
/*                                                                          */
/* See DPSResetContext for details on what to do when an exception to       */
/* report dps_err_ps is raised.                                             */
/*                                                                          */
/* See dpsexcept.h for general information on RAISE and exception handling.  */
/*                                                                          */
/*                                                                          */
void dps$default_error_proc() ;
/*                                                                          */
/*                                                                          */
/*  dps$set_text_backstop(text_proc)                                        */
/*                                                                          */
/*   text_proc.ra.vp = user written text event handler                      */
/*                                                                          */
/*  Call this to establish textProc as the handler for text output from     */
/*  dps$default_error_proc or from contexts created by the 'fork' operator  */
/*  but not made known to the dps client library. NULL will be passed as the  */
/*  ctxt argument to textProc in the latter case.                           */
/*                                                                          */
/*                                                                          */
void dps$set_text_backstop() ;
/*                                                                          */
/*  dps$get_current_text_backstop()                                         */
/*                                                                          */
/*  Returns the textProc passed most recently to DPSSetTextBackstop, or NULL */
/*  if none                                                                 */
/*                                                                          */
/*                                                                          */
int *dps$get_current_text_backstop() ;
/*                                                                          */
/*                                                                          */
/*  dps$set_error_backstop(error_proc)                                      */
/*                                                                          */
/*   error_proc.wa.vp = user written error event handler                    */
/*                                                                          */
/*  Call this to establish errorProc as the handler for PostScript interpreter */
/*  errors from contexts created by the 'fork' operator but not made        */
/*  known to the dps client library. NULL will be passed as the ctxt        */
/*  argument to errorProc.                                                  */
/*                                                                          */
/*                                                                          */
void dps$set_error_backstop() ;
/*                                                                          */
/*  dps$get_current_error_backstop()                                        */
/*                                                                          */
/*  Returns the errorProc passed most recently to DPSSetErrorBackstop, or NULL */
/*  if none                                                                 */
/*                                                                          */
/*                                                                          */
int *dps$get_current_error_backstop() ;
/*                                                                          */
/*  dps$get_current_context()                                               */
/*                                                                          */
/*   dpscontext_struc.wr.r = dps context structure                          */
/*                                                                          */
/*                                                                          */
/*  Get the default context. Used in conjunction with xdps$psops.h and with */
/*  wraps that are defined without an explicit DPSContext argument.         */
/*  Initially NULL.                                                         */
/*                                                                          */
/*                                                                          */
dps$context_ptr dps$get_current_context() ;
/*                                                                          */
/*  dps$set_context(dpscontext_struc)                                       */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*                                                                          */
/*  Set the default context. Used in conjunction with psops.h and with      */
/*  wraps that are defined without an explicit DPSContext argument.         */
/*                                                                          */
/*                                                                          */
void dps$set_context() ;
/*                                                                          */
/*                                                                          */
/* dps$write_postscript(                                                    */
/*           dpscontext_struc, postscript_data, length)                     */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  postscript_data.rt.dx = postscript data                                 */
/*  length.rl.r = data length                                               */
/*                                                                          */
/*  Send as input to 'ctxt' 'count' bytes of PostScript language contained  */
/*  in 'buf'. The code may be in either of the 3 encodings for PostScript   */
/*  language programs: plain text, encoded tokens, or binary object sequence. */
/*  If the form is encoded tokens or binary object sequence, an entire      */
/*  one of these must be sent (perhaps in a series of calls on              */
/*  DPSWritePostScript) before PostScript language in a different encoding  */
/*  can be sent.                                                            */
/*                                                                          */
/*  DPSWritePostScript may transform the PostScript language to a different */
/*  encoding, depending on the characteristics established for 'ctxt' when  */
/*  it was created. For example, a context created to store its PostScript  */
/*  in an ASCII file would convert binary object sequences to ASCII.        */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the dps_err_invalidContext    */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*  If 'ctxt' is incapable of accepting more PostScript language, for example */
/*  because it is backlogged with code that was sent earlier to be executed, */
/*  this will block until transmission of 'count' bytes can be completed.   */
/*                                                                          */
/*                                                                          */
void dps$write_postscript() ;
/*                                                                          */
/*                                                                          */
/* dps$printf(dpscontext_struc, format, argument_string)                    */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  format.rt.dx = C type format information                                */
/*  argument_string.rt.dx = arguments separated by commas                   */
/*                                                                          */
/*  Write string 'fmt' to ctxt with the optional arguments converted,       */
/*  formatted and logically inserted into the string in a manner            */
/*  identical to the C library routine printf.                              */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the dps_err_invalidContext    */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*  If 'ctxt' is incapable of accepting more PostScript language, for example */
/*  because it is backlogged with code that was sent earlier to be executed, */
/*  this will block until transmission of the string can be completed.      */
/*                                                                          */
/*                                                                          */
void dps$printf() ;
/*                                                                          */
/*                                                                          */
/* dps$write_data(                                                          */
/*           dpscontext_struc, postscript_data, length)                     */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  postscript_data.rt.dx = postscript data                                 */
/*  length.rl.r = data length                                               */
/*  Write 'count' bytes of data from 'buf' to 'ctxt'. This will not         */
/*  change the data.                                                        */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the dps_err_invalidContext    */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*  If 'ctxt' is incapable of accepting more PostScript language, for example */
/*  because it is backlogged with code that was sent earlier to be executed, */
/*  this will block until transmission of 'count' bytes can be completed.   */
/*                                                                          */
/*                                                                          */
void dps$write_data() ;
/*                                                                          */
/* dps$flush_context(dpscontext_struc)                                      */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  Force any buffered data to be sent to ctxt.                             */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the dps_err_invalidContext    */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*  If 'ctxt' is incapable of accepting more PostScript language, for example */
/*  because it is backlogged with code that was sent earlier to be executed, */
/*  this will block until transmission of all buffered bytes can be completed. */
/*                                                                          */
/*                                                                          */
void dps$flush_context() ;
/*                                                                          */
/*                                                                          */
/* status_return = dps$chain_context(dpscontext_struc_parent,               */
/*                                        dpscontext_struc_child)           */
/*                                                                          */
/*  status_return.wlc.v = status of context creation                        */
/*                        0 -OK, -1 child is already spoken for             */
/*                                                                          */
/*  dpscontext_struc_parent.rr.r = structure of parent context              */
/*  dpscontext_struc_child.rr.r = structure of child context                */
/*                                                                          */
/*  This links child and all of child's children onto parent's 'chainChild' */
/*  list. The 'chainChild' list threads those contexts that automatically   */
/*  receive copies of any PostScript code sent to parent. A context may     */
/*  appear on only one such list.                                           */
/*                                                                          */
/*  Normally, DPSChainContext returns 0. It returns -1 if child already     */
/*  appears on some other context's 'chainChild' list.                      */
/*                                                                          */
/*                                                                          */
long int dps$chain_context() ;
/*                                                                          */
/*                                                                          */
/* dps$unchain_context(dpscontext_struc)                                    */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  This unlinks ctxt from the chain that it is on, if any. It leaves       */
/*	ctxt->chainParent == ctxt->chainChild == NULL                       */
/*                                                                          */
/*                                                                          */
void dps$unchain_context() ;
/*                                                                          */
/*                                                                          */
/* dps$reset_context(dpscontext_struc)                                      */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  This should be called by the application in its HANDLER clauses         */
/*  when Exception.Code == dps_err_ps. See the discussion above about       */
/*  DPSDefaultErrorProc. Also see the discussion of error handling in       */
/*  the client library documentation.                                       */
/*                                                                          */
/*  DPSResetContext closes the input stream to the server for the context   */
/*  and discards any pending bytes on the output stream from the server for */
/*  the context. It then waits for this output stream to close, then reopens */
/*  both streams. DPSResetContext is designed to work with resyncstart to   */
/*  leave the context ready to read and execute more input after handling   */
/*  a PostScript error.                                                     */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the dps_err_invalidContext    */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*                                                                          */
void dps$reset_context() ;
/*                                                                          */
/*                                                                          */
/* dps$wait_context(dpscontext_struc)                                       */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  Waits until the PostScript interpreter is ready for more input to       */
/*  this context.  This is useful for synchronizing an application          */
/*  with the DPS server.                                                    */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the DPS$ERR_INVALID_CONTEXT   */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*                                                                          */
void dps$wait_context() ;
/*                                                                          */
/*                                                                          */
/* dps$set_text_proc(dpscontext_struc, text_proc)                           */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  text_proc.wa.vp = user written text event handler                       */
/*                                                                          */
/* Change ctxt's textProc.                                                  */
/*                                                                          */
/* Change the address in the dpscontext_struc to a new test_proc            */
/*                                                                          */
void dps$set_text_proc() ;
/*                                                                          */
/* dps$set_error_proc(dpscontext_struc, error_proc)                         */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  error_proc.wa.vp = user written error event handler                     */
/*                                                                          */
/* Change ctxt's errorProc.                                                 */
/*                                                                          */
/* Change the address in the dpscontext_struc to a new error_proc           */
/*                                                                          */
/*                                                                          */
void dps$set_error_proc() ;
/*                                                                          */
/*                                                                          */
/* dps$interrupt_context(dpscontext_struc)                                  */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  Sends a request to the server to interrupt execution of the context.    */
/*  This causes a PostScript language 'interrupt' error in the context.     */
/*                                                                          */
/*  DPSInterruptContext returns immediately after sending the request.      */
/*                                                                          */
/*  If 'ctxt' represents an invalid context, for example because            */
/*  the context has terminated in the server, the dps_err_invalidContext    */
/*  error will be reported via ctxt's error proc.                           */
/*                                                                          */
/*                                                                          */
void dps$interrupt_context() ;
/*                                                                          */
/*                                                                          */
/* dps$destroy_context(dpscontext_struc)                                    */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  This calls DPSUnchainContext, then (for an interpreter context) sends a */
/*  request to the interpreter to terminate ctxt, then frees the storage    */
/*  referenced by ctxt. The termination request is ignored by the           */
/*  server if the context is invalid, for example if it has already         */
/*  terminated.                                                             */
/*                                                                          */
/*                                                                          */
void dps$destroy_context() ;
/*                                                                          */
/* dpsspace_return_ptr = dps$space_from_context(dpscontext_struc)           */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*  dpsspace_return_ptr.wr.r = pointer to the dps$space_rec structure       */
/*                                                                          */
/*  Extract space handle from context.                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
dps$space_ptr dps$space_from_context() ;
/*                                                                          */
/*                                                                          */
/* dps$destroy_space(dpsspace_struc_ptr)                                    */
/*                                                                          */
/*  dpsspace_struc_ptr.rr.r = pointer to the dps$space_rec structure        */
/*                                                                          */
/*  Calls DPSDestroyContext for each of the contexts in the space, then     */
/*  sends a request to the server to terminate the space, then frees the    */
/*  storage referenced by dpsspace_struc_ptr.                               */
/*                                                                          */
/*                                                                          */
void dps$destroy_space() ;
/*                                                                          */
/* Additional error conditions:                                             */
/*                                                                          */
/* dps$c_err_invalidAccess: signaled when expecting output from a context   */
/*     created by another client.  Such contexts send their                 */
/*     output only to the original creator and attempting to                */
/*     receive output from them would cause indefinite blocking.            */
/*                                                                          */
/* dps$c_err_encodingCheck: signaled when changing name encoding for a      */
/*     context created by another client or a context created               */
/*     in a space which was created by another client.  Such                */
/*     contexts can only accept string name encoding.  This                 */
/*     error is also generated when an attempt is made to change            */
/*     name or program encoding to other than acceptable values.            */
/*                                                                          */
/* dps$c_err_closedDisplay: when sending PostScript code to a context       */
/*     that has had its 'display' closed.                                   */
/*                                                                          */
/* dps$c_err_deadContext: signaled when expecting output from a context     */
/*     which has died in the server but still has its X resources           */
/*     active (a zombie context).  Attempting to receive output             */
/*     from such a context would cause indefinite blocking.                 */
/*                                                                          */
#define xdps$c_err_invalid_access 2000
#define xdps$c_err_encoding_check 2001
#define xdps$c_err_closed_display 2002
#define xdps$c_err_dead_context 2003
/*                                                                          */
/*  Declare status proc type                                                */
/*                                                                          */
typedef void (*xdps$status_proc)();
/*                                                                          */
/*                                                                          */
/* Define the entry points for the XDPS and DPS routines                    */
/*                                                                          */
/*                                                                          */
/* dpscontext_return = xdps$create_simple_context (                         */
/*    display, drawable_id, gc_id, x_coord, y_coord,                        */
/*    text_proc, error_proc, dpsspace_struc);                               */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  drawable_id.rlu.r = drawable id                                         */
/*  gc_id.rlu.r = gcontext                                                  */
/*  x_coord.rl.r = source x coord                                           */
/*  y_coord.rl.r = source y coord                                           */
/*  text_proc.wa.vp = user written text event handler                       */
/*  error_proc.wa.vp = user written error handler                           */
/*  dpsspace_struc.rr.r = address of the DPS space structure                */
/*                                                                          */
/*  Checks to see if 'display' supports the DPS extension.  If not,         */
/*  NULL is returned.  If so, a context associated with 'display',          */
/*  'drawable_id' and 'gc_id' is created.  'x' and 'y' are are offsets from */
/*  the drawable's origin to the PostScript device's origin in              */
/*  PostScript device space coordinates.  'textProc' is called to           */
/*  dispose of text sent by the context.  'errorProc' is called to          */
/*  handle errors reported by the context.  'space' determines the          */
/*  execution space of the new context.  A null space causes a new          */
/*  one to be created.                                                      */
/*                                                                          */
/*                                                                          */
dps$context_ptr xdps$create_simple_context() ;
/*                                                                          */
/*                                                                          */
/* dpscontext_return = xdps$create_text_context (text_proc, error_proc)     */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*   text_proc.wa.vp = user written text event handler receives postscript data */
/*   error_proc.wa.vp = user written text event handler                     */
/*                                                                          */
/*   Create a new DPSContext whose PostScript is converted to text and sent */
/*   to 'text_proc' (rather than the interpreter).  'error_proc' can        */
/*   be used by the implementation of 'text_proc' to report any i/o         */
/*   errors.                                                                */
/*                                                                          */
dps$context_ptr dps$create_text_context() ;
/*                                                                          */
/* dpscontext_return = dps$context_from_context_id (                        */
/*    dpscontext_struc, context_psid, text_proc, error_proc)                */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  context_psid.rl.r = PostScript language context id generated by FORK    */
/*  text_proc.ra.vp = user written text event handler                       */
/*  error_proc.ra.vp = user written error handler                           */
/*                                                                          */
/*                                                                          */
/*  Returns a DPSContext that is bound to the PostScript context            */
/*  created when the "fork" operator was executed by 'ctxt', resulting      */
/*  in the integer value 'cid'.                                             */
/*                                                                          */
/*  If a DPSContext has already been created for cid, that DPSContext       */
/*  is returned.  Otherwise, a new one is created, as follows:              */
/*                                                                          */
/*  If 'text_proc' or 'error_proc' are NULL, the new DPSContext will        */
/*  inherit the respective procs from 'ctxt', otherwise the the new         */
/*  context gets the 'textProc' and/or 'errorProc' passed in. The new       */
/*  DPSContext inherits everything else from 'ctxt', except its             */
/*  chaining properties, which are set to NULL.                             */
/*                                                                          */
/*  dps$context_from_context_id  will return NULL if it is unable to create */
/*  the context.                                                            */
/*                                                                          */
/*                                                                          */
dps$context_ptr dps$context_from_context_id() ;
/*                                                                          */
/* dpscontext_return = xdps$find_context (display, context_psid)            */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  context_psid.rl.r = PostScript language context id generated by FORK    */
/*                                                                          */
/*  Find a known context based on its id and return its DPSContext.         */
/*                                                                          */
/*                                                                          */
dps$context_ptr xdps$find_context() ;
/*                                                                          */
/*                                                                          */
/*  dps$default_text_backstop(dpscontext_struc, text_data, length)          */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*  text_data.rt.dx = text data to be processed                             */
/*  length.rl.r = data length                                               */
/*                                                                          */
/*  This is the text backstop proc automatically installed by               */
/*  the client library.  Since it is a DPSTextProc, you may                 */
/*  use it as your context textProc.  Writes text to stdout                 */
/*  and flushes stdout.                                                     */
/*                                                                          */
/*                                                                          */
void dps$default_text_backstop() ;
/*                                                                          */
/*                                                                          */
/*  dps$change_encoding (dpscontext_struc, new_encoding,                    */
/*                             new_name_encoding)                           */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*   new_encoding.lu.r = new encoding of PostScript language                */
/*   new_name_encoding.lu.r = new user name encoding                        */
/*                                                                          */
/* Change one or more of the context's 2 encoding parameters.               */
/* If the formats and encodings for the system on which the client          */
/* library is built are different than the formats and encodings            */
/* specified by 'ctxt', DPSWritePostScript (as well as the                  */
/* operations BinObjSeqWrite and WriteTypedObjectArray defined              */
/* above, but not WriteData) will convert the bytes of                      */
/* code from the former to the latter before sending                        */
/* them on to 'ctxt'.                                                       */
/*                                                                          */
void dps$change_encoding() ;
/*                                                                          */
/*  xdps$register_status_proc (dpscontext_struc, status_proc)               */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*   status_proc.ra.vp = status procedure                                   */
/*                                                                          */
/* Register a procedure to be called when a XDPSStatusEvent                 */
/* is received by the client.  The procedure will be called with two        */
/* parameters: the context it was registered with, and the                  */
/* status code derived from the event.  The proc may be                     */
/* called at any time that the client processes events.  Overwrites         */
/* any previously registered routine. See XDPS$XDPS.h                       */
/*                                                                          */
void xdps$register_status_proc() ;
/*                                                                          */
/*  xdps$set_status_mask (dpscontext_struc, enable_mask, disable_mask,      */
/*                        next_mask);                                       */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*   enable_mask.rlu.r = events the client wants to receive                 */
/*   disable_mask.rlu.r = events the client no longer wants to receive      */
/*   next_mask.rlu.r = events the client wants only the next instace of.    */
/*                                                                          */
/* Set the status reporting mask for the client.  The enableMask            */
/* specifies the events the client wants to receive, the                    */
/* disableMask specifies the events the client no longer wants              */
/* to receive, and the nextMask specifies the events that                   */
/* the client wishes to receive only the next instance of.                  */
/* The mask values are specified in XDPS.h                                  */
/*                                                                          */
void xdps$set_status_mask() ;
/*                                                                          */
/*  context_status_return = xdps$get_context_status (dpscontext_struc)      */
/*                                                                          */
/*   context_status_return.wl.v = one of the status values from xdps$xdps   */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*                                                                          */
/*  Get the current status of the context.                                  */
/*  PSGetStatus types 0 - 4;                                                */
/*                                                                          */
/*                                                                          */
long int xdps$get_context_status() ;
/*                                                                          */
/*  new_object_index_return = dps$new_user_object_index ()                  */
/*                                                                          */
/*   new_object_return.wl.v = new user object index                         */
/*                                                                          */
/*  Returns a new user object index.  The Client Library is                 */
/*  the sole allocator of new user object indices.  User object             */
/*  indices are dynamic, and should not be used for computation             */
/*  or stored in long term storage, such as a file.                         */
/*                                                                          */
long int dps$new_user_object_index() ;
/* ==========================================================               */
/* The following items are provided for lower level access to the DPS       */
/*    X library extension.                                                  */
/*                                                                          */
typedef unsigned long int xdpsl$space_xid;
typedef unsigned long int xdpsl$context_xid;
typedef long int xdpsl$context_psid;
/*                                                                          */
/* dpscontext_return = xdps$context_from_shared_id                          */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  context_psid.rl.r = PostScript language context id                      */
/*  text_proc.ra.vp = user written text event handler                       */
/*  error_proc.ra.vp = user written error handler                           */
/*                                                                          */
/* Create a context record for a PostScript language context id             */
/* shared by another client.                                                */
/*                                                                          */
/*                                                                          */
dps$context_ptr xdps$context_from_shared_id() ;
/*                                                                          */
/*                                                                          */
/* dpsspace_return = xdps$space_from_shared_id (                            */
/*    display, dpsspace_struc);                                             */
/*                                                                          */
/*  dpsspace_struc.wr.v = DPS space structure                               */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  dpsspace_struc.rr.r = address of the DPS space structure                */
/*                                                                          */
/* Create a space record for a xlib space id shared by another client.      */
/*                                                                          */
/*                                                                          */
dps$space_ptr xdps$space_from_shared_id() ;
/*                                                                          */
/* context_xid_return = xdps$xid_from_context (                             */
/*                                                                          */
/*  context_xid_return.wlu.v = Xlib context id                              */
/*                                                                          */
/*  display.wlu.r = display                                                 */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/* Get the XID for the given context record.  Return its 'display'          */
/*                                                                          */
/*                                                                          */
unsigned long int xdps$xid_from_context() ;
/*                                                                          */
/* context_xid_return = xdps$xid_from_space(                                */
/*                                                                          */
/*  context_xid_return.wlu.v = Xlib context id                              */
/*                                                                          */
/*  display.wlu.r = display                                                 */
/*  dpsspace_struc.rr.r = xlib space structure                              */
/*                                                                          */
/* Get the XID for the given space record.  Return its 'display'            */
/*                                                                          */
/*                                                                          */
unsigned long int xdps$xid_from_space() ;
/*                                                                          */
/* dpscontext_return = xdps$context_from_xid (                              */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  context_xid.rlu.r = Xlib context id                                     */
/*                                                                          */
/* Get the dps context record for the given XID on 'display'                */
/*                                                                          */
/*                                                                          */
dps$context_ptr xdps$context_from_xid() ;
/*                                                                          */
/* dpscontext_return = xdps$space_from_xid (                                */
/*                                                                          */
/*  dpsspace_return.wr.v = xlib space structure                             */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  context_xid.rlu.r = Xlib context id                                     */
/*                                                                          */
/* Get the space record for the given XID on 'display'                      */
/*                                                                          */
/*                                                                          */
dps$space_ptr xdps$space_from_xid() ;
/*                                                                          */
/*                                                                          */
/*  xdps$unfreeze_context (dpscontext_struc)                                */
/*                                                                          */
/*   dpscontext_struc.rr.r = dps context structure                          */
/*                                                                          */
/*  Notify a context that is in "frozen" mode to continue                   */
/*  with execution.                                                         */
/*                                                                          */
/*                                                                          */
void xdps$unfreeze_context() ;
/*                                                                          */
/*  last_object_return = dps$last_user_object_index()                       */
/*                                                                          */
/*   last_object_return.wl.v = new user object index                        */
/*                                                                          */
/*  Return last user object index                                           */
/*                                                                          */
/*                                                                          */
long int dps$last_user_object_index() ;
/*                                                                          */
/* context_xid_return = xdps$create_context(                                */
/*    display, drawable_id, gc_id, x_coord, y_coord,                        */
/*    event_mask, gray_ramp, color_cube, actual,                            */
/*    text_proc, error_proc, dpsspace_struc)                                */
/*                                                                          */
/*  dpscontext_return.wr.v = dps context structure                          */
/*                                                                          */
/*  display.rlu.r = display                                                 */
/*  drawable_id.rlu.r = drawable id                                         */
/*  gc_id.rlu.r = gcontext                                                  */
/*  x_coord.rl.r = source x coord                                           */
/*  y_coord.rl.r = source y coord                                           */
/*	event_mask.rl.r = event mask                                        */
/*  gray_ramp.rr.r = standard colormap                                      */
/*  color_cube.rr.r = standard colormap                                     */
/*  actual.rwu.r = number of colors postscript tries to allocate            */
/*  dpsspace_struc.r.r.r = dps space structure pointer                      */
/*                                                                          */
dps$context_ptr xdps$create_context() ;
/*                                                                          */
/********************************************************************************************************************************/
/* Created 25-MAY-1990 18:44:47 by VAX SDL V3.2-10     Source:  9-NOV-1989 12:23:01 DECW$LIBSRESD:[DPSBINDINGS.SRC]XDPS$PSOPS.SDL */
/********************************************************************************************************************************/
/*  XPS$PSOPS.SDL                                                           */
/**************************************************************************** */
/*                                                                          * */
/*  COPYRIGHT (c) 1989 BY                                                   * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                           * */
/*  ALL RIGHTS RESERVED                                                     * */
/*                                                                          * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  * */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  * */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  * */
/*  TRANSFERRED.                                                            * */
/*                                                                          * */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  * */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  * */
/*  CORPORATION.                                                            * */
/*                                                                          * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 * */
/*                                                                          * */
/**************************************************************************** */
 
/*** MODULE XPS$PSOPS IDENT Version 1 ***/
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*  ps$font_directory ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$font_directory() ;
/*                                                                          */
/*                                                                          */
/*  ps$iso_latin1_encoding ()                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$iso_latin1_encoding() ;
/*                                                                          */
/*                                                                          */
/*  ps$shared_font_directory ()                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$shared_font_directory() ;
/*                                                                          */
/*                                                                          */
/*  ps$standard_encoding ()                                                 */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$standard_encoding() ;
/*                                                                          */
/*                                                                          */
/*  ps$abs ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$abs() ;
/*                                                                          */
/*                                                                          */
/*  ps$add ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$add() ;
/*                                                                          */
/*                                                                          */
/*  ps$a_load ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$a_load() ;
/*                                                                          */
/*                                                                          */
/*  ps$anchor_search (truth_return)                                         */
/*                                                                          */
/*  truth_return.wlc.r = if string was found or not                         */
/*                true = found, false = not found                           */
/*                                                                          */
void ps$anchor_search() ;
/*                                                                          */
/*                                                                          */
/*  ps$and ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$and() ;
/*                                                                          */
/*                                                                          */
/*  ps$arc (x_coord, y_coord, radius, angle1, angle2)                       */
/*                                                                          */
/*  x_coord.rf.r = x coord of arc center                                    */
/*  y_coord.rf.r = y coord of arc center                                    */
/*  radius.rf.r = radius of arc                                             */
/*  angle1.rf.r = angle of first end point above the x plane                */
/*  angle2.rf.r = angle of second end point above the x plane               */
/*                                                                          */
/*                                                                          */
void ps$arc() ;
/*                                                                          */
/*                                                                          */
/*  ps$arcn (x_coord, y_coord, radius, angle1, angle2)                      */
/*                                                                          */
/*  x_coord.rf.r = x coord of arc center                                    */
/*  y_coord.rf.r = y coord of arc center                                    */
/*  radius.rf.r = radius of arc                                             */
/*  angle1.rf.r = angle of first end point above the x plane                */
/*  angle2.rf.r = angle of second end point above the x plane               */
/*                                                                          */
/*                                                                          */
void ps$arcn() ;
/*                                                                          */
/*                                                                          */
/*  ps$arc_t (x1_coord, y1_coord, x2_coord, y2_coord,                       */
/*            radius)                                                       */
/*                                                                          */
/*  x1_coord.rf.r = x1 coord                                                */
/*  y1_coord.rf.r = y1 coord                                                */
/*  x2_coord.rf.r = x2 coord                                                */
/*  y2_coord.rf.r = y2 coord                                                */
/*  radius.rf.r = radius of arc                                             */
/*                                                                          */
/*                                                                          */
void ps$arc_t() ;
/*                                                                          */
/*                                                                          */
/*  ps$arc_to (x1_coord, y1_coord, x2_coord, y2_coord,                      */
/*             radius, x1_tangent_return, y1_tangent_return, x2_tangent_return, */
/*             y2_tangent_return)                                           */
/*                                                                          */
/*  x1_coord.rf.r = x1 coord                                                */
/*  y1_coord.rf.r = y1 coord                                                */
/*  x2_coord.rf.r = x2 coord                                                */
/*  y2_coord.rf.r = y2 coord                                                */
/*  radius.rf.r = radius of arc                                             */
/*  x1_tangent_return.wf.r = x1 coord of tangent                            */
/*  y1_tangent_return.wf.r = y1 coord of tangent                            */
/*  x2_tangent_return.wf.r = x2 coord of tangent                            */
/*  y2_tangent_return.wf.r = y2 coord of tangent                            */
/*                                                                          */
/*                                                                          */
void ps$arc_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$array (length)                                                       */
/*                                                                          */
/*  length.rl.r = length of array must be >= 0                              */
/*                                                                          */
void ps$array() ;
/*                                                                          */
/*                                                                          */
/*  ps$a_show (x_displacement , y_displacement, postscript_data, length)    */
/*                                                                          */
/*  x_displacement.rf.r = x spacing displacement                            */
/*  y_displacement.rf.r = y spacing displacement                            */
/*  postscript_data.rt.dx = postscript data                                 */
/*  length.rl.r = pointer to data length                                    */
/*                                                                          */
/*                                                                          */
void ps$a_show() ;
/*                                                                          */
/*                                                                          */
/*  ps$a_store ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$a_store() ;
/*                                                                          */
/*                                                                          */
/*  ps$a_tan ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$a_tan() ;
/*                                                                          */
/*                                                                          */
/*  ps$a_width_show (char_x_displacement, char_y_displacement,              */
/*                  char_value, x_displacement, y_displacement,             */
/*                  postscript_data, length)                                */
/*                                                                          */
/*  char_x_displacement.rf.r = x displacement added to char_value characters  */
/*  char_y_displacement.rf.r = y displacement added to char_value characters */
/*  char_value.rl.r = 0 - 255 integer value of character                    */
/*  x_displacement.rf.r = x spacing displacement                            */
/*  y_displacement.rf.r = y spacing displacement                            */
/*  postscript_data.rt.dx = postscript data                                 */
/*  length.rl.r = pointer to data length                                    */
/*                                                                          */
/*                                                                          */
void ps$a_width_show() ;
/*                                                                          */
/*                                                                          */
/*  ps$band_device ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$band_device() ;
/*                                                                          */
/*                                                                          */
/*  ps$begin ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$begin() ;
/*                                                                          */
/*                                                                          */
/*  ps$bind ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$bind() ;
/*                                                                          */
/*                                                                          */
/*  ps$bit_shift (shift)                                                    */
/*                                                                          */
/*  shift.rl.r = number of bits to shift left (neg value right shift)       */
/*                                                                          */
/*                                                                          */
void ps$bit_shift() ;
/*                                                                          */
/*                                                                          */
/*  ps$bytes_available (num_bytes_return)                                   */
/*                                                                          */
/*  num_bytes_return.wl.r = number of bytes available for reading from input */
/*                                                                          */
/*                                                                          */
void ps$bytes_available() ;
/*                                                                          */
/*                                                                          */
/*  ps$cache_status ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cache_status() ;
/*                                                                          */
/*                                                                          */
/*  ps$ceiling ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$ceiling() ;
/*                                                                          */
/*                                                                          */
/*  ps$char_path (postscript_data, boolean_value)                           */
/*                                                                          */
/*  postscript_data.rt.dx = postscript data                                 */
/*  boolean_value.rl.r = path boolean. True - apply stokepath operator to path */
/*                                     False - add path to current path     */
/*                                                                          */
/*                                                                          */
void ps$char_path() ;
/*                                                                          */
/*                                                                          */
/*  ps$clear ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$clear() ;
/*                                                                          */
/*                                                                          */
/*  ps$clear_dict_stack ()                                                  */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$clear_dict_stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$clear_to_mark ()                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$clear_to_mark() ;
/*                                                                          */
/*                                                                          */
/*  ps$clip ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$clip_path ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$clip_path() ;
/*                                                                          */
/*  ps$close_file ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$close_file() ;
/*                                                                          */
/*  ps$close_path ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$close_path() ;
/*                                                                          */
/*  ps$color_image ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$color_image() ;
/*                                                                          */
/*  ps$concat (matrix_array)                                                */
/*                                                                          */
/*  matrix_array.rr.ra = transformation matrix 6 members                    */
/*                                                                          */
/*                                                                          */
void ps$concat() ;
/*                                                                          */
/*  ps$concat_matrix ()                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$concat_matrix() ;
/*                                                                          */
/*  ps$condition ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$condition() ;
/*                                                                          */
/*                                                                          */
/*  ps$copy (num_elements)                                                  */
/*                                                                          */
/*  num_elements.rl.r = number of stack elements to be duplicated           */
/*                                                                          */
/*                                                                          */
void ps$copy() ;
/*                                                                          */
/*                                                                          */
/*  ps$copy_page ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$copy_page() ;
/*                                                                          */
/*                                                                          */
/*  ps$cos ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cos() ;
/*                                                                          */
/*                                                                          */
/*  ps$count (num_elements_return)                                          */
/*                                                                          */
/*  num_elements_return.wl.r = number of elements on the operand stack      */
/*                                                                          */
/*                                                                          */
void ps$count() ;
/*                                                                          */
/*                                                                          */
/*  ps$count_dict_stack (num_elements_return)                               */
/*                                                                          */
/*  num_elements_return.wl.r = number of elements on the dictionary stack   */
/*                                                                          */
/*                                                                          */
void ps$count_dict_stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$count_exec_stack (num_elements_return)                               */
/*                                                                          */
/*  num_elements_return.wl.r = number of elements on the execution stack    */
/*                                                                          */
/*                                                                          */
void ps$count_exec_stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$count_to_mark (num_elements_return)                                  */
/*                                                                          */
/*  num_elements_return.wl.r = number of elements on the operand stack up to the */
/*                      first mark                                          */
/*                                                                          */
/*                                                                          */
void ps$count_to_mark() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_black_generation ()                                          */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_black_generation() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_cache_params ()                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_cache_params() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_cmyk_color (cyan_return, magenta_return,                     */
/*                          yellow_return, black_return)                    */
/*                                                                          */
/*  cyan_return.wf.r = cyan  color component                                */
/*  magenta_return.wf.r = mmagenta color component                          */
/*  yellow_return.wf.r = yellow color component                             */
/*  black_return.wf.r = black color component                               */
/*                                                                          */
/*                                                                          */
void ps$current_cmyk_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_color_screen ()                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_color_screen() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_color_transfer ()                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_color_transfer() ;
/*                                                                          */
/*                                                                          */
/* ps$current_context (context_psid)                                        */
/*                                                                          */
/*  context_psid.rl.r = PostScript language context id                      */
/*                                                                          */
/*                                                                          */
void ps$current_context() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_dash ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_dash() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_dict ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_file ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_file() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_flat (flatness_return)                                       */
/*                                                                          */
/*  flatness_return.wf.r = current GS flatness parameter                    */
/*                                                                          */
/*                                                                          */
void ps$current_flat() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_font ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_gray (gray_value_return)                                     */
/*                                                                          */
/*  gray_value_return.wf.r = current GS gray value                          */
/*                                                                          */
/*                                                                          */
void ps$current_gray() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_gstate (g_state_return)                                      */
/*                                                                          */
/*  g_state_return.wl.r = graphics state                                    */
/*                                                                          */
/*                                                                          */
void ps$current_gstate() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_halftone ()                                                  */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_halftone() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_halftone_phase (x_return, y_return)                          */
/*                                                                          */
/*  x_return.wf.r = current x halftone parameter                            */
/*  y_return.wf.r = current y halftone parameter                            */
/*                                                                          */
/*                                                                          */
void ps$current_halftone_phase() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_hsb_color (hue_return,                                       */
/*                         saturation_return, brightness_return)            */
/*                                                                          */
/*  hue_return.wf.r = current color hue                                     */
/*  saturation_return.wf.r = current color saturation                       */
/*  brightness_return.wf.r = current color brightness                       */
/*                                                                          */
/*                                                                          */
void ps$current_hsb_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_line_cap (line_cap_return)                                   */
/*                                                                          */
/*  line_cap_return.wl.r = current GS line cap parameter                    */
/*                                                                          */
/*                                                                          */
void ps$current_line_cap() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_line_join (line_join_return)                                 */
/*                                                                          */
/*  line_join_return.wl.r = current GS line join parameter                  */
/*                                                                          */
/*                                                                          */
void ps$current_line_join() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_line_width (line_width_return)                               */
/*                                                                          */
/*  line_width_return.wf.r = current GS line width parameter                */
/*                                                                          */
/*                                                                          */
void ps$current_line_width() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_matrix ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_miter_limit (miter_limit_return)                             */
/*                                                                          */
/*  miter_limit_return.wf.r = current GS miter limit parameter              */
/*                                                                          */
/*                                                                          */
void ps$current_miter_limit() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_object_format (format_code_return)                           */
/*                                                                          */
/*  format_code_return.wl.r = current GS object format parameter            */
/*                                                                          */
/*                                                                          */
void ps$current_object_format() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_packing (packing_return)                                     */
/*                                                                          */
/*  packing_return.wl.r = current GS packing parameter                      */
/*                                                                          */
/*                                                                          */
void ps$current_packing() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_point (x_coord_return, y_coord_return)                       */
/*                                                                          */
/*  x_coord_return.wf.r = current x location                                */
/*  y_coord_return.wf.r = current y location                                */
/*                                                                          */
/*                                                                          */
void ps$current_point() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_rgb_color (red_return, green_return,                         */
/*                         blue_return)                                     */
/*                                                                          */
/*  red_return.wf.r = current red level                                     */
/*  green_return.wf.r = current green level                                 */
/*  blue_return.wf.r = current blue level                                   */
/*                                                                          */
/*                                                                          */
void ps$current_rgb_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_screen ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_screen() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_shared (amode_return)                                        */
/*                                                                          */
/*  amode_return.wl.r = current VM allocation mode                          */
/*                                                                          */
/*                                                                          */
void ps$current_shared() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_stroke_adjust (sa_param_return)                              */
/*                                                                          */
/*  sa_param_return.wl.r = current stroke adjust parameter                  */
/*                                                                          */
/*                                                                          */
void ps$current_stroke_adjust() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_transfer ()                                                  */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$current_transfer() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_under_color_removal (dpscontext_struc)                       */
/*                                                                          */
/*  dpscontext_struc.rr.r = dps context structure                           */
/*                                                                          */
/*                                                                          */
void ps$current_under_color_removal() ;
/*                                                                          */
/*                                                                          */
/*  ps$curve_to (x1_coord, y1_coord, x2_coord, y2_coord,                    */
/*               x3_coord, y3_coord)                                        */
/*                                                                          */
/*  x1_coord.rf.r = bezier x coord                                          */
/*  y1_coord.rf.r = bezier y coord                                          */
/*  x2_coord.rf.r = bezier x coord                                          */
/*  y2_coord.rf.r = bezier y coord                                          */
/*  x3_coord.rf.r = bezier x coord                                          */
/*  y3_coord.rf.r = bezier y coord                                          */
/*                                                                          */
/*                                                                          */
void ps$curve_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_i ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_i() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_lit ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_lit() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_n ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_n() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_r ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_r() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_rs ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_rs() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_s ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_s() ;
/*                                                                          */
/*                                                                          */
/*  ps$cv_x ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$cv_x() ;
/*                                                                          */
/*                                                                          */
/*  ps$def ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$def() ;
/*                                                                          */
/*                                                                          */
/*  ps$default_matrix ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$default_matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$define_font ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$define_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$define_username (index, username)                                    */
/*                                                                          */
/*  index.rl.r = user name index                                            */
/*  username.rt.dx = user name text                                         */
/*                                                                          */
/*                                                                          */
void ps$define_username() ;
/*                                                                          */
/*                                                                          */
/*  ps$define_user_object ()                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$define_user_object() ;
/*                                                                          */
/*                                                                          */
/*  ps$delete_file (file_name)                                              */
/*                                                                          */
/*  file_name.rt.dx = file to be deleted                                    */
/*                                                                          */
/*                                                                          */
void ps$delete_file() ;
/*                                                                          */
/*                                                                          */
/*  ps$detach ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$detach() ;
/*                                                                          */
/*                                                                          */
/*  ps$device_info ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$device_info() ;
/*                                                                          */
/*                                                                          */
/*  ps$dict (num_elements)                                                  */
/*                                                                          */
/*  num_elements.rl.r = user name index                                     */
/*                                                                          */
/*                                                                          */
void ps$dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$dict_stack ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$dict_stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$div ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$div() ;
/*                                                                          */
/*                                                                          */
/*  ps$d_transform (x1_coord, y1_coord,                                     */
/*                   x2_coord_return, y2_coord_return)                      */
/*                                                                          */
/*  x1_coord.rf.r = distance vector x coord                                 */
/*  y1_coord.rf.r = distance vector y coord                                 */
/*  x2_coord_return.wf.r = device distance vector y coord                   */
/*  y2_coord_return.wf.r = device distance vector y coord                   */
/*                                                                          */
/*                                                                          */
void ps$d_transform() ;
/*                                                                          */
/*                                                                          */
/*  ps$dup ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$dup() ;
/*                                                                          */
/*                                                                          */
/*  ps$echo (echo_bool)                                                     */
/*                                                                          */
/*  echo_bool.rl.r = 1 - echo, 0 - noecho                                   */
/*                                                                          */
/*                                                                          */
void ps$echo() ;
/*                                                                          */
/*                                                                          */
/*  ps$end ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$end() ;
/*                                                                          */
/*                                                                          */
/*  ps$eo_clip ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$eo_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$eo_fill ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$eo_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$eo_view_clip ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$eo_view_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$eq ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$eq() ;
/*                                                                          */
/*                                                                          */
/*  ps$equals ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$equals() ;
/*                                                                          */
/*                                                                          */
/*  ps$equals_equals ()                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$equals_equals() ;
/*                                                                          */
/*                                                                          */
/*  ps$erase_page ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$erase_page() ;
/*                                                                          */
/*                                                                          */
/*  ps$error_dict ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$error_dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$exch ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$exch() ;
/*                                                                          */
/*                                                                          */
/*  ps$exec ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$exec() ;
/*                                                                          */
/*                                                                          */
/*  ps$exec_stack ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$exec_stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$exec_user_object (index)                                             */
/*                                                                          */
/*  index.rl.r = index to user object must be >= 0                          */
/*                                                                          */
void ps$exec_user_object() ;
/*                                                                          */
/*                                                                          */
/*  ps$execute_only ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$execute_only() ;
/*                                                                          */
/*                                                                          */
/*  ps$exit ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$exit() ;
/*                                                                          */
/*                                                                          */
/*  ps$exp ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$exp() ;
/*                                                                          */
/*                                                                          */
/*  ps$false ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$false() ;
/*                                                                          */
/*                                                                          */
/*  ps$file (file_name, access)                                             */
/*                                                                          */
/*  file_name.rt.dx = file to be deleted                                    */
/*  access.rt.dx = file access mode                                         */
/*                                                                          */
/*                                                                          */
void ps$file() ;
/*                                                                          */
/*                                                                          */
/*  ps$file_name_for_all ()                                                 */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$file_name_for_all() ;
/*                                                                          */
/*                                                                          */
/*  ps$file_position (position_return)                                      */
/*                                                                          */
/*  position_return.wl.r = position of open file                            */
/*                                                                          */
void ps$file_position() ;
/*                                                                          */
/*                                                                          */
/*  ps$fill ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$find_font (font_key)                                                 */
/*                                                                          */
/*  font_key.rt.dx = file to be deleted                                     */
/*                                                                          */
/*                                                                          */
void ps$find_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$flatten_path ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$flatten_path() ;
/*                                                                          */
/*                                                                          */
/*  ps$floor ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$floor() ;
/*                                                                          */
/*                                                                          */
/*  ps$flush ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$flush() ;
/*                                                                          */
/*                                                                          */
/*  ps$flush_file ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$flush_file() ;
/*                                                                          */
/*                                                                          */
/*  ps$for ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$for() ;
/*                                                                          */
/*                                                                          */
/*  ps$for_all ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$for_all() ;
/*                                                                          */
/*                                                                          */
/*  ps$fork ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$fork() ;
/*                                                                          */
/*                                                                          */
/*  ps$frame_device ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$frame_device() ;
/*                                                                          */
/*                                                                          */
/*  ps$ge ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$ge() ;
/*                                                                          */
/*                                                                          */
/*  ps$get ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$get() ;
/*                                                                          */
/*                                                                          */
/*  ps$get_boolean (boolean_return)                                         */
/*                                                                          */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
void ps$get_boolean() ;
/*                                                                          */
/*  ps$get_char_array (size, array_return)                                  */
/*                                                                          */
/*  size.rl.r = array size                                                  */
/*  array_return.wt.dx = character array                                    */
/*                                                                          */
/*                                                                          */
void ps$get_char_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$get_float (float_return)                                             */
/*                                                                          */
/*  float_return.wf.r = returned value                                      */
/*                                                                          */
void ps$get_float() ;
/*                                                                          */
/*                                                                          */
/*  ps$get_float_array (size, array_return)                                 */
/*                                                                          */
/*  size.rl.r = array size                                                  */
/*  array_return.wr.ra = floating point array address                       */
/*                                                                          */
/*                                                                          */
void ps$get_float_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$get_int (integer_return)                                             */
/*                                                                          */
/*  integer_return.wl.r = returned integer                                  */
/*                                                                          */
void ps$get_int() ;
/*                                                                          */
/*  ps$get_int_array (size, array_return)                                   */
/*                                                                          */
/*  size.rl.r = array size                                                  */
/*  array_return.wr.ra = integer array address                              */
/*                                                                          */
/*                                                                          */
void ps$get_int_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$get_interval ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$get_interval() ;
/*                                                                          */
/*                                                                          */
/*  ps$get_string (string_return)                                           */
/*                                                                          */
/*  string_return.wt.dx = string                                            */
/*                                                                          */
/*                                                                          */
void ps$get_string() ;
/*                                                                          */
/*                                                                          */
/*  ps$g_restore ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$g_restore() ;
/*                                                                          */
/*                                                                          */
/*  ps$g_restore_all ()                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$g_restore_all() ;
/*                                                                          */
/*                                                                          */
/*  ps$g_save ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$g_save() ;
/*                                                                          */
/*                                                                          */
/*  ps$g_state ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$g_state() ;
/*                                                                          */
/*                                                                          */
/*  ps$gt ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$gt() ;
/*                                                                          */
/*                                                                          */
/*  ps$ident_matrix ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$ident_matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$i_div ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$i_div() ;
/*                                                                          */
/*                                                                          */
/*  ps$id_transform (x1_coord, y1_coord,                                    */
/*                   x2_coord_return, y2_coord_return)                      */
/*                                                                          */
/*  x1_coord.rf.r = distance vector x coord                                 */
/*  y1_coord.rf.r = distance vector y coord                                 */
/*  x2_coord_return.wf.r = device distance vector y coord                   */
/*  y2_coord_return.wf.r = device distance vector y coord                   */
/*                                                                          */
/*                                                                          */
void ps$id_transform() ;
/*                                                                          */
/*                                                                          */
/*  ps$if ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$if() ;
/*                                                                          */
/*                                                                          */
/*  ps$if_else ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$if_else() ;
/*                                                                          */
/*                                                                          */
/*  ps$image ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$image() ;
/*                                                                          */
/*                                                                          */
/*  ps$image_mask ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$image_mask() ;
/*                                                                          */
/*                                                                          */
/*  ps$index (index)                                                        */
/*                                                                          */
/*  index.rl.r = index to stack element                                     */
/*                                                                          */
void ps$index() ;
/*                                                                          */
/*                                                                          */
/*  ps$in_oe_fill (x_coord, y_coord, boolean_return)                        */
/*                                                                          */
/*  x_coord.rf.r = distance vector x coord                                  */
/*  y_coord.rf.r = distance vector y coord                                  */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*                                                                          */
void ps$in_oe_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$in_fill (x_coord, y_coord, boolean_return)                           */
/*                                                                          */
/*  x_coord.rf.r = distance vector x coord                                  */
/*  y_coord.rf.r = distance vector y coord                                  */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*                                                                          */
void ps$in_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$init_clip ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$init_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$init_graphics ()                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$init_graphics() ;
/*                                                                          */
/*                                                                          */
/*  ps$init_matrix ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$init_matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$init_view_clip ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$init_view_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$in_stroke (x_coord, y_coord, boolean_return)                         */
/*                                                                          */
/*  x_coord.rf.r = distance vector x coord                                  */
/*  y_coord.rf.r = distance vector y coord                                  */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*                                                                          */
void ps$in_stroke() ;
/*                                                                          */
/*                                                                          */
/*  ps$in_ueo_fill (x_coord, y_coord, nums_array, nlength,                  */
/*                   ops_aray, olength, boolean_return)                     */
/*                                                                          */
/*  x_coord.rf.r = distance vector x coord                                  */
/*  y_coord.rf.r = distance vector y coord                                  */
/*  nums_array.rr.ra = encoded number string  - character array             */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = operator string - character array                     */
/*  olength.rl.r = array size                                               */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*  together the nums array and ops array represent a userpath              */
/*                                                                          */
/*                                                                          */
void ps$in_ueo_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$in_u_fill (x_coord, y_coord, nums_array, nlength,                    */
/*                   ops_aray, olength, boolean_return)                     */
/*                                                                          */
/*  x_coord.rf.r = distance vector x coord                                  */
/*  y_coord.rf.r = distance vector y coord                                  */
/*  nums_array.rr.ra = character array                                      */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = character array                                       */
/*  olength.rl.r = array size                                               */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*                                                                          */
void ps$in_u_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$in_u_stroke (x_coord, y_coord, nums_array, nlength,                  */
/*                   ops_aray, olength, boolean_return)                     */
/*                                                                          */
/*  x_coord.rf.r = distance vector x coord                                  */
/*  y_coord.rf.r = distance vector y coord                                  */
/*  nums_array.rr.ra = character array                                      */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = character array                                       */
/*  olength.rl.r = array size                                               */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*                                                                          */
void ps$in_u_stroke() ;
/*                                                                          */
/*                                                                          */
/*  ps$invert_matrix ()                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$invert_matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$i_transform (x1_coord, y1_coord,                                     */
/*                   x2_coord_return, y2_coord_return)                      */
/*                                                                          */
/*  x1_coord.rf.r = distance vector x coord                                 */
/*  y1_coord.rf.r = distance vector y coord                                 */
/*  x2_coord_return.wf.r = device distance vector y coord                   */
/*  y2_coord_return.wf.r = device distance vector y coord                   */
/*                                                                          */
/*                                                                          */
void ps$i_transform() ;
/*                                                                          */
/*                                                                          */
/*  ps$join ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$join() ;
/*                                                                          */
/*                                                                          */
/*  ps$known (boolean_return)                                               */
/*                                                                          */
/*  boolean_return.wl.r = index to stack element                            */
/*                                                                          */
void ps$known() ;
/*                                                                          */
/*                                                                          */
/*  ps$k_show (pr_string)                                                   */
/*                                                                          */
/*  pr_string.rt.dx = string to print                                       */
/*                                                                          */
/*                                                                          */
void ps$k_show() ;
/*                                                                          */
/*                                                                          */
/*  ps$le ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$le() ;
/*                                                                          */
/*                                                                          */
/*  ps$length (length_return)                                               */
/*                                                                          */
/*  length_return.wl.r = length of operand                                  */
/*                                                                          */
void ps$length() ;
/*                                                                          */
/*                                                                          */
/*  ps$line_to (x_coord, y_coord)                                           */
/*                                                                          */
/*  x_coord.rf.r = point x coord                                            */
/*  y_coord.rf.r = point y coord                                            */
/*                                                                          */
/*                                                                          */
void ps$line_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$ln ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$ln() ;
/*                                                                          */
/*                                                                          */
/*  ps$load ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$load() ;
/*                                                                          */
/*                                                                          */
/*  ps$lock ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$lock() ;
/*                                                                          */
/*                                                                          */
/*  ps$log ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$log() ;
/*                                                                          */
/*                                                                          */
/*  ps$loop ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$loop() ;
/*                                                                          */
/*                                                                          */
/*  ps$lt ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$lt() ;
/*                                                                          */
/*                                                                          */
/*  ps$make_font ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$make_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$mark ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$mark() ;
/*                                                                          */
/*                                                                          */
/*  ps$matrix ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$max_length (length_return)                                           */
/*                                                                          */
/*  length_return.wl.r = max number of pairs                                */
/*                                                                          */
void ps$max_length() ;
/*                                                                          */
/*                                                                          */
/*  ps$mod ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$mod() ;
/*                                                                          */
/*                                                                          */
/*  ps$monitor ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$monitor() ;
/*                                                                          */
/*                                                                          */
/*  ps$move_to (x_coord, y_coord)                                           */
/*                                                                          */
/*  x_coord.rf.r = point x coord                                            */
/*  y_coord.rf.r = point y coord                                            */
/*                                                                          */
/*                                                                          */
void ps$move_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$mul ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$mul() ;
/*                                                                          */
/*                                                                          */
/*  ps$ne ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$ne() ;
/*                                                                          */
/*                                                                          */
/*  ps$neg ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$neg() ;
/*                                                                          */
/*                                                                          */
/*  ps$new_path ()                                                          */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$new_path() ;
/*                                                                          */
/*                                                                          */
/*  ps$no_access ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$no_access() ;
/*                                                                          */
/*                                                                          */
/*  ps$not ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$not() ;
/*                                                                          */
/*                                                                          */
/*  ps$notify ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$notify() ;
/*                                                                          */
/*                                                                          */
/*  ps$null ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$null() ;
/*                                                                          */
/*                                                                          */
/*  ps$null_device ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$null_device() ;
/*                                                                          */
/*                                                                          */
/*  ps$or ()                                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$or() ;
/*                                                                          */
/*                                                                          */
/*  ps$packed_array ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$packed_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$path_bbox (ll_x_coord, ll_y_coord, ur_x_coord,                       */
/*                ur_y_coord)                                               */
/*                                                                          */
/*  ll_x_coord.rf.r = lower left corner x coord                             */
/*  ll_y_coord.rf.r = lower left corner y coord                             */
/*  ur_x_coord.rf.r = upper right corner x coord                            */
/*  ur_y_coord.rf.r = upper right corner y coord                            */
/*                                                                          */
/*                                                                          */
void ps$path_bbox() ;
/*                                                                          */
/*                                                                          */
/*  ps$path_for_all ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$path_for_all() ;
/*                                                                          */
/*                                                                          */
/*  ps$pop ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$pop() ;
/*                                                                          */
/*                                                                          */
/*  ps$print ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$print() ;
/*                                                                          */
/*                                                                          */
/*  ps$print_object (tag)                                                   */
/*                                                                          */
/*  tag.rl.r = object tag                                                   */
/*                                                                          */
void ps$print_object() ;
/*                                                                          */
/*                                                                          */
/*  ps$prompt ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$prompt() ;
/*                                                                          */
/*                                                                          */
/*  ps$p_stack ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$p_stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$put ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$put() ;
/*                                                                          */
/*                                                                          */
/*  ps$put_interval ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$put_interval() ;
/*                                                                          */
/*                                                                          */
/*  ps$quit ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$quit() ;
/*                                                                          */
/*                                                                          */
/*  ps$rand ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$rand() ;
/*                                                                          */
/*                                                                          */
/*  ps$r_check (boolean_return)                                             */
/*                                                                          */
/*  boolean_return.wl.r = boolean return value                              */
/*                                                                          */
void ps$r_check() ;
/*                                                                          */
/*                                                                          */
/*  ps$r_curve_to (x1_coord, y1_coord, x2_coord, y2_coord,                  */
/*               x3_coord, y3_coord)                                        */
/*                                                                          */
/*  x1_coord.rf.r = bezier x coord                                          */
/*  y1_coord.rf.r = bezier y coord                                          */
/*  x2_coord.rf.r = bezier x coord                                          */
/*  y2_coord.rf.r = bezier y coord                                          */
/*  x3_coord.rf.r = bezier x coord                                          */
/*  y3_coord.rf.r = bezier y coord                                          */
/*                                                                          */
/*                                                                          */
void ps$r_curve_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$read (boolean_return)                                                */
/*                                                                          */
/*  boolean_return.wl.r = eof return value false = eof found                */
/*                                                                          */
void ps$read() ;
/*                                                                          */
/*                                                                          */
/*  ps$read_hex_string (boolean_return)                                     */
/*                                                                          */
/*  boolean_return.wl.r = eof return value false = eof found                */
/*                                                                          */
void ps$read_hex_string() ;
/*                                                                          */
/*                                                                          */
/*  ps$read_line (boolean_return)                                           */
/*                                                                          */
/*  boolean_return.wl.r = eof return value false = eof found                */
/*                                                                          */
void ps$read_line() ;
/*                                                                          */
/*                                                                          */
/*  ps$read_only ()                                                         */
/*                                                                          */
/*                                                                          */
void ps$read_only() ;
/*                                                                          */
/*                                                                          */
/*  ps$read_string (boolean_return)                                         */
/*                                                                          */
/*  boolean_return.wl.r = eof return value false = eof found                */
/*                                                                          */
void ps$read_string() ;
/*                                                                          */
/*                                                                          */
/*  ps$real_time (clock_value_return)                                       */
/*                                                                          */
/*  clock_value_return.wl.r = ovalue of one millisecond clock timer         */
/*                                                                          */
void ps$real_time() ;
/*                                                                          */
/*                                                                          */
/*  ps$rect_clip (x_coord, y_coord, width, height)                          */
/*                                                                          */
/*  x_coord.rf.r = lower left corner x coord                                */
/*  y_coord.rf.r = lower left corner y coord                                */
/*  width.rf.r = rectangle width                                            */
/*  height.rf.r = rectangle height                                          */
/*                                                                          */
/*                                                                          */
void ps$rect_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$rect_fill (x_coord, y_coord, width, height)                          */
/*                                                                          */
/*  x_coord.rf.r = lower left corner x coord                                */
/*  y_coord.rf.r = lower left corner y coord                                */
/*  width.rf.r = rectangle width                                            */
/*  height.rf.r = rectangle height                                          */
/*                                                                          */
/*                                                                          */
void ps$rect_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$rect_stroke (x_coord, y_coord, width, height)                        */
/*                                                                          */
/*  x_coord.rf.r = lower left corner x coord                                */
/*  y_coord.rf.r = lower left corner y coord                                */
/*  width.rf.r = rectangle width                                            */
/*  height.rf.r = rectangle height                                          */
/*                                                                          */
/*                                                                          */
void ps$rect_stroke() ;
/*                                                                          */
/*                                                                          */
/*  ps$rect_view_clip (x_coord, y_coord, width, height)                     */
/*                                                                          */
/*  x_coord.rf.r = lower left corner x coord                                */
/*  y_coord.rf.r = lower left corner y coord                                */
/*  width.rf.r = rectangle width                                            */
/*  height.rf.r = rectangle height                                          */
/*                                                                          */
/*                                                                          */
void ps$rect_view_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$rename_file (old_name, new_name)                                     */
/*                                                                          */
/*  old_name.rt.dx = old file name                                          */
/*  new_name.rt.dx = new file name                                          */
/*                                                                          */
/*                                                                          */
void ps$rename_file() ;
/*                                                                          */
/*                                                                          */
/*  ps$render_bands ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$render_bands() ;
/*                                                                          */
/*                                                                          */
/*  ps$repeat ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$repeat() ;
/*                                                                          */
/*                                                                          */
/*  ps$reset_file ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$reset_file() ;
/*                                                                          */
/*                                                                          */
/*  ps$restore ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$restore() ;
/*                                                                          */
/*                                                                          */
/*  ps$reverse_path ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$reverse_path() ;
/*                                                                          */
/*                                                                          */
/*  ps$r_line_to (x_coord, y_coord)                                         */
/*                                                                          */
/*  x_coord.rf.r = point x coord                                            */
/*  y_coord.rf.r = point y coord                                            */
/*                                                                          */
/*                                                                          */
void ps$r_line_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$r_move_to (x_coord, y_coord)                                         */
/*                                                                          */
/*  x_coord.rf.r = point x coord                                            */
/*  y_coord.rf.r = point y coord                                            */
/*                                                                          */
/*                                                                          */
void ps$r_move_to() ;
/*                                                                          */
/*                                                                          */
/*  ps$roll (count, direction)                                              */
/*                                                                          */
/*  count.rl.r = number of object to shift                                  */
/*  direction.rl.r = positive remove from tos place at n-1 position         */
/*                                                                          */
void ps$roll() ;
/*                                                                          */
/*                                                                          */
/*  ps$rotate (angle)                                                       */
/*                                                                          */
/*  angle.rf.r = angle of rotation pos = CCW                                */
/*                                                                          */
/*                                                                          */
void ps$rotate() ;
/*                                                                          */
/*                                                                          */
/*  ps$round ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$round() ;
/*                                                                          */
/*                                                                          */
/*  ps$r_rand ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$r_rand() ;
/*                                                                          */
/*                                                                          */
/*  ps$run (file_name)                                                      */
/*                                                                          */
/*  file_name.rt.dx = file name to be run                                   */
/*                                                                          */
/*                                                                          */
void ps$run() ;
/*                                                                          */
/*                                                                          */
/*  ps$save ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$save() ;
/*                                                                          */
/*                                                                          */
/*  ps$scale (scale_x, scale_y)                                             */
/*                                                                          */
/*  scale_x.rf.r = (1,1) in scale matrix                                    */
/*  scale_y.rf.r = (2,2) in scale matrix                                    */
/*                                                                          */
/*                                                                          */
void ps$scale() ;
/*                                                                          */
/*                                                                          */
/*  ps$scale_font (size)                                                    */
/*                                                                          */
/*  size.rf.r = scale size                                                  */
/*                                                                          */
/*                                                                          */
void ps$scale_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$s_check (boolean_return)                                             */
/*                                                                          */
/*  boolean_return.wl.r = true - can be stored as an element of a shared object */
/*                                                                          */
void ps$s_check() ;
/*                                                                          */
/*                                                                          */
/*  ps$search (boolean_return)                                              */
/*                                                                          */
/*  boolean_return.wl.r = true - seek string found                          */
/*                                                                          */
void ps$search() ;
/*                                                                          */
/*                                                                          */
/*  ps$select_font (font_name, font_scale)                                  */
/*                                                                          */
/*  font_name.rt.dx = file name to be run                                   */
/*  font_scale.rf.r = angle of rotation pos = CCW                           */
/*                                                                          */
/*                                                                          */
void ps$select_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_boolean (boolean_value)                                         */
/*                                                                          */
/*  boolean_value.rl.r = value to send                                      */
/*                                                                          */
void ps$send_boolean() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_char_array (char_array, clength)                                */
/*                                                                          */
/*  char_array.rr.ra = character array                                      */
/*  clength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$send_char_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_float (float_value)                                             */
/*                                                                          */
/*  float_value.rf.r = float value to send                                  */
/*                                                                          */
/*                                                                          */
void ps$send_float() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_float_array (float_array, flength)                              */
/*                                                                          */
/*  float_array.rr.ra = floating point value array                          */
/*  flength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$send_float_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_int (integer_value)                                             */
/*                                                                          */
/*  integer_value.rl.r = integer value to send                              */
/*                                                                          */
/*                                                                          */
void ps$send_int() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_int_array (integer_array, ilength)                              */
/*                                                                          */
/*  integer_array.rr.ra = integer value array                               */
/*  ilength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$send_int_array() ;
/*                                                                          */
/*                                                                          */
/*  ps$send_string (cstring)                                                */
/*                                                                          */
/*  cstring.rt.dx = string to be sent                                       */
/*                                                                          */
/*                                                                          */
void ps$send_string() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_bbox (ll_x_coord, ll_y_coord, ur_x_coord,                        */
/*                ur_y_coord)                                               */
/*                                                                          */
/*  ll_x_coord.rf.r = lower left corner x coord                             */
/*  ll_y_coord.rf.r = lower left corner y coord                             */
/*  ur_x_coord.rf.r = upper right corner x coord                            */
/*  ur_y_coord.rf.r = upper right corner y coord                            */
/*                                                                          */
/*                                                                          */
void ps$set_bbox() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_black_generation ()                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_black_generation() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_cache_device (width_x, width_y,                                  */
/*                        ll_x_coord, ll_y_coord,  ur_x_coord,              */
/*                        ur_y_coord)                                       */
/*                                                                          */
/*  width_x.rf.r = width vector for character                               */
/*  width_y.rf.r = width vector for character                               */
/*  ll_x_coord.rf.r = lower left corner x coord of character bounding box   */
/*  ll_y_coord.rf.r = lower left corner y coord of character bounding box   */
/*  ur_x_coord.rf.r = upper right corner x coord of character bounding box  */
/*  ur_y_coord.rf.r = upper right corner y coord of character bounding box  */
/*                                                                          */
/*                                                                          */
void ps$set_cache_device() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_cache_limit (limit)                                              */
/*                                                                          */
/*  limit.rf.r = number of bytes used by the oixal array of a single character */
/*                                                                          */
/*                                                                          */
void ps$cache_limit() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_cache_params ()                                                  */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_cache_params() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_char_width (width_x, width_y)                                    */
/*                                                                          */
/*  width_x.rf.r = width vector for character                               */
/*  width_y.rf.r = width vector for character                               */
/*                                                                          */
/*                                                                          */
void ps$set_char_width() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_cmyk_color (cyan, magenta,                                       */
/*                          yellow, black)                                  */
/*                                                                          */
/*  cyan.wf.r = cyan  color component                                       */
/*  magenta.wf.r = mmagenta color component                                 */
/*  yellow.wf.r = yellow color component                                    */
/*  black.wf.r = black color component                                      */
/*                                                                          */
/*                                                                          */
void ps$set_cmyk_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_color_screen ()                                                  */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_color_screen() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_color_transfer ()                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_color_transfer() ;
/*                                                                          */
/*  ps$set_dash (pattern_array, size, offset)                               */
/*                                                                          */
/*  pattern_array.rr.ra = dash pattern array                                */
/*  size.rl.r = array size                                                  */
/*  offset.wf.r = dash pattern offset                                       */
/*                                                                          */
/*                                                                          */
void ps$set_dash() ;
/*                                                                          */
/*  ps$set_file_position (position)                                         */
/*                                                                          */
/*  position.rl.r = file position                                           */
/*                                                                          */
/*                                                                          */
void ps$set_file_position() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_flat (flatness)                                                  */
/*                                                                          */
/*  flatness.rf.r = flatness parameter                                      */
/*                                                                          */
/*                                                                          */
void ps$set_flat() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_font (font)                                                      */
/*                                                                          */
/*  font.rl.r = font dictionary                                             */
/*                                                                          */
/*                                                                          */
void ps$set_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_gray (gray_shade)                                                */
/*                                                                          */
/*  gray_shade.rf.r = gray value between 0 - 1                              */
/*                                                                          */
/*                                                                          */
void ps$set_gray() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_g_state (graphics_state)                                         */
/*                                                                          */
/*  graphics_state.rl.r = graphics state object                             */
/*                                                                          */
/*                                                                          */
void ps$set_g_state() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_halftone ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_halftone() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_halftone_phase (param1, param2)                                  */
/*                                                                          */
/*  param1.rf.r = halftone parameter                                        */
/*  param2.rf.r = halftone parameter                                        */
/*                                                                          */
/*                                                                          */
void ps$set_halftone_phase() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_hsb_color (hue,                                                  */
/*                     saturation, brightness)                              */
/*                                                                          */
/*  hue.wf.r = color hue                                                    */
/*  saturation.wf.r = color saturation                                      */
/*  brightness.wf.r = color brightness                                      */
/*                                                                          */
/*                                                                          */
void ps$set_hsb_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_line_cap (line_cap)                                              */
/*                                                                          */
/*  line_cap.rl.r = type of line cap: 1- butt, 1- round, 2 - proj square    */
/*                                                                          */
/*                                                                          */
void ps$set_line_cap() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_line_join (line_join)                                            */
/*                                                                          */
/*  line_join.rl.r = type of line joint: 1- miter, 1- round, 2 - bevel      */
/*                                                                          */
/*                                                                          */
void ps$set_line_join() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_line_width (line_width)                                          */
/*                                                                          */
/*  line_width.rf.r = new width of lines.  stored in GS                     */
/*                                                                          */
/*                                                                          */
void ps$set_line_width() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_matrix ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_matrix() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_miter_limit (limit)                                              */
/*                                                                          */
/*  limit.rf.r = new miter limit                                            */
/*                                                                          */
/*                                                                          */
void ps$set_miter_limit() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_object_format (format_code)                                      */
/*                                                                          */
/*  format_code.rl.r = object format type 0-4 see pg 109 in Extensions Manual */
/*                                                                          */
/*                                                                          */
void ps$set_object_format() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_packing (boolean_value)                                          */
/*                                                                          */
/*  boolean_value.rl.r = boloean value: true - pack, false - no packing     */
/*                                                                          */
void ps$set_packing() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_rgb_color (red, green, blue)                                     */
/*                                                                          */
/*  red.rf.r = red level                                                    */
/*  green.rf.r = green level                                                */
/*  blue.rf.r = blue level                                                  */
/*                                                                          */
/*                                                                          */
void ps$set_rgb_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_screen ()                                                        */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_screen() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_shared (boolean_value)                                           */
/*                                                                          */
/*  boolean_value.rl.r = boloean value: true - share, false - private       */
/*                                                                          */
void ps$set_shared() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_stroke_adjust (boolean_value)                                    */
/*                                                                          */
/*  boolean_value.rl.r = boloean value: true - auto stroke adjust           */
/*                                                                          */
void ps$set_stroke_adjust() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_transfer ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_transfer() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_u_cache_params ()                                                */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_u_cache_params() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_under_color_removal ()                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$set_under_color_removal() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_vm_threshold (threshold)                                         */
/*                                                                          */
/*  threshold.rl.r = vm allocation threshold which triggers garbarge collection */
/*                                                                          */
void ps$set_vm_threshold() ;
/*                                                                          */
/*                                                                          */
/*  ps$shared_dict ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$shared_dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$show (pr_string)                                                     */
/*                                                                          */
/*  pr_string.rt.dx = string of characters to print                         */
/*                                                                          */
/*                                                                          */
void ps$show() ;
/*                                                                          */
/*                                                                          */
/*  ps$show_page ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$show_page() ;
/*                                                                          */
/*                                                                          */
/*  ps$sin ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$sin() ;
/*                                                                          */
/*                                                                          */
/*  ps$sqrt ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$sqrt() ;
/*                                                                          */
/*                                                                          */
/*  ps$s_rand ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$s_rand() ;
/*                                                                          */
/*                                                                          */
/*  ps$stack ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$stack() ;
/*                                                                          */
/*                                                                          */
/*  ps$start ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$start() ;
/*                                                                          */
/*                                                                          */
/*  ps$status (boolean_return)                                              */
/*                                                                          */
/*  boolean_return.wl.r = true - file is still valid                        */
/*                                                                          */
void ps$status() ;
/*                                                                          */
/*                                                                          */
/*  ps$status_dict ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$status_dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$stop ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$stop() ;
/*                                                                          */
/*                                                                          */
/*  ps$stopped ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$stopped() ;
/*                                                                          */
/*                                                                          */
/*  ps$store ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$store() ;
/*                                                                          */
/*                                                                          */
/*  ps$string (length)                                                      */
/*                                                                          */
/*  length.rl.r = length of zero initialized string                         */
/*                                                                          */
void ps$string() ;
/*                                                                          */
/*                                                                          */
/*  ps$string_width (cstring, x_width_return,                               */
/*                    y_width_return)                                       */
/*                                                                          */
/*  cstring.rt.dx = character string to use                                 */
/*  x_width_return.wf.r = string width x value                              */
/*  y_width_return.wf.r = string width y value                              */
/*                                                                          */
/*                                                                          */
void ps$string_width() ;
/*                                                                          */
/*                                                                          */
/*  ps$stroke ()                                                            */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$stroke() ;
/*                                                                          */
/*                                                                          */
/*  ps$stroke_path ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$stroke_path() ;
/*                                                                          */
/*                                                                          */
/*  ps$sub ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$sub() ;
/*                                                                          */
/*                                                                          */
/*  ps$system_dict ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$system_dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$token (boolean_return)                                               */
/*                                                                          */
/*  boolean_return.wl.r = true - token found                                */
/*                                                                          */
void ps$token() ;
/*                                                                          */
/*                                                                          */
/*  ps$transform (x1_coord, y1_coord,                                       */
/*                   x2_coord_return, y2_coord_return)                      */
/*                                                                          */
/*  x1_coord.rf.r = distance vector x coord                                 */
/*  y1_coord.rf.r = distance vector y coord                                 */
/*  x2_coord_return.wf.r = device distance vector y coord                   */
/*  y2_coord_return.wf.r = device distance vector y coord                   */
/*                                                                          */
/*                                                                          */
void ps$transform() ;
/*                                                                          */
/*                                                                          */
/*  ps$translate (x_trans, y_trans)                                         */
/*                                                                          */
/*  x_trans.rf.r = x transformation parameter                               */
/*  y_trans.rf.r = y transformation parameter                               */
/*                                                                          */
/*                                                                          */
void ps$translate() ;
/*                                                                          */
/*                                                                          */
/*  ps$true ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$true() ;
/*                                                                          */
/*                                                                          */
/*  ps$truncate ()                                                          */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$truncate() ;
/*                                                                          */
/*                                                                          */
/*  ps$type ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$type() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_append (nums_array, nlength, ops_aray, olength)                    */
/*                                                                          */
/*  nums_array.rr.ra = encoded number string  - character array             */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = operator string - character array                     */
/*  olength.rl.r = array size                                               */
/*                                                                          */
/*  together the nums array and ops array represent a userpath              */
/*                                                                          */
/*                                                                          */
void ps$u_append() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_cache ()                                                           */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$u_cache() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_cache_status ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$u_cache_status() ;
/*                                                                          */
/*                                                                          */
/*  ps$ueo_fill (nums_array, nlength, ops_aray, olength)                    */
/*                                                                          */
/*  nums_array.rr.ra = encoded number string  - character array             */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = operator string - character array                     */
/*  olength.rl.r = array size                                               */
/*                                                                          */
/*  together the nums array and ops array represent a userpath              */
/*                                                                          */
/*                                                                          */
void ps$ueo_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_fill (nums_array, nlength, ops_aray, olength)                      */
/*                                                                          */
/*  nums_array.rr.ra = character array                                      */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = character array                                       */
/*  olength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$u_fill() ;
/*                                                                          */
/*                                                                          */
/*  ps$undef (key)                                                          */
/*                                                                          */
/*  key.rt.dx = key to be removed from the dict                             */
/*                                                                          */
/*                                                                          */
void ps$undef() ;
/*                                                                          */
/*                                                                          */
/*  ps$undefine_font (font_key)                                             */
/*                                                                          */
/*  font_key.rt.dx = file to removed from the font dict                     */
/*                                                                          */
/*                                                                          */
void ps$undefine_font() ;
/*                                                                          */
/*                                                                          */
/*  ps$undefine_user_object (index)                                         */
/*                                                                          */
/*  index.rl.r = object index >= 0                                          */
/*                                                                          */
void ps$undefine_user_object() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_path (boolean_value)                                               */
/*                                                                          */
/*  boolean_value.rl.r = new path boolean: true - include ucache            */
/*                                                                          */
void ps$u_path() ;
/*                                                                          */
/*                                                                          */
/*  ps$user_dict ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$user_dict() ;
/*                                                                          */
/*                                                                          */
/*  ps$user_objects ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$user_objects() ;
/*                                                                          */
/*                                                                          */
/*  ps$user_time (clock_value_return)                                       */
/*                                                                          */
/*  clock_value_return.wl.r = value of one millisecond clock timer          */
/*                                                                          */
void ps$user_time() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_stroke (nums_array, nlength, ops_aray, olength)                    */
/*                                                                          */
/*  nums_array.rr.ra = character array                                      */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = character array                                       */
/*  olength.rl.r = array size                                               */
/*                                                                          */
/*  together the nums array and ops array represent a userpath              */
/*                                                                          */
void ps$u_stroke() ;
/*                                                                          */
/*                                                                          */
/*  ps$u_stroke_path (nums_array, nlength, ops_aray, olength)               */
/*                                                                          */
/*  nums_array.rr.ra = character array                                      */
/*  nlength.rl.r = array size                                               */
/*  ops_array.rr.ra = character array                                       */
/*  olength.rl.r = array size                                               */
/*                                                                          */
/*  together the nums array and ops array represent a userpath              */
/*                                                                          */
void ps$u_stroke_path() ;
/*                                                                          */
/*  ps$version (size, array_return)                                         */
/*                                                                          */
/*  size.rl.r = array size                                                  */
/*  array_return.wr.ra = character array                                    */
/*                                                                          */
/*                                                                          */
void ps$version() ;
/*                                                                          */
/*                                                                          */
/*  ps$view_clip ()                                                         */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$view_clip() ;
/*                                                                          */
/*                                                                          */
/*  ps$view_clip_path ()                                                    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$view_clip_path() ;
/*                                                                          */
/*  ps$vm_reclaim (collection_code)                                         */
/*                                                                          */
/*  collection_code.rl.r = type of garbarge collection -2 - 2               */
/*                                                                          */
/*                                                                          */
void ps$vm_reclaim() ;
/*                                                                          */
/*                                                                          */
/*  ps$vm_status (level_return, used_return, maximum_return)                */
/*                                                                          */
/*  level_return.wl.r = save nesting level                                  */
/*  used_return.wl.r = number bytes of vm used                              */
/*  maximum_return.wl.r = max numberof vm bytes                             */
/*                                                                          */
void ps$vm_status() ;
/*                                                                          */
/*                                                                          */
/*  ps$wait ()                                                              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$wait() ;
/*                                                                          */
/*                                                                          */
/*  ps$w_check (boolean_return)                                             */
/*                                                                          */
/*  boolean_return.wl.r = access to operator true - write access allowed    */
/*                                                                          */
void ps$w_check() ;
/*                                                                          */
/*                                                                          */
/*  ps$where (boolean_return)                                               */
/*                                                                          */
/*  boolean_return.wl.r = true - dict entry found                           */
/*                                                                          */
void ps$where() ;
/*                                                                          */
/*                                                                          */
/*  ps$width_show (x_adjustment, y_adjustment, cstring)                     */
/*                                                                          */
/*  x_adjustment.rf.r = value added to character x width                    */
/*  y_adjustment.rf.r = value added to character y width                    */
/*  character.rl.r = ascii value of character to be adjusted 0 - 255.       */
/*  cstring.rt.dx = string which contains character                         */
/*                                                                          */
/*                                                                          */
void ps$width_show() ;
/*                                                                          */
/*                                                                          */
/*  ps$write ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$write() ;
/*                                                                          */
/*                                                                          */
/*  ps$write_hex_string ()                                                  */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$write_hex_string() ;
/*                                                                          */
/*                                                                          */
/*  ps$write_object (tag)                                                   */
/*                                                                          */
/*  tag.rl.r = object tag                                                   */
/*                                                                          */
void ps$write_object() ;
/*                                                                          */
/*                                                                          */
/*  ps$write_string ()                                                      */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$write_string() ;
/*                                                                          */
/*                                                                          */
/*  ps$w_translation (x_trans, y_trans)                                     */
/*                                                                          */
/*  x_trans.wf.r = x transformation parameter                               */
/*  y_trans.wf.r = y transformation parameter                               */
/*                                                                          */
/*                                                                          */
void ps$w_translation() ;
/*                                                                          */
/*                                                                          */
/*  ps$x_check (boolean_return)                                             */
/*                                                                          */
/*  boolean_return.wl.r = true - dict entry found                           */
/*                                                                          */
void ps$x_check() ;
/*                                                                          */
/*                                                                          */
/*  ps$xor ()                                                               */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$xor() ;
/*                                                                          */
/*                                                                          */
/*  ps$x_show (cstring, numr_array, nlength)                                */
/*                                                                          */
/*  cstring.rt.dx = string to be adjusted by num_array                      */
/*  num_array.rr.ra = array of x adjustment values                          */
/*  nlength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$x_show() ;
/*                                                                          */
/*                                                                          */
/*  ps$xy_show (cstring, numr_array, nlength)                               */
/*                                                                          */
/*  cstring.rt.dx = string to be adjusted by num_array                      */
/*  num_array.rr.ra = array of x adjustment values                          */
/*  nlength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$xy_show() ;
/*                                                                          */
/*                                                                          */
/*  ps$yield ()                                                             */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$yield() ;
/*                                                                          */
/*                                                                          */
/*  ps$y_show (cstring, numr_array, nlength)                                */
/*                                                                          */
/*  cstring.rt.dx = string to be adjusted by num_array                      */
/*  num_array.rr.ra = array of x adjustment values                          */
/*  nlength.rl.r = array size                                               */
/*                                                                          */
/*                                                                          */
void ps$y_show() ;
/*  XDPS$PSCUSTOMOPS.SDL                                                    */
/**************************************************************************** */
/*                                                                          * */
/*  COPYRIGHT (c) 1989 BY                                                   * */
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                           * */
/*  ALL RIGHTS RESERVED                                                     * */
/*                                                                          * */
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  * */
/*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  * */
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  * */
/*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  * */
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  * */
/*  TRANSFERRED.                                                            * */
/*                                                                          * */
/*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  * */
/*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  * */
/*  CORPORATION.                                                            * */
/*                                                                          * */
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  * */
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.                 * */
/*                                                                          * */
/**************************************************************************** */
/*                                                                          */
/*                                                                          */
/*  ps$current_x_offset (x_offset_return, y_offset_return)                  */
/*                                                                          */
/*  x_offset_return.wl.r = current x offset                                 */
/*  y_offset_return.wl.r = current y offset                                 */
/*                                                                          */
/*                                                                          */
void ps$current_x_offset() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_x_offset (x_offset, y_offset)                                    */
/*                                                                          */
/*  x_offset.rw.r = new x distance offset                                   */
/*  y_offset.rw.r = new y distance offset                                   */
/*                                                                          */
/*                                                                          */
void ps$set_x_offset() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_x_gc_drawable (gc_id_return,                                 */
/*                             drawable_id_return, x_offset_return,         */
/*                             y_offset_return)                             */
/*                                                                          */
/*  gc_id_return.wl.r = gcontext id                                         */
/*  drawable_id_return.wl.r = drawable id                                   */
/*  x_offset_return.wl.r = current x offset                                 */
/*  y_offset_return.wl.r = current y offset                                 */
/*                                                                          */
/*                                                                          */
void ps$current_x_gc_drawable() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_x_gc_drawable (gc_id, drawable_id,                               */
/*                             x_offset, y_offset)                          */
/*                                                                          */
/*  gc_id.rl.r = gcontext id                                                */
/*  drawable_id.rl.r = drawable id                                          */
/*  x_offset.rl.r = current x offset                                        */
/*  y_offset.rl.r = current y offset                                        */
/*                                                                          */
/*                                                                          */
void ps$set_x_gc_drawable() ;
/*                                                                          */
/*                                                                          */
/*  ps$current_x_gc_drawable_color (gc_id_return,                           */
/*                             drawable_id_return, x_offset_return,         */
/*                             y_offset_return, color_info_return)          */
/*                                                                          */
/*  gc_id_return.wl.r = gcontext id                                         */
/*  drawable_id_return.wl.r = drawable id                                   */
/*  x_offset_return.wl.r = current x offset                                 */
/*  y_offset_return.wl.r = current y offset                                 */
/*  color_info_return.wr.ra = color array[12]                               */
/*                                                                          */
/*                                                                          */
void ps$current_x_gc_drawable_color() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_x_gc_drawable_color (gc_id, drawable_id,                         */
/*                             x_offset, y_offset, color_info)              */
/*                                                                          */
/*  gc_id.rl.r = gcontext id                                                */
/*  drawable_id.rl.r = drawable id                                          */
/*  x_offset.rl.r = current x offset                                        */
/*  y_offset.rl.r = current y offset                                        */
/*  color_info.rr.ra = color array[12]                                      */
/*                                                                          */
/*                                                                          */
void ps$set_x_gc_drawable_color() ;
/*                                                                          */
/*  ps$client_sync ()                                                       */
/*                                                                          */
/*                                                                          */
/*                                                                          */
void ps$client_sync() ;
/*                                                                          */
/*                                                                          */
/*  ps$set_x_rgb_actual (red, green, blue, boolean_return)                  */
/*                                                                          */
/*  red.rf.r = red level                                                    */
/*  green.rf.r = green level                                                */
/*  blue.rf.r = blue level                                                  */
/*  boolean_return.wl.r = returned boolean value                            */
/*                                                                          */
/*                                                                          */
void ps$set_x_rgb_actual() ;
#ifndef __XWDEF_LOADED
#define __XWDEF_LOADED	1

/*** MODULE $xwdef ***/
/*++                                                                        */
/*                                                                          */
/* XWDEF - System definitions for software DDCMP                            */
/*                                                                          */
/*--                                                                        */
#define XW$M_CHA_FDX 1
#define XW$M_CHA_XPR 2
#define XW$M_CHA_DSR 4
#define XW$M_FAT_STAT 1023
#define XW$M_INFO_STAT 64512
#define XW$M_EOT 1
#define XW$M_DATACK 2
#define XW$M_NODSR 4
#define XW$M_DISCON 8
#define XW$M_TRABINTMO 16
#define XW$M_PIPE_MARK 32
#define XW$M_BADCHAIN 64
#define XW$M_ILLMOD 128
#define XW$M_RVI 1024
#define XW$M_CONACK 2048
#define XW$M_XPR 4096
#define XW$M_ETXEND 8192
#define XW$M_PUNCH 65536
#define XW$M_HOR_FOR 131072
#define XW$M_IOMOD 57344
union xwdef {
    struct  {
        unsigned xw$v_cha_fdx : 1;      /* Full duplex line                 */
        unsigned xw$v_cha_xpr : 1;      /* Transparency                     */
        unsigned xw$v_cha_dsr : 1;      /* Data Set Ready set               */
        unsigned xw$v_fill_11 : 5;
        } xw$r_xwdef_bits0;
/*                                                                          */
/* Device dependent status                                                  */
/*                                                                          */
    struct  {
        unsigned xw$v_fat_stat : 10;    /* Beginning of fatal stat flags    */
        unsigned xw$v_info_stat : 6;    /* Start of informational status    */
        } xw$r_xwdef_bits1;
/*                                                                          */
/* Bit definitions for fatal and informational status fields                */
/*                                                                          */
    struct  {
        unsigned xw$v_eot : 1;          /* EOT received                     */
        unsigned xw$v_datack : 1;       /* Retry threshold exceeded         */
        unsigned xw$v_nodsr : 1;        /* Line not connected               */
        unsigned xw$v_discon : 1;       /* Disconnect (DLE, EOT) rcvd       */
        unsigned xw$v_trabintmo : 1;    /* Binary transmit timeout          */
        unsigned xw$v_pipe_mark : 1;    /* Aborted because of pipe mark     */
        unsigned xw$v_badchain : 1;     /* Bad record list                  */
        unsigned xw$v_illmod : 1;       /* Illegal QIO modifier             */
        unsigned xwdef$$_fill_1 : 2;
        unsigned xw$v_rvi : 1;          /* Buffer ACKed with RVI            */
        unsigned xw$v_conack : 1;       /* Buffer ACKed with conver resp    */
        unsigned xw$v_xpr : 1;          /* Buffer rcvd with transparency    */
        unsigned xw$v_etxend : 1;       /* Rcvd block ended with ETX        */
        unsigned xwdef$$_fill_2 : 2;
        unsigned xw$v_punch : 1;        /* Punch select found               */
        unsigned xw$v_hor_for : 1;      /* Horizontal forms record rcvd     */
        unsigned xw$v_fill_12 : 6;
        } xw$r_xwdef_bits2;
/*                                                                          */
/* Read/Write function modifier definition                                  */
/*                                                                          */
    struct  {
        unsigned xwdef$$_fill_3 : 13;
        unsigned xw$v_iomod : 3;        /* I/O modifier field start         */
        } xw$r_xwdef_bits3;
    } ;

#endif					/* __XWDEF_LOADED */
